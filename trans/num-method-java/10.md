# 10.约束优化

最优化在数学和工业应用的许多分支中都是普遍存在的。例如，回归和最大似然等许多统计理论都被公式化为优化问题。量化金融最大化投资组合的回报风险比来分配资产。在我们的公司 NM Limited，我们建立了数据驱动的决策系统，以帮助管理层做出科学而非临时的商业决策。例子包括钢铁制造厂的资源分配系统，以优化原材料、机器和人力的使用；一个路线规划者，寻找收发邮件的最佳路线；以及安排车辆及其班次的调度系统。

## 10.1 优化问题

一般来说，一个约束优化问题就是找到一个向量***【x】***<sup>∫</sup>，满足以下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equa.png)

服从，

![$$ {a}_i\left(\boldsymbol{x}\right)=0,i=1,2,\dots p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equb.png)

![$$ {c}_j\left(\boldsymbol{x}\right)\ge 0,j=1,2,\dots q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equc.png)

我们假设*a*<sub>*I*</sub>(*x*)c<sub>*j*</sub>(*x*)是两次可微的连续函数。这些约束一起定义了优化问题的可行区域 *R* 。即***x***<sup>∫</sup>∈*R*。假设可行域是凸的。

凸集是这样一个集合，即对于集合中任意两点 ***x*** 和 ***y*** ，连接这两点的任意线段，(1-T8】t)***x+****t****y***都位于该集合中。图 [10-1](#Fig1) 显示了一个凸集的例子。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig1_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig1_HTML.jpg)

图 10-1

凸集

图 [10-2](#Fig2) 显示了一个非凸集合的例子。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig2_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig2_HTML.jpg)

图 10-2

非凸集

下面是一个约束优化问题的例子:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\underset{\boldsymbol{x}}{\min}\left({\left({x}_1-1.5\right)}^2+2{x}_2^2\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equd.png)

![$$ \left\{\begin{array}{c}{x}_1^2+{x}_2^2=0\\ {}{x}_1^2-{x}_2\le 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Eque.png)服从，

图 [10-3](#Fig3) 显示了约束中两条曲线的交点所定义的可行区域。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig3_HTML.png](img/500382_1_En_10_Chapter/500382_1_En_10_Fig3_HTML.png)

图 10-3

由约束定义的可行区域

等高线图(虚线)是目标函数可以采用的(相同)值。(小于)不等式约束将解决方案限制在抛物线上方。等式约束要求解在圆周上。因此，可行区域只是抛物线内圆的 AB 弧。B 点上的点表示目标函数在弧上最小的解。

### 通用优化算法

一般来说，寻找优化问题的解决方案是一个迭代过程(除非我们有它的解析表达式，而我们通常没有)。所以，我们从一个初始点或猜测开始尝试。如果它不工作，我们尝试另一个。任何数值优化算法的核心部分是我们如何选择下一个尝试点。有两个因素决定第 *k* 次迭代中的搜索点。分别是方向***d***<sub>***k***</sub>和那个方向的变化幅度 *α* <sub>*k*</sub> 。因此，下一个搜索点如下:

![$$ {\boldsymbol{x}}_{\boldsymbol{k}}={\boldsymbol{x}}_{\boldsymbol{k}-\mathbf{1}}+{\alpha}_k{\boldsymbol{d}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equf.png)

我们重复这个过程，直到满足收敛标准。标准可以是目标函数值的变化太小。

![$$ \left|f\left({\boldsymbol{x}}_{\boldsymbol{k}}\right)-f\left({\boldsymbol{x}}_{\boldsymbol{k}-\mathbf{1}}\right)\right|&lt;{\varepsilon}_f $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equg.png)T2】

也可能是***x***<sub>***k***</sub>的变化太小。

![$$ \left|\Delta  {\boldsymbol{x}}_{\boldsymbol{k}}\right|=\left|{\boldsymbol{x}}_{\boldsymbol{k}}-{\boldsymbol{x}}_{\boldsymbol{k}-\mathbf{1}}\right|&lt;{\varepsilon}_{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equh.png)

### 约束条件

在 NM Dev 中，一组等式或不等式约束由一列实值多元函数表示。界面是`Constraints`。该类签名如下:

```py
public interface Constraints {
    /**
     * Get the list of constraint functions.
     *
     * @return the list of constraint functions
     */
    public List<RealScalarFunction> getConstraints();

    /**
     * Get the number of variables.
     *
     * @return the number of variables
     */
    public int dimension();

    /**
     * Get the number of constraints.
     *
     * @return the number of constraints
     */
    public int size();
}

```

#### 平等约束

等式约束的集合如下所示:

![$$ {a}_i\left(\boldsymbol{x}\right)=0,i=1,2,\dots p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equi.png)

或者以向量的形式，它如下:

![$$ a\left(\boldsymbol{x}\right)={\left[{a}_1\left(\boldsymbol{x}\right),{a}_2\left(\boldsymbol{x}\right),\dots, {a}_p\left(\boldsymbol{x}\right)\right]}^T=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equj.png)

这在*R*<sup>T3】nT5】中定义了一个超曲面。</sup>

如果 ***x*** 满足等式约束且列向量∇*a*<sub>1</sub>(***x***)、∇*a*<sub>2</sub>(***x***)，...、∇*a*<sub>*p*</sub>(***x***)都是线性无关的。即 ***x*** 是一个解。

T39

而雅可比矩阵看起来是这样的:

![$$ {\mathbf{J}}_{\mathbf{e}}\left(\boldsymbol{x}\right)=\left[\nabla {a}_1\left(\boldsymbol{x}\right),\nabla {a}_2\left(\boldsymbol{x}\right),\dots, \nabla {a}_p\left(\boldsymbol{x}\right)\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equl.png)

![$$ =\left[\begin{array}{ccc}\frac{d{a}_1}{d{x}_1}&amp; \cdots &amp; \frac{d{a}_1}{d{x}_n}\\ {}&amp; \ddots &amp; \\ {}\frac{d{a}_p}{d{x}_1}&amp; &amp; \frac{d{a}_p}{d{x}_n}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equm.png)

它有全行排名 *p* 。

如果 *p* > *n* ，那么 **J** <sub>**e**</sub> 就不能全排排位。没有规律的点。如果 *p* = *n* ，那么正则点只有有限个，优化问题就变得琐碎了。我们因此通常假设*p*T23*n*。如果 ***x*** 是一组等式约束的正则点，它定义了约束的超曲面的切平面。

和陆(2007)提供了下面的例子:

![$$ \left\{\begin{array}{c}-{x}_1+{x}_3-1=0\\ {}{x}_1^2+{x}_2^2-2{x}_1=0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equn.png)

雅可比矩阵如下:

![$$ {\mathbf{J}}_{\mathbf{e}}\left(\boldsymbol{x}\right)=\left[\begin{array}{ccc}-1&amp; 0&amp; 1\\ {}2{x}_1-2&amp; 2{x}_2&amp; 0\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equo.png)

除了在***x***=【1 0*x*<sub>3</sub><sup>*T*</sup>处，它的秩为 2，因为它不满足约束。其他任何点都是正则的。

在 NM Dev 中，接口`EqualityConstraints`是表示一组等式约束的标记。其签名如下:

```py
public interface EqualityConstraints extends Constraints {
}

```

类`GeneralEqualityConstraints`实现了一组等式约束。该类签名如下:

```py
public class GeneralEqualityConstraints extends GeneralConstraints implements EqualityConstraints {

    /**
     * Constructs an instance of equality constraints from a collection of
     * real-valued functions.
     *
     * @param constraints the equality constraints
     */
    public GeneralEqualityConstraints(Collection<RealScalarFunction> constraints) {
        super(constraints);
    }

    /**
     * Constructs an instance of equality constraints from an array of
     * real-valued functions.
     *
     * @param constraints the equality constraints
     */
    public GeneralEqualityConstraints(RealScalarFunction... constraints) {
        super(constraints);
    }
}

```

以下代码片段代表了前面的示例:

```py
// non-linear constraints
GeneralEqualityConstraints a
        = new GeneralEqualityConstraints(
                // the first equality constraint
                new AbstractRealScalarFunction(3) { // the domain dimension
            @Override
            public Double evaluate(Vector x) {
                double x1 = x.get(1);
                double x3 = x.get(3);

                double a1 = -x1 + x3 + 1;
                return a1;
            }
        },
                // the second equality constraint
                new AbstractRealScalarFunction(3) { // the domain dimension
            @Override
            public Double evaluate(Vector x) {
                double x1 = x.get(1);
                double x2 = x.get(2);

                double a2 = x1 * x1 + x2 * x2 - 2\. * x1;
                return a2;
            }
        }
        );

```

如果所有等式约束都是线性的，可以写成:

![$$ \mathbf{A}\boldsymbol{x}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equp.png)

**A** 是一个 *p* × *n* 矩阵。 ***b*** 是一个 *p* × 1 的向量。雅可比矩阵 **J** <sub>**e**</sub> 与常数矩阵 **A** 相同。因此，如果秩( **A** ) = *p* ，那么线性系统的任何解**A*****x***=***b***都是正则点。否则 rank 有两种可能(**A**)=*p*′<*p*。

如果![$$ \operatorname{rank}\left(\left[\mathbf{A}\kern0.5em \mathbf{b}\right]\right)&gt;p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq1.png)，那么线性系统无解。需要仔细检查以消除矛盾。如果![$$ \operatorname{rank}\left(\left[\mathbf{A}\kern0.5em \mathbf{b}\right]\right)=\operatorname{rank}\left(\mathbf{A}\right)={p}^{\prime }&lt;p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq2.png)，那么我们可以将约束减少到一个更小的等价等式约束集。【T2![$$ \hat{\mathbf{A}}\boldsymbol{x}=\hat{\boldsymbol{b}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equq.png)

其中![$$ \hat{\mathbf{A}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq3.png)是一个*p*′×*n*矩阵，![$$ \hat{\boldsymbol{b}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq4.png)是一个*p*′×1 向量。

一种方法是对 **A** 应用奇异值分解(SVD)。更多信息见第 [2](02.html) 章。我们可以将 **A** 分解如下:

![$$ \mathbf{A}=\mathbf{UD}{\boldsymbol{V}}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equr.png)

其中 **U** 是一个 *p* × *p* 正交矩阵和 **V** a *n* × *n* 正交矩阵。

![$$ \mathbf{D}=\left[\begin{array}{cc}\hat{\boldsymbol{D}}&amp; \mathbf{0}\\ {}\mathbf{0}&amp; \mathbf{0}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equs.png)

其中![$$ \hat{\boldsymbol{D}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq5.png)具有所有正奇异值。

T2

T4![$$ \hat{\boldsymbol{A}}=\hat{\boldsymbol{D}}{\left[{\boldsymbol{v}}_{\mathbf{1}},\dots, {\boldsymbol{v}}_{{\boldsymbol{p}}^{\prime }}\right]}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equu.png)T6】

***V***<sub>***I***</sub>是***V***<sup>***T***</sup>中的列。![$$ \hat{\boldsymbol{A}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq6.png)是一个*p*T23’×*n*矩阵。

![$$ \left[\begin{array}{c}\hat{\boldsymbol{A}}\\ {}\mathbf{0}\end{array}\right]\boldsymbol{x}=\left[\begin{array}{c}\hat{\boldsymbol{b}}\\ {}\mathbf{0}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equv.png)

![$$ \hat{\boldsymbol{b}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq7.png)是第一个*p*<sup>’</sup>条目的**U**<sup>***T***</sup>***b***。

以下代码片段复制了和鲁(2007)中的示例 10.2:

![$$ \left\{\begin{array}{c}{x}_1-2{x}_2+3{x}_3+2{x}_4=4\\ {}2{x}_2-{x}_3=1\\ {}2{x}_1-10{x}_2+9{x}_3+4{x}_4=5\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equw.png)

这个线性系统的秩是 2，因此是可约的。等式约束的精简集如下:

![$$ \left\{\begin{array}{c}2.177001{x}_1-10.342933{x}_2+9.525469{x}_3+4.354003{x}_4=5.713540\\ {}0.510554{x}_1+1.011800{x}_2+0.515208{x}_3+1.021108{x}_4=3.058670\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equx.png)

```py
/** Example 10.2, p. 270\. Practical Optimization: Algorithms and
 * Engineering Applications. Andreas Antoniou, Wu-Sheng Lu */
// linear constraints
Matrix A = new DenseMatrix(new double[][]{
    {1, -2, 3, 2},
    {0, 2, -1, 0},
    {2, -10, 9, 4}
});
Vector b = new DenseVector(new double[]{4, 1, 5});
LinearEqualityConstraints A_eq
        = new LinearEqualityConstraints(A, b);
System.out.println("original equality constraints: ");
System.out.println(A_eq);

// do SVD decomposition to reduce the eqaulity constraints
SVD svd = new SVD(A, true);
Matrix U = svd.U();
System.out.println("U = ");
System.out.println(U);
Matrix D = svd.D();
System.out.println("D = ");
System.out.println(D);
Matrix V = svd.V();
System.out.println("V = ");
System.out.println(V);

// check if the original equality constraints are reducible
double epsilon = 1e-8; // the precision parameter under which is considered 0
boolean isReducible = A_eq.isReducible(epsilon);
System.out.println(isReducible);
int r = MatrixMeasure.rank(
        A,
        epsilon
);
System.out.printf("rank of A = %d%n", r);

// construct a new set of reduced constraints
LinearEqualityConstraints A_eq_hat
        = A_eq.getReducedLinearEqualityConstraints(epsilon);
System.out.println("reduced equality constraints: ");
System.out.println(A_eq_hat);

```

输出如下所示:

```py
original equality constraints:
3x4
         [,1] [,2] [,3] [,4]
[1,] 1.000000, -2.000000, 3.000000, 2.000000,
[2,] 0.000000, 2.000000, -1.000000, 0.000000,
[3,] 2.000000, -10.000000, 9.000000, 4.000000,  * x =
[4.000000, 1.000000, 5.000000]
U =
3x3
          [,1] [,2] [,3]
[1,] 0.271659, 0.800304, -0.534522,
[2,] -0.136451, 0.581828, 0.801784,
[3,] 0.952671, -0.144875, 0.267261,
D =
3x3
          [,1] [,2] [,3]
[1,] 14.879768, 0.000000, 0.000000,
[2,] 0.000000, 1.610126, 0.000000,
[3,] 0.000000, 0.000000, 0.000000,
V =
4x3
          [,1] [,2] [,3]
[1,] 0.146306, 0.317089, -0.936741,
[2,] -0.695100, 0.628398, 0.112540,
[3,] 0.640162, 0.319980, 0.225081,
[4,] 0.292612, 0.634179, 0.243290,
true
rank of A = 2
reduced equality constraints:
2x4
          [,1] [,2] [,3] [,4]
[1,] 2.177001, -10.342933, 9.525469, 4.354003,
[2,] 0.510554, 1.011800, 0.515208, 1.021108,  * x =
[5.713540, 3.058670]

```

#### 不平等约束

不等式约束是这样的:

![$$ {c}_j\left(\boldsymbol{x}\right)\ge 0,j=1,2,\dots q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equy.png)

与等式约束不同，不等式约束的数量 *q* 不需要小于 *n* 。对于任何可行点![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq8.png)，有两类不等式约束。带有*c*<sub>*j*</sub>(***x***)>0 的约束集合称为非活动约束，如图 [10-2](img/#Fig2) 中的![$$ {c}_1\left(\overline{\boldsymbol{x}}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq9.png)和![$$ {c}_2\left(\overline{\boldsymbol{x}}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq10.png)。因为![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq11.png)在它们的边界上，下一个搜索点不能向违反约束的方向移动。因此，这些有效约束限制了![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq12.png)附近的可行区域。另一方面，不活跃的约束如![$$ {c}_3\left(\overline{\boldsymbol{x}}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq13.png)远离![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq14.png)，因此在![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq15.png)的足够小的邻域内，它们对可行区域没有影响。见图 [10-4](img/#Fig4) 。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig4_HTML.png](img/500382_1_En_10_Chapter/500382_1_En_10_Fig4_HTML.png)

图 10-4

不等式约束

在 NM Dev 中，接口`GreaterThanConstraints`是一个标记，用来表示一组(大于)不等式约束。其签名如下:

```py
public interface GreaterThanConstraints extends Constraints {

    /**
     * Convert the greater-than or equal-to constraints to less-than or equal-to
     * constraints.
     *
     * @return the equivalent less-than or equal-to constraints
     */
    public LessThanConstraints toLessThanConstraints();
}

```

等价地，我们可以通过改变符号将不等式约束写成小于不等式约束。也就是

![$$ {c}_j\left(\boldsymbol{x}\right)\le 0,j=1,2,\dots q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equz.png)

接口`LessThanConstraints`是一个标记，用来表示一组小于不等式约束。其签名如下:

```py
public interface LessThanConstraints extends Constraints {

    /**
     * Convert the less-than or equal-to constraints to greater-than or equal-to
     * constraints.
     *
     * @return the equivalent greater-than or equal-to constraints
     */
    public GreaterThanConstraints toGreaterThanConstraints();
}

```

类`GeneralGreaterThanConstraints`实现了一组大于等式的约束。该类签名如下:

```py
public class GeneralGreaterThanConstraints
        extends GeneralConstraints
        implements GreaterThanConstraints {

    /**
     * Construct an instance of greater-than-or-equal-to inequality constraints
     * from a collection of real-valued functions.
     *
     * @param constraints the greater-than-or-equal-to inequality constraints
     */
    public GeneralGreaterThanConstraints(Collection<RealScalarFunction> constraints) {
        super(constraints);
    }

    /**
     * Construct an instance of greater-than-or-equal-to inequality constraints
     * from an array of real-valued functions.
     *
     * @param constraints the greater-than-or-equal-to inequality constraints
     */
    public GeneralGreaterThanConstraints(RealScalarFunction... constraints) {
        super(constraints);
}
...
}

```

例如，下面的代码片段构造了这个大于不等式约束:

![$$ {x}_2-{x}_1^2\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equaa.png)

```py
GeneralGreaterThanConstraints c_gr
        = new GeneralGreaterThanConstraints(
                new AbstractBivariateRealFunction() {
            @Override
            public double evaluate(double x1, double x2) {
                double c = x2 - x1 * x1;
                return c;
            }
        });

```

或者，我们可以使用类`GeneralLessThanConstraints`构造相同的约束。该类签名如下:

```py
public class GeneralLessThanConstraints
        extends GeneralConstraints
        implements LessThanConstraints {

    /**
     * Construct an instance of less-than or equal-to inequality constraints
     * from a collection of real-valued functions.
     *
     * @param constraints the less-than or equal-to inequality constraints
     */
    public GeneralLessThanConstraints(Collection<RealScalarFunction> constraints) {
        super(constraints);
    }

    /**
     * Construct an instance of less-than or equal-to inequality constraints
     * from an array of real-valued functions.
     *
     * @param constraints the less-than or equal-to inequality constraints
     */
    public GeneralLessThanConstraints(RealScalarFunction... constraints) {
        super(constraints);
}
...
}

```

例如，同样的约束可以写成:

![$$ {x}_1^2-{x}_2\le 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equab.png)

代码如下:

```py
GeneralLessThanConstraints c_less = new GeneralLessThanConstraints(
        new AbstractBivariateRealFunction() {
    @Override
    public double evaluate(double x1, double x2) {
        double c = x1 * x1 - x2;
        return c;
    }
});

```

如果所有的不等式约束都是线性的，如下图:

![$$ \boldsymbol{Ax}\ge \boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equac.png)

然后我们可以使用类`LinearGreaterThanConstraints`。该类签名如下:

```py
public class LinearGreaterThanConstraints
        extends LinearConstraints
        implements GreaterThanConstraints {

    /**
     * Construct a collection of linear greater-than or equal-to constraints.
     *
     * @param A the inequality coefficients
     * @param b the inequality values
     */
    public LinearGreaterThanConstraints(Matrix A, Vector b);

    @Override
    public LinearLessThanConstraints toLessThanConstraints();

    /**
     * Given a collection of linear greater-than-or-equal-to constraints as well
     * as a collection of equality constraints,
     * find a feasible initial point that satisfy the constraints.
     * This implementation solves eq. 11.25 in the reference.
     * The first (n-1) entries consist of a feasible initial point.
     * The last entry is the single point perturbation.
     *
     * @param equal a collection of linear equality constraints
     * @return a feasible initial point, and the single point perturbation (in
     *         one vector)
     * @see
     * <ul>
     * <li>"Jorge Nocedal, Stephen Wright, "p. 473," Numerical
     * Optimization."</li>
     * <li>"Andreas Antoniou, Wu-Sheng Lu, "Eq 11.25, Quadratic and Convex
     * Programming," Practical
     * Optimization: Algorithms and Engineering Applications."</li>
     * </ul>
     */
    public Vector getFeasibleInitialPoint(LinearEqualityConstraints equal);

    /**
     * Given a collection of linear greater-than-or-equal-to constraints,
     * find a feasible initial point that satisfy the constraints.
     * This implementation solves eq. 11.25 in the reference.
     * The first (n-1) entries consist of a feasible initial point.
     * The last entry is the single point perturbation.
     *
     * @return a feasible initial point, and the single point perturbation (in
     *         one vector)
     * @see "Andreas Antoniou, Wu-Sheng Lu, "Eq 11.25, Quadratic and Convex
     * Programming," Practical
     * Optimization: Algorithms and Engineering Applications."
     */
    public Vector getFeasibleInitialPoint();
}

```

例如，在现代投资组合优化中，我们经常对每只股票设定一个最小权重，比如 0%。这意味着不允许卖空。这个不等式约束可以写成:

![$$ \boldsymbol{w}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equad.png)

下面的代码代表了这组约束:

```py
// w_i >= 0 mean no short selling
Matrix A = new DenseMatrix(new double[][]{
    {1, 0, 0},
    {0, 1, 0},
    {0, 0, 1}
});
Vector b1 = new DenseVector(new double[]{0, 0, 0}); // 3 stocks
LinearGreaterThanConstraints no_short_selling1
        = new LinearGreaterThanConstraints(A, b1);// w >= 0
System.out.println(no_short_selling1);

```

输出如下所示:

```py
3x3
          [,1] [,2] [,3]
[1,] 1.000000, 0.000000, 0.000000,
[2,] 0.000000, 1.000000, 0.000000,
[3,] 0.000000, 0.000000, 1.000000,  * x >=
[0.000000, 0.000000, 0.000000]

```

或者，我们可以使用包装类`LowerBoundConstraints`来构建这样一组下限约束。

```py
LowerBoundConstraints no_short_selling2
        = new LowerBoundConstraints(3, 0.);
System.out.println(no_short_selling2);

```

输出如下所示:

```py
3x3
          [,1] [,2] [,3]
[1,] 1.000000, 0.000000, 0.000000,
[2,] 0.000000, 1.000000, 0.000000,
[3,] 0.000000, 0.000000, 1.000000,  * x >=
[0.000000, 0.000000, 0.000000]

```

如果所有变量的下限都是 0，那么我们可以简单地使用类`NonNegativityConstraints`。例如，以下代码片段构建了完全相同的禁止卖空约束:

```py
NonNegativityConstraints no_short_selling3
        = new NonNegativityConstraints(3);
System.out.println(no_short_selling3);

```

输出如下所示:

```py
3x3
          [,1] [,2] [,3]
[1,] 1.000000, 0.000000, 0.000000,
[2,] 0.000000, 1.000000, 0.000000,
[3,] 0.000000, 0.000000, 1.000000,  * x >=
[0.000000, 0.000000, 0.000000]

```

类似地，类`LinearLessThanConstraints`表示线性小于约束。

![$$ \boldsymbol{Ax}\le \boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equae.png)

该类签名如下:

```py
public class LinearLessThanConstraints
        extends LinearConstraints
        implements LessThanConstraints {

    /**
     * Construct a collection of linear less-than or equal-to constraints.
     *
     * @param A the less-than inequality constraints
     * @param b the less-than inequality values
     */
    public LinearLessThanConstraints(Matrix A, Vector b) {
        super(A, b);
    }

    @Override
    public LinearGreaterThanConstraints toGreaterThanConstraints() {
        return new LinearGreaterThanConstraints(A().scaled(-1), b().scaled(-1));
    }

    /**
     * Given a collection of linear less-than-or-equal-to constraints as well as
     * a collection of equality constraints,
     * find a feasible initial point that satisfy the constraints.
     * This implementation solves eq. 11.25 in the reference.
     * The first (n-1) entries consist of a feasible initial point.
     * The last entry is the single point perturbation.
     *
     * @param equal a collection of linear equality constraints
     * @return a feasible initial point, and the single point perturbation (in
     *         one vector)
     * @see "Andreas Antoniou, Wu-Sheng Lu, "Eq 11.25, Quadratic and Convex
     * Programming," Practical Optimization: Algorithms and Engineering
     * Applications."
     */
    public Vector getFeasibleInitialPoint(LinearEqualityConstraints equal) {
        return this.toGreaterThanConstraints().getFeasibleInitialPoint(equal);
    }

    /**
     * Given a collection of linear less-than-or-equal-to constraints,
     * find a feasible initial point that satisfy the constraints.
     * This implementation solves eq. 11.25 in the reference.
     * The first (n-1) entries consist of a feasible initial point.
     * The last entry is the single point perturbation.
     *
     * @return a feasible initial point, and the single point perturbation (in
     *         one vector)
     * @see "Andreas Antoniou, Wu-Sheng Lu, "Eq 11.25, Quadratic and Convex
     * Programming," Practical Optimization: Algorithms and Engineering
     * Applications."
     */
    public Vector getFeasibleInitialPoint() {
        return getFeasibleInitialPoint(null);
    }
}

```

例如，我们可能希望对投资组合中的每只股票设定一个最大权重，以避免过度集中。以下不等式约束确保没有股票超过投资组合的 20%:

![$$ \boldsymbol{w}\le 0.2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equaf.png)

相应的代码片段如下:

```py
// w_i <= 0.2
Matrix A = new DenseMatrix(new double[][]{
    {1, 0, 0},
    {0, 1, 0},
    {0, 0, 1}
});
Vector b2 = new DenseVector(new double[]{0.2, 0.2, 0.2}); // 3 stocks
LinearLessThanConstraints maximum_exposure
        = new LinearLessThanConstraints(A, b2);// w >= 0
System.out.println(maximum_exposure);

```

输出如下所示:

```py
3x3
          [,1] [,2] [,3]
[1,] 1.000000, 0.000000, 0.000000,
[2,] 0.000000, 1.000000, 0.000000,
[3,] 0.000000, 0.000000, 1.000000,  * x <=
[0.200000, 0.200000, 0.200000]

```

## 10.2 线性规划

线性规划在数学优化中非常重要。许多其他类型的优化问题的算法是通过将 LP 问题作为子问题来解决的。它广泛应用于商业、经济和工程领域。使用 LP 模型的行业包括运输、能源、电信和制造业。它已被证明在计划、路由、调度、分配和设计中对不同类型的问题建模是有用的。例如，管理层使用 LP 以有限的资源实现利润最大化和成本最小化。YouTube 使用 LP 来稳定视频。众所周知，LP 问题的最优解必定是可行域的一个顶点。虽然我们可以用一种蛮力的方法来逐个检查所有的顶点，并在理论上进行比较，但这不是一种实用的方法。一些大规模的 LP 问题可能涉及多达 1200 万个变量。有许多有效的算法来解决一个线性规划问题。在这一节中，我们将介绍基本的单纯形法，这是求解线性规划问题的主要方法。

### 线性规划问题

标准型 LP 问题表述如下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equag.png)

其中以下列为准:

![$$ \boldsymbol{Ax}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equah.png)

![$$ \boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equai.png)

其中***c≦*****0**是一个 *n* × 1 矢量， *n* 变量个数，***A***A*p*×*n*矩阵， *p* 约束个数，***b***A*p*我们假设 ***A*** 为满秩，即秩(***A***)=*p*<*n*。目标函数 *f* 和所有约束都是线性函数。

对于一个固定的标量 *β* 、*T3】c*<sup>***T***</sup>***x =****β*定义了一个在 *n* 维欧氏空间中的仿射(线性)流形。当 *n* = 2 时，是一条线。***c***<sup>***T***</sup>***x =****β*<sub>*I*</sub>为不同的 *β* <sub>*i*</sub> 代表一族平行线。这些线的法线是 ***c*** ，因此 ***c*** 常被称为目标函数的法向量。

在 NM Dev 中，我们可以使用类`LPStandardProblem`构造一个标准形式的 LP 问题。该类签名如下:

```py
public class LPStandardProblem extends LPProblemImpl1 {

    /**
     * Construct a linear programming problem in the standard form.
     *
     * @param c     the objective function
     * @param equal the equality constraints
     */
    public LPStandardProblem(Vector c, LinearEqualityConstraints equal);
}

```

例如，下面的代码片段构造了这个 LP 问题:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=-{x}_1-{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equaj.png)

服从，

![$$ \left[\begin{array}{cccc}7&amp; 1&amp; 1&amp; 0\\ {}-1&amp; 1&amp; 0&amp; 1\end{array}\right]\left[\begin{array}{c}{x}_1\\ {}{x}_2\\ {}{x}_3\\ {}{x}_4\end{array}\right]=\left[\begin{array}{c}15\\ {}1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equak.png)

![$$ \boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equal.png)

```py
// construct an LP problem in standard form
LPStandardProblem problem1 = new LPStandardProblem(
        new DenseVector(new double[]{-1.0, -1.0, 0, 0}), // c
        new LinearEqualityConstraints(
                new DenseMatrix( // A
                        new double[][]{
                            {7, 1, 1, 0},
                            {-1, 1, 0, 1}
                        }),
                new DenseVector(new double[]{15.0, 1.0}) // b
        ));
System.out.println(problem1);

```

输出如下所示:

```py
min. objective:
[-1.000000, -1.000000, 0.000000, 0.000000]
less-than-or-equal-to inequalities:
4x4
          [,1] [,2] [,3] [,4]
[1,] -7.000000, -1.000000, -1.000000, -0.000000,
[2,] 1.000000, -1.000000, -0.000000, -1.000000,
[3,] 7.000000, 1.000000, 1.000000, 0.000000,
[4,] -1.000000, 1.000000, 0.000000, 1.000000,  * x <=
[-15.000000, -1.000000, 15.000000, 1.000000]
equalities:
free variables:

```

注意，输出实际上是 LP 问题的规范形式。规范形式表述如下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equam.png)

服从，

![$$ \boldsymbol{Ax}\ge \boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equan.png)

![$$ \boldsymbol{x}\ge \mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equao.png)

通过将等式约束写入不等式约束，可以将标准形式转换为规范形式。

![$$ \boldsymbol{Ax}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equap.png)T2】

前面的相当于这个:

![$$ \left\{\begin{array}{c}\boldsymbol{Ax}\ge \boldsymbol{b}\\ {}\boldsymbol{Ax}\le \boldsymbol{b}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equaq.png)

因此，标准形式的不等式约束如下:

![$$ \left[\begin{array}{c}\boldsymbol{A}\\ {}-\boldsymbol{A}\end{array}\right]\boldsymbol{x}\ge \left[\begin{array}{c}\boldsymbol{b}\\ {}-\boldsymbol{b}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equar.png)

同样，通过引入一个 *p* 维松弛向量变量 ***y*** 使得

![$$ \boldsymbol{y}=\boldsymbol{Ax}-\boldsymbol{b}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equas.png)

，可以将标准形式转换为标准形式

原来的向量变量 ***x*** 可以分解为正数部分***x***<sup>***+***</sup>≥0 和负数部分***x***<sup>***—***</sup>≥0。

![$$ \boldsymbol{x}={\boldsymbol{x}}^{+}-{\boldsymbol{x}}^{-} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equat.png)

让:

![$$ \hat{\boldsymbol{x}}=\left[\begin{array}{c}{\boldsymbol{x}}^{+}\\ {}{\boldsymbol{x}}^{-}\\ {}\boldsymbol{y}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq16.png)、![$$ \hat{\boldsymbol{c}}=\left[\begin{array}{c}\boldsymbol{c}\\ {}-\boldsymbol{c}\\ {}\mathbf{0}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq17.png)、![$$ \hat{\boldsymbol{A}}=\left[\boldsymbol{A}\kern0.5em -\boldsymbol{A}\kern0.5em -{\boldsymbol{I}}_{\boldsymbol{p}}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq18.png)

那么标准形式的等价 LP 问题如下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\hat{\boldsymbol{c}}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equau.png)

服从，

![$$ \hat{\boldsymbol{A}}\hat{\boldsymbol{x}}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equav.png)

![$$ \hat{\boldsymbol{x}}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equaw.png)

NM Dev 类`LPCanonicalProblem1`构造了标准形式的 LP 问题。该类签名如下:

```py
public class LPCanonicalProblem1 extends LPProblemImpl1 {

    /**
     * Construct a linear programming problem in the canonical form.
     *
     * @param c the objective function
     * @param A the coefficients, <i>A</i>, of the greater-than-or-equal-to
     *          constraints <i>A * x &ge; b</i>
     * @param b the values, <i>b</i>, of the greater-than-or-equal-to
     *          constraints <i>A * x &ge; b</i>
     */
    public LPCanonicalProblem1(
            Vector c,
            Matrix A,
            Vector b
    );

    /**
     * Construct a linear programming problem in the canonical form.
     *
     * @param cost    the objective function
     * @param greater a collection of greater-than-or-equal-to constraints
     */
    public LPCanonicalProblem1(
            Vector cost,
            LinearGreaterThanConstraints greater
    );

    /**
     * Convert a linear programming problem from the 2nd canonical form to the
     * 1st canonical form.
     *
     * @param problem a linear programming problem in the 2nd canonical form
     */
    public LPCanonicalProblem1(LPCanonicalProblem2 problem);

    /**
     * Get the greater-than-or-equal-to constraints of the linear programming
     * problem.
     *
     * @return the greater-than-or-equal-to constraints
     */
    public LinearGreaterThanConstraints getGreaterThanConstraints();
}

```

以下代码片段以规范形式构建了相同的 LP 问题:

```py
// construct an LP problem in canonical form 1
LPCanonicalProblem1 problem2
        = new LPCanonicalProblem1(
                new DenseVector(new double[]{-1.0, -1.0, 0, 0}), // c
                new DenseMatrix( // A
                        new double[][]{
                            {7, 1, 1, 0},
                            {-1, 1, 0, 1},
                            {-7, -1, -1, 0},
                            {1, -1, 0, -1}
                        }),
                new DenseVector(new double[]{15.0, 1.0, -15.0, -1.0}) // b
        );
System.out.println(problem2);

```

输出如下所示:

```py
min. objective:
[-1.000000, -1.000000, 0.000000, 0.000000]
less-than-or-equal-to inequalities:
4x4
          [,1] [,2] [,3] [,4]
[1,] -7.000000, -1.000000, -1.000000, -0.000000,
[2,] 1.000000, -1.000000, -0.000000, -1.000000,
[3,] 7.000000, 1.000000, 1.000000, -0.000000,
[4,] -1.000000, 1.000000, -0.000000, 1.000000,  * x <=
[-15.000000, -1.000000, 15.000000, 1.000000]
equalities:
free variables:

```

它与以标准形式构造的最后一个输出相同。

NM Dev 提供了另一个类`LPCanonicalProblem2`，使用小于不等式约束以规范形式构造一个 LP 问题。

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equax.png)

这受制于以下:

![$$ \boldsymbol{Ax}\le \boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equay.png)

![$$ \boldsymbol{x}\ge \mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equaz.png)

以下代码片段构建了前面显示的相同 LP 问题:

```py
// construct an LP problem in canonical form 2
LPCanonicalProblem2 problem3
        = new LPCanonicalProblem2(
                new DenseVector(new double[]{-1.0, -1.0, 0, 0}), // c
                new DenseMatrix( // A
                        new double[][]{
                            {-7, -1, -1, 0},
                            {1, -1, 0, -1},
                            {7, 1, 1, 0},
                            {-1, 1, 0, 1}
                        }),
                new DenseVector(new double[]{-15.0, -1.0, 15.0, 1.0}) // b
        );
System.out.println(problem3);

```

输出如下所示:

```py
min. objective:
[-1.000000, -1.000000, 0.000000, 0.000000]
less-than-or-equal-to inequalities:
4x4
          [,1] [,2] [,3] [,4]
[1,] -7.000000, -1.000000, -1.000000, 0.000000,
[2,] 1.000000, -1.000000, 0.000000, -1.000000,
[3,] 7.000000, 1.000000, 1.000000, 0.000000,
[4,] -1.000000, 1.000000, 0.000000, 1.000000,  * x <=
[-15.000000, -1.000000, 15.000000, 1.000000]
equalities:
free variables:

```

作为另一个例子，下面的代码片段构造了这个 LP 问题:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={x}_1+{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equba.png)

服从，

![$$ \left[\begin{array}{cc}1&amp; 1\\ {}1&amp; 2\\ {}0&amp; 3\end{array}\right]\left[\begin{array}{c}{x}_1\\ {}{x}_2\end{array}\right]\le \left[\begin{array}{c}150\\ {}170\\ {}180\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbb.png)

![$$ \boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbc.png)

```py
// construct an LP problem in canonical form 2
LPCanonicalProblem2 problem4
        = new LPCanonicalProblem2(
                new DenseVector(new double[]{1.0, 1.0}), // c
                new DenseMatrix( // A
                        new double[][]{
                            {1, 1},
                            {1, 2},
                            {0, 3}
                        }),
                new DenseVector(new double[]{150, 170, 180}) // b
        );
System.out.println(problem4);

```

输出如下所示:

```py
min. objective:
[1.000000, 1.000000]
less-than-or-equal-to inequalities:
3x2
        [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] 1.000000, 2.000000,
[3,] 0.000000, 3.000000,  * x <=
[150.000000, 170.000000, 180.000000]
equalities:
free variables:

```

图 [10-5](#Fig5) 描绘了约束条件。可行区域被着色。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig5_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig5_HTML.jpg)

图 10-5

标准型线性规划问题

### 一阶必要条件

在数学优化中，拉格朗日乘子法是一种寻找等式约束下函数的局部最大值和最小值的策略。这是极值的一阶导数测试。它将目标函数的梯度与等式约束的梯度联系起来。

假设我们要解决这个:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbd.png)

![$$ g\left(\boldsymbol{x}\right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Eqube.png)服从，

我们构造拉格朗日函数，一个 ***x*** 和 *λ* :

![$$ \mathcal{L}\left(\boldsymbol{x},\lambda \right)=f\left(\boldsymbol{x}\right)-\lambda g\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbf.png)

的函数

原约束优化对应的解***x***<sup>***∫***</sup>总是拉格朗日函数的一个鞍点。所以，我们有了这个:

![$$ \nabla \mathcal{L}\left({\boldsymbol{x}}^{\ast},{\lambda}^{\ast}\right)=\nabla f\left({\boldsymbol{x}}^{\ast}\right)-{\lambda}^{\ast}\nabla g\left({\boldsymbol{x}}^{\ast}\right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbg.png)

![$$ \nabla f\left({\boldsymbol{x}}^{\ast}\right)={\lambda}^{\ast}\nabla g\left({\boldsymbol{x}}^{\ast}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbh.png)

例如，假设我们要解决这个:

![$$ \underset{x,y}{\min }f\left(x,y\right)=x+y $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbi.png)

![$$ g\left(x,y\right)={x}^2+{y}^2-1=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbj.png)服从，

可行集是单位圆， *f* 的水平集是对角线(斜率为 1)。图 [10-6](#Fig6) 图示最小值出现在![$$ \left(-\frac{\sqrt{2}}{2},-\frac{\sqrt{2}}{2}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq19.png)。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig6_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig6_HTML.jpg)

图 10-6

带有等式约束的极小化问题

应用拉格朗日乘数，我们有如下:

![$$ \mathcal{L}\left(x,y,\lambda \right)=f\left(x,y\right)+\lambda g\left(x,y\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbk.png)

![$$ =x+y+\lambda \left({x}^2+{y}^2-1\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbl.png)

渐变如下:

![$$ \nabla \mathcal{L}\left(x,y,\lambda \right)=\left(\frac{\partial \mathcal{L}}{\partial x},\frac{\partial \mathcal{L}}{\partial y},\frac{\partial \mathcal{L}}{\partial \lambda },\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbm.png)

![$$ =\left(1+2\lambda x,1+2\lambda y,{x}^2+{y}^2-1\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbn.png)

求解![$$ \nabla \mathcal{L}\left(x,y,\lambda \right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq20.png)给出如下:

![$$ \left\{\begin{array}{c}1+2\lambda x=0\\ {}1+2\lambda y=0\\ {}{x}^2+{y}^2-1=0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbo.png)

或者等价地，

![$$ \left\{\begin{array}{c}x=-\frac{\sqrt{2}}{2}\\ {}y=-\frac{\sqrt{2}}{2}\\ {}\lambda =\frac{1}{\sqrt{2}}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbp.png)

所以，![$$ f\left(-\frac{\sqrt{2}}{2},-\frac{\sqrt{2}}{2}\right)=-\sqrt{2} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq21.png)是最小值。

卡鲁什-库恩-塔克(KKT)条件推广了拉格朗日乘数法，也考虑了不等式约束。类似于拉格朗日方法，约束最小化(最大化)问题被重写为拉格朗日函数，其最优点是鞍点，即在选择变量的域上的全局最小值(最大值)和在乘数上的全局最小值(最大值)。KKT 条件声明如果***x***<sup>***∫***</sup>是以下问题的局部极小点:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbq.png)

服从，

![$$ {a}_i\left(\boldsymbol{x}\right)=0,i=1,2,\dots p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbr.png)

![$$ {c}_j\left(\boldsymbol{x}\right)\ge 0,j=1,2,\dots q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbs.png)

然后存在拉格朗日乘数***【λ】***<sup>***】∫***</sup>和***μ***<sup>***∫***</sup>使得下面的拉格朗日函数:

![$$ \mathcal{L}\left(\boldsymbol{x},\boldsymbol{\lambda}, \boldsymbol{\mu} \right)=f\left(\boldsymbol{x}\right)-\boldsymbol{\lambda} a\left(\boldsymbol{x}\right)-\boldsymbol{\mu} c\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbt.png)

在***x***<sup>***∫***</sup>处有一个鞍点。也就是

![$$ \nabla \mathcal{L}\left({\boldsymbol{x}}^{\ast },{\boldsymbol{\lambda}}^{\ast },{\boldsymbol{\mu}}^{\ast}\right)=\nabla f\left({\boldsymbol{x}}^{\ast}\right)-{\boldsymbol{\lambda}}^{\ast}\nabla a\left({\boldsymbol{x}}^{\ast}\right)-{\boldsymbol{\mu}}^{\ast}\nabla c\left({\boldsymbol{x}}^{\ast}\right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbu.png)

或者，

![$$ \nabla f\left({\boldsymbol{x}}^{\ast}\right)={\boldsymbol{\lambda}}^{\ast}\nabla a\left({\boldsymbol{x}}^{\ast}\right)+{\boldsymbol{\mu}}^{\ast}\nabla c\left({\boldsymbol{x}}^{\ast}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbv.png)

而且，

![$$ {\boldsymbol{\lambda}}^{\ast }a\left({\boldsymbol{x}}^{\ast}\right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbw.png)

![$$ {\boldsymbol{\mu}}^{\ast }c\left({\boldsymbol{x}}^{\ast}\right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbx.png)

还有，

![$$ {\mu}_j^{\ast}\ge 0,j=1,2,\dots q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equby.png)

因此，对于非活动约束*c*<sub>*j*</sub>(***x***<sup>***∫***</sup>)>0，![$$ {\mu}_j^{\ast } $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq22.png)需要为 0。

例如，为简单起见，假设优化问题没有等式约束，只有一个不等式约束。如果极小元***x***<sup>***∫***</sup>在由 *c* <sub>1</sub> 定义的 *R* 可行域内，那么 *c* <sub>1</sub> 为无效约束。![$$ {\mu}_1^{\ast }=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq23.png)。否则，如果极小值在*c*T23】1 的边界上，即*c*T27】1(***x***<sup>***∫***</sup>)= 0，则![$$ {\mu}_1^{\ast }&gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq24.png)。![$$ \nabla f\left({\boldsymbol{x}}^{\ast}\right)={\mu}_1^{\ast}\nabla {c}_1\left({\boldsymbol{x}}^{\ast}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq25.png)。 *f* 和 *c* 的倾斜度必须朝向 *R* 的内部，如图 [10-7](img/#Fig7) 所示。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig7_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig7_HTML.jpg)

图 10-7

***x***<sup>∫</sup>是一个不等式约束边界上的极小值

### 单纯形法

当我们把 KKT 条件应用于 LP 问题的标准形式时，如下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equbz.png)

服从，

![$$ \boldsymbol{Ax}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equca.png)

![$$ \boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcb.png)

我们有这个:

![$$ \boldsymbol{c}={\boldsymbol{A}}^{\boldsymbol{T}}{\boldsymbol{\lambda}}^{\ast}+{\boldsymbol{\mu}}^{\ast} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcc.png)

还有

![$$ {\mu}_i^{\ast }{x}_i^{\ast }=0,\kern0.5em 1\le i\le n $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcd.png)

一个直接的观察是，一个解***【x】***<sup>***∫***</sup>不可能在可行域的内部。如果是，那么就不会有主动约束，**<sup>***∫***</sup>***=*****0**。那么我们就会有以下:**

**![$$ \boldsymbol{c}={\boldsymbol{A}}^{\boldsymbol{T}}{\boldsymbol{\lambda}}^{\ast} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equce.png)**

 ***n*-维向量 ***c*** 将位于***A**<sup>***T***</sup>的 *p* 列所跨越的*维子空间中。既然*p*<T22】n*这是极不可能的，除非解在边界上。因此，LP 问题的任何解都可能位于可行域的边界上，即由不等式约束定义的那些边上。*

此外，如果候选解在可行区域的边界上，我们可以简单地沿着边界移动以减小目标函数值。换句话说，从边界上的候选解开始，我们可以沿着边向下滑动以找到更小的值，直到我们到达边的末端，即顶点。参见图 [10-8](#Fig8) 。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig8_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig8_HTML.jpg)

图 10-8

LP 问题的解一定在顶点上

对于图 [10-8](#Fig8) 中的例子，假设我们从 *v* <sub>1</sub> 开始。我们可以向函数值递减的方向(向左)移动。当我们到达顶点*v*T8】2 时，我们切换到另一条边，继续向函数值递减的方向下滑到*v*T12】3，最后是*v*T16】4。*v*T20】4 是边结束的顶点。从这个顶点移动到另一个边不再减少函数值。的确，我们已经找到了极小值*v*T24】4=(0，0)。很容易看出*x*<sub>1</sub>+*x*<sub>2</sub>= 0+0 = 0 就是这个问题的解。

可以证明，对于标准形式的线性问题，如果目标函数在可行域中具有最小值，那么它在(至少)一个顶点上具有该值。这将问题简化为有限的计算，因为顶点的数量有限。原则上，我们可以检查所有顶点上的所有值来找到最小值。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig9_HTML.png](img/500382_1_En_10_Chapter/500382_1_En_10_Fig9_HTML.png)

图 10-9

线性不等式系统将多面体定义为可行域。单纯形算法从起始顶点开始，沿着多面体的边缘移动，直到到达最优解的顶点

还可以看出，如果顶点不是目标函数的最小点，则存在包含该顶点的边，使得目标函数值在远离顶点的边上严格递减。如果边是有限的，则该边连接到目标函数值较小的另一个顶点；否则，目标函数在边缘下方无界，线性问题无解。单纯形方法通过沿着多面体的边缘(由约束定义的可行区域)走到具有越来越小的目标值的顶点来应用这种洞察力。这种情况会持续下去，直到达到最小值或访问到一个无界边(得出问题无解的结论)。该算法总是终止，因为多面体中的顶点数是有限的。此外，由于我们总是在同一个方向(目标函数的方向)的顶点之间跳跃，我们希望访问的顶点的数量会很少。

对于一个规范形式的 LP 问题，如下图:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcf.png)

服从，

![$$ \boldsymbol{Ax}\ge \boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcg.png)

![$$ \boldsymbol{x}\ge \mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equch.png)

可以通过引入松弛变量***x***<sub>***B***</sub>转换成标准形式，如下图:

![$$ {\boldsymbol{x}}_{\boldsymbol{B}}=\boldsymbol{A}{\boldsymbol{x}}_{\boldsymbol{N}}-\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equci.png)

(这里我们把原始变量 ***x*** 写成***x***<sub>***N***</sub>)。)

标准形式的等价 LP 问题如下:

![$$ \underset{{\boldsymbol{x}}_{\boldsymbol{N}},{\boldsymbol{x}}_{\boldsymbol{B}}}{\min }{\boldsymbol{c}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{N}}+{\mathbf{0}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{B}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcj.png)

服从，

![$$ {\boldsymbol{x}}_{\boldsymbol{B}}=\boldsymbol{A}{\boldsymbol{x}}_{\boldsymbol{N}}-\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equck.png)

![$$ {\boldsymbol{x}}_{\boldsymbol{N}},{\boldsymbol{x}}_{\boldsymbol{B}}\boldsymbol{\ge}\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcl.png)

在这里， ***N =*** {1，2，...， *n* }是原始变量的一组指数，***B =***{*+1，...， *n* + *m* }是松弛变量的指数集合。*

 *我们将通过以下表格来表示标准 LP 问题:

![$$ {\displaystyle \begin{array}{cccccc}&amp; &amp; {x}_1&amp; \dots &amp; {x}_n&amp; 1\\ {}{x}_{n+1}&amp; =&amp; {A}_{11}&amp; &amp; {A}_{1n}&amp; -{b}_1\\ {}\vdots &amp; &amp; &amp; &amp; &amp; \\ {}{x}_{n+m}&amp; =&amp; {A}_{m1}&amp; &amp; {A}_{mn}&amp; -{b}_m\\ {}f&amp; =&amp; {c}_1&amp; &amp; {c}_n&amp; 0\end{array}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcm.png)

我们阅读这个表格的方式是，最左边的一列有因变量(或基本变量)，最上面的一行有自变量(或非基本变量)。下面举个例子:

![$$ {x}_{n+i}={A}_{i1}{x}_1+\dots +{A}_{in}{x}_n-{b}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcn.png)

![$$ f={c}_1{x}_1+\dots +{c}_n{x}_n+0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equco.png)

简而言之，画面如下:

![$$ {\displaystyle \begin{array}{cccc}&amp; &amp; {\boldsymbol{x}}_{\boldsymbol{N}}&amp; \mathbf{1}\\ {}{\boldsymbol{x}}_{\boldsymbol{B}}&amp; =&amp; \boldsymbol{A}&amp; -\boldsymbol{b}\\ {}f&amp; =&amp; {\boldsymbol{c}}^{\boldsymbol{T}}&amp; \mathbf{0}\end{array}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcp.png)

Ferris，Mangasarian，& Wright (2007)提供了下面的例子:

![$$ \underset{x_1,{x}_2}{\min }3{x}_1-6{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcq.png)

![$$ \left\{\begin{array}{c}{x}_1+2{x}_2\ge -1\\ {}2{x}_1+{x}_2\ge 0\\ {}{x}_1-{x}_2\ge -1\\ {}{x}_1-4{x}_2\ge -13\\ {}-4{x}_1+{x}_2\ge -23\\ {}{x}_1,{x}_2\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcr.png)服从，

约束的时差变量如下:

![$$ \left\{\begin{array}{c}{x}_3={x}_1+2{x}_2+1\\ {}{x}_4=2{x}_1+{x}_2\\ {}{x}_5={x}_1-{x}_2+1\\ {}{x}_6={x}_1-4{x}_2+13\\ {}{x}_7=-4{x}_1+{x}_2+23\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcs.png)

NM Dev 类`SimplexTable`为 LP 问题构造单纯形表。这里有一个例子:

```py
// construct an LP problem
LPCanonicalProblem1 problem
        = new LPCanonicalProblem1(
                new DenseVector(3., -6.), // c
                new DenseMatrix( // A
                        new double[][]{
                            {1, 2},
                            {2, 1},
                            {1, -1},
                            {1, -4},
                            {-4, 1}
                        }),
                new DenseVector(-1., 0, -1, -13, -23) // b
        );

SimplexTable tableau = new SimplexTable(problem);
System.out.println(tableau);

```

输出如下所示:

```py
                  x,1               x,2              B,2147483647
x_slack,1         1.000000          2.000000         1.000000
x_slack,2         2.000000          1.000000        -0.000000
x_slack,3         1.000000         -1.000000         1.000000
x_slack,4         1.000000         -4.000000        13.000000
x_slack,5        -4.000000          1.000000        23.000000
COST,2147483647   3.000000         -6.000000         0.000000

```

在这个初始画面中，`x,1`是*x*T5】1，`x,2`是*x*T9】2。五个`x_slack`变量是五个不等式约束的松弛变量。参见图 [10-10](#Fig10) 。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig10_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig10_HTML.jpg)

图 10-10

顶点是约束的交叉点(Ferris，Mangasarian 和 Wright，2007)

可行域多面体中的每个顶点都是由 *n* 个相应约束定义的 *n* 个超平面的交集。图 [10-8](#Fig8) 显示了作为约束交叉点的顶点。可以证明，这相当于将所有的 *n* 非基本变量设置为 0，即***x***<sub>***N***</sub>***=*****0**。例如，前面所示的初始 tableau 对应于坐标系原点处的顶点，使得所有原始变量都为 0，即***x***=***x***<sub>***N***</sub>***=*****0**。为了使这个 ***x*** 可行(不违反任何约束)，x**<sub>***B***</sub>***=—B***中的时差变量必须是非负的。即***b≤*****0**。在这种情况下，目标值 *f* ( **0** ) = 0。**

 **为了检查另一个(相邻的)顶点，我们可以将一个非基本变量与一个基本变量交换，有效地将一个非基本变量的值从 0 增加到正值，同时将一个基本变量设置为 0。比如我们需要从***x =***(*x*<sub>1</sub>，*x*<sub>2</sub>)***=***(0，0)移动到下一个顶点。在标准的线性规划问题中，由于变量的非负约束，我们只能增加变量的值。比如我们可以尝试增加*x*T18】1。

![$$ {x}_1=\lambda &gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equct.png)

于是，目标值变成如下:

![$$ f=3\lambda -6(0)=3\lambda &gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcu.png)

增加 *x* <sub>1</sub> 实际上增加了 *f* ，这与我们想要的正好相反。所以，我们可以试试这个:

![$$ {x}_2=\lambda &gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcv.png)

对于这个选择，我们有以下:

![$$ f=3(0)-6\lambda =-6\lambda &lt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcw.png)

选择非基本变量或透视列的过程称为定价。pivot 列被称为输入变量，因为它“输入”基本变量。

为了确定哪个基本变量与输入变量互换，我们需要检查增加输入变量对每个基本变量的影响。对于这个例子，我们有如下:

![$$ \left\{\begin{array}{c}{x}_3=2\lambda +1\ge 0\\ {}{x}_4=\lambda \ge 0\\ {}{x}_5=-\lambda +1\ge 0\\ {}{x}_6=-4\lambda +13\ge 0\\ {}{x}_7=\lambda +23\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcx.png)

我们希望使 *λ* 尽可能大，以最大限度地降低目标函数值，但它不能太大，以至于一些基本变量变成负值，从而违反约束。非否定性约束翻译成如下:

![$$ \left\{\begin{array}{c}\lambda \ge -\frac{1}{2}\\ {}\lambda \ge 0\\ {}\lambda \le 1\\ {}\lambda \le \frac{13}{4}\\ {}\lambda \ge -23\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcy.png)

在不违反这些约束的情况下， *λ* 可以取的最大非负值是 *λ* = 1。此外，我们观察到，阻塞变量，即如果我们将 *λ* 增加到其极限 1 以上将变为负值的变量，是*x*T8】5。因此，我们选择*x*T12】5 作为枢纽行。

选择基本变量或数据透视表行的过程称为比率测试。枢纽行被称为离开变量，因为它“离开”基本变量，成为非基本变量，取值为 0。

我们使用乔丹交换来交换 tableau 中的 *x* <sub>5</sub> (第 3 行)和 *x* <sub>2</sub> (第 2 列)。对于线性系统，Jordan 交换是将一个自变量与一个因变量交换的操作。考虑这个简单的例子:

![$$ y= ax $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equcz.png)

要颠倒 *x* 和 *y* 的作用，我们可以这样写:

![$$ x=\overset{\sim }{a}y,\overset{\sim }{a}=\frac{1}{a} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equda.png)

我们可以将这种思想推广到自变量***【x】***∈*ℝ*<sup>*n*</sup>和因变量***y***∈*ℝ*<sup>*m*</sup>的多元情况。更具体地说，假设我们有这样的:

![$$ {y}_i={A}_{i1}{x}_1+{A}_{i2}{x}_2+\dots +{A}_{in}{x}_n,i=1,\dots, m $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdb.png)

等价地，以 tableau 的形式，假设我们有这样:

![$$ {\displaystyle \begin{array}{ccccccc}&amp; &amp; {x}_1&amp; \dots &amp; {x}_s&amp; \dots &amp; {x}_n\\ {}{y}_1&amp; =&amp; {A}_{11}&amp; \dots &amp; {A}_{1s}&amp; \dots &amp; {A}_{1n}\\ {}\vdots &amp; &amp; \vdots &amp; &amp; \vdots &amp; &amp; \vdots \\ {}{y}_r&amp; =&amp; {A}_{r1}&amp; &amp; {A}_{rs}&amp; &amp; {A}_{rn}\\ {}\vdots &amp; &amp; \vdots &amp; &amp; \vdots &amp; &amp; \vdots \\ {}{y}_m&amp; =&amp; {A}_{m1}&amp; &amp; {A}_{ms}&amp; &amp; {A}_{mn}\end{array}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdc.png)

将行*r*(*y*<sub>T5】r</sub>)与列*s*(*x*<sub>*s*</sub>)对调意味着我们用 *y* <sub>*r*</sub> 来写 *x* <sub>*s* ，而留下另一个*x*这可以通过求解一个线性方程组得到 *x* <sub>*s*</sub> 。最终的画面是这样的:**</sub>

**![$$ {\displaystyle \begin{array}{ccccccccc}&amp; &amp; {x}_1&amp; \dots &amp; {x}_{s-1}&amp; {y}_r&amp; {x}_{s+1}&amp; \dots &amp; {x}_n\\ {}{y}_1&amp; =&amp; {B}_{11}&amp; \dots &amp; &amp; {B}_{1s}&amp; &amp; \dots &amp; {B}_{1n}\\ {}\vdots &amp; &amp; \vdots &amp; &amp; &amp; \vdots &amp; &amp; &amp; \vdots \\ {}{y}_{r-1}&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ {}{x}_s&amp; =&amp; {B}_{r1}&amp; &amp; &amp; {B}_{rs}&amp; &amp; &amp; {B}_{rn}\\ {}{y}_{r+1}&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\ {}\vdots &amp; &amp; \vdots &amp; &amp; &amp; \vdots &amp; &amp; &amp; \vdots \\ {}{y}_m&amp; =&amp; {B}_{m1}&amp; &amp; &amp; {B}_{ms}&amp; &amp; &amp; {B}_{mn}\end{array}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdd.png)**

在我们的示例中，这段代码执行约旦交换，将第 3 行(*x*T2】5 与第 2 列(*x*T6】2)交换。

```py
tableau = tableau.swap(3, 2);
System.out.println(tableau);

```

输出如下所示:

```py
6x3
                  x,1                x_slack,3          B,2147483647
x_slack,1         3.000000          -2.000000           3.000000
x_slack,2         3.000000          -1.000000           1.000000
x,2               1.000000          -1.000000           1.000000
x_slack,4        -3.000000           4.000000           9.000000
x_slack,5        -3.000000          -1.000000          24.000000
COST,2147483647  -3.000000           6.000000          -6.000000

```

目标函数值从 0 下降到-6。

通过重复定价和比率测试的过程，我们将测试下一个顶点，直到找到最优解(或证明无解)。请注意，tableau 的底行包含当前非基本变量的系数。就是变量每增加一个单位，f 的减少量。因此，经验法则是在定价过程中选择负系数最大的列。在我们的例子中，接下来将是 *x* <sub>1</sub> (系数为-3)。

这段代码执行第 4 行(*x*T2】6 与第 1 列(*x*T6】1)的交换。

```py
tableau = tableau.swap(4, 1);
System.out.println(tableau);

```

输出如下所示:

```py
6x3
                  x_slack,4          x_slack,3            B,2147483647
x_slack,1        -1.000000           2.000000             12.000000
x_slack,2        -1.000000           3.000000             10.000000
x,2              -0.333333           0.333333              4.000000
x,1              -0.333333           1.333333              3.000000
x_slack,5         1.000000          -5.000000             15.000000
COST,2147483647   1.000000           2.000000            -15.000000

```

现在底部行中的所有系数都是正的。我们可以从表格的最后一栏读到 LP 问题的解答。

![$$ f\left(3,4\right)=3(3)-6(4)=-15 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equde.png)T2】

这种单纯形算法对于求解线性规划问题是有效的。这是一种迭代方法，更新可行点(可行区域中的顶点)，直到达到最优。它通过对对应于线性约束方程组的矩阵执行线性变换来寻找下一个顶点。因此，解决一个线性规划问题通常需要两个阶段。第一阶段是找到一个满足所有约束的可行起点。也就是说，它找到一个 tableau，使得最后一列是非负的。在前面的例子中，如果 LP 问题是标准形式的，就意味着原点( ***x*** = **0** )满足所有约束。第二阶段从可行的表格开始，并应用一系列线性变换，直到找到最佳表格。

为了找到一个可行的起点，我们将解决一个相关的 LP 问题，称为阶段 1 LP 问题。为这个阶段 1 问题确定一个初始可行点应该很容易，它的解决方案应该给我们一个原始问题的可行点。具体来说，给定一个标准的 LP 问题，如下图:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdf.png)

服从，

![$$ \boldsymbol{Ax}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdg.png)

![$$ \boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdh.png)

我们可以通过引入一个额外的人工变量 *x* <sub>0</sub> 和松弛变量*x*<sub>*n*+*I*</sub>来构造阶段 1 LP 问题，如下:

![$$ \underset{x_0,\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)={x}_0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdi.png)

服从，

![$$ {x}_{n+i}={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i+{x}_0,{b}_i&gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdj.png)

![$$ {x}_{n+i}={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i,{b}_i\le 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdk.png)

![$$ {x}_0,{x}_{n+i},\boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdl.png)

首先，目标函数在下面有界，所以最小解是 *f* = *x* <sub>0</sub> = 0。二、第一阶段 LP 问题有一个明显的可行点，如下图:

![$$ {x}_0=\max \left(\underset{1\le i\le m}{\max }{b}_i,0\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdm.png)

还有这里:

![$$ {\boldsymbol{x}}_{\boldsymbol{N}}=\boldsymbol{x}=\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdn.png)

松弛变量如下:

![$$ {b}_i&gt;0\Longrightarrow {x}_{n+i}={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i+{x}_0=-{b}_i+\underset{1\le i\le m}{\max }{b}_i\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdo.png)

![$$ {b}_i\le 0\Longrightarrow {x}_{n+i}={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i=-{b}_i\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdp.png)

所以，***x***<sub>***B***</sub>***≥*****0**，满足所有约束。

第三，如果原问题存在一个可行点![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq26.png)，那么这个点![$$ \left({x}_0,\boldsymbol{x}\right)=\left(0,\overline{\boldsymbol{x}}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq27.png)对于第一阶段问题是可行的，因为***x***<sub>***B***</sub>***≥*****0**。

第四，如果![$$ \left(0,\overline{\boldsymbol{x}}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq28.png)是阶段 1 问题的解，那么![$$ \overline{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq29.png)就是原问题的可行点。因为这是真的:

![$$ {b}_i&gt;0\Longrightarrow 0\le {x}_{n+i}={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i+{x}_0={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdq.png)

![$$ {b}_i\le 0\Longrightarrow 0\le {x}_{n+i}={\boldsymbol{A}}_{\boldsymbol{i}}\boldsymbol{x}-{b}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdr.png)

我们有这个:

![$$ \boldsymbol{Ax}\boldsymbol{\ge}\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equds.png)

它满足原问题中的所有约束。

最后，如果( *x* <sub>0</sub> 、*T5】x*)是第 1 阶段问题的解而 *x* <sub>0</sub> > 0，那么原问题一定是不可行的。

我们可以用前面描述的单纯形法解决第一阶段的问题。NM Dev 类`FerrisMangasarianWrightPhase1`实现这个阶段 1 过程，通过旋转相关阶段 1 问题的单纯形表从不可行表中找到可行表。下面举个例子:

![$$ \min 4{x}_1+5{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdt.png)

![$$ \left\{\begin{array}{c}{x}_1+{x}_2\ge -1\\ {}{x}_1+2{x}_2\ge 1\\ {}4{x}_1+2{x}_2\ge 8\\ {}-{x}_1-{x}_2\ge -3\\ {}-{x}_1+{x}_2\ge 1\\ {}{x}_1,{x}_2\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdu.png)服从，

```py
// construct an LP problem
LPProblemImpl1 problem = new LPProblemImpl1(
        new DenseVector(4.0, 5.0), // c
        new LinearGreaterThanConstraints(
                new DenseMatrix( // A
                        new double[][]{
                            {1.0, 1.0},
                            {1.0, 2.0},
                            {4.0, 2.0},
                            {-1.0, -1.0},
                            {-1.0, 1.0}
                        }),
                new DenseVector(-1.0, 1.0, 8.0, -3.0, 1.0)), // b
        null, // less-than constraints
        null, // equality constraints
        null); // box constraints
SimplexTable table0 = new SimplexTable(problem);
System.out.println("tableau for the original problem:");
System.out.println(table0);

FerrisMangasarianWrightPhase1 phase1
        = new FerrisMangasarianWrightPhase1(table0);
SimplexTable table1 = phase1.process();
System.out.println("tableau for the phase 1 problem:");
System.out.println(table1);

System.out.printf("minimum = %f%n", table1.minimum());
System.out.printf("minimizer = %s%n", table1.minimizer());

```

输出如下所示:

```py
tableau for the original problem:
6x3
                   x,1               x,2              B,2147483647
x_slack,1          1.000000          1.000000         1.000000
x_slack,2          1.000000          2.000000        -1.000000
x_slack,3          4.000000          2.000000        -8.000000
x_slack,4         -1.000000         -1.000000         3.000000
x_slack,5         -1.000000          1.000000        -1.000000
COST,2147483647    4.000000          5.000000         0.000000

tableau for the phase 1 problem:
6x3
                   x_slack,3         x_slack,5        B,2147483647
x_slack,1          0.333333          0.333333         4.000000
x_slack,2          0.500000          1.000000         4.000000
x,2                0.166667          0.666667         2.000000
x_slack,4         -0.333333         -0.333333         0.000000
x,1                0.166667         -0.333333         1.000000
COST,2147483647    1.500000          2.000000        14.000000

minimum = 14.000000
minimizer = [1.000000, 2.000000]

```

我们找到了原问题的一个可行点， ***x*** = (1，2)。原题的最小值 *f* ( ***x*** ) = 14。

在 NM Dev 中，单纯形求解器实现接口`LPSimplexSolver`。

```py
public interface LPSimplexSolver<P extends LPProblem>
        extends LPSolver<P, LPSimplexSolution> {

    /**
     * Solve an LP problem by a simplex algorithm on a simplex table
     *
     * @param table the initial simplex table corresponding to the LP problem
     * @return an LP solution
     * @throws Exception when there is an error
     */
    public LPSimplexSolution solve(SimplexTable table) throws Exception;
}

```

类`LPTwoPhaseSolver`实现了我们在本节中描述的两阶段算法。它以`LPProblem`的形式接受一个 LP 问题，并以`LPSimplexSolution`的形式输出一个解决方案。该类签名如下:

```py
public class LPTwoPhaseSolver implements LPSimplexSolver<LPProblem> {

    private class Solution implements LPSimplexSolution {
......
    }

    private final LPSimplexSolver<LPCanonicalProblem1> solver;//a canonical LP solver

    /**
     * Construct an LP solver to solve LP problems.
     *
     * @param solver a canonical LP solver
     */
    public LPTwoPhaseSolver(LPSimplexSolver<LPCanonicalProblem1> solver) {
        this.solver = solver;
    }

    /**
     * Construct an LP solver to solve LP problems.
     */
    public LPTwoPhaseSolver() {
        this(new LPCanonicalSolver());
    }

    @Override
    public LPSimplexSolution solve(SimplexTable table) throws LPInfeasible, Exception {
        return new Solution(table);
    }

    @Override
    public LPSimplexSolution solve(LPProblem problem) throws LPInfeasible, Exception {
        return solve(new SimplexTable(problem));
    }
}

```

继续前面的示例，下面的代码使用两阶段算法解决了 LP 问题:

```py
// construct an LP problem
LPProblemImpl1 problem = new LPProblemImpl1(
        new DenseVector(4.0, 5.0), // c
        new LinearGreaterThanConstraints(
                new DenseMatrix( // A
                        new double[][]{
                            {1.0, 1.0},
                            {1.0, 2.0},
                            {4.0, 2.0},
                            {-1.0, -1.0},
                            {-1.0, 1.0}
                        }),
                new DenseVector(-1.0, 1.0, 8.0, -3.0, 1.0)), // b
        null, // less-than constraints
        null, // equality constraints
        null); // box constraints

// construct the simplex tableau for the LP problem
SimplexTable table0 = new SimplexTable(problem);
System.out.println("simplex tableau for the problem:");
System.out.println(table0);

// solve the LP problem using the 2-phase algorithm
LPTwoPhaseSolver solver = new LPTwoPhaseSolver();
LPBoundedMinimizer solution
        = (LPBoundedMinimizer) solver.solve(problem).minimizer();

System.out.printf("minimum = %f%n", solution.minimum());
System.out.printf("minimizer = %s%n", solution.minimizer());

```

输出如下所示:

```py
simplex tableau for the problem:
6x3
                  x,1               x,2                 B,2147483647
x_slack,1         1.000000          1.000000            1.000000
x_slack,2         1.000000          2.000000           -1.000000
x_slack,3         4.000000          2.000000           -8.000000
x_slack,4        -1.000000         -1.000000            3.000000
x_slack,5        -1.000000          1.000000           -1.000000
COST,2147483647   4.000000          5.000000            0.000000

minimum = 14.000000
minimizer = [1.000000, 2.000000]

```

原来 *f* (1，2) = 14 确实是原问题的解。

作为另一个例子，下面的代码解决了陈，Batson，& Dang (2009)中的 LP 问题:

![$$ \underset{x_1,{x}_2}{\min }-5{x}_1+2{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdv.png)

![$$ \left\{\begin{array}{c}{x}_1+3{x}_2\ge 9\\ {}-{x}_1+2{x}_2\le 5\\ {}3{x}_1+2{x}_2\ge 19\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdw.png)服从，

```py
// construct an LP problem
LPProblemImpl1 problem = new LPProblemImpl1(
        new DenseVector(-5.0, 2.0), // c
        new LinearGreaterThanConstraints(
                new DenseMatrix( // A1
                        new double[][]{
                            {1.0, 3.0}}),
                new DenseVector(9.0)), // b1
        new LinearLessThanConstraints(
                new DenseMatrix( // A2
                        new double[][]{
                            {-1.0, 2.0},
                            {3.0, 2.0}}),
                new DenseVector(5.0, 19.0)), // b2
        null,
        null);

// construct the simplex tableau for the LP problem
SimplexTable table0 = new SimplexTable(problem);
System.out.println("simplex tableau for the problem:");
System.out.println(table0);

// solve the LP problem using the 2-phase algorithm
LPTwoPhaseSolver solver = new LPTwoPhaseSolver();
LPMinimizer solution = solver.solve(problem).minimizer();

System.out.printf("minimum = %f%n", solution.minimum());
System.out.printf("minimizer = %s%n", solution.minimizer());

```

输出如下所示:

```py
simplex tableau for the problem:
4x3
                     x,1             x,2                    B,2147483647
x_slack,1            1.000000        3.000000              -9.000000
x_slack,2            1.000000       -2.000000               5.000000
x_slack,3           -3.000000       -2.000000              19.000000
COST,2147483647     -5.000000        2.000000               0.000000

minimum = -25.571429
minimizer = [5.571429, 1.142857]

```

最优解是![$$ f\left(\frac{39}{7},\frac{8}{7}\right)=-25.57 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq30.png)。

作为另一个例子，下面的代码解决了 Ferris，Mangasarian 和 Wright (2007)中的 LP 问题。

![$$ \underset{x_1,{x}_2}{\min }2{x}_1-{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdx.png)T2】

![$$ \left\{\begin{array}{c}{x}_1\ge -6\\ {}-{x}_1=-4\\ {}{x}_1\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdy.png)服从，

```py
// construct an LP problem
LPProblemImpl1 problem = new LPProblemImpl1(
        new DenseVector(2.0, -1.0), // c
        new LinearGreaterThanConstraints(
                new DenseMatrix( // A1
                        new double[][]{
                            {1.0, 0.0}
                        }),
                new DenseVector(-6.0)), // b1
        null,
        new LinearEqualityConstraints(
                new DenseMatrix( // A2
                        new double[][]{
                            {-1.0, 0.0} // b2
                        }),
                new DenseVector(-4.0)),
        new BoxConstraints(
                2,
                new BoxConstraints.Bound(
                        2,
                        Double.NEGATIVE_INFINITY,
                        Double.POSITIVE_INFINITY)) // x2 is free
);

// construct the simplex tableau for the LP problem
SimplexTable table0 = new SimplexTable(problem);
System.out.println("simplex tableau for the problem:");
System.out.println(table0);

// solve the LP problem using the 2-phase algorithm
LPTwoPhaseSolver solver = new LPTwoPhaseSolver();
LPUnboundedMinimizer solution
        = (LPUnboundedMinimizer) solver.solve(problem).minimizer();

System.out.printf("minimum = %f%n", solution.minimum());
System.out.printf("minimizer = %s%n", solution.minimizer());
System.out.printf("v = %s%n", minimizer.v());

```

输出如下所示:

```py
simplex tableau for the problem:
3x3
                     x,1              FREE,2             B,2147483647
x_slack,1            1.000000         0.000000           6.000000
EQUALITY,1          -1.000000         0.000000           4.000000
COST,2147483647      2.000000        -1.000000           0.000000

minimum = -Infinity
minimizer = [0.000000, 1.000000]
v = [0.000000, 1.000000]

```

原来这个问题下面无界。

作为另一个例子，下面的代码解决了费里斯、曼加萨里安和赖特(2007)的 LP 问题:

![$$ \underset{x_1,{x}_2}{\min }2{x}_1-{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equdz.png)

![$$ \left\{\begin{array}{c}{x}_1-2{x}_2\ge -2\\ {}{x}_1=4\\ {}2{x}_1=6\\ {}{x}_1\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equea.png)服从，

```py
// construct an LP problem
LPProblemImpl1 problem = new LPProblemImpl1(
        new DenseVector(2.0, -1.0), // c
        new LinearGreaterThanConstraints(
                new DenseMatrix( // A
                        new double[][]{{1.0, 0.0}}),
                new DenseVector(6.0)), // b
        null,
        new LinearEqualityConstraints(
                new DenseMatrix(
                        new double[][]{
                            {-1.0, 0.0}}), // A
                new DenseVector(-4.0)), // b
        new BoxConstraints(
                2,
                new BoxConstraints.Bound(
                        2,
                        Double.NEGATIVE_INFINITY,
                        Double.POSITIVE_INFINITY)) // x2 is free
);

// construct the simplex tableau for the LP problem
SimplexTable table0 = new SimplexTable(problem);
System.out.println("simplex tableau for the problem:");
System.out.println(table0);

// solve the LP problem using the 2-phase algorithm
LPTwoPhaseSolver solver = new LPTwoPhaseSolver();
LPMinimizer minimizer = solver.solve(problem).minimizer();

```

输出如下所示:

```py
simplex tableau for the problem:
3x3
                    x,1                 FREE,2              B,2147483647
x_slack,1           1.000000            0.000000            -6.000000
EQUALITY,1         -1.000000            0.000000             4.000000
COST,2147483647     2.000000           -1.000000             0.000000

Exception in thread "main" dev.nm.solver.multivariate.constrained.convex.sdp.socp.qp.lp.exception.LPInfeasible
         at dev.nm.solver.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.FerrisMangasarianWrightPhase1.process(FerrisMangasarianWrightPhase1.java:81)
         at dev.nm.solver.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver$Solution.<init>(LPTwoPhaseSolver.java:64)
         at dev.nm.solver.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver$Solution.<init>(LPTwoPhaseSolver.java:45)
         at dev.nm.solver.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver.solve(LPTwoPhaseSolver.java:104)
         at dev.nm.solver.multivariate.constrained.convex.sdp.socp.qp.lp.simplex.solver.LPTwoPhaseSolver.solve(LPTwoPhaseSolver.java:109)
         at dev.nm.nmj.Chapter10.lp_solver_3(Chapter10.java:108)
         at dev.nm.nmj.Chapter10.main(Chapter10.java:75)

```

注意，这个程序抛出了一个`LPInfeasible`异常。在阶段 1 中检测到这个问题是不可行的。

### 10.2.4 单纯形法代数

在上一节中，我们讨论了单纯形法的几何。我们也可以在 10.1.1 节的通用优化框架中对算法进行强制转换。给定一个顶点***x***<sub>***k***</sub>(不伦不类的意思是它正好有 *n* 条边或活动约束)，一个顶点***x***<sub>***k+*****1**</sub>据说与***x***<sub>***相邻***</sub>

***T57***

其中![$$ {\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq31.png)是第*个*个约束的系数。与 ***相关联的一个***<sub>***AK***</sub>是活动约束的集合索引。

![$$ {\mathfrak{I}}_k=\left\{j1,j2,\dots jn\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equec.png)

其中 *ji* 代表原始变量中的索引。

换句话说，如果![$$ {\mathfrak{I}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq32.png)和![$$ {\mathfrak{I}}_{k+1} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq33.png)有完全相同的(*n*—1)个成员，**x**<sub>***k***</sub>和***x***<sub>***k+*****1**</sub>相邻。作为顶点***x***<sub>***k***</sub>，单纯形算法检查***x***<sub>***k***</sub>是否为极小点。如果不是，则查找给出较小目标函数值的相邻***x***<sub>***k+*****1**</sub>。如果存在极小值，并且有有限个顶点，单纯形算法将总是在有限次迭代中找到解。

KKT 条件说存在一个***λ***<sub>***k***</sub>∈*<sup>*n*</sup>这样*

*![$$ \boldsymbol{c}={\boldsymbol{A}}_{\boldsymbol{ak}}^{\boldsymbol{T}}{\boldsymbol{\lambda}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equed.png)*

 *并且那个***x***<sub>***k***</sub>是极小值如果这个为真:

![$$ {\boldsymbol{\lambda}}_{\boldsymbol{k}}\boldsymbol{\ge}\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equee.png)

换句话说，***x***<sub>***k***</sub>不是极小值当且仅当***λ***<sub>***k***</sub>中至少有一个分量，比如说 *l* -th 分量(***λ***<sub>***k**【T30)也就是*</sub>

*![$$ {\left({\boldsymbol{\lambda}}_{\boldsymbol{k}}\right)}_l&lt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equef.png)*

在我们的一般优化算法中，下一个(和相邻的)顶点由下面给出:

![$$ {\boldsymbol{x}}_{\boldsymbol{k}+\mathbf{1}}={\boldsymbol{x}}_{\boldsymbol{k}}+{\alpha}_k{\boldsymbol{d}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equeg.png)

可以看出，一个可行的下降方向***【d】***<sub>***k***</sub>的特征如下:

**a**<sub>***【AK】***</sub>

求边缘***d***<sub>***k***</sub>，我们求解如下:

![$$ {\boldsymbol{A}}_{\boldsymbol{ak}}{\boldsymbol{d}}_{\boldsymbol{k}}={\boldsymbol{e}}_{\boldsymbol{l}}\boldsymbol{\ge}\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equeh.png)

其中***e***<sub>***l***</sub>为第 *l* 个坐标向量(即第 *l* 列的第 *n* × *n* 个单位矩阵)。

于是，我们有了以下:

![$$ {\boldsymbol{c}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}={\boldsymbol{\lambda}}_{\boldsymbol{k}}^{\boldsymbol{T}}{\boldsymbol{A}}_{\boldsymbol{ak}}{\boldsymbol{d}}_{\boldsymbol{k}}={\boldsymbol{\lambda}}_{\boldsymbol{k}}^{\boldsymbol{T}}{\boldsymbol{e}}_{\boldsymbol{l}}={\left({\boldsymbol{\lambda}}_{\boldsymbol{k}}\right)}_l&lt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equei.png)

因此，***d***<sub>***k***</sub>是一个可行的下降方向。

而且，对于*I*≦*l*，我们有这个:

![$$ {\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}}\left({\boldsymbol{x}}_{\boldsymbol{k}}+{\alpha}_k{\boldsymbol{d}}_{\boldsymbol{k}}\right)={\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{k}}+{\alpha}_k{\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}={b}_{ji} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equej.png)

我们可以求解*α*<sub>T3】IT5】对于每个 *i* 在指标集**<sub>***k***</sub>和![$ {\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}&lt;0 $](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq35.png)**</sub>

**![$$ {\mathcal{I}}_k=\left\{i:{\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{k}}-{b}_{ji}&gt;0,{\boldsymbol{a}}_{\boldsymbol{ji}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}&lt;0\ \right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equek.png)**

**![$$ {\alpha}_k=\underset{i\in {\mathcal{I}}_k}{\min}\left\{{\alpha}_i\right\}=\underset{i\in {\mathcal{I}}_k}{\min}\left(\frac{b_i-{\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{k}}}{{\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equel.png)**

 **NM Dev 类`LPRevisedSimplexSolver`实现了& Lu (2007)中描述的单纯形算法的代数形式。我们可以使用这个求解器来解决我们在上一节中解决的陈，【Batson，】Dang (2009)中的 LP 问题。

我们需要改变这一行:

```py
LPTwoPhaseSolver solver = new LPTwoPhaseSolver();

```

对此:

```py
LPRevisedSimplexSolver solver = new LPRevisedSimplexSolver(1e-8);

```

使用不同的规划求解。

![$$ \underset{x_1,{x}_2}{\min }-5{x}_1+2{x}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equem.png)T2】

![$$ \left\{\begin{array}{c}{x}_1+3{x}_2\ge 9\\ {}-{x}_1+2{x}_2\le 5\\ {}3{x}_1+2{x}_2\ge 19\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equen.png)服从，

```py
// construct an LP problem
LPProblemImpl1 problem = new LPProblemImpl1(
        new DenseVector(-5.0, 2.0), // c
        new LinearGreaterThanConstraints(
                new DenseMatrix( // A1
                        new double[][]{
                            {1.0, 3.0}}),
                new DenseVector(9.0)), // b1
        new LinearLessThanConstraints(
                new DenseMatrix( // A2
                        new double[][]{
                            {-1.0, 2.0},
                            {3.0, 2.0}}),
                new DenseVector(5.0, 19.0)), // b2
        null,
        null);

// solve the LP problem using the algebraic LP solver
LPRevisedSimplexSolver solver = new LPRevisedSimplexSolver(1e-8);
LPMinimizer solution = solver.solve(problem).minimizer();

System.out.printf("minimum = %f%n", solution.minimum());
System.out.printf("minimizer = %s%n", solution.minimizer());

```

输出如下所示:

```py
minimum = -25.571429
minimizer = [5.571429, 1.142857]

```

它们与其他两相求解器的结果完全相同。

## 10.3 二次规划

二次规划(QP)是最小化受线性约束的二次目标函数。它有重要的应用，如在定量金融。此外，它还经常用于解决其他更一般的非线性约束优化中的子问题，如序列二次规划。这个问题经常这样表述:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\frac{1}{2}{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{Hx}+{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{p} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equeo.png)

![$$ \boldsymbol{A}x\ge \boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equep.png)服从，

其中***a***∑*ℝ*<sup>*p*×*n*</sup>为 *p* 为 *n* 变量的线性约束。我们通常假设矩阵 ***A*** 是对称的，满秩的，并且半正定 ***A*** ≽ 0。

如果海森矩阵 ***H*** ≽ 0 是半正定的，那么这个问题就是一个凸优化问题。这个问题可以在(弱)多项式时间内解决。否则问题就是 NP 难的。一个非凸问题可以有几个驻点和局部极小值。事实上，即使 ***H*** 只有一个负特征值，问题也是强 NP 难的。

QP 的一个重要应用是现代投资组合理论。假设我们想分配一笔资金购买 n 只股票，并持有该投资组合一年。虽然一只股票一年后的确切回报是未知的，但我们可以对年回报建模，*r*<sub>T5】I</sub>，对于股票 *i* 作为随机变量，称之为正态分布。也就是

![$$ {r}_i\sim N\left({\mu}_i,{\sigma}_i\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equeq.png)

因为股票并不是完全独立的，它们往往会上下联动。它们是相关的。股票 *i* 和股票 *j* 的相关性如下:

![$$ {\rho}_{ij}=\frac{\mathrm{E}\left[\left({r}_i-{\mu}_i\right)\left({r}_j-{\mu}_j\right)\right]}{\sigma_i{\sigma}_j} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equer.png)

投资者的决策是决定将资金池中的多少部分或多少权重 *w* <sub>*i*</sub> 】投入每只股票，以构建他们的投资组合。投资组合的预期收益如下:

![$$ \mathrm{E}\left[R\right]=\mathrm{E}\left[\sum \limits_{i=1}^n{w}_i{r}_i\right]=\sum \limits_{i=1}^n{w}_i\mathrm{E}\left[{r}_i\right]=\sum \limits_{i=1}^n{w}_i{\mu}_i={\boldsymbol{w}}^{\boldsymbol{T}}\boldsymbol{\mu} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Eques.png)

投资组合的方差如下:

![$$ Var\left[R\right]=\mathrm{E}\left[{\left(R-\mathrm{E}\left[R\right]\right)}^2\right]=\sum \limits_{i=1}^n\sum \limits_{j=1}^n{w}_i{w}_j{\sigma}_i{\sigma}_j{\rho}_{ij}={\boldsymbol{w}}^{\boldsymbol{T}}\boldsymbol{\Sigma} \boldsymbol{w} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equet.png)

其中**σ**为 *n* × *n* 对称半正定协方差矩阵定义如下:

![$$ {\Sigma}_{ij}={\rho}_{ij}{\sigma}_i{\sigma}_j $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equeu.png)

Markowitz 提出，投资者应该找到一个权重，使投资组合的预期回报最大化，而风险(由投资组合方差衡量)最小化。这实质上成立了以下 QP 问题:

![$$ \underset{\boldsymbol{w}}{\min}\lambda {\boldsymbol{w}}^{\boldsymbol{T}}\boldsymbol{\Sigma} \boldsymbol{w}-{\boldsymbol{w}}^{\boldsymbol{T}}\boldsymbol{\mu} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equev.png)

![$$ \sum \limits_{i=1}^n{w}_i=1 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equew.png)服从，

所有权重的总和等于 100%。我们可以施加其他约束，比如每只股票的最小权重为 0%。这意味着不允许卖空。这个不等式约束可以写成:

![$$ \boldsymbol{w}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equex.png)

*λ*T14】0 称为风险厌恶系数。为了最小化风险而更加保守的投资者会选择更小的 *λ* 。另一方面，一个更激进的投资者，他的目标是更高的预期回报，并能承受可能的更大损失，他会选择更大的 *λ* 。改变 *λ* 给出不同的投资组合(不同的权重),这些投资组合满足以下条件:不存在其他投资组合具有更高的预期回报，但具有与该 *λ* 相同的回报标准差(即风险)。这些最优投资组合的集合(对于不同的 *λ* s)一起画出了我们所说的有效边界。参见图 [10-11](#Fig11) 。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig11_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig11_HTML.jpg)

图 10-11

投资组合的有效边界

### 10.3.1 只有等式约束的凸 QP 问题

让我们从一个简单的凸 QP 问题开始，我们可以解析地解决它。一个只有等式约束的凸 QP 问题表述如下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\frac{1}{2}{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{Hx}+{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{p} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equey.png)

![$$ \boldsymbol{A}x=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equez.png)服从，

其中 ***H*** ≽ 0， ***A*** ≽ 0，***a***∈*ℝ*<sup>*p*×*n*</sup>， ***A*** 与 *p* < *n* 对称且满秩。

可以看出，解 ***x*** 采取这样的形式:

![$$ \boldsymbol{x}={\boldsymbol{V}}_{\boldsymbol{r}}\boldsymbol{\phi} +{\boldsymbol{A}}^{+}\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfa.png)

其中***V***<sub>***r***</sub>由最后一个*n*—*p*列的 ***V*** 组成。 ***V*** 是对***A = U*****σ*****V***<sup>***T***</sup>的奇异值分解。**<sup>***+***</sup>是 ***的摩尔-彭罗斯逆。*****

 **利用这种解的形式，问题可以转化为一个等价的无约束极小化问题，如下图:

![$$ \underset{\boldsymbol{\phi}}{\min}\hat{f}\left(\boldsymbol{\phi} \right)=\frac{1}{2}{\boldsymbol{\phi}}^{\boldsymbol{T}}\hat{\boldsymbol{H}}\boldsymbol{\phi} +{\boldsymbol{\phi}}^{\boldsymbol{T}}\hat{\boldsymbol{p}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfb.png)

其中

![$$ \hat{\boldsymbol{H}}={\boldsymbol{V}}_{\boldsymbol{r}}^{\boldsymbol{T}}\boldsymbol{H}{\boldsymbol{V}}_{\boldsymbol{r}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfc.png)

![$$ \hat{\boldsymbol{p}}={\boldsymbol{V}}_{\boldsymbol{r}}^{\boldsymbol{T}}\left(\boldsymbol{H}{\boldsymbol{A}}^{+}\boldsymbol{b}+\boldsymbol{p}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfd.png)

如果 ***H*** ≻ 0 是正定的，那么![$$ \hat{\boldsymbol{H}}\succ 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq36.png)问题的唯一全局极小点如下:

![$$ {\boldsymbol{x}}^{\ast}={\boldsymbol{V}}_{\boldsymbol{r}}{\boldsymbol{\phi}}^{\ast}+{\boldsymbol{A}}^{+}\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfe.png)

其中**<sup>***∫***</sup>是线性系统的解:**

**![$$ \hat{\boldsymbol{H}}\boldsymbol{\phi} =-\hat{\boldsymbol{p}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equff.png)**

 **如果 ***H*** ≽ 0 是半正定的，那么![$$ \hat{\boldsymbol{H}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq37.png)不是正定就是半正定。如果![$$ \hat{\boldsymbol{H}}\succ 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq38.png)是正定的，那么***x***<sup>***∫***</sup>就是问题的唯一全局极小点。如果![$$ \hat{\boldsymbol{H}}\succcurlyeq 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq39.png) ≽ 0 是半正定的，那么有两种可能。如果![$$ \hat{\boldsymbol{p}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq40.png)可以表示为![$$ \hat{\boldsymbol{H}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq41.png)列的线性组合，那么 *f* ( *x* )有无穷多个全局极小值。否则，不存在极小值。

下面用和陆(2007)

![$$ \underset{x_1,{x}_2,{x}_3}{\min }f\left({x}_1,{x}_2,{x}_3\right)=\frac{1}{2}\left({x}_1^2+{x}_2^2\right)+2{x}_1+{x}_2-{x}_3 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfg.png)

中的问题来说明这个方法

![$$ \boldsymbol{Ax}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfh.png)服从，

![$$ \boldsymbol{A}=\left[0\kern0.5em 1\kern0.5em 1\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq42.png)， *** b *** = 1

矩阵形式的目标函数如下:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\frac{1}{2}{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{Hx}+{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{p} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfi.png)

![$$ \boldsymbol{H}=\left[\begin{array}{ccc}1&amp; 0&amp; 0\\ {}0&amp; 1&amp; 0\\ {}0&amp; 0&amp; 0\end{array}\right]\succcurlyeq 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfj.png)

![$$ \boldsymbol{p}=\left[\begin{array}{c}2\\ {}1\\ {}-1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfk.png)

**的奇异值分解给出如下:![$$ {\boldsymbol{V}}_{\boldsymbol{r}}=\left[\kern0.5em \begin{array}{cc}1&amp; 0\\ {}0&amp; \frac{\sqrt{2}}{2}\\ {}0&amp; -\frac{\sqrt{2}}{2}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfl.png)**

**![$$ {\mathbf{A}}^{+}=\left[\begin{array}{c}0\\ {}0.5\\ {}0.5\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfm.png)**

 **因此，我们有以下:

![$$ \hat{\boldsymbol{H}}={\boldsymbol{V}}_r^T\boldsymbol{H}{\boldsymbol{V}}_r=\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; \frac{\sqrt{2}}{2}\end{array}\right]\succ 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfn.png)

唯一的全局极小点如下:

![$$ {\boldsymbol{x}}^{\ast}={\boldsymbol{V}}_{\boldsymbol{r}}{\boldsymbol{\phi}}^{\ast}+{\boldsymbol{A}}^{+}\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfo.png)

![$$ =\left[\kern0.75em \begin{array}{cc}1&amp; 0\\ {}0&amp; \frac{\sqrt{2}}{2}\\ {}0&amp; -\frac{\sqrt{2}}{2}\end{array}\ \right]\times \left[\ \begin{array}{c}-2\\ {}-3.5355\end{array}\ \right]+\left[\ \begin{array}{c}0\\ {}0.5\\ {}0.5\end{array}\ \right]\left[1\right]=\left[\ \begin{array}{c}-2\\ {}-2\\ {}3\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfp.png)

在 NM Dev 中，类`QuadraticFunction`构造了一个如下形式的二次函数:

![$$ f\left(\boldsymbol{x}\right)=\frac{1}{2}{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{Hx}+{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{p}+\boldsymbol{c} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfq.png)

该类签名如下:

```py
public class QuadraticFunction extends AbstractRealScalarFunction {

    /**
     * Construct a quadratic function of this form: \(f(x) = \frac{1}{2} \times
     * x'Hx + x'p + c\).
     *
     * @param H a symmetric, positive semi-definite matrix
     * @param p a vector
     * @param c a constant
     */
    public QuadraticFunction(Matrix H, Vector p, double c);

    /**
     * Construct a quadratic function of this form: \(f(x) = \frac{1}{2} \times
     * x'Hx + x'p\).
     *
     * @param H a symmetric, positive semi-definite matrix
     * @param p a vector
     */
    public QuadraticFunction(Matrix H, Vector p);

    /**
     * Copy constructor.
     *
     * @param f a quadratic function
     */
    public QuadraticFunction(QuadraticFunction f);

    public ImmutableMatrix Hessian();

    public ImmutableVector p();

    @Override
    public Double evaluate(Vector z);

    @Override
    public String toString();
}

```

类`QPSimpleMinimizer`是一个效用类，它有一个效用函数集合来解决无约束的 QP 问题和只有等式约束的 QP 问题。这两个问题都可以通过分析来解决。以下代码重现了前面的示例:

```py
//construct the QP problem with only equality constraints
DenseMatrix H = new DenseMatrix(
        new double[][]{
            {1, 0, 0},
            {0, 1, 0},
            {0, 0, 0}
        });
DenseVector p = new DenseVector(2, 1, -1);
QuadraticFunction f = new QuadraticFunction(H, p);
System.out.println("minimizing:");
System.out.println(f);

// equality constraints
DenseMatrix A = new DenseMatrix(
        new double[][]{
            {0, 1, 1}
        });
DenseVector b = new DenseVector(1.);
LinearEqualityConstraints Aeq = new LinearEqualityConstraints(A, b);

// solve a QP problem with only equality constraints
QPSolution soln = QPSimpleMinimizer.solve(f, Aeq);
Vector x = soln.minimizer();
double fx = f.evaluate(x);
System.out.printf("f(%s) = %f%n", x, fx);
System.out.printf("is unique = %b%n", soln.isUnique());

```

输出如下所示:

```py
minimizing:
1/2 * x'3x3
          [,1] [,2] [,3]
[1,] 1.000000, 0.000000, 0.000000,
[2,] 0.000000, 1.000000, 0.000000,
[3,] 0.000000, 0.000000, 0.000000, x + x'[2.000000, 1.000000, -1.000000]
f([-2.000000, -2.000000, 3.000000] ) = -5.000000
is unique = true

```

NM Dev 计算相同的最优解![$$ {\boldsymbol{x}}^{\ast}=\left[\begin{array}{c}-2\\ {}-2\\ {}3\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq43.png)和最小值 5。

### 10.3.2 严格凸 QP 问题的有效集方法

一般来说，一个 QP 问题可以表述为:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\frac{1}{2}{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{Hx}+{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{p} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfr.png)

![$$ \boldsymbol{Ax}\boldsymbol{\ge}\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfs.png)服从，

其中***A***∈*R*<sup>*p*×*n*</sup>。

不失一般性，我们跳过等式约束，因为它们可以在 10.3.1 节中消除。

最小点处的卡鲁什-库恩-塔克(KKT)条件 ***x*** 由以下给出:

![$$ \boldsymbol{Hx}+\boldsymbol{p}-{\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{\mu} =\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equft.png)

![$$ \left({\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{x}-{b}_i\right){\mu}_i=0,i=1,2,\dots, p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfu.png)

![$$ {\mu}_i\ge 0,i=1,2,\dots, p $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfv.png)

假设解***×解***<sup>***∫***</sup>在可行区域的内部。(与解必须在边界上的 LP 不同，QP 问题的解可以在可行域内。)然后我们有了这个:

![$$ \boldsymbol{A}{\boldsymbol{x}}^{\ast}-\boldsymbol{b}&gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfw.png)

这暗示了以下:

![$$ {\boldsymbol{\mu}}^{\ast}=\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfx.png)

于是我们有了这个:

![$$ \boldsymbol{H}{\boldsymbol{x}}^{\ast}+\boldsymbol{p}=\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfy.png)

唯一的全局极小元***x***<sup>***∫***</sup>就是这个线性系统的解，如下图:

![$$ {\boldsymbol{x}}^{\ast}=-{\boldsymbol{H}}^{-\mathbf{1}}\boldsymbol{p} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equfz.png)

#### 原始活动集方法

如果解***x***<sup>***∫***</sup>不是内点而是在可行域的边界上，那么下一步的搜索方向就是将当前迭代点 ***x*** 处的活动约束视为一组等式约束，而忽略其他约束。这是解决一般凸 QP 问题的有效集方法。

设***x***<sub>***k***</sub>为第 *k* 次迭代中的可行迭代点。设 *J* <sub>*k*</sub> 为活动约束的索引集，即那些带有![$$ {\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{x}-{b}_i=\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq44.png)的约束称为活动集。下一次迭代，如 10.1.1 节中的一般优化算法，如下:

![$$ {\boldsymbol{x}}_{\boldsymbol{k}+\mathbf{1}}={\boldsymbol{x}}_{\boldsymbol{k}}+\boldsymbol{d}={\boldsymbol{x}}_{\boldsymbol{k}}+{\alpha}_k{\boldsymbol{d}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equga.png)

在***x***<sub>***k***</sub>处于活动状态的约束在***x***<sub>***k+*****1**</sub>保持活动状态，如果下列条件成立:

![$$ {\boldsymbol{a}}_{\boldsymbol{j}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{k}+\mathbf{1}}-{b}_j=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq45.png)、*【j】**【j】*

 *在下一个迭代方程的两边乘以![$$ {\boldsymbol{a}}_{\boldsymbol{j}}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq46.png),我们得到:

![$$ {\boldsymbol{a}}_{\boldsymbol{j}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq47.png)、*【j】**【j】*

 ****处的目标函数 x***<sub>***k***</sub>+***d***如下:

![$$ {f}_k\left(\boldsymbol{d}\right)=\frac{1}{2}{\boldsymbol{d}}^{\boldsymbol{T}}\boldsymbol{Hd}+{\boldsymbol{d}}^{\boldsymbol{T}}{\boldsymbol{g}}_{\boldsymbol{k}}+{c}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgb.png)

其中

![$$ {\boldsymbol{g}}_{\boldsymbol{k}}=\boldsymbol{p}+{\boldsymbol{Hx}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgc.png)

而*c*<sub>T3】kT5】是常数。</sub>

活动集方法中的一个主要步骤就是用等式约束来解决下面这个 QP 子问题，如下所示:

![$$ \underset{\boldsymbol{d}}{\min}\hat{f}\left(\boldsymbol{d}\right)=\frac{1}{2}{\boldsymbol{d}}^{\boldsymbol{T}}\boldsymbol{Hd}+{\boldsymbol{d}}^{\boldsymbol{T}}{\boldsymbol{g}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgd.png)

服从于，

![$$ {\boldsymbol{a}}_{\boldsymbol{j}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq48.png)、*【j】**【j】*

 *这可以使用第 10.3.1 节中的方法解决。原始活动集算法如下:

**原始有效集算法**

**第一步**

从一个可行的初始点***x***<sub>T5】0</sub>开始。

确定初始激活集*J*T2【0】T3】。

形成矩阵***A***<sub>***A*****0**</sub>作为 ***A*** 的子矩阵，仅使用 *J* <sub>0</sub> 中的活动约束。

设置 *k* = 0。

**第二步**

计算***g***<sub>***k***</sub>=***p***+***Hx***<sub>***k***</sub>。

使用***g***<sub>***k***</sub>检查***d***<sub>***k***</sub>是否为零。如果***d***<sub>***k***</sub>不为零，则转到**步骤 4** 。

**第三步**

(***d***<sub>***k***</sub>***=*****0**)

使用![$$ {\boldsymbol{A}}_{\boldsymbol{ak}}^{\boldsymbol{T}}\hat{\boldsymbol{\mu}}={\boldsymbol{g}}_{\boldsymbol{k}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq50.png)求解![$$ \hat{\boldsymbol{\mu}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq49.png)。

如果![$$ \hat{\boldsymbol{\mu}}\boldsymbol{\ge}\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq51.png)，输出***x***T5***k***作为解并终止。

否则，从***【J】***<sub>***k***</sub>中移除与最负拉格朗日乘数相关联的索引。

**第四步**

(

 ********利用只有等式约束的子 QP 问题求解***d***<sub>***k***</sub>。

**第五步**

计算出*a*<sub>T3】kT5】。</sub>

![$$ {\alpha}_k=\min \left\{1,\kern0.5em \underset{i\notin {J}_k,{\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}&lt;0}{\min}\frac{b_i-{\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}{\boldsymbol{x}}_{\boldsymbol{k}}}{{\boldsymbol{a}}_{\boldsymbol{i}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}}\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equge.png)

set***x***<sub>***【k+***</sub>*****【x】*****

 ****第六步**

如果*α*<sub>*k*</sub><1，通过在**步骤 5** 中给 *J* <sub>*k*</sub> 加上产生最小值的指标，构建 *J* <sub>*k* + 1</sub> 。

否则，让*J*<sub>T3】k</sub>=*J*<sub>*k*+1</sub>。

**第七步**

设置 *k* = *k* + 1。

从**开始重复步骤 2** 。

考虑 Nocedal & Wright (2006)中的这个例子问题:

![$$ \underset{\boldsymbol{x}}{\min }q\left(\boldsymbol{x}\right)={\left({x}_1-1\right)}^2+{\left({x}_2-2.5\right)}^2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgf.png)

约束条件如下:

![$$ \left\{\begin{array}{c}{x}_1-2{x}_2+2\ge 0\\ {}-{x}_1-2{x}_2+6\ge 0\\ {}-{x}_1+2{x}_2+2\ge 0\\ {}{x}_1\ge 0\\ {}{x}_2\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgg.png)

我们可以把这个问题写成矩阵形式。

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\frac{1}{2}{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{Hx}+{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{p} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgh.png)T2】

![$$ \boldsymbol{Ax}\boldsymbol{\ge}\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgi.png)服从，

其中

![$$ \boldsymbol{H}=\left[\begin{array}{cc}2&amp; 0\\ {}0&amp; 2\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgj.png)

![$$ \boldsymbol{p}=\left[\begin{array}{c}-2\\ {}-5\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgk.png)

![$$ \boldsymbol{A}=\left[\begin{array}{cc}1&amp; -2\\ {}-1&amp; -2\\ {}-1&amp; 2\\ {}1&amp; 0\\ {}0&amp; 1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgl.png)

![$$ \boldsymbol{b}=\left[\begin{array}{c}-2\\ {}-6\\ {}-2\\ {}0\\ {}0\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgm.png)

(注意这两个公式有不同的常数项，但与解无关。)

从图片上看，我们有图 [10-12](#Fig12) 。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig12_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig12_HTML.jpg)

图 10-12

一个二次规划问题

图 [10-12](#Fig12) 显示了可行域、边界、目标函数的轮廓以及约束标签**<sub>***I***</sub>。**

 **假设我们的初始迭代点是***x***<sup>T5】0</sup>=【2，0】<sup>*T*</sup>(这里上标表示迭代次数，下标表示分量)。该顶点有两个活动约束，***a***<sub>**3**</sub>和***a***<sub>**5**</sub>。*工作集为*J*T68】0= { 3，5}。QP 子问题的解法是***d***<sup>**0**</sup>***=*****0**。我们需要求解 KKT 条件中的拉格朗日乘子，以检查它是否是最小点。*

*![$$ \left[\begin{array}{cc}-1&amp; 2\\ {}0&amp; 1\end{array}\right]\left[\begin{array}{c}{\hat{\mu}}_1\\ {}{\hat{\mu}}_2\end{array}\right]=\left[\begin{array}{c}2\\ {}-5\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgn.png)*

也就是我们有了这个:

![$$ \left[\begin{array}{c}{\hat{\mu}}_3\\ {}{\hat{\mu}}_5\end{array}\right]=\left[\begin{array}{c}-2\\ {}-1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgo.png)

这不符合非负的要求，意味着没有找到最小值。我们从工作集中去掉约束 3，**<sub>**3**</sub>，因为它具有最大的拉格朗日乘子绝对值。**

 **在下一次迭代中 *k* = 1，活动工作集现在是 *J* <sub>1</sub> = {5}。***x***<sup>**1**</sup>=***x***<sup>**0**</sup>=【2，0】<sup>*T*</sup>因为上次迭代没有移动搜索点。***d***<sup>**1**</sup>***=***【1，0】<sup>*T*</sup>。步长公式得出 *α* <sub>1</sub> = 1。新的迭代是***x***<sup>**2**</sup>=【1，0】<sup>*T*</sup>。

在下一次迭代中 *k* = 2，***x***<sup>**2**</sup>=【1，0】<sup>*T*</sup>。***d***<sup>T19】2</sup>***=*****0**。![$$ {\hat{\mu}}_5=-5 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq52.png)。我们从工作集中删除**<sub>**5**</sub>。现在是空的，*J*T39】1= { }。**

 **在下一次迭代中 *k* = 3、***x***<sup>**3**</sup>=【1，0】<sup>*T*</sup>因为***d***<sup>**2**</sup>***=*****0**。因为工作集是空的，所以 QP 子问题是无约束的。求解它给出了***d***<sup>**3**</sup>***=***【0，2.5】<sup>*T*</sup>。步长公式得出*α*T46】3= 0.6。新的迭代是***x***<sup>**4**</sup>=【1，1.5】<sup>*T*</sup>。

在下一次迭代中 *k* = 4，***x***<sup>**4**</sup>=【1，1.5】<sup>*T*</sup>。有一个单阻塞约束 ***一个*** <sub>**一个**</sub> 。第一个约束被添加到工作集，*J*T24】4= { 1 }。***d***<sup>**4**</sup>***=***【0.4，0.2】<sup>*T*</sup>。*α*4= 1。新的迭代是***x***<sup>**5**</sup>=【1.4，1.7】<sup>*T*</sup>。工作集保持不变。

在下一次迭代中 *k* = 5，***x***<sup>**5**</sup>=【1.4，1.7】<sup>*T*</sup>。***d***<sup>T19】5</sup>***=*****0**。检查 KKT 条件给出![$$ {\hat{\mu}}_1=0.8&gt;0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq53.png)。最小化器已经找到了。我们有以下:

![$$ {\boldsymbol{x}}^{\ast}=\left[\begin{array}{c}1.4\\ {}1.7\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgp.png)

下面的 NM Dev 代码解决了这个 QP 问题:

```py
// construct a quadratic function
Matrix H = new DenseMatrix(new double[][]{
    {2, 0},
    {0, 2}
});
Vector p = new DenseVector(new double[]{-2, -5});
QuadraticFunction f = new QuadraticFunction(H, p);

// construct the linear inequality constraints
Matrix A = new DenseMatrix(new double[][]{
    {1, -2},
    {-1, -2},
    {-1, 2},
    {1, 0},
    {0, 1}
});
Vector b = new DenseVector(new double[]{-2, -6, -2, 0, 0});
LinearGreaterThanConstraints greater
        = new LinearGreaterThanConstraints(A, b);// x >= 0
// construct the QP problem
QPProblem problem = new QPProblem(f, null, greater);

// construct a primal active set solver
double epsion = Math.sqrt(PrecisionUtils.autoEpsilon(problem.f().Hessian()));
QPPrimalActiveSetMinimizer solver1
        = new QPPrimalActiveSetMinimizer(
                epsion, // precision
                Integer.MAX_VALUE // max number of iterations
        );
// solve the QP problem using the primal active set method
QPPrimalActiveSetMinimizer.Solution solution1 = solver1.solve(problem);
solution1.search(new DenseVector(2., 0.));
// print out the solution
System.out.println("minimizer = " + solution1.minimizer().minimizer());
System.out.println("minimum = " + solution1.minimum());

```

输出如下所示:

```py
x_0 = [2.000000, 0.000000]
J_0
 = active: [3, 5]; inactive: []
g_0 = [2.000000, -5.000000]
d_0 = [0.000000, 0.000000]
mu = [-2.000000, -1.000000]

x_1 = [2.000000, 0.000000]
J_1
 = active: [5]; inactive: [3]
g_1 = [2.000000, -5.000000]
d_1 = [-1.000000, 0.000000]
a = 1.000000

x_2 = [1.000000, 0.000000]
J_2
 = active: [5]; inactive: [3]
g_2 = [0.000000, -5.000000]
d_2 = [0.000000, 0.000000]
mu = [-5.000000]

x_3 = [1.000000, 0.000000]
J_3
 = active: []; inactive: [3, 5]
g_3 = [0.000000, -5.000000]
d_3 = [-0.000000, 2.500000]
a = 0.600000

x_4 = [1.000000, 1.500000]
J_4
 = active: [1]; inactive: [3, 5]
g_4 = [0.000000, -2.000000]
d_4 = [0.400000, 0.200000]
a = 1.000000

x_5 = [1.400000, 1.700000]
J_5
 = active: [1]; inactive: [3, 5]
g_5 = [0.800000, -1.600000]
d_5 = [0.000000, 0.000000]
mu = [0.800000]
minimizer = [1.400000, 1.700000]
minimum = -6.450000000000001

```

同样，我们有 *f* (1.4，1.7)=-6.45。我们鼓励您将输出与我们之前讨论的迭代轨迹进行比较。

#### 双重活动集方法

对偶的概念是一种解决与原始问题相关的问题的技术，我们称之为原始问题。相关的问题叫做对偶问题。对偶问题的参数是原问题的拉格朗日乘子。在不等式约束的个数远大于 ***x*** 的维数的情况下，求解对偶问题求拉格朗日乘子然后求原问题的***x***<sup>***∑***</sup>可以更容易。具体来说，设**<sup>***∫***</sup>，***λ***<sup>***∫***</sup>，***【μ***<sup>***∫***</sup>为 a 的两个拉格朗日乘数他们解决了对偶问题，如下图:**

**![$$ \underset{\boldsymbol{x},\boldsymbol{\lambda}, \boldsymbol{\mu}}{\max}\mathcal{L}\left(\boldsymbol{x},\boldsymbol{\lambda}, \boldsymbol{\mu} \right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgq.png)**

 **![$$ \left\{\begin{array}{c}\nabla \mathcal{L}\left(\boldsymbol{x},\boldsymbol{\lambda}, \boldsymbol{\mu} \right)=\mathbf{0}\\ {}\boldsymbol{\mu} \ge \mathbf{0}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgr.png)服从，

另外，我们还有这个:

![$$ f\left({\boldsymbol{x}}^{\ast}\right)=\mathcal{L}\left({\boldsymbol{x}}^{\ast },{\boldsymbol{\lambda}}^{\ast },{\boldsymbol{\mu}}^{\ast}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgs.png)

解决 QP 问题的对偶有效集方法本质上是前一节中的有效集方法，但是适用于 QP 问题的对偶。一个 QP 问题的对偶如下:

![$$ \underset{\boldsymbol{\mu}}{\min }h\left(\boldsymbol{\mu} \right)=\frac{1}{2}{\boldsymbol{\mu}}^{\boldsymbol{T}}\boldsymbol{A}{\boldsymbol{H}}^{-\mathbf{1}}{\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{\mu} -{\boldsymbol{\mu}}^{\boldsymbol{T}}\left(\boldsymbol{A}{\boldsymbol{H}}^{-\mathbf{1}}\boldsymbol{p}+\boldsymbol{b}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgt.png)

![$$ \boldsymbol{\mu} \boldsymbol{\ge}\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgu.png)服从，

在其极小点***【μ】***<sup>**∫**</sup>确定后，原始问题的极小点就可以从 KKT 条件中得到，如下图所示:

![$$ \boldsymbol{Hx}+\boldsymbol{p}-{\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{\mu} =\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgv.png)

也就是

![$$ {\boldsymbol{x}}^{\ast}={\boldsymbol{H}}^{-\mathbf{1}}\left({\boldsymbol{A}}^{\boldsymbol{T}}{\boldsymbol{\mu}}^{\ast}-\boldsymbol{p}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgw.png)

解决对偶问题而不是原始问题有一些好处。

*   可行的初始点可以容易地被识别为具有非负条目的任何向量，例如，**<sub>**0**</sub>***=*****0**。**

***   问题中的约束矩阵是 *p* × *p* 单位矩阵。所以对偶问题总是满足非退化假设。

    *   该问题只涉及有界不等式约束，大大降低了算法所需的计算成本。** 

 **在 NM Dev 中，类`QPDualActiveSetMinimizer`将 QP 问题转化为它的对偶问题，然后应用活动集方法。下面的代码使用双重活动集方法来解决相同的问题:

```py
// construct a quadratic function
Matrix H = new DenseMatrix(new double[][]{
    {2, 0},
    {0, 2}
});
Vector p = new DenseVector(new double[]{-2, -5});
QuadraticFunction f = new QuadraticFunction(H, p);

// construct the linear inequality constraints
Matrix A = new DenseMatrix(new double[][]{
    {1, -2},
    {-1, -2},
    {-1, 2},
    {1, 0},
    {0, 1}
});
Vector b = new DenseVector(new double[]{-2, -6, -2, 0, 0});
LinearGreaterThanConstraints greater
        = new LinearGreaterThanConstraints(A, b);// x >= 0
// construct the QP problem
QPProblem problem = new QPProblem(f, null, greater);

// construct a primal active set solver
double epsion = Math.sqrt(PrecisionUtils.autoEpsilon(problem.f().Hessian()));
QPPrimalActiveSetMinimizer solver1
        = new QPPrimalActiveSetMinimizer(
                epsion, // precision
                Integer.MAX_VALUE // max number of iterations
        );
// solve the QP problem using the primal active set method
QPPrimalActiveSetMinimizer.Solution solution1 = solver1.solve(problem);
solution1.search(new DenseVector(2., 0.));
// print out the solution
System.out.println(solution1.minimizer().minimizer());
System.out.println(solution1.minimum());

// solve the QP problem using the dual active set method
QPDualActiveSetMinimizer solver2
        = new QPDualActiveSetMinimizer(
                epsion, // precision
                Integer.MAX_VALUE); // max number of iterations
QPDualActiveSetMinimizer.Solution solution2 = solver2.solve(problem);
solution2.search();
// print out the solution
System.out.println("minimizer = " + solution2.minimizer().minimizer());
System.out.println("minimum = " + solution2.minimum());

```

我们只改变了解算器:

```py
QPPrimalActiveSetMinimizer solver1
        = new QPPrimalActiveSetMinimizer(
                epsion, // precision
                Integer.MAX_VALUE // max number of iterations
        );
// solve the QP problem using the primal active set method
QPPrimalActiveSetMinimizer.Solution solution1 = solver1.solve(problem);

```

到

```py
QPDualActiveSetMinimizer solver2
        = new QPDualActiveSetMinimizer(
                epsion, // precision
                Integer.MAX_VALUE); // max number of iterations
QPDualActiveSetMinimizer.Solution solution2 = solver2.solve(problem);

```

我们甚至不需要为双重活动集求解器提供初始猜测。

输出如下所示:

```py
x_0 = [0.000000, 0.000000, 0.000000, 0.000000, 0.000000]
J_0
 = active: [1, 2, 3, 4, 5]; inactive: []
g_0 = [-2.000000, 0.000000, 6.000000, 1.000000, 2.500000]
d_0 = [0.000000, 0.000000, 0.000000, 0.000000, 0.000000]
mu = [-2.000000, 0.000000, 6.000000, 1.000000, 2.500000]

x_1 = [0.000000, 0.000000, 0.000000, 0.000000, 0.000000]
J_1
 = active: [2, 3, 4, 5]; inactive: [1]
g_1 = [-2.000000, 0.000000, 6.000000, 1.000000, 2.500000]
d_1 = [0.800000, 0.000000, 0.000000, 0.000000, 0.000000]
a = 1.000000

x_2 = [0.800000, 0.000000, 0.000000, 0.000000, 0.000000]
J_2
 = active: [2, 3, 4, 5]; inactive: [1]
g_2 = [0.000000, 1.200000, 4.000000, 1.400000, 1.700000]
d_2 = [0.000000, 0.000000, 0.000000, 0.000000, 0.000000]
mu = [1.200000, 4.000000, 1.400000, 1.700000]
minimizer = [1.400000, 1.700000]
minimum = -6.450000000000001

```

这个结果和我们用原始有效集方法得到的结果是一样的。

## 半定规划

半定规划(SDP)是凸优化的一个子领域，涉及半定矩阵与仿射空间的锥上的线性目标函数的优化。半正定矩阵是特征值非负的对称矩阵。SDP 是一个越来越受关注的领域，原因有几个。运筹学和组合优化中的许多实际问题都可以建模或近似为 SDP 问题。在自动控制理论中，SDP 用于线性矩阵不等式的上下文中。一些量子查询复杂性问题已经根据 SDP 被公式化。此外，所有的线性规划，如线性规划和 QP 可以重新制定为 SDP。向量不等式约束被矩阵不等式约束代替。图 [10-13](#Fig13) 显示了凸规划的层次和子域。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig13_HTML.png](img/500382_1_En_10_Chapter/500382_1_En_10_Fig13_HTML.png)

图 10-13

凸规划的层次结构

### 10.4.1 原始和对偶 SDP 问题

设***S***<sup>*n*</sup>为实对称 *n* × *n* 矩阵的空间。***S***<sup>*n*</sup>上的标准内积定义如下:

![$$ \boldsymbol{A}\bullet \boldsymbol{B}=\mathrm{trace}\left(\boldsymbol{AB}\right)=\sum \limits_{i=1}^n\sum \limits_{j=1}^n{a}_{ij}{b}_{ij} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgx.png)

原始 SDP 问题定义如下:

![$$ \min \boldsymbol{C}\bullet \boldsymbol{X} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equgy.png)

服从于，

**a**<sub>*【I】****【x = b】****【I】-我...。， *p**</sub>

****【0】****

 **其中 ***C，X，A***<sub>T5】I</sub>均在***S***<sup>*n*</sup>中。 ***X*** 为半正定。

一个简单的 SDP 问题是这样的:

![$$ \underset{\boldsymbol{X}}{\min }{x}_{11}+2{x}_{12}+3{x}_{13}+2{x}_{21}+9{x}_{22}+0{x}_{23}+3{x}_{31}+0{x}_{32}+7{x}_{33}={x}_{11}+4{x}_{12}+6{x}_{13}+9{x}_{22}+7{x}_{33} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equha.png)

服从，

![$$ \left\{\begin{array}{c}{x}_{11}+2{x}_{13}+3{x}_{22}+14{x}_{23}+5{x}_{33}=11\\ {}4{x}_{12}+16{x}_{13}+6{x}_{22}+4{x}_{33}=19\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhb.png)

![$$ \boldsymbol{X}=\left[\begin{array}{ccc}{x}_{11}&amp; {x}_{12}&amp; {x}_{13}\\ {}{x}_{21}&amp; {x}_{22}&amp; {x}_{23}\\ {}{x}_{31}&amp; {x}_{32}&amp; {x}_{33}\end{array}\right]\succcurlyeq 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhc.png)

在矩阵形式中，问题是这样写的:

![$$ \underset{\boldsymbol{X}}{\min}\left[\begin{array}{ccc}1&amp; 2&amp; 3\\ {}2&amp; 9&amp; 0\\ {}3&amp; 0&amp; 7\end{array}\right]\bullet \left[\begin{array}{ccc}{x}_{11}&amp; {x}_{12}&amp; {x}_{13}\\ {}{x}_{12}&amp; {x}_{22}&amp; {x}_{23}\\ {}{x}_{13}&amp; {x}_{23}&amp; {x}_{33}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhd.png)

![$$ \left\{\begin{array}{c}\left[\begin{array}{ccc}1&amp; 0&amp; 1\\ {}0&amp; 3&amp; 7\\ {}1&amp; 7&amp; 5\end{array}\right]\bullet \left[\begin{array}{ccc}{x}_{11}&amp; {x}_{12}&amp; {x}_{13}\\ {}{x}_{12}&amp; {x}_{22}&amp; {x}_{23}\\ {}{x}_{13}&amp; {x}_{23}&amp; {x}_{33}\end{array}\right]=11\\ {}\left[\begin{array}{ccc}0&amp; 2&amp; 8\\ {}2&amp; 6&amp; 0\\ {}8&amp; 0&amp; 4\end{array}\right]\bullet \left[\begin{array}{ccc}{x}_{11}&amp; {x}_{12}&amp; {x}_{13}\\ {}{x}_{12}&amp; {x}_{22}&amp; {x}_{23}\\ {}{x}_{13}&amp; {x}_{23}&amp; {x}_{33}\end{array}\right]=19\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhe.png)服从，

这个 SDP 问题看起来非常类似于 LP 问题。注意，现在涉及的决策变量是矩阵 ***X*** 而不是向量。同样，正如 ***x*** ≥ **0** 意味着 *n* 个分量中的每一个都必须是非负的一样，***x*****≽0**意味着 *n* 个特征值中的每一个都必须是非负的。

在 NM Dev 中，类`SDPPrimalProblem`以原始形式构造 SDP 问题。该类签名如下:

```py
public class SDPPrimalProblem { // TODO: convert to SDPDualProblem; implement ConstrainedOptimProblem

    /**
     * Constructs a primal SDP problem.
     * \[
     * \min_x \mathbf{c'x} \textrm{, s.t., } \\
     * \mathbf{Ax} = \mathbf{b}, \mathbf{x} \geq \mathbf{0}
     * \]
     *
     * @param C \(C\)
     * @param A \(A\)
     */
    public SDPPrimalProblem(SymmetricMatrix C, SymmetricMatrix[] A);

    /**
     * Gets the dimension of the system, i.e., the dimension of <i>x</i>, the
     * number of variables.
     *
     * @return the dimension of the system
     */
    public int n();

    /**
     * Gets the size of <i>b</i>.
     *
     * @return the size of <i>b</i>
     */
    public int p();

    /**
     * Gets <i>C</i>.
     *
     * @return <i>C</i>
     */
    public SymmetricMatrix C();

    /**
     * Gets <i>A<sub>i</sub></i>.
     *
     * @param i an index to the A's, counting from 1
     * @return <i>A<sub>i</sub></i>
     */
    public SymmetricMatrix A(int i);
}

```

以下代码构建了上一个示例中的主要问题:

```py
// the primal SDP matrices
SymmetricMatrix C
        = new SymmetricMatrix(
                new double[][]{
                    {1},
                    {2, 9},
                    {3, 0, 7}
                });
SymmetricMatrix A1
        = new SymmetricMatrix(
                new double[][]{
                    {1},
                    {0, 3},
                    {1, 7, 5}
                });
SymmetricMatrix A2
        = new SymmetricMatrix(
                new double[][]{
                    {0},
                    {2, 6},
                    {8, 0, 4}
                });

// construct the primal SDP problem
SDPPrimalProblem primal
        = new SDPPrimalProblem(
                C,
                new SymmetricMatrix[]{A1, A2}
        );

```

如果***C =***diag(***C***)和***A***<sub>***I***</sub>***=***diag(***A***<sub>***I***</sub>)都是对角矩阵，那么问题就可以一个标准型 LP 问题的对偶问题如下:

![$$ \max {\boldsymbol{b}}^{\boldsymbol{t}}\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhf.png)

服从，

![$$ {\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{y}+\boldsymbol{s}=\boldsymbol{c} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhg.png)

![$$ \boldsymbol{s}\boldsymbol{\ge}\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhh.png)

其中 ***s*** 为松弛变量。

类似地，对偶 SDP 问题相对于原始 SDP 问题如下:

![$$ \max {\boldsymbol{b}}^{\boldsymbol{t}}\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhi.png)

![$$ \sum \limits_{i=1}^p{y}_i{\boldsymbol{A}}_i+\boldsymbol{S}=\boldsymbol{C} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhj.png)服从，

***s*****【0】**

其中 ***S*** 为松弛变量。

对偶问题的例子如下:

![$$ \max 11{y}_1+19{y}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhl.png)

![$$ {y}_1\left[\begin{array}{ccc}1&amp; 0&amp; 1\\ {}0&amp; 3&amp; 7\\ {}1&amp; 7&amp; 5\end{array}\right]+{y}_2\left[\begin{array}{ccc}0&amp; 2&amp; 8\\ {}2&amp; 6&amp; 0\\ {}8&amp; 0&amp; 4\end{array}\right]+\boldsymbol{S}=\left[\begin{array}{ccc}1&amp; 2&amp; 3\\ {}2&amp; 9&amp; 0\\ {}3&amp; 0&amp; 7\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhm.png)服从，

***s*****【0】**

或者，如下

![$$ \max 11{y}_1+19{y}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equho.png)

服从，

![$$ \left[\begin{array}{ccc}1-1{y}_1-0{y}_2&amp; 2-0{y}_1-2{y}_2&amp; 3-1{y}_1-8{y}_2\\ {}2-0{y}_1-2{y}_2&amp; 9-3{y}_1-6{y}_2&amp; 0-7{y}_1-0{y}_2\\ {}3-1{y}_1-8{y}_2&amp; 0-7{y}_1-0{y}_2&amp; 7-5{y}_1-4{y}_2\end{array}\right]\succcurlyeq \mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhp.png)

**≽ 0**

使用对偶形式通常更容易理解和操作，因为变量是乘数 *p* ，*y*<sub>T5】I</sub>s

NM Dev 类`SDPPrimalProblem`构造了一个对偶形式的 SDP 问题。该类签名如下:

```py
public class SDPDualProblem extends ConstrainedOptimProblemImpl1 {

    /**
     * Constructs a dual SDP problem.
     *
     * @param b \(b\)
     * @param C \(C\)
     * @param A \(A\)
     */
    public SDPDualProblem(
            final Vector b,
            final SymmetricMatrix C,
            final SymmetricMatrix[] A
    );

    /**
     * Gets the dimension of the square matrices <i>C</i> and <i>A</i>s.
     *
     * @return the dimension of the matrices
     */
    public int n();

    /**
     * Gets the dimension of the system, i.e., <i>p</i> = the dimension of
     * <i>y</i>, the number of
     * variables.
     *
     * @return the dimension of the system
     */
    public int p();

    /**
     * Gets <i>b</i>.
     *
     * @return <i>b</i>
     */
    public ImmutableVector b();

    /**
     * Gets <i>C</i>.
     *
     * @return <i>C</i>
     */
    public SymmetricMatrix C();

    /**
     * Gets <i>A<sub>i</sub></i>.
     *
     * @param i an index to the A's, counting from 1
     * @return <i>A<sub>i</sub></i>
     */
    public SymmetricMatrix A(int i);
}

```

继续我们的示例，以下代码构建了对偶问题:

```py
// the dual SDP vector and matrices
Vector b = new DenseVector(11., 19.);
// construct the primal SDP problem
SDPDualProblem dual
        = new SDPDualProblem(
                b,
                C,
                new SymmetricMatrix[]{A1, A2}
        );

```

### 中央道路

卡鲁什-库恩-塔克(KKT) SDP 问题的条件假设矩阵***x***<sup>***∫***</sup>是原问题的极小值当且仅当存在矩阵***s***<sup>***∫***</sup>∈***s***<sup>*n*</sup>和 a 使得以下系统成立:

![$$ \sum \limits_{i=1}^p{\boldsymbol{y}}_i^{\ast }{\boldsymbol{A}}_i+{\boldsymbol{S}}^{\ast }=\boldsymbol{C} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhq.png)

![$$ {\boldsymbol{A}}_i\bullet {\boldsymbol{X}}^{\ast }={b}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhr.png)

![$$ {\boldsymbol{S}}^{\ast}{\boldsymbol{X}}^{\ast}=\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhs.png)

x *≽0，S* ≽ 0，

可以证明 KKT 条件的解是存在的。最初的解决方案是![$$ \left\{{\boldsymbol{X}}^{\ast},{\boldsymbol{y}}_i^{\ast},{\boldsymbol{S}}^{\ast}\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq54.png)。还可以看出，![$$ \left\{{\boldsymbol{y}}_i^{\ast},{\boldsymbol{S}}^{\ast}\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq55.png)是最大化器，因此是对偶问题的解决方案。因此，这个解称为原对偶解。

中心路径在内点算法的构造中起着至关重要的作用。对于 SDP 问题，中心路径由集合{***x***(*【τ*)，***y***(*【τ*)，***s***(*【τ*)}组成，使得以下系统成立:

![$$ \sum \limits_{i=1}^p\boldsymbol{y}\left(\tau \right){\boldsymbol{A}}_i+\boldsymbol{S}\left(\tau \right)=\boldsymbol{C} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhu.png)

![$$ {\boldsymbol{A}}_i\bullet \boldsymbol{X}\left(\tau \right)={b}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhv.png)

![$$ \boldsymbol{S}\left(\tau \right)\boldsymbol{X}\left(\tau \right)=\tau \boldsymbol{I} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhw.png)

x

除了****I***之外，几乎是 KKT 条件的解。*

 *这种差异或二元差距，*【δ】*，沿着中心路径可以评价为:

![$$ \delta \left[\boldsymbol{X}\left(\tau \right),\boldsymbol{y}\left(\tau \right)\right]=\boldsymbol{C}\bullet \boldsymbol{X}\left(\tau \right)-{\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y}\left(\tau \right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhy.png)

![$$ =\left[\sum \limits_{i=1}^p\boldsymbol{y}\left(\tau \right){\boldsymbol{A}}_i+\boldsymbol{S}\left(\tau \right)\right]\bullet \boldsymbol{X}\left(\tau \right)-{\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y}\left(\tau \right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equhz.png)

![$$ =\boldsymbol{S}\left(\tau \right)\boldsymbol{X}\left(\tau \right)=\mathrm{trace}\left(\boldsymbol{S}\left(\tau \right)\boldsymbol{X}\left(\tau \right)\right)=\mathrm{trace}\left(\tau \boldsymbol{I}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equia.png)

![$$ = n\tau $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equib.png)

如果我们可以通过追踪 *τ* 到 0 来缩小差距，则中心路径接近 SDP 问题的解决方案。参见图 [10-14](#Fig14) 。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig14_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig14_HTML.jpg)

图 10-14

内点算法的中心路径

换言之，

![$$ \underset{\tau \to 0}{\lim}\delta \left[\boldsymbol{X}\left(\tau \right),\boldsymbol{y}\left(\tau \right)\right]=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equic.png)

还有，我们有这个:

![$$ \underset{\tau \to 0}{\lim}\boldsymbol{X}\left(\tau \right)={\boldsymbol{X}}^{\ast} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equid.png)

![$$ \underset{\tau \to 0}{\lim}\boldsymbol{y}\left(\tau \right)={\boldsymbol{y}}^{\ast} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equie.png)

![$$ \underset{\tau \to 0}{\lim}\boldsymbol{S}\left(\tau \right)={\boldsymbol{S}}^{\ast} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equif.png)

原对偶解法是![$$ \left\{{\boldsymbol{X}}^{\ast},{\boldsymbol{y}}_{\boldsymbol{i}}^{\ast},{\boldsymbol{S}}^{\ast}\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq56.png)。

内点算法被开发来通过沿着问题的中心路径生成收敛到原始对偶解的迭代。对于每个*>0， ***X*** ( *τ* )和{***y***(*τ*)，*T15】S*(*τ*)}分别处于原问题和对偶问题的可行域的内部。这就是路径跟踪算法。*

 *### 10.4.3 原始对偶路径跟踪法

我们首先定义一些运算和符号。给定矩阵 ***K*** ， ***M*** ， ***N*** 在*ℝ*<sup>*n*×*n*</sup>中，一般非对称克罗内克积定义如下:

![$$ \boldsymbol{M}\otimes \boldsymbol{N}=\left[\begin{array}{ccc}{m}_{11}\boldsymbol{N}&amp; \dots &amp; {m}_{1n}\boldsymbol{N}\\ {}\mathbf{\vdots}&amp; \mathbf{\ddots}&amp; \mathbf{\vdots}\\ {}{m}_{n1}\boldsymbol{N}&amp; \dots &amp; {m}_{nn}\boldsymbol{N}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equig.png)

svec( ***K*** )操作将对称矩阵***K =***{*K*<sub>*ij*</sub>}转换为维数为 *n* ( *n* + 1)/2 的向量，如下:

![$$ \mathrm{svec}\left(\boldsymbol{K}\right)={\left[{k}_{11},\sqrt{2}{k}_{12},\dots, \sqrt{2}{k}_{1n},{k}_{22},\sqrt{2}{k}_{23},\dots, \sqrt{2}{k}_{2n},\dots, {k}_{nn}\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equih.png)

对称克罗内克积由恒等式定义，如下图:

![$$ \left(\boldsymbol{M}\bigodot \boldsymbol{N}\right)\mathrm{svec}\left(\boldsymbol{K}\right)=\mathrm{svec}\left[\frac{1}{2}\left(\boldsymbol{NK}{\boldsymbol{M}}^{\boldsymbol{T}}+\boldsymbol{MK}{\boldsymbol{N}}^{\boldsymbol{T}}\right)\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equii.png)

对于矩阵变量，有时将矩阵表示为向量更容易。nevc( ***K*** )操作将 ***K*** 中的列堆叠起来，创建一个向量。

在牛顿法中，我们从给定的集合{ ***X*** 、 ***y*** 、 ***S*** }开始，寻找增量∈***X***、∈***y***、∈***S***，其中∈ ***∈***y***，∈***S***}满足以下线性化方程:***

***![$$ \sum \limits_{i=1}^p\Delta  {\boldsymbol{y}}_i{\boldsymbol{A}}_i+\Delta  \boldsymbol{S}=\boldsymbol{C}-\boldsymbol{S}-\sum \limits_{i=1}^p{\boldsymbol{y}}_i{\boldsymbol{A}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equij.png)***

***![$$ {\boldsymbol{A}}_i\bullet \Delta  \boldsymbol{X}={b}_i-{\boldsymbol{A}}_i\bullet \boldsymbol{X} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equik.png)***

***![$$ \boldsymbol{X}\Delta  \boldsymbol{S}+\Delta  \boldsymbol{S}\boldsymbol{X}+\Delta  \boldsymbol{X}\boldsymbol{S}+\boldsymbol{S}\Delta  \boldsymbol{X}=2\tau \boldsymbol{I}-\boldsymbol{XS}-\boldsymbol{SX} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equil.png)***

最后一个方程可以用一个对称的克罗内克乘积来表示:

![$$ \left(\boldsymbol{X}\bigodot \boldsymbol{I}\right)\mathrm{svec}\left(\Delta  \boldsymbol{S}\right)+\left(\boldsymbol{S}\bigodot \boldsymbol{I}\right)\mathrm{svec}\left(\Delta  \boldsymbol{X}\right)=\mathrm{svec}\left[\tau \boldsymbol{I}-\frac{1}{2}\left(\boldsymbol{X}\boldsymbol{S}+\boldsymbol{SX}\right)\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equim.png)

为简单起见，我们分别表示如下:

![$$ \mathrm{svec}\left(\Delta  \boldsymbol{X}\right)=\Delta  \mathbf{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equin.png)

![$$ \mathrm{svec}\left(\Delta  \boldsymbol{S}\right)=\Delta  \mathbf{s} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equio.png)

![$$ \boldsymbol{S}\bigodot \boldsymbol{I}=\boldsymbol{E} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equip.png)

![$$ \boldsymbol{X}\bigodot \boldsymbol{I}=\boldsymbol{F} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equiq.png)

![$$ \mathrm{svec}\left[\tau \boldsymbol{I}-\frac{1}{2}\left(\boldsymbol{XS}+\boldsymbol{SX}\right)\right]={\boldsymbol{r}}_c $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equir.png)

这些符号中的最后一个等式变成了:

![$$ \boldsymbol{E}\Delta  \mathbf{x}+\mathbf{F}\Delta  \mathbf{s}={\boldsymbol{r}}_c $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equis.png)

再者，我们让:

![$$ \boldsymbol{A}=\left[\begin{array}{c}{\left[\mathrm{svec}\left({\boldsymbol{A}}_1\right)\right]}^T\\ {}{\left[\mathrm{svec}\left({\boldsymbol{A}}_2\right)\right]}^T\\ {}\vdots \\ {}{\left[\mathrm{svec}\left({\boldsymbol{A}}_p\right)\right]}^T\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equit.png)

![$$ \mathbf{x}=\mathrm{svec}\left(\boldsymbol{X}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equiu.png)

![$$ \boldsymbol{y}={\left[{y}_1,{y}_2,\dots, {y}_p\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equiv.png)

![$$ \Delta  \boldsymbol{y}={\left[\Delta  {y}_1,\Delta  {y}_2,\dots, \Delta  {y}_p\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equiw.png)

![$$ {\boldsymbol{r}}_p=\boldsymbol{b}-\boldsymbol{A}\mathbf{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equix.png)

![$$ {\boldsymbol{r}}_d=\mathrm{svec}\left(\boldsymbol{C}-\boldsymbol{S}-\mathrm{mat}\left({\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{y}\right)\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equiy.png)

其中 mat()是 svec()的倒数。

有了这些符号，线性化系统可以写成:

![$$ \left\{\begin{array}{c}{\boldsymbol{A}}^{\boldsymbol{T}}\Delta  \boldsymbol{y}+\Delta  \mathbf{s}={\boldsymbol{r}}_d\\ {}\boldsymbol{A}\Delta  \mathbf{x}={\boldsymbol{r}}_p\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equiz.png)

或者在后继形式中，我们有这样的:

![$$ \boldsymbol{J}\left[\begin{array}{c}\Delta  \mathbf{x}\\ {}\Delta  \boldsymbol{y}\\ {}\Delta  \mathbf{s}\end{array}\right]=\left[\begin{array}{c}{\boldsymbol{r}}_d\\ {}{\boldsymbol{r}}_p\\ {}{\boldsymbol{r}}_c\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equja.png)

其中:

![$$ \boldsymbol{J}=\left[\begin{array}{ccc}\mathbf{0}&amp; {\boldsymbol{A}}^{\boldsymbol{T}}&amp; \boldsymbol{I}\\ {}\boldsymbol{A}&amp; \mathbf{0}&amp; \mathbf{0}\\ {}\boldsymbol{E}&amp; \mathbf{0}&amp; \boldsymbol{F}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjb.png)

和陆(2007)提供了求解 SDP 问题的内点算法的细节如下:

**原始对偶路径跟踪算法** **求解 SDP 问题**

**第一步**

输入问题为***a***<sub>*I*</sub>for 1≤*I*≤*p*，***b***∈*ℝ*<sup>*p*</sup>***c***∈*ℝ* <sup>*满足可行性约束的 ***y*** <sub>0</sub> ， ***S*** <sub>0</sub> 以及满足可行性约束的***x***<sub>0</sub>**≻**0，***s***<sub>0</sub>**≻***</sup>

选择一个标量 *σ* ∈ [0，1]。

设置迭代计数器 *k* = 0，初始化二元间隙*δ*<sub>T5】k</sub>的公差ε。

**第二步**

计算如下:

![$$ {\delta}_k=\frac{{\boldsymbol{X}}_k\bullet {\boldsymbol{S}}_k}{n} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjc.png)

**第三步**

若 *δ* <sub>*k*</sub> ≤ ε，则输出解{***X***<sub>***k***</sub>，***y***<sub>***k***</sub>，***S***<sub>***k***</sub>

否则，设置如下:

![$$ {\tau}_k=\sigma \frac{{\boldsymbol{X}}_k\bullet {\boldsymbol{S}}_k}{n} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjd.png)

**第四步**

求解如下:

![$$ \boldsymbol{J}\left[\begin{array}{c}\Delta  \mathbf{x}\\ {}\Delta  \boldsymbol{y}\\ {}\Delta  \mathbf{s}\end{array}\right]=\left[\begin{array}{c}{\boldsymbol{r}}_d\\ {}{\boldsymbol{r}}_p\\ {}{\boldsymbol{r}}_c\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equje.png)

解决方法如下:

![$$ \Delta  \mathbf{x}=-{\boldsymbol{E}}^{-\mathbf{1}}\left[\boldsymbol{F}\left({\boldsymbol{r}}_d-{\boldsymbol{A}}^{\boldsymbol{T}}\Delta  \boldsymbol{y}\right)-{\boldsymbol{r}}_c\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjf.png)

![$$ \Delta  \mathbf{s}={\boldsymbol{r}}_d-{\boldsymbol{A}}^{\boldsymbol{T}}\Delta  \boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjg.png)

![$$ \boldsymbol{M}\Delta  \boldsymbol{y}={\boldsymbol{r}}_p+\boldsymbol{A}{\boldsymbol{E}}^{-\mathbf{1}}\left(\boldsymbol{F}{\boldsymbol{r}}_d-{\boldsymbol{r}}_c\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjh.png)

其中 ***M*** 是由以下给出的舒尔补码矩阵:

![$$ \boldsymbol{M}=\boldsymbol{A}{\boldsymbol{E}}^{-\mathbf{1}}\boldsymbol{F}{\boldsymbol{A}}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equji.png)

将解{∈**X**，∈*T3】yT5】，∈**S**}转换为{∈***X***，∈***y***，∈***S***}用∈***X =****

**第五步**

选择一个参数 *γ* ∈ (0，1)，确定参数 *α* 和 *β* 如下:

![$$ \alpha =\min \left(1,\gamma \hat{\alpha}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjj.png)

![$$ \beta =\min \left(1,\gamma \hat{\beta}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjk.png)

其中:

![$$ \hat{\alpha}=\underset{{\boldsymbol{X}}_k+\overline{\alpha}\Delta  \boldsymbol{X}\ge 0}{\max}\overline{\alpha} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjl.png)

![$$ \hat{\beta}=\underset{{\boldsymbol{S}}_k+\overline{\beta}\Delta  \boldsymbol{S}\ge 0}{\max}\overline{\beta} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjm.png)

**第六步**

设置如下:

![$$ {\boldsymbol{X}}_{k+1}={\boldsymbol{X}}_k+\alpha \Delta  \boldsymbol{X} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjn.png)

![$$ {\boldsymbol{y}}_{k+1}={\boldsymbol{y}}_k+\beta \Delta  \boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjo.png)

![$$ {\boldsymbol{S}}_{k+1}={\boldsymbol{S}}_k+\beta \Delta  \boldsymbol{S} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjp.png)

设置 *k* = *k* + 1，从**第二步**开始重复。

和陆(2007)提供了下面的例子。求标量 *y* <sub>1</sub> ， *y* <sub>2</sub> ， *y* <sub>3</sub> 使得下列最大特征值:

![$$ \boldsymbol{F}={\boldsymbol{A}}_{\mathbf{0}}+{y}_1{\boldsymbol{A}}_{\mathbf{1}}+{y}_2{\boldsymbol{A}}_{\mathbf{2}}+{y}_3{\boldsymbol{A}}_{\mathbf{3}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjq.png)

被最小化。

![$$ {\boldsymbol{A}}_0=\left[\begin{array}{ccc}2&amp; -0.5&amp; -0.6\\ {}-0.5&amp; 2&amp; 0.4\\ {}-0.6&amp; 0.4&amp; 3\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjr.png)

![$$ {\boldsymbol{A}}_1=\left[\begin{array}{ccc}0&amp; 1&amp; 0\\ {}1&amp; 0&amp; 0\\ {}0&amp; 0&amp; 0\end{array}\ \right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjs.png)

![$$ {\boldsymbol{A}}_2=\left[\begin{array}{ccc}0&amp; 0&amp; 1\\ {}0&amp; 0&amp; 0\\ {}1&amp; 0&amp; 0\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjt.png)

![$$ {\boldsymbol{A}}_3=\left[\begin{array}{ccc}0&amp; 0&amp; 0\\ {}0&amp; 0&amp; 1\\ {}0&amp; 1&amp; 0\end{array}\ \right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equju.png)T11】

这个问题可以表述为一个(对偶)SDP 问题。

![$$ \underset{\boldsymbol{y}}{\max }{\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjv.png)T2】

主题为，

![$$ \sum \limits_{i=1}^4{y}_i{\boldsymbol{A}}_i+\boldsymbol{S}=\boldsymbol{C} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjw.png)

年代≽ 0

还有，

![$$ \boldsymbol{b}={\left[0\ 0\ 0\ 1\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjy.png)

![$$ \boldsymbol{y}={\left[{y}_1\ {y}_2\ {y}_3\ {y}_4\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equjz.png)

![$$ \boldsymbol{C}=-{\boldsymbol{A}}_0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equka.png)

![$$ {\boldsymbol{A}}_4=\boldsymbol{I} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkb.png)

—*y*<sub>4</sub>是矩阵*T5】F*的最大特征值。

很容易验证初始设置{ ***X*** <sub>0</sub> ， ***y*** <sub>0</sub> ，***S***<sub>0</sub>}如下:

![$$ {\boldsymbol{X}}_0=\frac{1}{3}\boldsymbol{I} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkc.png)

![$$ {\boldsymbol{y}}_0={\left[0.2\ 0.2\ 0.2-4\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkd.png)

![$$ {\boldsymbol{S}}_0=\left[\begin{array}{ccc}2&amp; 0.3&amp; 0.4\\ {}0.3&amp; 2&amp; -0.6\\ {}0.4&amp; -0.6&amp; 1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equke.png)

对这个原始对偶问题是严格可行的。

矩阵**如下:**

**![$$ \boldsymbol{A}=\left[\ \begin{array}{ccc}0&amp; \sqrt{2}&amp; 0\\ {}0&amp; 0&amp; \sqrt{2}\\ {}\begin{array}{c}0\\ {}1\end{array}&amp; \begin{array}{c}0\\ {}0\end{array}&amp; \begin{array}{c}0\\ {}0\end{array}\end{array}\kern1em \begin{array}{ccc}0&amp; 0&amp; 0\\ {}0&amp; 0&amp; 0\\ {}\begin{array}{c}0\\ {}1\end{array}&amp; \begin{array}{c}\sqrt{2}\\ {}0\end{array}&amp; \begin{array}{c}0\\ {}1\end{array}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkf.png)**

 **我们设![$$ \sigma =\frac{n}{15\sqrt{n}+n}=0.1035 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq57.png)， *γ* = 0.9， *ε* = 0.001。

这个算法，经过四次迭代，返回解{***X***<sup>***∫***</sup>，***y***<sup>***∫***</sup>，***S***<sup>***∫***</sup>}我们这里有:

***F*** 的最大特征值为 3。

在 NM Dev 中，类`PrimalDualPathFollowingMinimizer`实现了这种原始对偶路径跟踪算法。以下代码解决了前面的 SDP 问题:

```py
// define an SDP problem with matrices and vectors
SymmetricMatrix A0
        = new SymmetricMatrix(
                new double[][]{
                    {2},
                    {-0.5, 2},
                    {-0.6, 0.4, 3}
                });
SymmetricMatrix A1
        = new SymmetricMatrix(
                new double[][]{
                    {0},
                    {1, 0},
                    {0, 0, 0}
                });
SymmetricMatrix A2
        = new SymmetricMatrix(
                new double[][]{
                    {0},
                    {0, 0},
                    {1, 0, 0}
                });
SymmetricMatrix A3
        = new SymmetricMatrix(
                new double[][]{
                    {0},
                    {0, 0},
                    {0, 1, 0}
                });
SymmetricMatrix A4 = A3.ONE();
SymmetricMatrix C = A0.scaled(-1.);
Vector b = new DenseVector(0., 0., 0., 1.);
// construct an SDP problem
SDPDualProblem problem
        = new SDPDualProblem(
                b,
                C,
                new SymmetricMatrix[]{A1, A2, A3, A4});

// the initial feasible point
DenseMatrix X0
        = new DenseMatrix(
                new double[][]{
                    {1\. / 3., 0., 0.},
                    {0., 1\. / 3., 0.},
                    {0., 0., 1\. / 3.}
                });
Vector y0 = new DenseVector(0.2, 0.2, 0.2, -4.);
DenseMatrix S0
        = new DenseMatrix(
                new double[][]{
                    {2, 0.3, 0.4},
                    {0.3, 2, -0.6},
                    {0.4, -0.6, 1}
                });
// the initial central path
CentralPath path0 = new CentralPath(X0, y0, S0);

// solving SDP problem
PrimalDualPathFollowingMinimizer solver
        = new PrimalDualPathFollowingMinimizer(
                0.9, // γ
                0.001); // ε
IterativeSolution<CentralPath> solution = solver.solve(problem);
CentralPath path = solution.search(path0);

//the solution from the textbook is accurate up to epsilon
//changing epsilon will change the answers
// primal solution
System.out.println("X = ");
System.out.println(path.X);
// dual solution
System.out.println("y = ");
System.out.println(path.y);
System.out.println("S = ");
System.out.println(path.S);

```

输出如下所示:

```py
X =
3x3
          [,1] [,2] [,3]
[1,] 0.000552, -0.000000, -0.000000,
[2,] -0.000000, 0.000552, 0.000000,
[3,] -0.000000, 0.000000, 0.998896,
y =
[0.392921, 0.599995, -0.399992, -3.000469]
S =
3x3
          [,1] [,2] [,3]
[1,] 1.000469, 0.107079, 0.000005,
[2,] 0.107079, 1.000469, -0.000008,
[3,] 0.000005, -0.000008, 0.000469,

```

## 10.5 二阶锥形编程

二阶锥规划(SOCP)问题是凸优化问题，其中线性函数在仿射线性流形与二阶锥的笛卡儿积的交集上最小化。SOCP 广泛应用于工程、控制和金融中的鲁棒优化和组合优化。线性规划，凸 QP，和许多其他线性问题可以制定为 SOCP 问题。另一方面，SDP 将 SOCP 列为特例。像 LP、QP 和 SDP 问题一样，SOCP 问题可以用内点法在多项式时间内求解。这些方法求解 SOCP 问题所需的每次迭代的计算量大于求解 LP 和 QP 问题所需的计算量，但小于求解类似大小和结构的 SDP 所需的计算量。虽然 SOCP 问题可以作为 SDP 问题来解决，但由于数值稳定性和计算复杂性，我们通常不这样做。

### SOCP 问题

圆锥∁是这样的集合，使得对于任何标量 *α* ≥ 0， ***x*** ∈ ∁暗示 *α* ***x*** ∈ ∁。根据定义，圆锥总是无界的。凸锥![$$ \mathcal{K} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq58.png)是一个凸集，使得![$$ \boldsymbol{x}\in \mathcal{K} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq59.png)暗示![$$ \alpha \boldsymbol{x}\in \mathcal{K} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq60.png)对于任何标量 *α* ≥ 0。图 [10-15](img/#Fig15) 为*ℝ*t21】3 中的凸锥。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig15_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig15_HTML.jpg)

图 10-15

凸锥体

不是所有的圆锥体都是凸的。例如，下面的一维圆锥体不是凸的(见图 [10-16](#Fig16) ):

![$$ y=\left|x\right| $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkh.png)

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig16_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig16_HTML.jpg)

图 10-16

非凸圆锥

两点(2，2)和(2，2)的中点(0，2)不在曲线上。

一个定额锥定义如下:

![$$ \complement =\left\{\left(\boldsymbol{x},t\right)\ |\ \left\Vert \boldsymbol{x}\right\Vert \le t,\boldsymbol{x}\mathbf{\in }{\mathbb{R}}^{n-1},t\in \mathbb{R}\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equki.png)

二阶锥是欧几里得空间的范数锥。其定义如下:

![$$ \mathcal{K}=\left\{\left[\begin{array}{c}t\\ {}\boldsymbol{u}\end{array}\right]\ |\ \left\Vert \boldsymbol{u}\right\Vert \le t,\boldsymbol{u}\mathbf{\in }{\mathbb{R}}^{n-1},t\in \mathbb{R}\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkj.png)

图 [10-17](#Fig17) 显示了尺寸 1、2、3 的二阶圆锥。

![img/500382_1_En_10_Chapter/500382_1_En_10_Fig17_HTML.jpg](img/500382_1_En_10_Chapter/500382_1_En_10_Fig17_HTML.jpg)

图 10-17

1 维、2 维和 3 维的二阶锥(和陆，2007)

脑瓜子 SOCP 问题表述如下:

![$$ \min \sum \limits_{i=1}^q{\hat{\boldsymbol{c}}}_i^{\boldsymbol{T}}{\boldsymbol{x}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkk.png)

![$$ \sum \limits_{i=1}^q{\hat{\boldsymbol{A}}}_i^{\boldsymbol{T}}{\boldsymbol{x}}_i=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkl.png)服从，

![$$ {\boldsymbol{x}}_i\boldsymbol{\in}{\mathcal{K}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq61.png)， *i* = 1，...，*问*

其中![$$ {\hat{\boldsymbol{c}}}_i\mathbf{\in}{\mathbb{R}}^{n_i} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq62.png)、![$$ {\boldsymbol{x}}_i\mathbf{\in}{\mathbb{R}}^{n_i} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq63.png)、![$$ {\hat{\boldsymbol{A}}}_i\mathbf{\in}{\mathbb{R}}^{m\times {n}_i} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq64.png)、*、**b*****∈***ℝ*<sup>*m*</sup>。

![$$ {\mathcal{K}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq65.png)是维数为 *n* <sub>* i *</sub> 的二阶圆锥体。SOCP 问题中的每个变量向量***x***<sub>*I*</sub>被约束为一个二阶锥![$$ {\mathcal{K}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq66.png)。

SOCP 问题的对偶表述如下:

![$$ \max {\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkm.png)

![$$ {\hat{\boldsymbol{A}}}_i^{\boldsymbol{T}}\boldsymbol{y}+{\boldsymbol{s}}_i={\hat{\boldsymbol{c}}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkn.png)服从，

![$$ {\boldsymbol{s}}_i\boldsymbol{\in}{\mathcal{K}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq67.png)， *i* = 1，...，*问*

其中***y*****∈***<sup>*m*</sup>和![$$ {\boldsymbol{s}}_i\mathbf{\in}{\mathbb{R}}^{n_i} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq68.png)。*

 *如果我们让

![$$ \boldsymbol{x}=-\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equko.png)

![$$ {\hat{\boldsymbol{A}}}_{\boldsymbol{i}}^{\boldsymbol{T}}=\left[\begin{array}{c}{\boldsymbol{b}}_i^{\boldsymbol{T}}\\ {}{\boldsymbol{A}}_i^{\boldsymbol{T}}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkp.png)

![$$ {\hat{\boldsymbol{c}}}_i=\left[\begin{array}{c}{d}_i\\ {}{\boldsymbol{c}}_i\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkq.png)

其中***b***<sub>***I***</sub>***∈****ℝ*<sup>*m*</sup>和 *d* <sub>*i*</sub> 是标量，那么 SOCP 问题的对偶就可以写成标准形式，如下所示:

![$$ \min {\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkr.png)

![$$ \left\Vert {\boldsymbol{A}}_i^{\boldsymbol{T}}\boldsymbol{x}+{\boldsymbol{c}}_i\right\Vert \le {\boldsymbol{b}}_i^{\boldsymbol{T}}\boldsymbol{x}+{d}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equks.png)服从，

NM Dev 类`SOCPGeneralConstraint`以标准形式实现约束。该类签名如下:

```py
public class SOCPGeneralConstraint {

    private final Matrix A;
    private final Vector c;
    private final Vector b;
    private final double d;

    /**
     * Constructs a SOCP general constraint.
     *
     * @param A <i>A</i>
     * @param c <i>c</i>
     * @param b <i>b</i>
     * @param d <i>d</i>
     */
    public SOCPGeneralConstraint(
            Matrix A,
            Vector c,
            Vector b,
            double d
    ) {
        this.A = A;
        this.c = c;
        this.b = b;
        this.d = d;
    }

    /**
     * Gets <i>A</i>.
     *
     * @return <i>A</i>
     */
    public Matrix A() {
        return A;
    }

    /**
     * Gets <i>c</i>.
     *
     * @return <i>c</i>
     */
    public Vector c() {
        return c;
    }

    /**
     * Gets <i>b</i>.
     *
     * @return <i>b</i>
     */
    public Vector b() {
        return b;
    }

    /**
     * Gets <i>d</i>.
     *
     * @return <i>d</i>
     */
    public double d() {
        return d;
    }
}

```

NM Dev 还支持类`SOCPLinearEquality`的 SOCP 等式约束。

![$$ {\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{x}=\boldsymbol{c} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkt.png)

该类签名如下:

```py
public class SOCPLinearEquality {

    private final Matrix A;
    private final Vector c;

    public SOCPLinearEquality(Matrix A, Vector c) {
        assertTrue(
            A.nCols() == c.size(),
            "A.nCols() (%d) == c.size() (%d)",
            A.nCols(), c.size()
        );
        this.A = A;
        this.c = c;
    }

    /**
     * @return the matrix A
     */
    public Matrix A() {
        return A;
    }

    /**
     * @return the vector c
     */
    public Vector c() {
        return c;
    }
}

```

NM Dev 类`SOCPGeneralProblem`构造了一个标准形式的 SOCP 问题。该类签名如下:

```py
public class SOCPGeneralProblem extends SOCPDualProblem {

    /**
     * Copy constructor.
     *
     * @param that another {@linkplain  SOCPGeneralProblem}
     */
    public SOCPGeneralProblem(SOCPGeneralProblem that);

    /**
     * Construct a general Second Order Conic Programming problem. Minimize
     * \[
     * f^' x
     * \]
     * subject to the SOCP constraints
     * \[
     * \lVert A_i x + b_i \rVert_2 \leq c_i^T x + d_i,\quad i = 1,\dots,m
     * \]
     *
     * @param f           <i>f</i>
     * @param constraints the SOCP constraints
     */
    public SOCPGeneralProblem(
            Vector f,
            SOCPGeneralConstraint[] constraints
    );

    /**
     * Construct a general Second Order Conic Programming problem. Minimize
     * \[
     * f^' x
     * \]
     * subject to the SOCP constraints
     * \[
     * \lVert A_i x + b_i \rVert_2 \leq c_i^T x + d_i,\quad i = 1,\dots,m
     * \]
     *
     * @param f           <i>f</i>
     * @param constraints the SOCP constraints
     */
    public SOCPGeneralProblem(
            Vector f,
            List<SOCPGeneralConstraint> constraints
    );
}

```

这种标准形式的 SOCP 被证明与工程和科学中的许多凸规划问题有直接联系，例如定量金融。

#### 投资组合优化

在第 10.3 节中，我们将经典的现代投资组合理论表述为一个二次规划问题。

![$$ \underset{\boldsymbol{x}}{\min}\lambda {\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{\Sigma} \boldsymbol{x}-{\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{\mu} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equku.png)T2】

服从，

![$$ \sum \limits_{i=1}^n{x}_i=1 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkv.png)

![$$ \boldsymbol{x}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkw.png)

在实践中，我们可能会添加其他约束来匹配真实的交易场景。假设你是一家大型银行，想要出售大量股票。你不希望只是将股票抛售到市场，这将导致价格大幅下跌，这反过来对你的销售不利。当重新平衡一个大的股票投资组合时，你会希望最小化市场影响。股票的市场影响通常被建模为与股票的成交量的 3/2 次方成比例。最小化市场影响的约束条件通常表述如下:

![$$ \sum \limits_{j=1}^n\left({m}_j{\left|{x}_j\right|}^{\frac{3}{2}}\right)\le {t}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equkx.png)

其中 *m* <sub>*j*</sub> 为一只股票的市场影响系数； *x* <sub>*j*</sub> 是股票的成交量、持仓量或重量；并且*t*T14】2 是可接受公差的常数。

这不是线性约束，因为有 3/2 次幂项。然而，它可以被公式化为 SOCP 约束，并且投资组合优化问题可以被公式化为 SOCP 问题来解决。

假设![$$ \overline{x}=\left|\boldsymbol{x}\right| $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq69.png)，市场影响项转化为:

![$$ \sum \limits_{j=1}^n\left({m}_j{{\overline{x}}_{\boldsymbol{j}}}^{\frac{3}{2}}\right)\le {t}_2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equky.png)

通过引入变量***y = x+w***<sup>**0**</sup>(***w***<sup>**0**</sup>代表最后或原始的股票仓位， ***x*** 代表调整或交易量， ***y*** 代表新的股票仓位)， ***α*** 和

这些约束可以进一步转化为以下:

![$$ \left\{\begin{array}{c}\sum \limits_{j=1}^n{\beta}_j\le {t}_2\\ {}{y}_j-{w}_j^0\le {\overline{x}}_j\\ {}-{y}_j+{w}_j^0\le {\overline{x}}_j\\ {}{{\overline{x}}_{\boldsymbol{j}}}^{\frac{3}{2}}\le \frac{\beta_j}{m_j}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equla.png)

因此，我们有以下:

![$$ \left\{\begin{array}{c}{\left\Vert 0\right\Vert}_2\le {t}_2-\sum \limits_{j=1}^n{\beta}_j\\ {}{\left\Vert 0\right\Vert}_2\le {\overline{x}}_j-\left({y}_j-{w}_j^0\right)\\ {}{\left\Vert 0\right\Vert}_2\le {\overline{x}}_j-\left(-{y}_j+{w}_j^0\right)\\ {}{{\overline{x}}_{\boldsymbol{j}}}^{\frac{3}{2}}\le \frac{\beta_j}{m_j}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlb.png)

最后一个不等式，![$$ {{\overline{x}}_{\boldsymbol{j}}}^{\frac{3}{2}}\le \frac{\beta_j}{m_j} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq70.png)，相当于下面的:

![$$ {{\overline{x}}_{\boldsymbol{j}}}^{\frac{3}{2}}\le \frac{\beta_j}{m_j},{\overline{x}}_{\boldsymbol{j}}\boldsymbol{\ge}0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlc.png)

![$$ \Longleftrightarrow {{\overline{x}}_{\boldsymbol{j}}}^2\le {s}_j\frac{\beta_j}{m_j},{s}_j\le \sqrt{{\overline{x}}_{\boldsymbol{j}}},{\overline{x}}_{\boldsymbol{j}}\boldsymbol{\ge}0,{s}_j\ge 0,\frac{\beta_j}{m_j}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equld.png)

![$$ \Longleftrightarrow {{\overline{x}}_{\boldsymbol{j}}}^2\le {s}_j\frac{\beta_j}{m_j},{s_j}^2\le {\overline{x}}_{\boldsymbol{j}},{\overline{x}}_{\boldsymbol{j}}\boldsymbol{\ge}0,{s}_j\ge 0,\frac{\beta_j}{m_j}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equle.png)

![$$ \Longleftrightarrow {{\overline{x}}_{\boldsymbol{j}}}^2+{\left(\ \frac{\beta_j}{2{m}_j}-\frac{s_j}{2}\right)}^2\le {\left(\ \frac{\beta_j}{2{m}_j}+\frac{s_j}{2}\right)}^2,{s_j}^2+{\left(\ \frac{1-{\overline{x}}_{\boldsymbol{j}}}{2}\right)}^2\le {\left(\ \frac{1+{\overline{x}}_{\boldsymbol{j}}}{2}\right)}^2,{\overline{x}}_{\boldsymbol{j}}\boldsymbol{\ge}0,{s}_j\ge 0,\frac{\beta_j}{m_j}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlf.png)

因为![$$ {\overline{x}}_{\boldsymbol{j}}\boldsymbol{\ge}0,{s}_j\ge 0,\frac{\beta_j}{m_j}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq71.png)可以从其他约束中推导出来，并且它们可以从约束系统中删除。前面的约束条件可以写成:

![$$ \left\{\begin{array}{c}{\left\Vert \left(\begin{array}{c}{\overline{x}}_{\boldsymbol{j}}\\ {}\ \frac{\beta_j}{2{m}_j}-\frac{s_j}{2}\end{array}\right)\right\Vert}_2\le \frac{\beta_j}{2{m}_j}+\frac{s_j}{2}\\ {}{\left\Vert \left(\begin{array}{c}{s}_{\boldsymbol{j}}\\ {}\frac{1-{\overline{x}}_{\boldsymbol{j}}}{2}\ \end{array}\right)\right\Vert}_2\le \frac{1+{\overline{x}}_{\boldsymbol{j}}}{2}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlg.png)

综合所有约束条件，对市场影响的约束体系如下:

![$$ \left\{\begin{array}{c}{\left\Vert 0\right\Vert}_2\le {t}_2-\sum \limits_{j=1}^n{\beta}_j\\ {}{\left\Vert 0\right\Vert}_2\le {\overline{x}}_j-\left({y}_j-{w}_j^0\right)\\ {}{\left\Vert 0\right\Vert}_2\le {\overline{x}}_j-\left(-{y}_j+{w}_j^0\right)\\ {}{\left\Vert \left(\begin{array}{c}{\overline{x}}_{\boldsymbol{j}}\\ {}\ \frac{\beta_j}{2{m}_j}-\frac{s_j}{2}\end{array}\right)\right\Vert}_2\le \frac{\beta_j}{2{m}_j}+\frac{s_j}{2}\\ {}{\left\Vert \left(\begin{array}{c}{s}_{\boldsymbol{j}}\\ {}\frac{1-{\overline{x}}_{\boldsymbol{j}}}{2}\ \end{array}\right)\right\Vert}_2\le \frac{1+{\overline{x}}_{\boldsymbol{j}}}{2}\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlh.png)

那么，SOCP 约束的标准形式如下:

![$$ \left\{\begin{array}{c}{\left\Vert 0\right\Vert}_2\le {t}_2-\sum \limits_{j=1}^n{\beta}_j\Longleftrightarrow {\left\Vert {\boldsymbol{A}}_{\mathbf{1}}^{\boldsymbol{T}}\boldsymbol{z}+{\boldsymbol{C}}_{\mathbf{1}}\right\Vert}_2\le {\boldsymbol{b}}_{\mathbf{1}}^{\boldsymbol{T}}\boldsymbol{z}+{d}_1\\ {}{\boldsymbol{A}}_{\mathbf{1}}^{\boldsymbol{T}}={\mathbf{0}}_{\mathbf{1}\times \boldsymbol{n}},{\boldsymbol{C}}_{\mathbf{1}}=\mathbf{0},{\boldsymbol{b}}_{\mathbf{1}}=\left(\begin{array}{c}-{\mathbf{1}}_{n\times 1}\\ {}\mathbf{1}\end{array}\right),{d}_1=0,\boldsymbol{z}=\left(\begin{array}{c}\boldsymbol{\beta} \\ {}{t}_2\end{array}\right)\ \end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equli.png)

又如下:

![$$ \left\{\begin{array}{c}{\left\Vert 0\right\Vert}_2\le {\overline{x}}_j-\left({y}_j-{w}_j^0\right)\Longleftrightarrow {\left\Vert {\boldsymbol{A}}_{\mathbf{2},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{\boldsymbol{C}}_{\mathbf{2},\boldsymbol{j}}\right\Vert}_2\le {\boldsymbol{b}}_{\mathbf{2},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{d}_{2,j}\\ {}{\boldsymbol{A}}_{\mathbf{2},\boldsymbol{j}}^{\boldsymbol{T}}={\mathbf{0}}_{\mathbf{1}\times \mathbf{2}\boldsymbol{n}},{\boldsymbol{C}}_{\mathbf{2},\boldsymbol{j}}=\mathbf{0},{\boldsymbol{b}}_{\mathbf{2},\boldsymbol{j}}=\left(\begin{array}{c}-{\boldsymbol{e}}_j\\ {}{\boldsymbol{e}}_j\end{array}\right),{d}_{2,j}={w}_j^0,\boldsymbol{z}=\left(\begin{array}{c}\boldsymbol{y}\\ {}\overline{x}\end{array}\right)\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlj.png)

![$$ \left\{\begin{array}{c}{\left\Vert 0\right\Vert}_2\le {\overline{x}}_j-\left(-{y}_j+{w}_j^0\right)\Longleftrightarrow {\left\Vert {\boldsymbol{A}}_{\mathbf{3},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{\boldsymbol{C}}_{\mathbf{3},\boldsymbol{j}}\right\Vert}_2\le {\boldsymbol{b}}_{\mathbf{3},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{d}_{3,j}\\ {}{\boldsymbol{A}}_{\mathbf{3},\boldsymbol{j}}^{\boldsymbol{T}}={\mathbf{0}}_{\mathbf{1}\times \mathbf{2}\boldsymbol{n}},{\boldsymbol{C}}_{\mathbf{3},\boldsymbol{j}}=\mathbf{0},{\boldsymbol{b}}_{\mathbf{3},\boldsymbol{j}}=\left(\begin{array}{c}{\boldsymbol{e}}_j\\ {}{\boldsymbol{e}}_j\end{array}\right),{d}_{3,j}=-{w}_j^0,\boldsymbol{z}=\left(\begin{array}{c}\boldsymbol{y}\\ {}\overline{x}\end{array}\right)\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlk.png)

其中***e***<sub>*j*</sub>是一个 *n* 维向量，其第 *j* 个条目为 1，所有其他条目为 0。

还有，我们有以下:

![$$ \left\{\begin{array}{c}{\left\Vert \left(\begin{array}{c}{\overline{x}}_{\boldsymbol{j}}\\ {}\ \frac{\beta_j}{2{m}_j}-\frac{s_j}{2}\end{array}\right)\right\Vert}_2\le \frac{\beta_j}{2{m}_j}+\frac{s_j}{2}\Longleftrightarrow {\left\Vert {\boldsymbol{A}}_{\mathbf{4},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{\boldsymbol{C}}_{\mathbf{4},\boldsymbol{j}}\right\Vert}_2\le {\boldsymbol{b}}_{\mathbf{4},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{d}_{4,j}\\ {}{\boldsymbol{A}}_{\mathbf{4},\boldsymbol{j}}^{\boldsymbol{T}}=\left(\begin{array}{ccc}{{\boldsymbol{e}}_j}^{\boldsymbol{T}}&amp; {\mathbf{0}}_{\mathbf{1}\times \boldsymbol{n}}&amp; {\mathbf{0}}_{\mathbf{1}\times \boldsymbol{n}}\\ {}{\mathbf{0}}_{\mathbf{1}\times \boldsymbol{n}}&amp; \frac{1}{2{m}_j}{{\boldsymbol{e}}_j}^{\boldsymbol{T}}&amp; -\frac{1}{2}{{\boldsymbol{e}}_j}^{\boldsymbol{T}}\end{array}\right),{\boldsymbol{C}}_{\mathbf{4},\boldsymbol{j}}={\mathbf{0}}_{\mathbf{2}\times \mathbf{1}},{\boldsymbol{b}}_{\mathbf{4},\boldsymbol{j}}=\left(\begin{array}{c}{\mathbf{0}}_{\boldsymbol{n}\times \mathbf{1}}\\ {}\frac{1}{2{m}_j}{\boldsymbol{e}}_j\\ {}\frac{1}{2}{\boldsymbol{e}}_j\end{array}\right),{d}_{4,j}=0,\boldsymbol{z}=\left(\begin{array}{c}\overline{x}\\ {}{\beta}_j\\ {}\boldsymbol{s}\end{array}\right)\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equll.png)

![$$ \left\{\begin{array}{c}{\left\Vert \left(\begin{array}{c}{s}_{\boldsymbol{j}}\\ {}\frac{1-{\overline{x}}_{\boldsymbol{j}}}{2}\ \end{array}\right)\right\Vert}_2\le \frac{1+{\overline{x}}_{\boldsymbol{j}}}{2}\Longleftrightarrow {\left\Vert {\boldsymbol{A}}_{\mathbf{5},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{\boldsymbol{C}}_{\mathbf{5},\boldsymbol{j}}\right\Vert}_2\le {\boldsymbol{b}}_{\mathbf{5},\boldsymbol{j}}^{\boldsymbol{T}}\boldsymbol{z}+{d}_{5,j}\\ {}{\boldsymbol{A}}_{\mathbf{5},\boldsymbol{j}}^{\boldsymbol{T}}=\left(\begin{array}{cc}{\mathbf{0}}_{\mathbf{1}\times \boldsymbol{n}}&amp; {{\boldsymbol{e}}_j}^{\boldsymbol{T}}\\ {}-\frac{1}{2}{{\boldsymbol{e}}_j}^{\boldsymbol{T}}&amp; {\mathbf{0}}_{\mathbf{1}\times \boldsymbol{n}}\end{array}\right),{\boldsymbol{C}}_{\mathbf{5},\boldsymbol{j}}=\left(\begin{array}{c}\mathbf{0}\\ {}\frac{1}{2}\end{array}\right),{\boldsymbol{b}}_{\mathbf{5},\boldsymbol{j}}=\left(\begin{array}{c}\frac{1}{2}{\boldsymbol{e}}_j\\ {}{\mathbf{0}}_{\boldsymbol{n}\times \mathbf{1}}\end{array}\right),{d}_{5,j}=\frac{1}{2},\boldsymbol{z}=\left(\begin{array}{c}\overline{x}\\ {}\boldsymbol{s}\end{array}\right)\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlm.png)

NM Dev 类`MarketImpact1`实现了高级投资组合优化的 SOCP 约束。该类签名如下:

```py
public class MarketImpact1 extends SOCPPortfolioConstraint {

    /**
     * Constructs a market impact term.
     *
     * @param w_0 the initial position
     * @param m   the market impact parameter
     */
    public MarketImpact1(Vector w_0, Vector m);
}

```

前面的例子显示了我们如何将非线性约束转换成标准形式的一组 SOCP 约束。类似的技术也可以应用于其他非线性约束。NM FinTech 目前支持的其他`SOCPPortfolioConstraint`约束如下:

*   `SOCPMaximumLoan`:股票最大允许借入金额

*   `SOCPNoTradingList1`:不得交易股票黑名单

*   `SOCPSectorExposure`:扇区允许的最大曝光

*   `SOCPSectorNeutrality`:行业中性投资组合

*   `SOCPSelfFinancing`:自筹资金组合

*   `SOCPZeroValue`:零成本投资组合

你可以在 NM FinTech 包中找到更多信息:

`tech.nmfin.portfoliooptimization`

或者，查看网站:

```py
https://nmfin.tech/

```

### 10 . 5 . 2 SOCP 问题的原始对偶方法

让:

![$$ \boldsymbol{c}={\left[{\hat{\boldsymbol{c}}}_{\mathbf{1}}\ {\hat{\boldsymbol{c}}}_{\mathbf{2}}\dots {\hat{\boldsymbol{c}}}_{\boldsymbol{q}}\right]}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equln.png)

![$$ \boldsymbol{x}={\left[{\boldsymbol{x}}_{\mathbf{1}}\ {\boldsymbol{x}}_{\mathbf{2}}\dots {\boldsymbol{x}}_{\boldsymbol{q}}\right]}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlo.png)

![$$ \boldsymbol{s}={\left[{\boldsymbol{s}}_{\mathbf{1}}\ {\boldsymbol{s}}_{\mathbf{2}}\dots {\boldsymbol{s}}_{\boldsymbol{q}}\right]}^{\boldsymbol{T}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlp.png)

![$$ \boldsymbol{A}={\left[{\hat{\boldsymbol{A}}}_{\mathbf{1}}{\hat{\boldsymbol{A}}}_{\mathbf{2}}\dots {\hat{\boldsymbol{A}}}_{\boldsymbol{q}}\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlq.png)

![$$ \mathcal{K}={\mathcal{K}}_1\ast {\mathcal{K}}_2\ast \dots \ast {\mathcal{K}}_q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlr.png)

其中![$$ {\mathcal{K}}_1\ {\mathcal{K}}_2\dots {\mathcal{K}}_q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq72.png)为二阶锥，![$$ \mathcal{K} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq73.png)表示二阶锥，其元素为***x***=【***x***<sub>**1**</sub>***x***<sub>**2**</sub>...***x***<sub>***q***</sub><sup>***T***</sup>同![$$ {\boldsymbol{x}}_{\boldsymbol{i}}\in {\mathcal{K}}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq74.png)。那么，脑瓜子 SOCP 问题可以写成:

![$$ \min {\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equls.png)

![$$ \boldsymbol{Ax}=\boldsymbol{b},\boldsymbol{x}\in \mathcal{K} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Eqult.png)服从，

或者，在对偶形式中，我们有这样的:

![$$ \max {\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlu.png)

![$$ {\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{y}+\boldsymbol{s}=\boldsymbol{c},\boldsymbol{s}\in \mathcal{K} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlv.png)服从，

所以 ***x*** 和( ***s*** ， ***y*** )的二元差距如下:

![$$ \delta \left(\boldsymbol{x},\boldsymbol{s},\boldsymbol{y}\right)={\boldsymbol{c}}^{\boldsymbol{T}}\boldsymbol{x}-{\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y}={\left({\mathbf{A}}^{\boldsymbol{T}}\ \boldsymbol{y}+\boldsymbol{s}\right)}^{\boldsymbol{T}}\boldsymbol{x}-{\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{y}={\boldsymbol{s}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlw.png)

KKT 条件下，对于一个![$$ \left(\boldsymbol{x},\boldsymbol{s},\boldsymbol{y}\right)\in \mathcal{K}\ast \mathcal{K}\ast {\mathbb{R}}^m $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq75.png)，有如下几种:

![$$ \boldsymbol{Ax}=\boldsymbol{b} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlx.png)

![$$ {\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{y}+\boldsymbol{s}=\boldsymbol{c} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equly.png)

![$$ {\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{s}=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equlz.png)

假设经过 *k* -th 次迭代后，向量集为(***x***<sub>***k***</sub>，***s***<sub>***k***</sub>，***y***<sub>***k***</sub>)。下次更新如下:

![$$ \left({\boldsymbol{x}}_{\boldsymbol{k}+\mathbf{1}},{\boldsymbol{s}}_{\boldsymbol{k}+\mathbf{1}},{\boldsymbol{y}}_{\boldsymbol{k}+\mathbf{1}}\right)=\left({\boldsymbol{x}}_{\boldsymbol{k}},{\boldsymbol{s}}_{\boldsymbol{k}},{\boldsymbol{y}}_{\boldsymbol{k}}\right)+{\alpha}_k\left(\boldsymbol{\Delta} \boldsymbol{x},\boldsymbol{\Delta} \boldsymbol{s},\boldsymbol{\Delta} \boldsymbol{y}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equma.png)

其中*α*<sub>T3】kT5】为正标量。</sub>

(**δ*****x***，**δ*****s***，**δ*****y***)通过解方程组得到，如下图所示:

![$$ \boldsymbol{A}\boldsymbol{\Delta  x}=\boldsymbol{b}-\boldsymbol{Ax} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmb.png)

![$$ {\boldsymbol{A}}^{\boldsymbol{T}}\Delta  \boldsymbol{y}+\Delta  \boldsymbol{s}=\boldsymbol{c}-\boldsymbol{s}-{\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{y} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmc.png)

![$$ \boldsymbol{S}\Delta  \boldsymbol{x}+\boldsymbol{X}\Delta  \boldsymbol{s}=\sigma \mu \boldsymbol{e}-\boldsymbol{Xs} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmd.png)

其中

![$$ \boldsymbol{e}={\left[1\ 1\dots 1\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equme.png)

***X*** =诊断{ ***X*** <sub>1</sub> ，...、***X***<sub>*q*</sub>}、![$$ {\boldsymbol{X}}_1=\left[\begin{array}{cc}{t}_i&amp; {\boldsymbol{u}}_{\boldsymbol{i}}^{\boldsymbol{T}}\\ {}{\boldsymbol{u}}_{\boldsymbol{i}}&amp; {t}_i{\boldsymbol{I}}_{\boldsymbol{i}}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq76.png)

![$$ \boldsymbol{S}=\operatorname{diag}\left\{{\boldsymbol{S}}_1,\dots, {\boldsymbol{S}}_q\right\} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmf.png)

![$$ \boldsymbol{\mu} ={\boldsymbol{x}}^{\boldsymbol{T}}\boldsymbol{s}/q $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmg.png)

*σ* 是一个小的正标量。***I***<sub>***I***</sub>是一个*<sub>*I*</sub>—1 的单位矩阵。可以看出，向量集(***x***<sub>***k***</sub>，***s***<sub>***k***</sub>，***y***<sub>***k***</sub>)被更新，使得新的向量集( ***s***<sub>***k+*****1**</sub>，***y***<sub>***【k+*****【1**</sub>)更好地逼近了 KKT 条件，因而对偶缺口更小。*

 *和陆(2007)提供了内点算法解决 SOCP 问题的细节如下。

**原始对偶内点算法** **求解 SOCP 问题**

**第一步**

输入问题规格{ ***A*** ， ***b*** ， ***c*** }，参数 *q* 和{*n*<sub>*I*</sub>}为 *i* = 1，2，...， *q* ，公差 *ε* 。

在可行区域的内部输入一个初始向量集(***x***<sub>**0**</sub>，***s***<sub>**0**</sub>， ***，*** <sub>**0**</sub> )。

设置![$$ {\delta}_0=\frac{x_0^T{s}_0}{q} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq77.png)、*σ*= 10<sup>—5</sup>。

Se 迭代计数器 *k* = 0。

**第二步**

求解为(**δ*****x***，**δ*****s***，**δ*****y***)。

**第三步**

选择*α*<sub>T3】kT5】。</sub>

**第四步**

更新(*t1*<sub>**【K6】**</sub>*****【s】 ***和***<sub>***【k】***</sub>+*<sub>*【k】*</sub>******

 ****第五步**

计算如下:

![$$ {\delta}_{k+1}=\frac{x_{k+1}^T{s}_{k+1}}{q} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmh.png)

如果*<sub>*【k】*+1</sub>*，则输出溶液( **<sup>***s***<sub>***【k+***</sub>**、 ***和*****</sup>****

 ******否则，设置 *k* = *k* + 1，并从**步骤 2** 开始重复。

和陆(2007)提供了下面的例子来演示算法:

![$$ \min \delta $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmi.png)

服从，

![$$ {\left[{\left({x}_1-{x}_3\right)}^2+{\left({x}_2-{x}_4\right)}^2\right]}^{1/2}\le \delta $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmj.png)

![$$ \left[{x}_1\kern0.5em {x}_2\right]\left[\begin{array}{cc}0.25&amp; 0\\ {}0&amp; 1\end{array}\right]\left[\begin{array}{c}{x}_1\\ {}{x}_2\end{array}\right]-\left[\begin{array}{cc}{x}_1&amp; {x}_2\end{array}\right]\left[\begin{array}{c}0.5\\ {}0\end{array}\right]\le 0.75 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmk.png)

![$$ \left[{x}_3\kern0.5em {x}_4\right]\left[\begin{array}{cc}0.625&amp; 0.375\\ {}0.375&amp; 0.625\end{array}\right]\left[\begin{array}{c}{x}_3\\ {}{x}_4\end{array}\right]-\left[\begin{array}{cc}{x}_3&amp; {x}_4\end{array}\right]\left[\begin{array}{c}5.5\\ {}6.5\end{array}\right]\le -17.5 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equml.png)

我们首先把问题写成标准形式。

![$$ \boldsymbol{x}={\left[\delta {x}_1\kern0.5em {x}_2\kern0.5em {x}_3\kern0.5em {x}_4\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmm.png)让:

SOCP 问题可以这样写:

![$$ \min {\boldsymbol{b}}^{\boldsymbol{T}}\boldsymbol{x} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmn.png)

![$$ \left\Vert {\boldsymbol{A}}_i^{\boldsymbol{T}}\boldsymbol{x}+{\boldsymbol{c}}_i\right\Vert \le {\boldsymbol{b}}_i^{\boldsymbol{T}}\boldsymbol{x}+{d}_i $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmo.png)服从，

其中

![$$ \boldsymbol{b}={\left[1\kern0.5em 0\kern0.5em 0\kern0.5em 0\kern0.5em 0\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Eqump.png)

![$$ {\boldsymbol{A}}_{\mathbf{1}}^{\boldsymbol{T}}=\left[\begin{array}{ccc}0&amp; -1&amp; 0\\ {}0&amp; 0&amp; 1\end{array}\kern1em \begin{array}{cc}1&amp; 0\\ {}0&amp; -1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmq.png)

![$$ {\boldsymbol{A}}_{\mathbf{2}}^{\boldsymbol{T}}=\left[\begin{array}{ccc}0&amp; 0.5&amp; 0\\ {}0&amp; 0&amp; 1\end{array}\kern1em \begin{array}{cc}0&amp; 0\\ {}0&amp; -0\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmr.png)

![$$ {\boldsymbol{A}}_{\mathbf{3}}^{\boldsymbol{T}}=\left[\begin{array}{ccc}0&amp; 0&amp; 0\\ {}0&amp; 0&amp; 0\end{array}\kern1em \begin{array}{cc}-0.7071&amp; -0.7071\\ {}-0.3536&amp; 0.3536\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equms.png)

![$$ {\boldsymbol{b}}_{\mathbf{1}}=\boldsymbol{b},{\boldsymbol{b}}_{\mathbf{2}}=\mathbf{0},{\boldsymbol{b}}_{\mathbf{3}}=\mathbf{0} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmt.png)

![$$ {\boldsymbol{c}}_{\mathbf{1}}=\mathbf{0},{\boldsymbol{c}}_{\mathbf{2}}=\left[\begin{array}{c}-0.5\\ {}0\end{array}\right],{\boldsymbol{c}}_{\mathbf{3}}=\left[\begin{array}{c}4.2426\\ {}-0.7071\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmu.png)

![$$ {d}_1=0,{d}_2=1,{d}_3=1 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmv.png)

为了生成一个初始的严格可行向量集(***x***<sub>**0**</sub>，***s***<sub>**0**</sub>，***y***<sub>**0**</sub>)，我们尝试如下:

![$$ \left[{x}_1\kern0.5em {x}_2\kern0.5em {x}_3\kern0.5em {x}_4\right]=\left[\begin{array}{cccc}1.5&amp; 0.5&amp; 2.5&amp; 4\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmw.png)

![$$ {\boldsymbol{y}}_{\mathbf{0}}={\left[\beta \kern0.5em -1.5\kern0.5em -0.5\kern0.5em -2.5\kern0.5em -4\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmx.png)

其中 *β* 为标量，以保证*T3 sT5 T6 T7 0T9】为内点。*

*![$$ {\boldsymbol{s}}_{\mathbf{0}}=\boldsymbol{c}-{\boldsymbol{A}}^{\boldsymbol{T}}\boldsymbol{y}={\left[\beta \kern0.5em 1\kern0.5em 3.5\kern0.5em 0\kern0.5em 0\kern0.5em 1\kern0.5em 0.25\kern0.5em 0.5\kern0.5em 1\kern0.5em -0.3535\kern0.5em -0.1767\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmy.png)*

当 *n* <sub>1</sub> = 5、 *n* <sub>2</sub> = 3、 *n* <sub>3</sub> = 3 时，选择 *β* = 3.7 可以保证***s***<sub>**0**</sub>为内点。这就给出了以下:

![$$ {\boldsymbol{y}}_{\mathbf{0}}={\left[3.7\kern0.5em -1.5\kern0.5em -0.5\kern0.5em -2.5\kern0.5em -4\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equmz.png)

![$$ {\boldsymbol{s}}_{\mathbf{0}}={\left[3.7\kern0.5em 1\kern0.5em 3.5\kern0.5em 0\kern0.5em 0\kern0.5em 1\kern0.5em 0.25\kern0.5em 0.5\kern0.5em 1\kern0.5em -0.3535\kern0.5em -0.1767\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equna.png)

![$$ {\boldsymbol{x}}_{\mathbf{0}}={\left[1\kern0.5em 0\kern0.5em 0\kern0.5em 0\kern0.5em 0\kern0.5em 0.1\kern0.5em 0\kern0.5em 0\kern0.5em 0.1\kern0.5em 0\kern0.5em 0\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnb.png)

设置*ε*= 10<sup>4</sup>，算法在 15 次迭代后返回一个解。

![$$ {\boldsymbol{y}}^{\ast}={\left[-1.707791\kern0.5em -2.044005\kern0.5em -0.852730\kern1em \begin{array}{cc}-2.544838&amp; -2.485646\end{array}\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnc.png)

NM Dev 类`PrimalDualInteriorPointMinimizer`实现了这个算法。以下代码解决了前面的示例问题:

```py
// the problem specifications
Vector b = new DenseVector(1., 0., 0., 0., 0.);

Matrix A1t
        = new DenseMatrix(
                new double[][]{
                    {0, -1, 0, 1, 0},
                    {0, 0, 1, 0, -1}
                });
Matrix A2t
        = new DenseMatrix(
                new double[][]{
                    {0, 0.5, 0, 0, 0},
                    {0, 0, 1, 0, 0}
                });
Matrix A3t
        = new DenseMatrix(
                new double[][]{
                    {0, 0, 0, -0.7071, -0.7071},
                    {0, 0, 0, -0.3536, 0.3536}
                });

Vector b1 = b;
Vector b2 = b.ZERO();
Vector b3 = b.ZERO();

Vector c1 = new DenseVector(2);//zero
Vector c2 = new DenseVector(-0.5, 0.);
Vector c3 = new DenseVector(4.2426, -0.7071);

double[] d = new double[]{0., 1, 1};

// construct an SOCP problem in standard form
SOCPGeneralProblem problem
        = new SOCPGeneralProblem(
                b,
                Arrays.asList(
                        new SOCPGeneralConstraint(A1t.t(), c1, b1, d[0]),
                        new SOCPGeneralConstraint(A2t.t(), c2, b2, d[1]),
                        new SOCPGeneralConstraint(A3t.t(), c3, b3, d[2])
                )
        );

// an initial strictly feasible point
Vector x0 = new DenseVector(1, 0, 0, 0.1, 0, 0, 0.1, 0, 0);
Vector s0 = new DenseVector(3.7, 1, -3.5, 1, 0.25, 0.5, 1, -0.35355, -0.1767);
Vector y0 = new DenseVector(-3.7, -1.5, -0.5, -2.5, -4);
PrimalDualSolution initial = new PrimalDualSolution(x0, s0, y0);

// solving an SOCP problem
PrimalDualInteriorPointMinimizer solver
        = new PrimalDualInteriorPointMinimizer(0.00001, 20);
IterativeSolution<PrimalDualSolution> solution
        = solver.solve(problem);
solution.search(initial);

// primal solution
System.out.println("X = ");
System.out.println(solution.minimizer().x);
// dual solution
System.out.println("y = ");
System.out.println(solution.minimizer().y);
System.out.println("S = ");
System.out.println(solution.minimizer().s);
System.out.println("minimum = " + solution.minimum());

```

输出如下所示:

```py
X =
[1.000000, -0.292607, 0.956232, 1.121095, -0.585213, -0.956232, 1.288558, -0.883070, 0.938384]
y =
[-1.707796, -2.043378, -0.853136, -2.544339, -2.485799]
S =
[1.707796, 0.500961, -1.632663, 1.000000, 0.521689, 0.853136, 1.000000, 0.685789, -0.727800]
minimum = -1.7077862121401681

```

截至 2014 年 1 月 9 日，该 SOCP 求解器在解决大型投资组合优化问题时测试了多达 6，000 个变量和 26，000 个约束。五分钟后返回结果。

## 10.6 一般非线性优化问题

最常见的优化问题是目标函数和约束都是非线性的。有许多方法可以解决这些问题，例如第 [11](11.html) 章中的惩罚方法。在这一节中，我们介绍序列二次规划(SQP)方法。当目标函数和约束条件都是两次连续可微时，这是解决一般约束问题的最有效方法之一。SQP 适用于小问题和大问题，并且非常适合解决具有显著非线性的问题。SQP 方法可以被看作是牛顿方法在无约束最优化中的推广，因为它通过最小化问题的二次模型找到了远离当前点的一步。

### 10.6.1 只有平等限制的 SQP 问题

考虑以下优化问题:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Eqund.png)

服从于，

*a*<sub>T3】IT5】(***x***)= 0， *i* = 1，...， *p*</sub>

其中 *f* 和*a*<sub>T5】I</sub>为连续函数，具有连续的一阶和二阶偏导数。假设可行域是非空的，并且 *p* ≤ *n* 。最小化的一阶必要条件由拉格朗日乘数法给出，如下:

![$$ \mathcal{L}\left(\boldsymbol{x},\boldsymbol{\lambda} \right)=f\left(\boldsymbol{x}\right)-\sum \limits_{i=1}^p{\lambda}_i{a}_i\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equne.png)

![$$ \nabla \mathcal{L}\left({\boldsymbol{x}}^{\ast },{\boldsymbol{\lambda}}^{\ast}\right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnf.png)

假设我们有 *k* -th 迭代集{***x***<sub>*k*</sub>，***λ***<sub>*k*</sub>}，它被假定为足够接近解{***x***<sup>***∫***</sup>， *并且我们希望找到一个增量{*δ*<sub>***x***</sub>，*δ*<sub>***λ***</sub>}，使得下一次迭代更接近最优。 利用泰勒级数，我们有如下:*

*![$$ \nabla \mathcal{L}\left({\boldsymbol{x}}_{k+1},{\boldsymbol{\lambda}}_{k+1}\right)\approx \nabla \mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\lambda}}_k\right)+{\nabla}^2\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\lambda}}_k\right)\left[\begin{array}{c}{\delta}_{\boldsymbol{x}}\\ {}{\delta}_{\boldsymbol{\lambda}}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equng.png)*

{***x***<sub>*k*+1</sub>，***λ***<sub>*k*+1</sub>}是{***x***<sup>***∵***</sup>，***λ***<sup>***的更好的近似***</sup>

我们可以用拉格朗日的黑森矩阵***W***for {***x***，***λ***} = {***x***<sub>*k*</sub>，***λ***<sub>*k*</sub>}和雅可比矩阵

*![$$ \left[\begin{array}{cc}{\boldsymbol{W}}_k&amp; -{\boldsymbol{A}}_k^T\\ {}-{\boldsymbol{A}}_k&amp; \mathbf{0}\end{array}\right]\left[\begin{array}{c}{\delta}_{\boldsymbol{x}}\\ {}{\delta}_{\boldsymbol{\lambda}}\end{array}\right]=\left[\begin{array}{c}{\boldsymbol{A}}_k^T{\boldsymbol{\lambda}}_k-{\boldsymbol{g}}_k\\ {}{\boldsymbol{a}}_k\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equni.png)*

其中

![$$ {\boldsymbol{W}}_k={\nabla}_x^2f\left({\boldsymbol{x}}_k\right)-\sum \limits_{i=1}^p{\left({\boldsymbol{\lambda}}_k\right)}_i{\nabla}_{\boldsymbol{x}}^2{a}_i\left({\boldsymbol{x}}_k\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnj.png)

![$$ {\boldsymbol{A}}_k=\left[\begin{array}{c}{\nabla}_{\boldsymbol{x}}^T{a}_1\left({\boldsymbol{x}}_k\right)\\ {}{\nabla}_{\boldsymbol{x}}^T{a}_2\left({\boldsymbol{x}}_k\right)\\ {}\vdots \\ {}{\nabla}_{\boldsymbol{x}}^T{a}_p\left({\boldsymbol{x}}_k\right)\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnk.png)

![$$ {\boldsymbol{g}}_k={\nabla}_{\boldsymbol{x}}f\left({\boldsymbol{x}}_k\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnl.png)

![$$ {\boldsymbol{a}}_k=\left[{a}_1\left({\boldsymbol{x}}_k\right)\kern0.5em {a}_2\left({\boldsymbol{x}}_k\right)\kern0.5em \dots \kern0.5em {a}_p\left({\boldsymbol{x}}_k\right)\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnm.png)

如果***w***<sub>*k*</sub>≻0 和***a***<sub>*k*</sub>满秩，那么方程的解，即![$$ \left[\begin{array}{c}{\delta}_{\boldsymbol{x}}\\ {}{\delta}_{\boldsymbol{\lambda}}\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq79.png)存在。要计算*δ*<sub>***x***</sub>，我们可以将矩阵方程展开成这样:

![$$ \left\{\begin{array}{c}{\boldsymbol{W}}_k{\delta}_{\boldsymbol{x}}+{\boldsymbol{g}}_k={\boldsymbol{A}}_k^T{\boldsymbol{\lambda}}_k+{\boldsymbol{A}}_k^T{\delta}_k={\boldsymbol{A}}_k^T{\boldsymbol{\lambda}}_{k+1}\\ {}{\boldsymbol{A}}_k{\delta}_{\boldsymbol{x}}=-{\boldsymbol{a}}_k\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnn.png)

这两个方程本质上是一个 QP 问题对于*δ*<sub>***x***</sub>的一阶必要条件。就是我们有这个:

![$$ \underset{\delta_{\boldsymbol{x}}}{\min}\frac{1}{2}{\delta}_{\boldsymbol{x}}^T{\boldsymbol{W}}_k{\delta}_{\boldsymbol{x}}+{\delta}_{\boldsymbol{x}}^T{\boldsymbol{g}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equno.png)

![$$ {\boldsymbol{A}}_k{\delta}_{\boldsymbol{x}}=-{\boldsymbol{a}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnp.png)服从，

这是一个只有等式约束的 QP 问题。可以使用第 10.3.1 节中的算法求解。一旦找到*δ*<sub>***x***</sub>，下一次迭代如下:

![$$ {\boldsymbol{x}}_{k+1}={\boldsymbol{x}}_k+{\delta}_{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnq.png)

***λ***<sub>*k*+1</sub>，***W***<sub>*k*+1</sub>，***g***<sub>*k*+1</sub>，***A***<sub>*k*+1</sub>可以从我们继续这个过程，直到当‖*δ*<sub>***x***</sub>‖足够小时，算法收敛。这种反复求解 QP 子问题的迭代方法被称为序列二次规划(SQP)。本质上，SQP 所做的是试图迭代最小化拉格朗日函数![$$ \mathcal{L}\left(\boldsymbol{x},\boldsymbol{\lambda} \right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq80.png)的二阶近似，而不是函数*f*(***x***)本身。

和陆(2007)讨论了以下例子:

![$$ \underset{\boldsymbol{x}}{\min }-{x}_1^4-2{x}_2^4-{x}_3^4-{x}_1^2{x}_2^2-{x}_1^2{x}_3^2 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnr.png)

![$$ \left\{\begin{array}{c}{a}_1\left(\boldsymbol{x}\right)={x}_1^4+{x}_2^4+{x}_3^4-25=0\\ {}{a}_2\left(\boldsymbol{x}\right)=8{x}_1^2+14{x}_2^2+7{x}_3^2-56=0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equns.png)服从，

有了![$$ {\boldsymbol{x}}_{\boldsymbol{k}}={\left[{x}_1\kern0.5em {x}_2\kern0.5em {x}_3\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq81.png)和![$$ {\lambda}_{\boldsymbol{k}}={\left[{\lambda}_1\kern0.5em {\lambda}_2\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq82.png)，我们还有以下:![img/500382_1_En_10_Chapter/500382_1_En_10_Figa_HTML.gif](img/500382_1_En_10_Chapter/500382_1_En_10_Figa_HTML.gif)

![$$ {\boldsymbol{g}}_k=\left[\begin{array}{c}-4{x}_1^3-2{x}_1{x}_2^2-2{x}_1{x}_3^2\\ {}-8{x}_2^3-2{x}_1^2{x}_2\\ {}-4{x}_3^3-2{x}_1^2{x}_3\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnu.png)

![$$ {\boldsymbol{A}}_k=\left[\begin{array}{ccc}4{x}_1^3&amp; 4{x}_2^3&amp; 4{x}_3^3\\ {}16{x}_1&amp; 28{x}_2&amp; 14{x}_3\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnv.png)

![$$ {\boldsymbol{a}}_k=\left[\begin{array}{c}{x}_1^4+{x}_2^4+{x}_3^4-25\\ {}8{x}_1^2+14{x}_2^2+7{x}_3^2-56\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnw.png)

用![$$ {\boldsymbol{x}}_{\boldsymbol{k}}={\left[3\kern0.5em 1.5\kern0.5em 3\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq83.png)和![$$ {\lambda}_{\boldsymbol{k}}={\left[-1\kern0.5em -1\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_IEq84.png)，算法求出解:

![$$ {\boldsymbol{x}}^{\ast}=\left[\begin{array}{c}1.874065\\ {}-0.465820\\ {}1.884720\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnx.png)

![$$ f\left(\boldsymbol{x}\right)=-38.384828 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equny.png)

NM Dev 类`SQPActiveSetOnlyEqualityConstraint1Minimizer`实现这个算法来解决只有等式约束的 SDP 问题。以下示例代码解决了前面的示例:

```py
// objective function
RealScalarFunction f = new RealScalarFunction() {
    @Override
    public Double evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);

        double fx = -pow(x1, 4.);
        fx -= 2\. * pow(x2, 4.);
        fx -= pow(x3, 4.);
        fx -= pow(x1 * x2, 2.);
        fx -= pow(x1 * x3, 2.);

        return fx;
    }

    @Override
    public int dimensionOfDomain() {
        return 3;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

// equality constraints
EqualityConstraints equality_constraints
        = new GeneralEqualityConstraints(
                new RealScalarFunction() {
            @Override
            public Double evaluate(Vector x) {
                double x1 = x.get(1);
                double x2 = x.get(2);
                double x3 = x.get(3);

                double fx = pow(x1, 4.);
                fx += pow(x2, 4.);
                fx += pow(x3, 4.);
                fx -= 25.;

                return fx; // a1
            }

            @Override
            public int dimensionOfDomain() {
                return 3;
            }

            @Override
            public int dimensionOfRange() {
                return 1;
            }
        },
                new RealScalarFunction() {
            @Override
            public Double evaluate(Vector x) {
                double x1 = x.get(1);
                double x2 = x.get(2);
                double x3 = x.get(3);

                double fx = 8\. * pow(x1, 2.);
                fx += 14\. * pow(x2, 2.);
                fx += 7\. * pow(x3, 2.);
                fx -= 56.;

                return fx; // a2
            }

            @Override
            public int dimensionOfDomain() {
                return 3;
            }

            @Override
            public int dimensionOfRange() {
                return 1;
            }
        });

// construct an SQP solver
SQPActiveSetOnlyEqualityConstraint1Minimizer solver
        = new SQPActiveSetOnlyEqualityConstraint1Minimizer(
                (RealScalarFunction f1, EqualityConstraints equal) -> {
                    SQPASEVariation2 impl = new SQPASEVariation2(100., 0.01, 10);
                    impl.set(f1, equal);
                    return impl;
                },
                1e-8, // epsilon, threshold
                20); // max number of iterations
// solving an SQP problem
IterativeSolution<Vector> solution
        = solver.solve(f, equality_constraints);
Vector x = solution.search(
        new DenseVector(3., 1.5, 3.), // x0
        new DenseVector(-1., -1.)); // λ0
double fx = f.evaluate(x);
// solving an SQP problem
System.out.println("x = " + x);
System.out.println("fx = " + fx);

```

输出如下所示:

```py
x = [1.874065, -0.465820, 1.884720]
fx = -38.28482786994784

```

请注意，这个问题有多种解决方案。改变参数会导致不同的解决方案。另一种解决方法如下:

![$$ {\boldsymbol{x}}^{\ast}=\left[\begin{array}{c}1.874065\\ {}0.465820\\ {}1.884720\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equnz.png)

### 10.6.2 具有不等式约束的 SQP 问题

我们可以将前面的算法推广到不等式约束的情况。考虑一般优化问题:

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoa.png)

服从于，

*<sub>*【j】*</sub>(**)≥0，*I*= 1.2，-我...。 *q****

 ***我们假设 *f* 和{ *c* <sub>*j*</sub> }是两次可微的。运用同样的思路，我们再对第 *k* -th 次迭代{***x***<sub>*k*</sub>，***μ***<sub>*k*</sub>}，求一个增量{*δ****x***，*δ*

 *这样就满足了近似的 KKT 条件:

![$$ {\nabla}_{\boldsymbol{x}}\mathcal{L}\left(\boldsymbol{x},\boldsymbol{\mu} \right)=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoc.png)

![$$ {c}_j\left(\boldsymbol{x}\right)\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equod.png)

![$$ \boldsymbol{\mu} \ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoe.png)

![$$ {\mu}_i{c}_i=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equof.png)

利用泰勒展开，我们有如下:

![$$ {\nabla}_{\boldsymbol{x}}\mathcal{L}\left({\boldsymbol{x}}_{k+1},{\boldsymbol{\mu}}_{k+1}\right)\approx {\nabla}_{\boldsymbol{x}}\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\mu}}_k\right)+{\nabla}_{\boldsymbol{x}}^2\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\mu}}_k\right){\delta}_{\boldsymbol{x}}+{\nabla}_{\boldsymbol{x}\boldsymbol{\mu}}^2\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\mu}}_k\right){\delta}_{\boldsymbol{\mu}}=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equog.png)

![$$ {c}_j\left({\boldsymbol{x}}_k+{\boldsymbol{\delta}}_{\boldsymbol{x}}\right)\approx {c}_j\left({\boldsymbol{x}}_k\right)+{\delta}_{\boldsymbol{x}}^T{\nabla}_{\boldsymbol{x}}{c}_j\left({\boldsymbol{x}}_k\right)\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoh.png)

![$$ {\mu}_{k+1}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoi.png)

结合最后两个等式给出如下:

![$$ {\mu}_{k+1}\left[{c}_j\left({\boldsymbol{x}}_k\right)+{\delta}_{\boldsymbol{x}}^T{\nabla}_{\boldsymbol{x}}{c}_j\left({\boldsymbol{x}}_k\right)\right]=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoj.png)

拉格朗日定义如下:

![$$ \mathcal{L}\left(\boldsymbol{x},\boldsymbol{\mu} \right)=f\left(\boldsymbol{x}\right)-\sum \limits_{i=1}^q{\mu}_j{c}_j\left(\boldsymbol{x}\right) $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equok.png)

因此，我们有以下:

![$$ {\nabla}_{\boldsymbol{x}}\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\mu}}_k\right)={\nabla}_{\boldsymbol{x}}f\left({\boldsymbol{x}}_k\right)-\sum \limits_{i=1}^q{\left({\boldsymbol{\mu}}_k\right)}_j{\nabla}_x{c}_j\left({\boldsymbol{x}}_k\right)={\boldsymbol{g}}_k-{\boldsymbol{A}}_k^T{\boldsymbol{\mu}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equol.png)

![$$ {\nabla}_{\boldsymbol{x}}^2\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\mu}}_k\right)={\nabla}_{\boldsymbol{x}}^2f\left({\boldsymbol{x}}_k\right)-\sum \limits_{i=1}^q{\left({\boldsymbol{\mu}}_k\right)}_j{\nabla}_{\boldsymbol{x}}^2{c}_j\left({\boldsymbol{x}}_k\right)={\boldsymbol{Y}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equom.png)

![$$ {\nabla}_{\boldsymbol{x}\boldsymbol{\mu}}^2\mathcal{L}\left({\boldsymbol{x}}_k,{\boldsymbol{\mu}}_k\right)=-{\boldsymbol{A}}_k^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equon.png)

其中***A***<sub>*k*</sub>是约束在***x***<sub>*k*</sub>，即

![$$ {\boldsymbol{A}}_k=\left[\begin{array}{c}{\nabla}_{\boldsymbol{x}}^T{c}_1\left({\boldsymbol{x}}_k\right)\\ {}\vdots \\ {}{\nabla}_{\boldsymbol{x}}^T{c}_q\left({\boldsymbol{x}}_k\right)\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoo.png)

利用这些符号，近似的 KKT 条件可以写成:

![$$ {\boldsymbol{Y}}_k{\boldsymbol{\delta}}_{\boldsymbol{x}}+{\boldsymbol{g}}_k-{\boldsymbol{A}}_k^T{\boldsymbol{\mu}}_{k+1}=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equop.png)

![$$ {\boldsymbol{A}}_k{\boldsymbol{\delta}}_{\boldsymbol{x}}\ge -{\boldsymbol{c}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoq.png)

![$$ {\boldsymbol{\mu}}_{k+1}\ge 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equor.png)

![$$ {\left({\boldsymbol{\mu}}_{k+1}\right)}_j{\left({\boldsymbol{A}}_k{\boldsymbol{\delta}}_{\boldsymbol{x}}+{\boldsymbol{c}}_k\right)}_j=0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equos.png)

我们这里有:

![$$ {\boldsymbol{c}}_k={\left[{c}_1\left({\boldsymbol{x}}_k\right)\kern0.5em {c}_2\left({\boldsymbol{x}}_k\right)\kern0.5em \dots \kern0.5em {c}_q\left({\boldsymbol{x}}_k\right)\right]}^T $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equot.png)

这些近似的 KKT 条件就是这个 QP 问题的精确 KKT 条件:

![$$ \min \frac{1}{2}{\delta}_{\boldsymbol{x}}^T{\boldsymbol{Y}}_k{\boldsymbol{\delta}}_{\boldsymbol{x}}+{\delta}_{\boldsymbol{x}}^T{\boldsymbol{g}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equou.png)

![$$ {\boldsymbol{A}}_k{\boldsymbol{\delta}}_{\boldsymbol{x}}\ge -{\boldsymbol{c}}_k $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equov.png)服从，

那么在解决了 QP 子问题为***δ***<sub>***x***</sub>之后，我们就有了下面的:

![$$ {\boldsymbol{x}}_{k+1}={\boldsymbol{x}}_k+{\boldsymbol{\delta}}_{\boldsymbol{x}} $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equow.png)

SQP 算法迭代求解 QP 子问题，直到解收敛。

和陆(2007)讨论了这个的例子。

![$$ \underset{\boldsymbol{x}}{\min }f\left(\boldsymbol{x}\right)=\frac{1}{2}\left[{\left({x}_1-{x}_3\right)}^2+{\left({x}_2-{x}_4\right)}^2\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equox.png)T2】

![$$ \left\{\begin{array}{c}{c}_1\left(\boldsymbol{x}\right)=-\left[{x}_1\kern0.5em {x}_2\right]\left[\begin{array}{cc}\frac{1}{4}&amp; 0\\ {}0&amp; 1\end{array}\right]\left[\begin{array}{c}{x}_1\\ {}{x}_2\end{array}\right]+\left[\begin{array}{cc}{x}_1&amp; {x}_2\end{array}\right]\left[\begin{array}{c}\frac{1}{2}\\ {}0\end{array}\right]+\frac{3}{4}\ge 0\\ {}{c}_2\left(\boldsymbol{x}\right)=-\frac{1}{8}\left[\begin{array}{cc}{x}_3&amp; {x}_4\end{array}\right]\left[\begin{array}{cc}5&amp; 3\\ {}3&amp; 5\end{array}\right]\left[\begin{array}{c}{x}_3\\ {}{x}_4\end{array}\right]+\left[\begin{array}{cc}{x}_3&amp; {x}_4\end{array}\right]\left[\begin{array}{c}\frac{11}{2}\\ {}\frac{13}{2}\end{array}\right]-\frac{35}{2}\ge 0\end{array}\right. $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoy.png)服从，

其中

![$$ \boldsymbol{x}=\left[\begin{array}{c}{x}_1\\ {}{x}_2\\ {}{x}_3\\ {}{x}_4\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equoz.png)

由于目标函数和约束条件都是二次的，因此海森***Y***<sub>*k*</sub>独立于***x***<sub>*k*</sub>并给出如下:

![$$ {\boldsymbol{Y}}_k=\left[\begin{array}{cccc}1+\frac{\mu_1}{2}&amp; 0&amp; -1&amp; 0\\ {}0&amp; 1+2{\mu}_1&amp; 0&amp; -1\\ {}-1&amp; 0&amp; 1+\frac{5{\mu}_2}{4}&amp; \frac{3{\mu}_2}{4}\\ {}0&amp; -1&amp; \frac{3{\mu}_2}{4}&amp; 1+\frac{5{\mu}_2}{4}\end{array}\right]\succ 0 $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equpa.png)

我们用这些缩写:

![$$ {\boldsymbol{x}}_0=\left[\begin{array}{c}1.0\\ {}0.5\\ {}2.0\\ {}3.0\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equpb.png)

还有这个:

![$$ {\boldsymbol{\mu}}_0=\left[\begin{array}{c}1\\ {}1\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equpc.png)

解决方法如下:

![$$ {\boldsymbol{x}}^{\ast}=\left[\begin{array}{c}2.044750\\ {}0.852716\\ {}2.544913\\ {}2.485633\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equpd.png)

还有

![$$ {\boldsymbol{\mu}}^{\ast}=\left[\begin{array}{c}0.957480\\ {}1.100145\end{array}\right] $$](img/500382_1_En_10_Chapter/500382_1_En_10_Chapter_TeX_Equpe.png)

NM Dev 类`SQPActiveSetOnlyInequalityConstraintMinimizer`实现了这个算法来解决只有不等式约束的 SQP 问题。以下代码解决了前面的示例问题:

```py
// objective function
RealScalarFunction f = new RealScalarFunction() {
    @Override
    public Double evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        double fx = (x1 - x3) * (x1 - x3);
        fx += (x2 - x4) * (x2 - x4);
        fx /= 2;

        return fx;
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

// inequality constraints
GreaterThanConstraints greater
        = new GeneralGreaterThanConstraints(
                // c1
                new RealScalarFunction() {
            @Override
            public Double evaluate(Vector x) {
                double x1 = x.get(1);
                double x2 = x.get(2);
                double x3 = x.get(3);
                double x4 = x.get(4);

                Matrix x12
                        = new DenseMatrix(
                                new double[]{
                                    x1, x2},
                                2, 1);

                Matrix A
                        = new DenseMatrix(
                                new double[][]{
                                    {0.25, 0},
                                    {0, 1}
                                });
                Matrix B = new DenseMatrix(
                        new double[]{
                            0.5, 0},
                        2, 1);

                Matrix FX = x12.t().multiply(A).multiply(x12);
                FX = FX.scaled(-1);
                FX = FX.add(x12.t().multiply(B));

                double fx = FX.get(1, 1);
                fx += 0.75;

                return fx;
            }

            @Override
            public int dimensionOfDomain() {
                return 4;
            }

            @Override
            public int dimensionOfRange() {
                return 1;
            }
        },
                // c2
                new RealScalarFunction() {
            @Override
            public Double evaluate(Vector x) {
                double x1 = x.get(1);
                double x2 = x.get(2);
                double x3 = x.get(3);
                double x4 = x.get(4);

                Matrix x34
                        = new DenseMatrix(
                                new double[]{
                                    x3, x4},
                                2, 1);

                Matrix A
                        = new DenseMatrix(
                                new double[][]{
                                    {5, 3},
                                    {3, 5}
                                });
                Matrix B
                        = new DenseMatrix(
                                new double[]{
                                    11\. / 2, 13\. / 2},
                                2, 1);

                Matrix FX = x34.t().multiply(A).multiply(x34);
                FX = FX.scaled(-1\. / 8);
                FX = FX.add(x34.t().multiply(B));

                double fx = FX.get(1, 1);
                fx += -35\. / 2;

                return fx;
            }

            @Override
            public int dimensionOfDomain() {
                return 4;
            }

            @Override
            public int dimensionOfRange() {
                return 1;
            }
        });

/**
 * TODO: making the 2nd precision parameter 0 gives a better minimizer;
 * how to choose the precision parameters in general?
 */
// construct an SQP solver
SQPActiveSetOnlyInequalityConstraintMinimizer solver
        = new SQPActiveSetOnlyInequalityConstraintMinimizer(
                1e-7, // epsilon1
                1e-3, // epsilon2
                10 // max number of iterations
        );
// solving the SQP problem
IterativeSolution<Vector> solution = solver.solve(f, greater);
Vector x = solution.search(
        new DenseVector(1., 0.5, 2., 3.), // x0
        new DenseVector(1., 1.)); // μ0
double fx = f.evaluate(x);
// print out the solution
System.out.println("x = " + x);
System.out.println("fx = " + fx);

```

输出如下所示:

```py
x = [2.044833, 0.852724, 2.545007, 2.485578]
fx = 1.4581925507489448

```*********************************************************