# 15.时间序列分析

时间序列分析是一种研究时间序列数据的统计技术。时间序列是以离散时间顺序索引的数据点序列。一般来说，时间序列是在连续的等间隔时间点上获得的序列(但不是必须的)。时间序列的例子有标准普尔 500 (SPX)的每日收盘值、过去 100 年的人口以及每月的销售数字。时间序列分析是为了提取时间序列数据中有意义的统计量和其他特征。时间序列预测基于观察值预测未来值。

在回归中，我们分析响应和(其他)解释变量之间的关系。在时间序列分析中，我们感兴趣的不仅是观察值和解释变量(即时间)之间的关系，更重要的是观察值本身之间的关系，比如时间 *t* 的值和之前的两个最后值。例如，回归分析计算响应变量和解释变量之间的相关性。时间序列分析计算观察值本身之间的相关性。回归不假设观察值的顺序。时序数据有一个自然的时间顺序，即时间。时间序列模型通常会反映这样一个事实，即在时间上靠近的观测值比远离的观测值关系更密切。在简单的线性回归(一个解释变量)和时间序列分析中，我们在数据点上画一条线来最好地拟合序列。时间序列分析通常使用线性回归来研究数据。

时间序列分析可以应用于实值、连续数据、离散数字数据，甚至离散符号数据(例如，字符序列，如英语中的字母和单词)。时间序列分析(和预测)是一个大课题。研究时间序列有许多方法:参数与非参数、线性与非线性、频域与时域。在这一章中，我们只能简要地讨论一个重要的类别:线性参数时域方法。

时间序列作为一种主要的统计工具，被广泛应用于许多领域。在统计学、计量经济学、定量金融学、地震学、气象学和地球物理学中，时间序列分析的主要目标是预测。在信号处理、控制工程和通信工程中，它用于信号检测。在机器学习、数据挖掘和模式识别中，它用于聚类、分类、按内容查询、异常检测和预测。

任何时间序列分析的第一步都是绘制数据。可视化对于发现模式以深入了解数据集非常重要，例如识别趋势、检测异常和发现聚类。在我们建立任何模型之前，我们需要对数据有一些概念。例如，图 [15-1](#Fig1) 显示了从 2015 年 1 月到 2019 年 12 月的 SPX 每日价格图。我们可以看到，SPX 总体上涨(这正是沃伦巴菲特建议被动投资者购买 SPX 股票的原因)。此外，我们注意到一些大的下跌，其中指数可能下跌超过 40%，但最终会回升(这正是为什么沃伦巴菲特建议被动投资者持有 SPX 指数多年，忽略所有的涨跌，无论市场如何波动)。另一个发现是，SPX 有多种状态:上涨、下跌和横向。还有，小波动期之后通常是小波动期，大波动期之后是大波动期；因此，我们有波动聚类。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig1_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig1_HTML.jpg)

图 15-1

标准普尔 500 指数每日收盘价的时间序列

理解时间序列是一个随机过程是很重要的。某一时间点的观测值是随机变量在该时间点的实现。(它可以取另一个值。)一个时间序列通常表示为:

![$$ X=\left\{{X}_1,{X}_2,\dots \right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equa.png)

其中指数是自然数。

或者，我们有这样的:

![$$ X=\left\{{X}_t\ |\ t\in T\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equb.png)

其中 *T* 是索引集。

每个*X*<sub>T3t</sub>都是一个随机变量。因此，时间序列是一系列相互关联的索引随机变量。

有三大类模型表示线性时间序列，即仅线性依赖于过去值的值:自回归(ar)模型、移动平均(MA)模型和集成(I)模型。这些思想的结合产生了自回归移动平均(ARMA)和自回归综合移动平均(ARIMA)模型。在多变量时间序列模型的标题下，可以使用这些类的扩展来处理向量值数据，有时前面的缩写词会通过包含“向量”的首字母 *V* 来扩展，如 VAR 中的向量自回归。这些模型描述了一阶效应，即时间序列的平均值或水平。描述一个(非线性)时间序列的二阶效应，即波动率，有自回归条件异方差(ARCH)和广义自回归条件异方差(GARCH)等模型。

在 NM Dev 库中，有大量表示单变量和多变量时间序列的模型和预测的类。还有一个实用函数和类的集合，用于操作、转换和计算时间序列的属性。通用时间序列的接口是`TimeSeries`。签名如下:

```py
public interface TimeSeries<T extends Comparable<? super T>, V, E extends TimeSeries.Entry<T, V>> extends Iterable<E> {

    /**
     * A time series is composed of a sequence of {@code Entry}s.
     * <p/>
     * An {@code TimeSeries.Entry} is immutable.
     *
     * @param <T> the time type
     * @param <V> the value type
     */
    public static interface Entry<T, V> {
        /**
         * Get the timestamp.
         *
         * @return the timestamp
         */
        public T getTime();

        /**
         * Get the entry value.
         *
         * @return the entry value
         */
        public V getValue();
    }

    /**
     * Get the length of the time series.
     *
     * @return the time series length
     */
    public int size();
}

```

这个实现将每个数据及其时间戳表示为一对值和索引，通常称为时间。条目(对)按时间戳升序排序。这是一个泛型接口，其中泛型类型`T`可以是任何允许排序或可比较的类。例如，`T`可以是由`LocalDateTime`实现的实际时间戳。这里有一个例子:

```py
public class DateTimeGenericTimeSeries<V>
    implements TimeSeries<LocalDateTime, V, DateTimeGenericTimeSeries.Entry<V>> {...}

```

另一方面，泛型类型`V`可以表示任何值类型。当`V`为向量时，可以表示多元时间序列。在单变量时间序列的情况下，我们最常想研究的是一个实数的时间序列，用`double`来表示。接口`UnivariateTimeSeries`扩展了`TimeSeries`，实现了这样一个时序。索引是一些时间的概念，值是`double`。

```py
public interface UnivariateTimeSeries<T extends Comparable<? super T>, E extends UnivariateTimeSeries.Entry<T>> extends dev.nm.stat.timeseries.datastructure.TimeSeries<T, Double, E> {...}

```

在大多数应用程序中，索引集由自然数组成。接口`IntTimeTimeSeries`，扩展`UnivariateTimeSeries`，用整数索引，值类型为`double`。

```py
public interface IntTimeTimeSeries extends dev.nm.stat.timeseries.datastructure.univariate.UnivariateTimeSeries<Integer, IntTimeTimeSeries.Entry> {...}

```

为了简化编码和使用，NM Dev 使用实现了`IntTimeTimeSeries`的类`SimpleTimeSeries`，来表示一个由自然数索引并取实数值的时间序列。这个类还支持一些常见的操作来处理这样的时间序列。其签名如下:

```py
public class SimpleTimeSeries implements IntTimeTimeSeries {

    /**
     * Construct an instance of {@code SimpleTimeSeries}.
     *
     * @param values an array of values
     */
    public SimpleTimeSeries(double[] values);

    @Override
    public int size();

    @Override
    public Iterator<Entry> iterator();

    @Override
    public double[] toArray();

    @Override
    public double get(int t);

    /**
     * Constructs an instance of {@code SimpleTimeSeries} by dropping the
     * first {@code nItems} entries.
     *
     * @param nItems the number of leading entries to be dropped
     * @return a {@code SimpleTimeSeries}
     */
    public SimpleTimeSeries drop(int nItems);

    /**
     * Constructs an instance of {@code SimpleTimeSeries} by taking the first
     * difference {@code d} times.
     *
     * @param d the number of differences

     * @return {@code diff(x, lag = 1, differences = d)} as in DoubleUtils
     */
    public SimpleTimeSeries diff(int d);

    /**
     * Constructs an instance of {@code SimpleTimeSeries} by lagging the time
     * series. This operation makes sense only for equi-distant data points.
     *
     * @param nLags  the number of lags
     * @param length the length of the lagged time series
     * @return a lagged time series
     */
    public SimpleTimeSeries lag(int nLags, int length);

    /**
     * Constructs an instance of {@code SimpleTimeSeries} by lagging the time
     * series. This operation makes sense only for equi-distant data points.
     *
     * @param nLags the number of lags
     * @return a lagged time series
     */
    public SimpleTimeSeries lag(int nLags);

    @Override
    public String toString();
}

```

图 [15-2](#Fig2) 根据时间或索引类型和值类型绘制了表示不同单变量时间序列的类的层次结构。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig2_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig2_HTML.png)

图 15-2

表示单变量时间序列的类的层次结构

以下示例构建了一个单变量时间序列，并演示了对其进行的一些操作:

```py
// construct a time series
SimpleTimeSeries ts1 = new SimpleTimeSeries(new double[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
System.out.println("ts1:" + ts1);

// construct a time series by taking the first difference of another one
// each term is the difference between two successive terms in the original time series
SimpleTimeSeries ts2 = ts1.diff(1);
System.out.println("ts2:" + ts2);

// construct a time series by dropping the first two terms of another one
SimpleTimeSeries ts3 = ts1.drop(2);
System.out.println("ts3:" + ts3);

// construct a time series by lagging another one
// This operation makes sense only for equi-distant data points.
SimpleTimeSeries ts4 = ts1.lag(2);
System.out.println("ts4:" + ts4);

```

输出如下所示:

```py
ts1:length = 10
[1,] 1.000000, [2,] 2.000000, [3,] 3.000000, [4,] 4.000000, [5,] 5.000000, [6,] 6.000000, [7,] 7.000000, [8,] 8.000000, [9,] 9.000000, [10,] 10.000000,
ts2:length = 9
[1,] 1.000000, [2,] 1.000000, [3,] 1.000000, [4,] 1.000000, [5,] 1.000000, [6,] 1.000000, [7,] 1.000000, [8,] 1.000000, [9,] 1.000000,
ts3:length = 8
[1,] 3.000000, [2,] 4.000000, [3,] 5.000000, [4,] 6.000000, [5,] 7.000000, [6,] 8.000000, [7,] 9.000000, [8,] 10.000000,
ts4:length = 8
[1,] 1.000000, [2,] 2.000000, [3,] 3.000000, [4,] 4.000000, [5,] 5.000000, [6,] 6.000000, [7,] 7.000000, [8,] 8.000000,

```

函数`drop`的前导或删除操作将时间序列向左移动。请注意，时间序列从最早的观察值(左)到最新的观察值(右)排列。删除第一个或第一个观察值意味着删除最早的观察值。例如，对于以下:

![$$ \left\{{X}_{0,t}\right\}=\left\{1,2,3,4,5,6,7,8,9,10\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equc.png)

最早的观察值是 1，最近的是 10。我们可以预测下一个项目可能是 11。所以，领先或落后 2 个观测值给出了如下:

![$$ \left\{{X}_{1,t}\right\}=\left\{2,3,4,5,6,7,8,9\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equd.png)

![$$ \left\{{X}_{2,t}\right\}=\left\{3,4,5,6,7,8\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Eque.png)

相反，滞后操作，函数`lag`，将序列向右移动，以便最近的观察来自过去。

![$$ \left\{{X}_{0,t}\right\}=\left\{1,2,3,4,5,6,7,8,9,10\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equf.png)

滞后 1 意味着最近的观察是来自之前的一个时间单位(例如，年、月或日)。

![$$ \left\{{X}_{1,t}\right\}=\left\{ NA,1,2,3,4,5,6,7,8,9\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equg.png)T2】

滞后 2 意味着最近的观测来自两个时间单位之前。

![$$ \left\{{X}_{2,t}\right\}=\left\{ NA, NA,1,2,3,4,5,6,7,8\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equh.png)T2】

NM Dev 在数组或时间序列中不输出`NaN`。如果需要，用户可能需要进行填充。

## 15.1 单变量时间序列

单变量时间序列是一个随机的(“随机”的别称)过程，由一系列时间索引的随机变量*X*<sub>*t*</sub>= {*X*<sub>1</sub>， *X* <sub>2</sub> ，...}，其中 *X* <sub>1</sub> 表示时间 *t* = 1 的随机变量， *X* <sub>2</sub> 表示时间 *t* = 2 的随机变量，以此类推。这样一个随机过程的观测值，*X*<sub>1</sub>=*X*<sub>1</sub>，*X*<sub>2</sub>=*X*<sub>2</sub>等等，称为随机过程的一个实现。这个序列{*X*<sub>*t*</sub>} = {*X*<sub>1</sub>， *x* <sub>2</sub> ，...}也叫时间序列。从上下文可以清楚地看出，我们指的是随机过程还是该过程的特定实现。

以下 NM Dev 代码读取 SPX 数据，使用 2015 年 1 月 2 日至 2019 年 12 月 30 日指数的调整后每日收盘价创建一个单变量时间序列。调整后的收盘价与每天公布的指数收盘价并不完全相同。因为股票在过去可以分割和分配股息，我们根据证券价格研究中心(CRSP)的标准，使用适当的分割和股息乘数来调整数据。我们通常使用调整后的价格而不是原始价格来分析权益资产价格。

```py
// read the S&P 500 data from a csv file
double[][] spx_arr
        = DoubleUtils.readCSV2d(
                this.getClass().getClassLoader().getResourceAsStream("sp500_daily.csv"),
                true,
                true
        );
// convert the csv file into a matrix for manipulation
Matrix spx_M = new DenseMatrix(spx_arr);
// extract the column of adjusted close prices
Vector spx_v = spx_M.getColumn(5); // adjusted closes
// construct a univariate time series from the data
SimpleTimeSeries spx = new SimpleTimeSeries(spx_v.toArray());
System.out.println(spx);

```

(简略的)输出如下:

```py
length = 1257
[1,] 2058.199951, [2,] 2020.579956, [3,] 2002.609985, [4,] 2025.900024, [5,] 2062.139893, [6,] 2044.810059, [7,] 2028.260010, [8,] 2023.030029, [9,] 2011.270020, [10,] 1992.670044, [11,] 2019.420044, [12,] 2022.550049, [13,] 2032.119995, [14,] 2063.149902, [15,] 2051.820068, [16,] 2057.090088, [17,] 2029.550049, [18,] 2002.160034, [19,] 2021.250000, [20,] 1994.989990,
[21,] 2020.849976, [22,] 2050.030029, [23,] 2041.510010, [24,] 2062.520020, [25,] 2055.469971, [26,] 2046.739990, [27,] 2068.590088, [28,] 2068.530029, [29,] 2088.479980, [30,] 2096.989990, [31,] 2100.340088, [32,] 2099.679932, [33,] 2097.449951, [34,] 2110.300049, [35,] 2109.659912, [36,] 2115.479980, [37,] 2113.860107, [38,] 2110.739990, [39,] 2104.500000, [40,] 2117.389893,
[41,] 2107.780029, [42,] 2098.530029, [43,] 2101.040039, [44,] 2071.260010, [45,] 2079.429932, [46,] 2044.160034, [47,] 2040.239990, [48,] 2065.949951, [49,] 2053.399902, [50,] 2081.189941, [51,] 2074.280029, [52,] 2099.500000, [53,] 2089.270020, [54,] 2108.100098, [55,] 2104.419922, [56,] 2091.500000, [57,] 2061.050049, [58,] 2056.149902, [59,] 2061.020020, [60,] 2086.239990,

```

同样，任何数据分析的第一步都是可视化，也就是说，在我们的例子中，(在数据收集、数据清理等之后)绘制数据。).我们再次将 SPX 数据绘制在图 [15-3](#Fig3) 中。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig3_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig3_HTML.jpg)

图 15-3

标准普尔 500 指数每日收盘价格的时间序列

在不同的时间，SPX(或股票)的(每日)价格具有不同的统计属性。例如，在 2015 年，价格的水平/平均值在 2000 左右(然而每天仍然不同)；2019 年的价格从 2500 英镑到 3000 英镑不等。我们不能处理价格数据，因为统计分析通常处理静态数据，这意味着数据共享相同的概率分布、相同的均值、相同的方差等。

解决这个问题的一个方法是将价格 *P* <sub>*t*</sub> 转换成简单的回报 *R* <sub>*t*</sub> 。这种标准化以一种可比较的度量标准，即百分比来衡量所有股票。这允许评估两个或更多股票之间的关系，例如协方差矩阵，尽管它们的价格可能具有不同的幅度。(截至今日，SPX 为 4370.04 美元，GOOG 为 2619.38 美元，AAPL 为 145.62 美元，SRNE 为 8.25 美元。)

![$$ {R}_t=\frac{P_t-{P}_{t-1}}{P_{t-1}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equi.png)

继续上一个示例，下面的代码计算价格的简单回报:

```py
double[] diff = spx.diff(1).toArray();
double[] p0 = spx.lag(1).toArray();
double[] simple_returns = new double[diff.length];
for (int i = 0; i < diff.length; ++i) {
    simple_returns[i] = diff[i] / p0[i];
}
System.out.println(Arrays.toString(simple_returns));

```

(简略的)输出如下:

```py
[-0.01827810508970322, -0.008893471870112912, 0.011629842642575248, 0.01788828104579755, -0.008403811040573337, -0.008093685243358803, -0.002578555497921567, -0.005813066949783809, -0.00924787612555373, 0.013424199395451945, 0.0015499524278268393, 0.0047316238254433785, 0.015269721805970466, -0.0054915224477955155, 0.002568461085935695, -0.013387862379316457, -0.013495609538427277, 0.009534685377702431, -0.01299196536796535, 0.012962464037225537, 0.014439494938539686, -0.004156045950290833, 0.010291406800400634, -0.003418172396697485, -0.0042471946188310196, 0.010675561188404731, -2.903378506370865E-5, 0.009644506350069552, 0.004074738604868008, 0.001597574626476824, -3.14309098689124E-4,

```

在量化金融中，我们经常使用对数收益率 *r* <sub>*t*</sub> ，而不是简单收益率，原因有很多。

![$$ {r}_t=\ln \left(\frac{P_t}{P_{t-1}}\right)=\ln \left({P}_t\right)-\ln \left({P}_{t-1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equj.png)

首先，我们通常假设价格是对数正态分布，而不是正态分布。对数正态分布总是正的，但是正态分布可能给出负的价格。然后，对数收益方便地正态分布，因为许多经典统计假设正态。价格、简单回报和对数回报之间的关系如下:

![$$ 1+{R}_t=\frac{P_t}{P_{t-1}}=\exp \left({r}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equk.png)

第二，当回报很小时(常见于短期价格变化，但不像高频交易那样太短)，简单回报和对数回报彼此接近。

![$$ {r}_t=\log \exp \left({r}_t\right)=\log \left(1+{R}_t\right)\approx {R}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equl.png)T2】

第三，简单回报不是时间累加的，但对数回报是时间累加的。具体来说，简单回报序列的复利回报如下:

![$$ \frac{P_t}{P_0}=\frac{P_t}{P_{t-1}}\frac{P_{t-1}}{P_{t-2}}\times \dots \times \frac{P_1}{P_0}=\left(1+{R}_1\right)\left(1+{R}_2\right)\cdots \left(1+{R}_n\right)=\prod \limits_{i=1}^n\left(1+{R}_i\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equm.png)

该复利是(独立)正态变量的乘积，并且不是正态分布的。

相反，复利回报的对数是一系列对数回报的总和。

![$$ \ln \left(\frac{P_t}{P_0}\right)=\ln \left({P}_t\right)-\ln \left({P}_0\right)=\ln \left({P}_t\right)-\ln \left({P}_{t-1}\right)+\ln \left({P}_{t-1}\right)-\ln \left({P}_{t-2}\right)+\ln \left({P}_{t-2}\right)+\dots -\ln \left({P}_0\right)=\ln \left(\frac{P_t}{P_{t-1}}\right)+\ln \left(\frac{P_{t-1}}{P_{t-2}}\right)+\dots +\ln \left(\frac{P_1}{P_0}\right)={r}_t+{r}_{t-1}+\dots +{r}_1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equn.png)T2】

复合回报的对数正态分布为(独立)正态变量之和正态分布。即使对数回报不是正态的，由于中心极限定理，当 *t* 足够大时，它们的总和(和平均值)大约是。

第四，许多金融数学是建立在连续时间随机过程的基础上的，这种过程严重依赖于积分和微分。对数收益的指数，即价格，在微积分中很容易处理。

![$$ {e}^x=\int {e}^x dx=\frac{d{e}^x}{dx}={e}^x $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equo.png)T2】

第五，小数字相加在数值上更稳定，但是小数字相乘却不稳定，因为它会受到算术下溢的影响。这可能是一个严重的问题，尤其是对于长时间的计算。为了解决这个问题，要么需要修改算法，使其在数值上具有鲁棒性，要么可以通过对数将其转换为数值上安全的求和。

继续上一个示例，下面的代码根据价格计算对数收益:

```py
// compute log returns from prices
double[] p1 = spx.drop(1).toArray();
double[] p = spx.toArray();
double[] log_return = new double[p1.length];
for (int i = 0; i < p0.length; i++) {
    log_return[i] = log(p1[i]) - log(p[i]);
}
System.out.println(Arrays.toString(log_return));

```

(简略的)输出如下:

```py
[-0.01844721347614442, -0.008933254839187832, 0.011562735816044167, 0.017730168536121305, -0.00843932215298615, -0.00812661692658967, -0.002581885698118569, -0.0058300285881660585, -0.009290903210184887, 0.013334893185903418, 0.0015487524912991546, 0.004720464879542696, 0.015154312961683125, -0.005506656287836975, 0.002565168226942305, -0.01347828778434046, -0.013587502985455302, 0.009489517148010052, -0.01307709912379984, 0.012879170322592337, 0.014336238227742548, -0.004164706312833388, 0.010238810823374855, -0.0034240276947166137, -0.004256239569425446, 0.010618979721447985, -2.9034206551870057E-5, 0.009598294984989764, 0.004066459340458017, 0.00159629986164056, -3.1435850414673894E-4,

```

图 [15-4](#Fig4) 绘制了该输出，即 SPX 测井返回的时间序列。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig4_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig4_HTML.jpg)

图 15-4

标准普尔 500 指数对数收益的时间序列

### 平稳性

平稳时间序列的统计特性不依赖于序列被观察的时间。因此，具有趋势性或季节性的时间序列不是静态的。趋势和季节性会影响时间序列在不同时间的值，如水平/平均值。另一方面，白噪声序列是稳定的。每个点看起来都非常像是从同一(正态)分布中抽取出来的。比较图 [15-3](#Fig3) 和图 [15-4](#Fig4) ，我们可以很容易地看到，SPX 价格并不是稳定的，它随着时间的推移而上升；对数回波(或简称为回波)是稳定的，因为它们只是像白噪声一样在 0 附近振荡。预测未来的回报率(可能在 0 左右)比猜测 SPX 的未来要容易得多(华尔街最聪明的人都尝试过，但很多人都失败了！).我们可以对平稳时间序列进行预测，因为它们的统计特性不会随时间而改变，但对非平稳时间序列则不会。此外，样本统计，如均值、方差和与其他变量的相关性，只有当数据是稳定的时才有意义。一阶差分法是一种将非平稳时间序列转化为平稳时间序列的常用技术，它取连续观测值之间的差值或连续对数观测值之间的差值。如果一次不够，我们可以做两次，这意味着二阶差分。在实践中，几乎没有必要超越二阶差分。

数学上，一个时间序列{*X*<sub>T3】t</sub>}是一阶强平稳的如果所有随机变量 *X* <sub>*t*</sub> 对于所有的 *t* = 1，...， *T* 具有相同的概率密度函数。一个时间序列{*X*<sub>*t*</sub>}是一阶弱平稳的如果所有的随机变量 *X* <sub>*t*</sub> 对于所有的 *t* = 1，...， *T* 具有相同的有限均值。如果所有的随机变量 *X* <sub>*t*</sub> 对于所有的 *t* = 1，...， *T* 具有相同的有限均值和有限方差，并且协方差不依赖于 *t* ，仅依赖于变量之间的滞后次数。一个(二阶)弱平稳过程{*X*<sub>*t*</sub>}满足以下条件:

*   e(*x**=*<**

***   e(| > t0]x*|<sup><sub>=*<<*</sub></sup>*

    ***   cov(*X*<sub>T3】tT5、*X*<sub>*s*)=*f*(|*t*—*s*|)并且独立于 *t* 和 *s*</sub></sub>**** 

 **### 自动变异

第三个条件定义了一个称为自协方差函数的函数。数学上，给定一个时间序列{ *X* <sub>*t*</sub> }和自协方差函数(ACVF)，cov(*X*<sub>*t*</sub>， *X* <sub>*s*</sub> )给出该过程在成对时间点( *t* ， *s* )与其自身的协方差。对于平稳过程，该函数仅取决于 *t* 和 *s* 之间的距离或滞后*k*=∣*t*—*s*∣，而不取决于 *t* 和 *s* 本身。即对于所有的 *k* = 0，1，2，...:

![$$ \gamma (k)=\operatorname{cov}\left({X}_t,{X}_{t+k}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equp.png)

注意，由于自协方差函数的对称性(因为只有距离重要，而不是指数)，我们有

![$$ \gamma (k)=\operatorname{cov}\left({X}_t,{X}_{t+k}\right)=\operatorname{cov}\left({X}_{t-k},{X}_t\right)=\operatorname{cov}\left({X}_t,{X}_{t-k}\right)=\gamma \left(-k\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equq.png)

具体来说，我们有这样的:

![$$ \gamma (0)=\operatorname{cov}\left({X}_t,{X}_t\right)=\operatorname{var}\left({X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equr.png)

对于 *k* = 0，1，2， *k* 阶的样本自相关系数(ACVF)...

![$$ \hat{\gamma}(k)={\sum}_{t=1}^{n-k}\left({X}_t-\overline{X}\right)\left({X}_{t+k}-\overline{X}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equs.png)定义如下

其中![$$ \overline{X}={\sum}_{t=1}^n{X}_t/n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq1.png)是时间序列的样本均值。

在 NM Dev 中，类`SampleAutoCovariance`计算每个滞后的样本 ACVF。例如，以下代码计算从 1981 年 1 月到 2019 年 12 月每月 S & P 500 调整收盘的前 25 个滞后的![$$ \hat{\gamma}(k) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq2.png):

```py
// read the monthly S&P 500 data from a csv file
double[][] spx_arr
        = DoubleUtils.readCSV2d(
                this.getClass().getClassLoader().getResourceAsStream("sp500_monthly.csv"),
                true,
                true
        );
// convert the csv file into a matrix for manipulation
Matrix spx_M = new DenseMatrix(spx_arr);
// extract the column of adjusted close prices
Vector spx_v = spx_M.getColumn(5); // adjusted closes
// construct a univariate time series from the data
SimpleTimeSeries spx = new SimpleTimeSeries(spx_v.toArray());
//        System.out.println(spx);

// ACVF for lags 0, 1, 2, ..., 24
SampleAutoCovariance acvf = new SampleAutoCovariance(spx);
for (int i = 0; i < 25; i++) {
    System.out.printf("acvf(%d) = %f%n", i, acvf.evaluate(i));
}

```

输出如下所示:

```py
acvf(0) = 551182.987070
acvf(1) = 543953.818490
acvf(2) = 537216.947501
acvf(3) = 530958.035823
acvf(4) = 524883.334938
acvf(5) = 519097.358346
acvf(6) = 512715.454348
acvf(7) = 506618.687345
acvf(8) = 501222.083894
acvf(9) = 494564.151860
acvf(10) = 488414.476447
acvf(11) = 482362.807657
acvf(12) = 476667.617979
acvf(13) = 471903.185864
acvf(14) = 465878.602696
acvf(15) = 460072.984734
acvf(16) = 453220.603768
acvf(17) = 446307.958179
acvf(18) = 439721.402860
acvf(19) = 433499.577238
acvf(20) = 427157.843522
acvf(21) = 421179.456775
acvf(22) = 415192.648687
acvf(23) = 409011.565601
acvf(24) = 402280.844734

```

### 自相关

归一化 ACVF 的阶为 *k* 的自相关函数(ACF)定义如下:

![$$ \rho (k)=\frac{\gamma (k)}{\gamma (0)}=\frac{\operatorname{cov}\left({X}_t,{X}_{t+k}\right)}{\sqrt{\operatorname{var}\left({X}_t\right)}\sqrt{\operatorname{var}\left({X}_{t+k}\right)}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equt.png)

注意以下:

![$$ \rho (0)=\frac{\gamma (0)}{\gamma (0)}=1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equu.png)

ACF 具有对称性*ρ*(*k*)=*ρ*(*k*)。

对于 *k* = 0，1，2， *k* 阶的样本自相关系数(ACF)...

![$$ \hat{\rho}(k)=\frac{\sum_{t=1}^{n-k}\left({X}_t-\overline{X}\right)\left({X}_{t+k}-\overline{X}\right)}{\sum_{t=1}^n{\left({X}_t-\overline{X}\right)}^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equv.png)定义如下

其中![$$ \overline{X}={\sum}_{t=1}^n{X}_t/n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq3.png)是时间序列的样本均值。

当时间序列有趋势时，小滞后的 ACF 趋于大而正；连续项的相关性更强。当时间序列具有季节性时，ACF 在季节滞后或季节频率的倍数时会更大；四季的术语更加相关。当时间序列具有这两种属性时，ACF 将显示这些特征的组合。

在 NM Dev 中，类`SampleAutoCorrelation`计算每个滞后的样本 ACF。继续前面的例子，下面的代码计算从 1981 年 1 月到 2019 年 12 月每月 S & P 500 调整收盘的前 25 个滞后的![$$ {\hat{p}}_k $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq4.png):

```py
// ACF for lags 0, 1, 2, ..., 24
SampleAutoCorrelation acf = new SampleAutoCorrelation(spx);
for (int i = 0; i < 25; i++) {
    System.out.printf("acf(%d) = %f%n", i, acf.evaluate(i));
}

```

输出如下所示:

```py
acvf(0) = 1.000000
acvf(1) = 0.986884
acvf(2) = 0.974662
acvf(3) = 0.963306
acvf(4) = 0.952285
acvf(5) = 0.941788
acvf(6) = 0.930209
acvf(7) = 0.919148
acvf(8) = 0.909357
acvf(9) = 0.897278
acvf(10) = 0.886120
acvf(11) = 0.875141
acvf(12) = 0.864808
acvf(13) = 0.856164
acvf(14) = 0.845234
acvf(15) = 0.834701
acvf(16) = 0.822269
acvf(17) = 0.809727
acvf(18) = 0.797778
acvf(19) = 0.786489
acvf(20) = 0.774984
acvf(21) = 0.764137
acvf(22) = 0.753276
acvf(23) = 0.742061
acvf(24) = 0.729850

```

图 [15-5](#Fig5) 描绘了结果。我们可以看到，在滞后 22 天之后，每月 S & P 500 的样本 ACF 从正下降到负。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig5_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig5_HTML.jpg)

图 15-5

每月标准普尔 500 回报的 ACF

### 部分自相关

偏自相关系数(pacf)*<sub>*k*</sub>衡量两个变量*x*<sub>*t*—*k*</sub>和 *X* <sub>*t*</sub> 之间的相关性，并去除它们之间所有中间变量的影响。是*X*<sub>*t*—*k*</sub>与 *X* <sub>*t*</sub> 之间的自相关，不计入滞后*t*—*k*+1 至*t*—1，共包含*k*—1 项。数学上，我们有这样的:*

*![$$ {\phi}_k=\frac{\operatorname{cov}\left({X}_t,{X}_{t+k}\ |\ {X}_{t+1},{X}_{t+2},\dots, {X}_{t+k-1}\right)}{\sqrt{\operatorname{var}\left({X}_t\kern0.5em |\ {X}_{t+1},{X}_{t+2},\dots, {X}_{t+k-1}\right)}\sqrt{\operatorname{var}\left({X}_{t+k}\kern0.5em |\ {X}_{t+1},{X}_{t+2},\dots, {X}_{t+k-1}\right)}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equw.png)*

 *对于均值为零的平稳时间序列，我们运行两个回归来消除中间变量的线性相关性。(没有截取是因为*X*<sub>T3】tT5】的均值为零。)</sub>

![$$ {\hat{X}}_{t+k}={\beta}_{11}{X}_{t+k-1}+{\beta}_{12}{X}_{t+k-2}+\dots +{\beta}_{1,k+1}{X}_{t+1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equx.png)

![$$ {\hat{X}}_t={\beta}_{21}{X}_{t+1}+{\beta}_{22}{X}_{t+2}+\dots +{\beta}_{2,k-1}{X}_{t+k-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equy.png)T11】

于是，我们有了这个:

![$$ {\phi}_1= cor\left({X}_{t+1},{X}_t\right)={\rho}_1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equz.png)

*、*【k】*≥2*

可以根据样本 ACF ![$$ \hat{\rho}(k) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq6.png) :

![$$ {\hat{\phi}}_k={\hat{\phi}}_{k+1,k+1}=\frac{\hat{\rho}\left(k+1\right)-{\sum}_{j=1}^k{\hat{\phi}}_{kj}\hat{\rho}\left(k+1-j\right)}{1-{\sum}_{j=1}^k{\hat{\phi}}_{kj}\hat{\rho}(j)} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equaa.png)

递归计算样本 PACF

还有

![$$ {\hat{\phi}}_{k+1,j}={\hat{\phi}}_{k,j}+{\hat{\phi}}_{k+1,k+1}{\hat{\phi}}_{k,k+1-j} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equab.png)

![$$ {\hat{\phi}}_1={\hat{\phi}}_{1,1}=\hat{\rho}(1) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equac.png)

对于 *j* = 1，...， *k* 。

在 NM Dev 中，类`SamplePartialAutoCorrelation`计算每个滞后的样本 PACF。继续前面的例子，下面的代码计算前 24 个滞后的![$$ {\hat{\phi}}_k $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq7.png)，从 1 而不是 0 开始，计算从 1981 年 1 月到 2019 年 12 月的每月 S & P 500 调整收盘:

```py
// PACF for lags 1, 2, ..., 24
SamplePartialAutoCorrelation pacf = new SamplePartialAutoCorrelation(spx);
for (int i = 1; i < 25; i++) {
    System.out.printf("pacf(%d) = %f%n", i, pacf.evaluate(i));
}

```

输出如下所示:

```py
pacf(1) = 0.986884
pacf(2) = 0.027673
pacf(3) = 0.028265
pacf(4) = 0.009367
pacf(5) = 0.016586
pacf(6) = -0.044565
pacf(7) = 0.012763
pacf(8) = 0.042335
pacf(9) = -0.089551
pacf(10) = 0.025976
pacf(11) = 0.001272
pacf(12) = 0.019560
pacf(13) = 0.056418
pacf(14) = -0.078582
pacf(15) = 0.006884
pacf(16) = -0.089247
pacf(17) = -0.005869
pacf(18) = 0.000041
pacf(19) = 0.028124
pacf(20) = -0.015747
pacf(21) = 0.010677
pacf(22) = 0.012282
pacf(23) = -0.032621
pacf(24) = -0.031604

```

图 [15-6](#Fig6) 绘制了输出。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig6_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig6_HTML.jpg)

图 15-6

每月标准普尔 500 回报的 PACF

### 15.1.5 白噪声过程和随机游走

有一个特殊的时间序列叫做白噪声。设{ *ε* <sub>*t*</sub> }为白噪声过程，则 *ε* <sub>*t*</sub> 满足如下:

*   e(**=*<∞t8】***

****   var(*=*<sup><sub><∞T10】</sub></sup>**

    ***   cov(*，**)= 0， *t********* 

 *白噪声过程的 ACF 和 PACF 对于所有滞后都是零，因为对于所有 *k* = 1，2，...根据它的定义。

随机漫步是一个随机过程，是随机步骤的总和。一个*ε*<sub>T3】t</sub>![$$ {W}_t=\sum \limits_{i=1}^t{\varepsilon}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq9.png)的总和，就是一个随机游走。每个下一个值 *W* <sub>* t * + 1</sub> 与前一个值相差一个随机步长。当 E(*ε*<sub>*t*</sub>)= 0， *W* <sub>* t *</sub> 称为无漂移随机游走模型。在华尔街随机漫步表明，市场是随机漫步。这与有效市场假说相一致，即过去的信息无助于预测未来。我个人(也纯粹是我自己)的看法是，技术分析就像占星术一样虚幻。背后没有科学或证明或数学。相比之下，量化交易是建立在坚实的数学和证明基础上的。量化交易对于技术分析就像天文学对于占星术一样。幸运的是，占星术有时可能是正确的，因为一个坏的时钟一天也是正确的两次。

例如，如果我们模拟一个随机游走过程(比如对 100 个标准正态变量求和)，我们会发现它们中的许多会有显著的趋势，如图 [15-7](#Fig7) 所示。事实上，同一个模型通常会在重复迭代中产生向上和向下的趋势，以及看起来有趣的曲线，这些曲线似乎需要某种复杂的模型。这只是一个统计上的错觉。我们的大脑努力寻找模式，即使它们并不存在。图 [15-7](#Fig7) 由于强劲的上升趋势，看起来是一只值得购买的好股票。然而，这个时间序列纯粹是一个无漂移的随机游走模型，它是通过将 100 个标准正态变量相加而生成的，均值为 0，方差为 1。从长远来看，购买这种股票可能不会有任何收益。试图预测其未来价格，比如使用技术分析，是骗人的。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig7_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig7_HTML.jpg)

图 15-7

标准正态变量和的随机游动

### 15.1.6 白噪声的容格盒试验

检验一个时间序列是否是随机游走的一种方法(有很多方法，我们将在本章看到)是检验它的第一个差异是否是白噪声。白噪声的理论 ACF 为 0。然而，我们从数据中计算出的样本 ACF 值很小，但不可能精确到 0。问题是这些值应该有多小才能被认为是数值上的 0，这样我们就可以很有把握地(但不是绝对肯定地)断定这个过程是白噪声。

容格检验是对时间序列或残差序列零自相关的假设检验。它测试时间序列中任意数量滞后的自相关是否不为零。样本 ACF ![$$ \hat{\rho} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq10.png)值是针对我们想要测试的许多滞后计算的。无效假设是第一个 *m 个*自相关共同为零。

![$$ {H}_0:\hat{\rho}(1)=\hat{\rho}(2)=\dots =\hat{\rho}(m)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equad.png)

拒绝零意味着直到阶 *m* 存在一些不同于零的自相关。

永盒检验统计量如下:

![$$ Q(m)=n\left(n+2\right)\sum \limits_{k=1}^m\frac{\hat{\rho}{(k)}^2}{n-k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equae.png)

其中 *n* 是样本大小。

在零假设下，该统计遵循自由度为 *m* 、![$$ {\upchi}_m^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq11.png)的卡方分布。如果这个检验统计量大于临界值(小于阈值的 p 值)，我们拒绝零，并得出结论，这个时间序列不是白噪声过程。否则，我们接受零(或者从技术上说，拒绝零失败)，并得出结论，这个时间序列是一个白噪声过程。

我们可以用容格检验来检验标准普尔 500 的日收益是否是白噪声。首先，我们绘制 ACF 来检查有多少滞后是不重要的。图 [15-8](#Fig8) 显示前 14 个滞后可能是不重要的(![$$ \hat{\rho}(1)=1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq12.png)总是)。因此，我们检验这个零假设如下:

![$$ {H}_0:\hat{\rho}(1)=\hat{\rho}(2)=\dots =\hat{\rho}(14)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equaf.png)

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig8_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig8_HTML.jpg)

图 15-8

每日标准普尔 500 回报的 ACF

拒绝零意味着直到第 14 个滞后有一些不为零的自相关。这里的自由度 *m* = 14。NM Dev 类`LjungBox`实现了 Ljung-Box 测试。下面的代码解决了这个示例:

```py
// run the Ljung-Box test
LjungBox lb_test = new LjungBox(log_returns, 14, 0);
System.out.printf("The null hypothesis is: %s%n", lb_test.getNullHypothesis());
System.out.printf("The alternative hypothesis is: %s%n", lb_test.getAlternativeHypothesis());
System.out.printf("The test statistic = %f%n", lb_test.statistics());
System.out.printf("The p-value = %f%n", lb_test.pValue());

```

输出如下所示:

```py
The null hypothesis is: none of the autocorrelation coefficients up to lag 14 are different from zero; the data is random
The alternative hypothesis is: at least one value of autocorrelation coefficient is statistically different from zero at the specified significance level; the data is not random
The test statistic = 20.203475
The p-value = 0.123856

```

测试统计值是 20.20。p 值为 0.124，大于 5%的显著性水平。因此，我们不能拒绝零，即在滞后 14 之前没有一个自相关系数不同于零。我们的结论是，回报是白噪声。

### 模型分解

白噪声过程在时间序列分析中是重要的。它是任何时间序列的基本组成部分。Wold 分解定理说，对于任意协方差平稳随机过程{ *X* <sub>*t*</sub> }，可以写成一个确定性时间序列和一个随机时间序列之和。数学上，如果{ *X* <sub>*t*</sub> }是一个协方差平稳过程，而{*ε*<sub>*t*</sub>}是一个白噪声零均值过程，那么存在一个唯一的线性表示，如下:

![$$ {X}_t=\mu +{V}_t+{\varepsilon}_t+{\psi}_1{\varepsilon}_{t-1}+{\psi}_2{\varepsilon}_{t-2}+\dots =\mu +{V}_t+\sum \limits_{j=0}^{\infty }{\psi}_j{\varepsilon}_{t-j} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equag.png)

其中 *V* <sub>*t*</sub> 为确定性分量，![$$ \sum \limits_{j=0}^{\infty }{\psi}_j{\varepsilon}_{t-j} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq13.png)为随机分量 *ψ* <sub> 0 </sub> = 1，![$$ \sum \limits_{j=0}^{\infty }{\psi}_j^2&lt;\infty $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq14.png)。从![$$ \sum \limits_{j=0}^{\infty }{\psi}_j^2&lt;\infty $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq15.png)开始，应该有一个时间 *j* 这样 *ψ* <sub>* i *</sub> 对于 *i* = * j * + 1， *j* + 2，...会越来越小。

如果没有确定性成分，那么{*X*<sub>T3】t</sub>}就是一个漂移 *μ* 的随机游走。

![$$ {X}_t=\mu +\sum \limits_{j=0}^{\infty }{\psi}_j{\varepsilon}_{t-j} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equah.png)

还有

![$$ \mathrm{E}\left({X}_t\right)=\mu $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equai.png)

![$$ \operatorname{var}\left({X}_t\right)={\sigma}^2\sum \limits_{j=0}^{\infty }{\psi}_j^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equaj.png)

![$$ \gamma (k)=\operatorname{cov}\left({X}_t,{X}_{t+k}\right)={\sigma}^2\sum \limits_{j=0}^{\infty }{\psi}_j{\psi}_{j+k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equak.png)

![$$ \rho (k)=\frac{\gamma (k)}{\gamma (0)}=\frac{\sigma^2\sum \limits_{j=0}^{\infty }{\psi}_j{\psi}_{j+k}}{\sigma^2\sum \limits_{j=0}^{\infty }{\psi}_j^2}=\frac{\sum \limits_{j=0}^{\infty }{\psi}_j{\psi}_{j+k}}{1+\sum \limits_{j=1}^{\infty }{\psi}_j^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equal.png)

其中 *μ* 为常数，*ε*<sub>T5】t</sub>为白噪声。

决定性成分可以是趋势或季节成分，或者两者都是。一般来说，时间序列可以分解成以下三个部分:

*   趋势分量

*   季节性成分

*   不规则随机分量

当数据长期增加或减少时，趋势成分存在。例如，标准普尔 500 随时间而增加。当数据表现出季节(如月份或季度)模式时，就存在季节性因素。例如，去迪斯尼乐园的游客数量随着季节而变化(夏天人多，冬天人少)。不规则随机分量，也称为随机分量或白噪声，由随时间的新息组成。这是时间序列不确定性的来源。例如，标准普尔 500 的回归是一个不规则的过程。

这种分解被称为经典分解模型。分解有两种形式:加法和乘法。他们将趋势分量 *T* <sub>*t*</sub> ，季节分量 *S* <sub>*t*</sub> ，随机分量 *ε* <sub>*t*</sub> 结合起来构建时间序列模型。

加法模型把这些成分加起来:

![$$ {X}_t={T}_t+{S}_t+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equam.png)

在 NM Dev 中，类`AdditiveModel`构建了这样一个加法模型。趋势、季节性和随机成分以数组形式给出。这里有一个例子:

```py
RandomNumberGenerator rng = new StandardNormalRNG();

// construct an additive model
AdditiveModel additive_model = new AdditiveModel(
        // the trend
        new double[]{
            1, 3, 5, 7, 9, 11, 13, 15, 17, 19
        },
        // the seasonal component
        new double[]{
            0, 1
        },
        // the source of randomness
        rng
);
System.out.println(additive_model);

```

输出如下所示:

```py
length = 10
[1,] 0.657586, [2,] 3.794529, [3,] 5.718166, [4,] 6.634372, [5,] 9.802750, [6,] 10.789668, [7,] 12.700581, [8,] 16.614644, [9,] 15.694052, [10,] 20.973963,

```

请注意，季节性组件数组的长度只有 2，而不是 10。这是因为数组中的元素被重复使用来表示一个循环的季节模式。

乘法模型将这些分量相乘:

![$$ {X}_t={T}_t\times {S}_t\times {\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equan.png)

在 NM Dev 中，类`MultiplicativeModel`构建了这样一个乘法模型。趋势、季节性和随机成分以数组形式给出。这里有一个例子:

```py
RandomNumberGenerator rng = new StandardNormalRNG();

// construct a multiplicative model
MultiplicativeModel multiplicative_model = new MultiplicativeModel(
        // the trend
        new double[]{
            1, 3, 5, 7, 9, 11, 13, 15, 17, 19
        },
        // the seasonal component
        new double[]{
            -1, 1
        },
        // the source of randomness
        rng
);
System.out.println(multiplicative_model);

```

输出如下所示:

```py
length = 10
[1,] 0.035056, [2,] 4.531332, [3,] -5.732130, [4,] -1.103154, [5,] 0.125291, [6,] 4.601235, [7,] -35.735400, [8,] -8.219343, [9,] -14.441234, [10,] -11.707299,

```

另一方面，NM Dev 类`MADecomposition`使用带有对称窗口的移动平均估计方法将时间序列分解为趋势、季节和随机分量。该类首先使用移动平均(使用具有相等权重的对称窗口)来确定趋势分量，并将其从时间序列中移除。然后，通过对所有时间段的每个时间单位进行平均来计算季节性数字。季节性数字然后居中。最后，通过从原始时间序列中去除趋势和季节数字(根据需要回收)来确定误差成分。它建立的时间序列模型如下:

![$$ {X}_t={T}_t\times {S}_t\times {\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equao.png)

这样我们就有了这个:

*   e(*)= 0*

**   var(*=*<sup>2</sup>**

    ***   cov(*，**)= 0***

    ****   *S*<sub>T3】t+*d*T7】=*S*<sub>*t*</sub>；d 是一个季节的长度</sub>****** 

 **下面的代码将标准普尔 500 的月收益分解为三个部分。我们将季节性长度设置为 12。

```py
// decompose the S&P 500 monthly returns into a classical additive model
MADecomposition spx_model
        = new MADecomposition(
                spx.toArray(), // the SP 500 monthly returns
                12 // the lenght of seasonality
        );
System.out.printf("the trend component: %s%n", Arrays.toString(spx_model.getTrend()));
System.out.printf("the seasonal component: %s%n", Arrays.toString(spx_model.getSeasonal()));
System.out.printf("the random component: %s%n", Arrays.toString(spx_model.getRandom()));

```

(简略的)输出如下:

![../images/500382_1_En_15_Chapter/500382_1_En_15_Figa_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Figa_HTML.jpg)

图 [15-9](#Fig9) 绘制了三分量时间序列。它证实了我们的期望。趋势时间序列呈上升趋势。季节性时间序列呈现周期性模式。随机时间序列是一个白噪声过程。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig9_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig9_HTML.jpg)

图 15-9

用加法模型分解标准普尔 500 月收益

## 15.2 时间序列模型

一般来说，我们可以使用时间函数或平滑方法(如移动平均)来模拟趋势分量。我们可以使用虚拟变量的函数来模拟季节性因素。去除趋势和季节成分后，我们剩下的是随机残差。这里，我们总结了时间序列建模的一般步骤:

1.  绘制时间序列以检查非平稳行为，如趋势和季节性成分。

2.  去除不稳定的成分，例如减去趋势和季节性，取第一个差值，等等。，以获得随机残差的平稳时间序列。

3.  选择合适的时间序列模型来拟合残差。

4.  检查模型的拟合优度。

5.  反转步骤 2 中的操作，例如加回趋势和季节分量，对残差进行积分等。，为原始时间序列建立模型。

有许多重要的时间序列模型来模拟随机残差。它们是本节的主题。

### 15.2.1 AR 型号

给定一个时间序列*X*<sub>T3】tT5】，滞后运算符或后移运算符 *B* 是这样的，它将时间序列向右移动。数学上，我们有</sub>

![$$ B{X}_t={X}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equap.png)

![$$ {B}^k{X}_t={X}_{t-k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equaq.png)

![$$ Bc=c $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equar.png)

其中 *k* 是代表滞后数量的正整数， *c* 是常数。

例如，假设我们有这样的:

![$$ \left\{{X}_t\right\}=\left\{1,2,3,4,5,6,7,8,9,10\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equas.png)

于是，我们有了这个:

![$$ B{X}_t=\left\{1,2,3,4,5,6,7,8,9\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equat.png)

![$$ {B}^2{X}_t=\left\{1,2,3,4,5,6,7,8\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equau.png)

NM Dev 函数`lag`实现了 backshift 运算符。

我们可以根据后移算子写出应用于 *X* <sub>*t*</sub> 的第一差分算子∏。

![$$ \Delta {X}_t={X}_t-{X}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equav.png)

![$$ ={X}_t-B{X}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equaw.png)T11】

backshift 运算符在时序模型中普遍使用，因为许多时序模型依赖于过去的值。

#### 15.2.1.1 AR(1)

自回归(AR)模型规定输出变量线性依赖于其先前值(或滞后值)和随机项。最简单的 AR 模型是 AR(1)，一个阶为 1 的自回归模型。它的输出取决于一个常数(电平)、最后一个值和一个白噪声。具体来说，我们有这样的:

![$$ {X}_t={\phi}_0+{\phi}_1{X}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equax.png)

其中 *ϕ* <sub>0</sub> 为常数， *ϕ* <sub>1</sub> 为自回归系数， *ε* <sub>*t*</sub> 为随机或随机或误差项。这是带有以下内容的白噪声:

*   零均值，E[*ε*<sub>T3】t</sub>]= 0

*   恒定方差<sup><sup>、var[**= e[**</sup></sup>

***   独立分布，E[*ε*<sub>*t*</sub>*ε*<sub>*t*—1</sub>= 0** 

 **AR(1)被称为一阶，因为它只有一个过去的值作为因变量。

就后移算子而言，我们有这样的:

![$$ {X}_t={\phi}_0+B{X}_t+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equay.png)

重新排列术语并使用多项式表示法，我们有了这个:

![$$ \left(1-B\right){X}_t={\phi}_0+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equaz.png)

![$$ {X}_t=\frac{1}{\left(1-B\right)}\left({\phi}_0+{\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equba.png)

条件期望和条件方差如下:

![$$ \mathrm{E}\left({X}_t\ |\ {X}_{t-1}\right)={\phi}_0+{\phi}_1{X}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbb.png)

![$$ \operatorname{var}\left({X}_t\ |\ {X}_{t-1}\right)=\operatorname{var}\left({\varepsilon}_t\right)={\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbc.png)

如果{ *X* <sub>*t*</sub> }是一个平稳过程(即 *X* <sub>*t*</sub> 有一个不变的均值和方差)，那么无条件期望如下:

![$$ \mathrm{E}\left({X}_t\right)=\mathrm{E}\left({\phi}_0+{\phi}_1{X}_{t-1}+{\varepsilon}_t\right)={\phi}_0+{\phi}_1\mathrm{E}\left({X}_{t-1}\right)+\mathrm{E}\left({\varepsilon}_t\right)={\phi}_0+{\phi}_1\mathrm{E}\left({X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbd.png)

![$$ \left(1+{\phi}_1\right)\mathrm{E}\left({X}_t\right)={\phi}_0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Eqube.png)

![$$ \mathrm{E}\left({X}_t\right)=\frac{\phi_0}{\left(1+{\phi}_1\right)} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbf.png)

无条件方差如下(注意*X*<sub>T3】t1</sub>和 *ε* <sub>*t*</sub> 是独立的，所以它们的协方差为 0):

![$$ \operatorname{var}\left({X}_t\right)=\operatorname{var}\left({\phi}_0+{\phi}_1{X}_{t-1}+{\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbg.png)

![$$ =\operatorname{var}\left({\phi}_1{X}_{t-1}\right)+\operatorname{var}\left({\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbh.png)

![$$ ={\phi}_1^2\operatorname{var}\left({X}_{t-1}\right)+\operatorname{var}\left({\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbi.png)

![$$ ={\phi}_1^2\operatorname{var}\left({X}_t\right)+{\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbj.png)

![$$ \left(1-{\phi}_1^2\right)\operatorname{var}\left({X}_t\right)={\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbk.png)

![$$ \operatorname{var}\left({X}_t\right)=\frac{\sigma^2}{\left(1-{\phi}_1^2\right)} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbl.png)

从方差公式的最后一个表达式可以看出，AR(1)只有在∣*ϕ*T2】1∣<1 时才是平稳的。AR(1)是协方差平稳的一个必要(也可以证明是充分)条件是| *ϕ* | < 1。这种情况防止系列“爆炸” *ϕ* <sub>1</sub> 度量模型的持久性。ϕ <sub>1</sub> 越小，方差越小。

假设 AR(1)是一个均值为常数 *μ* 的平稳过程，那么退化的过程如下:

![$$ {X}_t-\mu ={\phi}_1\left({X}_{t-1}-\mu \right)+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbm.png)

或者，用![$$ {\overset{\sim }{X}}_t={X}_t-\mu $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq16.png)、

、![$$ {\overset{\sim }{X}}_t={\phi}_1{\overset{\sim }{X}}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbn.png)、

那么，退化变量和误差之间的协方差如下:

![$$ \mathrm{E}\left[{\overset{\sim }{X}}_t{\varepsilon}_t\right]=\mathrm{E}\left[\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\varepsilon}_t\right){\varepsilon}_t\right]={\phi}_1\mathrm{E}\left[{\overset{\sim }{X}}_{t-1}{\varepsilon}_t\right]+{\sigma}^2={\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbo.png)

方差如下:

![$$ \gamma (0)=\mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_t\right]=\mathrm{E}\left[\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\varepsilon}_t\right)\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\varepsilon}_t\right)\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbp.png)

![$$ =\mathrm{E}\left[\left({\phi}_1^2{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-1}+2{\phi}_1{\overset{\sim }{X}}_{t-1}{\varepsilon}_t+{\varepsilon}_t^2\right)\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbq.png)

![$$ ={\phi}_1^2\mathrm{E}\left[{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-1}\right]+2{\phi}_1\mathrm{E}\left[{\overset{\sim }{X}}_{t-1}{\varepsilon}_t\right]+\mathrm{E}\left[{\varepsilon}_t^2\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbr.png)

即

![$$ \gamma (0)={\phi}_1^2\gamma (0)+{\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbs.png)

![$$ \gamma (0)=\frac{\sigma^2}{1-{\phi}_1^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbt.png)

AR(1)的 ACVF 如下:

![$$ \mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-j}\right]=\mathrm{E}\left[\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\varepsilon}_t\right){\overset{\sim }{X}}_{t-j}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbu.png)

![$$ ={\phi}_1\mathrm{E}\left[{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-j}\right]+\mathrm{E}\left[{\varepsilon}_t{\overset{\sim }{X}}_{t-j}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbv.png)

![$$ ={\phi}_1\mathrm{E}\left[{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-j}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbw.png)

也就是我们有了这个:

![$$ \gamma (j)={\phi}_1\gamma \left(j-1\right),j=1,2,\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbx.png)

AR(1)的 ACF 如下:

![$$ \rho (j)=\frac{\gamma (j)}{\gamma (0)}={\phi}_1^j,j=1,2,\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equby.png)

当| *ϕ* <sub>1</sub> | < 1 时，AR(1)的 ACF | *ρ* ( *j* )|的大小呈指数下降。

AR(1)模型是连续时间均值回复过程的离散时间模拟，称为奥恩斯坦-乌伦贝克过程。因此，理解等价形式的 AR(1)模型的性质有时是有用的。在这种形式下，具有均值回复参数 *θ* 的 AR(1)模型由下式给出:

![$$ {X}_{t+1}={X}_t+\left(1-\theta \right)\left(\mu -{X}_t\right)+{\varepsilon}_{t+1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equbz.png)

以下可以证明:

![$$ \mathrm{E}\left[{X}_{t+n}\ |\ {X}_t\right]=\mu \left(1-{\theta}^n\right)+{X}_t{\theta}^n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equca.png)

![$$ \operatorname{var}\left[{X}_{t+n}\ |\ {X}_t\right]={\sigma}^2\frac{1-{\theta}^{2n}}{1-{\theta}^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcb.png)

在 NM Dev 中，类`ARModel`构造一个 AR 模型。该类签名如下:

```py
public class ARModel extends ARMAModel {

    /**
     * Construct a univariate AR model.
     *
     * @param mu    the intercept (constant) term
     * @param AR    the AR coefficients (excluding the initial 1)
     * @param sigma the white noise variance
     */
    public ARModel(double mu, double[] AR, double sigma) {
        super(mu, AR, null, sigma);
    }

    /**
     * Construct a univariate AR model with unit variance.
     *
     * @param mu the intercept (constant) term
     * @param AR the AR coefficients (excluding the initial 1)
     */
    public ARModel(double mu, double[] AR) {
        this(mu, AR, 1);
    }

    /**
     * Construct a univariate AR model with zero-intercept (mu).
     *
     * @param AR    the AR coefficients (excluding the initial 1)
     * @param sigma the white noise variance
     */
    public ARModel(double[] AR, double sigma) {
        this(0, AR, sigma);
    }

    /**
     * Construct a univariate AR model with unit variance and zero-intercept
     * (mu).
     *
     * @param AR the AR coefficients (excluding the initial 1)
     */
    public ARModel(double[] AR) {
        this(AR, 1);
    }

    /**
     * Copy constructor.
     *
     * @param that a univariate AR model
     */
    public ARModel(ARModel that) {
        super(that);
    }
}

```

例如，下面的代码构建了这个 AR(1)模型，并计算了它的 ACVF 和 ACF:

![$$ {X}_t=0.6{X}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcc.png)

```py
// define an AR(1) model
ARModel ar1 = new ARModel(
        new double[]{0.6} // phi_1 = 0.6
);

final int nLags = 10;
// compute the autocovariance function for the model
AutoCovariance acvf1 = new AutoCovariance(ar1);
for (int i = 0; i < nLags; i++) {
    System.out.printf("the acvf of the AR(1) model at lag%d = %f%n", i, acvf1.evaluate(i));
}

// compute the autocorrelation function for the model
AutoCorrelation acf1 = new AutoCorrelation(ar1, nLags);
for (int i = 0; i < nLags; i++) {
    System.out.printf("the acf of the AR(1) model at lag%d = %f%n", i, acf1.evaluate(i));
}

```

输出如下所示:

```py
the acvf of the AR(1) model at lag0 = 1.562500
the acvf of the AR(1) model at lag1 = 0.937500
the acvf of the AR(1) model at lag2 = 0.562500
the acvf of the AR(1) model at lag3 = 0.337500
the acvf of the AR(1) model at lag4 = 0.202500
the acvf of the AR(1) model at lag5 = 0.121500
the acvf of the AR(1) model at lag6 = 0.072900
the acvf of the AR(1) model at lag7 = 0.043740
the acvf of the AR(1) model at lag8 = 0.026244
the acvf of the AR(1) model at lag9 = 0.015746
the acf of the AR(1) model at lag0 = 1.000000
the acf of the AR(1) model at lag1 = 0.600000
the acf of the AR(1) model at lag2 = 0.360000
the acf of the AR(1) model at lag3 = 0.216000
the acf of the AR(1) model at lag4 = 0.129600
the acf of the AR(1) model at lag5 = 0.077760
the acf of the AR(1) model at lag6 = 0.046656
the acf of the AR(1) model at lag7 = 0.027994
the acf of the AR(1) model at lag8 = 0.016796
the acf of the AR(1) model at lag9 = 0.010078

```

我们看到 ACVF 和 ACF 都指数衰减到 0。图 [15-10](#Fig10) 绘制了 ACF 值。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig10_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig10_HTML.jpg)

图 15-10

当**<sub>**1**</sub>=**0.6**时 AR(1)过程的 ACF**

 **#### 15.2.1.2 AR(2)

一个 AR(2)模型如下:

![$$ {X}_t={\phi}_0+{\phi}_1{X}_{t-1}+{\phi}_2{X}_{t-2}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcd.png)

其中 *ϕ* <sub>1</sub> 和 *ϕ* <sub>2</sub> 为自回归系数。 *ε* <sub>*t*</sub> 是均值为零、方差恒定的误差项或白噪声 *σ* <sup>2</sup> 。AR(2)被称为具有阶 2，因为它具有作为其因变量的*X*<sub>*t*—1</sub>和*X*<sub>*t*—2</sub>。

就后移算子而言，我们有这样的:

![$$ {X}_t={\phi}_0+{\phi}_1B{X}_t+{\phi}_2{B}^2{X}_t+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equce.png)

重新排列术语并使用多项式表示法，我们有了这个:

![$$ \left(1-{\phi}_1B-{\phi}_2{B}^2\right){X}_t={\phi}_0+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcf.png)

![$$ {X}_t=\frac{1}{\left(1-{\phi}_1B-{\phi}_2{B}^2\right)}\left({\phi}_0+{\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcg.png)

AR(2)的条件均值和方差，以*X*<sub>T3】t1</sub>和*X*<sub>T9】t2</sub>为常数，如下:

![$$ \mathrm{E}\left[{X}_t\ |\ {X}_{t-1},{X}_{t-2}\right]={\phi}_0+{\phi}_1{X}_{t-1}+{\phi}_2{X}_{t-2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equch.png)

![$$ \operatorname{var}\left[{X}_t\ |\ {X}_{t-1},{X}_{t-2}\right]={\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equci.png)

假设{ *X* <sub>*t*</sub> }是静止的，那么无条件期望如下:

![$$ \mathrm{E}\left[{X}_t\ \right]=\mathrm{E}\left[{\phi}_0+{\phi}_1{X}_{t-1}+{\phi}_2{X}_{t-2}+{\varepsilon}_t\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcj.png)

![$$ ={\phi}_0+{\phi}_1\mathrm{E}\left[{X}_{t-1}\right]+{\phi}_2\mathrm{E}\left[{X}_{t-2}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equck.png)

![$$ ={\phi}_0+{\phi}_1\mathrm{E}\left[{X}_t\right]+{\phi}_2\mathrm{E}\left[{X}_t\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcl.png)

即

![$$ \left(1-{\phi}_1-{\phi}_2\right)\mathrm{E}\left[{X}_t\right]={\phi}_0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcm.png)

![$$ \mathrm{E}\left[{X}_t\right]=\frac{\phi_0}{1-{\phi}_1-{\phi}_2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcn.png)

无条件方差的计算有点复杂，因为我们需要考虑*X*<sub>*t*—1</sub>和*X*<sub>*t*—2</sub>之间的协方差，它是非零的。我们将使用 ACVF 来计算方差，这与滞后 0， *γ* (0)时的自协方差相同。

假设 AR(2)是具有恒定均值 *μ* 的平稳过程；然后贬低的过程如下:

![$$ {X}_t-\mu ={\phi}_1\left({X}_{t-1}-\mu \right)+{\phi}_2\left({X}_{t-2}-\mu \right)+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equco.png)

或者等价地，

![$$ {\overset{\sim }{X}}_t={\phi}_1{\overset{\sim }{X}}_{t-1}+{\phi}_2{\overset{\sim }{X}}_{t-2}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcp.png)

那么，退化变量和误差之间的协方差如下:

![$$ \mathrm{E}\left[{\varepsilon}_t{\overset{\sim }{X}}_t\right]=\mathrm{E}\left[{\varepsilon}_t\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\phi}_2{\overset{\sim }{X}}_{t-2}+{\varepsilon}_t\right)\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcq.png)

![$$ ={\phi}_1\mathrm{E}\left[{\varepsilon}_t{\overset{\sim }{X}}_{t-1}\right]+{\phi}_2\mathrm{E}\left[{\varepsilon}_t{\overset{\sim }{X}}_{t-2}\right]+E\left[{\varepsilon}_t^2\right]={\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcr.png)

AR(2)的 ACVF 如下:

![$$ \mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-j}\right]=\mathrm{E}\left[\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\phi}_2{\overset{\sim }{X}}_{t-2}+{\varepsilon}_t\right){\overset{\sim }{X}}_{t-j}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcs.png)

![$$ =\mathrm{E}\left[{\phi}_1{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-j}+{\phi}_2{\overset{\sim }{X}}_{t-2}{\overset{\sim }{X}}_{t-j}+{\varepsilon}_t{\overset{\sim }{X}}_{t-j}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equct.png)

![$$ ={\phi}_1\mathrm{E}\left[{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-j}\right]+{\phi}_2\mathrm{E}\left[{\overset{\sim }{X}}_{t-2}{\overset{\sim }{X}}_{t-j}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcu.png)

也就是

![$$ \gamma (j)={\phi}_1\gamma \left(j-1\right)+{\phi}_2\gamma \left(j-2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcv.png)

初始条件由以下给出:

![$$ \gamma (0)=\mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_t\right]=\mathrm{E}\left[{\overset{\sim }{X}}_t\left({\phi}_1{\overset{\sim }{X}}_{t-1}+{\phi}_2{\overset{\sim }{X}}_{t-2}+{\varepsilon}_t\right)\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcw.png)

![$$ =\mathrm{E}\left[{\phi}_1{\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-1}+{\phi}_2{\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-2}+{\overset{\sim }{X}}_t{\varepsilon}_t\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcx.png)

![$$ ={\phi}_1\mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-1}\right]+{\phi}_2\mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-2}\right]+\mathrm{E}\left[{\overset{\sim }{X}}_t{\varepsilon}_t\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcy.png)

![$$ ={\phi}_1\gamma (1)+{\phi}_2\gamma (2)+{\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equcz.png)

![$$ \gamma (1)={\phi}_1\gamma (0)+{\phi}_2\gamma \left(-2\right)={\phi}_1\gamma (0)+{\phi}_2\gamma (2) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equda.png)

![$$ \gamma (2)={\phi}_1\gamma (1)+{\phi}_2\gamma (0) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdb.png)

线性方程组如下:

![$$ \left\{\begin{array}{c}\gamma (0)={\phi}_1\gamma (1)+{\phi}_2\gamma (2)+{\sigma}^2\\ {}\gamma (1)={\phi}_1\gamma (0)+{\phi}_2\gamma (2)\\ {}\gamma (2)={\phi}_1\gamma (1)+{\phi}_2\gamma (0)\end{array}\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdc.png)

我们可以解出![$$ \gamma (0)=\mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_t\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq17.png)、 *γ* (1)和 *γ* (2)，然后我们可以利用递推关系计算出 *γ* ( *j* )对于 *j* = 1，2、....

ACF 如下:

![$$ \rho (j)={\phi}_1\rho \left(j-1\right)+{\phi}_2\rho \left(j-2\right),j=1,2,\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdd.png)

同样，初始条件由以下给出:

![$$ \rho (0)=1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equde.png)

![$$ \rho (1)={\phi}_1\rho (0)+{\phi}_2\rho \left(-1\right)={\phi}_1\rho (0)+{\phi}_2\rho (1) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdf.png)

![$$ \rho (1)=\frac{\phi_1}{1-{\phi}_2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdg.png)

做更多的代数，我们有变量的方差如下:

![$$ \mathrm{E}\left[{\overset{\sim }{X}}_t{\overset{\sim }{X}}_t\right]=\gamma (0)=\frac{1}{1-{\phi}_1\rho (1)-{\phi}_2\rho (2)}{\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdh.png)

下面的代码构建了这个 AR(2)模型，并计算了它的 ACVF 和 ACF:

![$$ {X}_t=1.2{X}_{t-1}-0.35{X}_{t-2}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdi.png)

```py
// define an AR(2) model
ARModel ar2 = new ARModel(
        new double[]{1.2, -0.35}
);

// compute the autocovariance function for the model
AutoCovariance acvf2 = new AutoCovariance(ar2);
for (int i = 1; i < nLags; i++) {
    System.out.printf("the acvf of the AR(2) model at lag%d = %f%n", i, acvf2.evaluate(i));
}

// compute the autocorrelation function for the model
AutoCorrelation acf2 = new AutoCorrelation(ar2, 10);
for (int i = 0; i < nLags; i++) {
    System.out.printf("the acf of the AR(2) model at lag%d = %f%n", i, acf2.evaluate(i));
}

```

输出如下所示:

```py
the acvf of the AR(2) model at lag1 = 4.826546
the acvf of the AR(2) model at lag2 = 3.891403
the acvf of the AR(2) model at lag3 = 2.980392
the acvf of the AR(2) model at lag4 = 2.214480
the acvf of the AR(2) model at lag5 = 1.614238
the acvf of the AR(2) model at lag6 = 1.162018
the acvf of the AR(2) model at lag7 = 0.829438
the acvf of the AR(2) model at lag8 = 0.588620
the acvf of the AR(2) model at lag9 = 0.416040
the acf of the AR(2) model at lag0 = 1.000000
the acf of the AR(2) model at lag1 = 0.888889
the acf of the AR(2) model at lag2 = 0.716667
the acf of the AR(2) model at lag3 = 0.548889
the acf of the AR(2) model at lag4 = 0.407833
the acf of the AR(2) model at lag5 = 0.297289
the acf of the AR(2) model at lag6 = 0.214005
the acf of the AR(2) model at lag7 = 0.152755
the acf of the AR(2) model at lag8 = 0.108404
the acf of the AR(2) model at lag9 = 0.076621

```

图 [15-11](#Fig11) 绘制了模型的 ACF。这些值按指数规律衰减到 0。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig11_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig11_HTML.jpg)

图 15-11

*<sub>*1*</sub>=*1.2*，*ϕ*<sub>*2*</sub>=*0.35*时 AR(2)过程的 ACF*

 *#### 15.2.1.3 开

AR(1)和 AR(2)是更一般的阶为 *p* 的 AP(p)模型的重要特例。其定义如下:

![$$ {X}_t={\phi}_0+{\phi}_1{X}_{t-1}+{\phi}_2{X}_{t-2}+\dots +{\phi}_p{X}_{t-p}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdj.png)

其中{ *ϕ* <sub>*i*</sub> }是自回归系数， *ε* <sub>*t*</sub> 是白噪声。

就后移运算符而言，我们编写如下:

![$$ {X}_t={\phi}_0+{\phi}_1B{X}_t+{\phi}_2{B}^2{X}_t+\dots +{\phi}_p{B}^p{X}_t+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdk.png)

![$$ {X}_t-{\phi}_1B{X}_t-{\phi}_2{B}^2{X}_t-\dots -{\phi}_p{B}^p{X}_t={\phi}_0+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdl.png)

![$$ \underset{\phi (B)}{\underbrace{\left(1-{\phi}_1B-{\phi}_2{B}^2-\dots -{\phi}_p{L}^p\right)}}{X}_t={\phi}_0+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdm.png)

![$$ \phi (B){X}_t={\phi}_0+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdn.png)

![$$ {X}_t=\frac{\phi_0+{\varepsilon}_t}{\phi (B)} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdo.png)

当进行右边的多项式除法时，应用于 *ε* <sub>*t*</sub> 的后移算子中的多项式具有无限阶，意味着无限个 *ε* <sub>*t*</sub> ，*ε*<sub>T15】t—1</sub>， *ε* <sub>*t* ...出现在等式的右边。因此，AR 模型可以被认为是无限数量的过去误差项的总和。因此，一次性冲击会对未来无限远的进化变量产生永久的影响。比如考虑 AR(1)模型*x*<sub>*t*</sub>=*ϕ*<sub>0</sub>+*ϕ*<sub>1</sub>*x*<sub>*t*—1</sub>+*ε**。比方说，在时间 *t* = 1 时 *ε* <sub>*t*</sub> 的非零值影响 *X* <sub>1</sub> 的量 *ε* <sub>1</sub> 。然后由 AR 方程为 *X* <sub>2</sub> 就 *X* <sub>1</sub> 而言，这影响到 *X* <sub>2</sub> 乘量*ϕ*<sub>1</sub>ε<sub>1</sub>。然后由 AR 方程为*X*T88】3*</sub>*就*X*2 而言，这影响*X*T96】3 的量![$$ {\phi}_1^2{\varepsilon}_1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq18.png)。继续这个过程显示出*ε*T101】1 的效应永远不会结束，尽管如果过程是静止的，那么效应在极限中向零减小。*

 *最简单的 AR 过程是 AR(0)，项之间没有依赖关系。只有误差项对过程的输出有贡献。AR(0)对应于图 [15-12](#Fig12) 中的白噪声。对于具有正*ϕ*T4】1 的 AR(1)过程，只有过程中的前一项和噪声项对输出有贡献。如果*ϕ*t8】1 接近 0，那么该过程看起来仍然像白噪声，但是随着*ϕ*T12】1 接近 1，相对于噪声，输出从前一项获得更大的贡献。这导致输出的“平滑”或积分，类似于图 [15-12](#Fig12) 中的低通滤波器。对于 AR(2)过程，前两项和噪声项对输出有贡献。如果*ϕ*t18】1 和*ϕ*t22】2 都为正，输出将类似于低通滤波器，噪声的高频部分减少。如果 *ϕ* <sub>1</sub> 为正，而 *ϕ* <sub>2</sub> 为负，则该过程倾向于在过程的项之间改变符号。输出振荡。这可以比作边缘检测或方向变化检测，如图 [15-12](#Fig12) 所示。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig12_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig12_HTML.jpg)

图 15-12

比较不同的 AR 流程

AR(p)的无条件均值如下:

![$$ E\left({X}_t\right)=\frac{\phi_0}{1-{\phi}_1-\dots -{\phi}_p} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdp.png)

#### 15.2.1.4 估计

给定一个时间序列的数据，我们可能要为它构建一个 AR(p)模型。我们需要做的第一件事是确定滞后的顺序， *p* 。这就决定了 AR 模型的规格。然后我们只需要确定自回归系数*ϕ*<sub>t5】I</sub>，0 ≤ *i* ≤ *p* 。

考虑一个 AR(p)模型:

![$$ {X}_t={\phi}_0+{\phi}_1{X}_{t-1}+{\phi}_2{X}_{t-2}+\dots +{\phi}_p{X}_{t-p}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdq.png)

直观上，由于*X*<sub>T3】tT5】是*X*<sub>*t*—*I*</sub>，1 ≤ *i* ≤ *p* ，那么*X*<sub>*t*—*I*</sub>为*I*≥ *X*<sub>*t*—*I*</sub>，1 ≤ *i* ≤ *p* 。 *X*<sub>*t*</sub>—E[*X**t*</sub>|*X*<sub>*t*—*I*</sub>，1≤*I*≤*p*=*⒇可以证明，PACF，即 *X* <sub>*t*</sub> 与*X*<sub>t*t*+*k*</sub>在去除中间变量*X*<sub>t*t*-*I*</sub>的影响后我们可以利用这一事实来确定 AR 模型的适当滞后，使用 PACF 图，如每月标准普尔 500 回报率的图。换句话说，非零部分自相关的数量告诉 AR 模型的顺序。*

固定了一个 *p* 之后，估计系数的方法有很多种。一种方法是尤尔-沃克方程。NM Dev 不使用 Yule-Walker 方程进行 AR 估计，但是为了完整起见，我们在这里包括了讨论。从贬低的 AR 模型(*ϕ*T4】0= 0)开始，我们有了这个:

![$$ {\overset{\sim }{X}}_t={\phi}_1{\overset{\sim }{X}}_{t-1}+{\phi}_2{\overset{\sim }{X}}_{t-2}+\dots +{\phi}_p{\overset{\sim }{X}}_{t-p}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdr.png)

两边相乘*X*<sub>T3】t—*k*</sub>，我们有这个:

![$$ {\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-k}={\phi}_1{\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-k}+{\phi}_2{\overset{\sim }{X}}_{t-2}{\overset{\sim }{X}}_{t-k}+\dots +{\phi}_p{\overset{\sim }{X}}_{t-p}{\overset{\sim }{X}}_{t-k}+{\varepsilon}_t{\overset{\sim }{X}}_{t-k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equds.png)

带着双方的期待，我们有了这个:

![$$ E\left({\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-k}\right)={\phi}_1E\left({\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-k}\right)+{\phi}_2E\left({\overset{\sim }{X}}_{t-2}{\overset{\sim }{X}}_{t-k}\right)+\dots +{\phi}_pE\left({\overset{\sim }{X}}_{t-p}{\overset{\sim }{X}}_{t-k}\right)+E\left({\varepsilon}_t{\overset{\sim }{X}}_{t-k}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdt.png)

![$$ ={\phi}_1E\left({\overset{\sim }{X}}_{t-1}{\overset{\sim }{X}}_{t-k}\right)+{\phi}_2E\left({\overset{\sim }{X}}_{t-2}{\overset{\sim }{X}}_{t-k}\right)+\dots +{\phi}_pE\left({\overset{\sim }{X}}_{t-p}{\overset{\sim }{X}}_{t-k}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdu.png)

用自协方差![$$ \gamma (k)=\operatorname{cov}\left({\overset{\sim }{X}}_t,{\overset{\sim }{X}}_{t+k}\right)=\mathrm{E}\left({\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t+k}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq19.png)和对称性*γ*(*k*)=*γ*(*k*)重写，我们有这个:

![$$ \gamma (k)={\phi}_1\gamma \left(k-1\right)+{\phi}_2\gamma \left(k-2\right)+\dots +{\phi}_p\gamma \left(k-p\right),k=1,\dots, p $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdv.png)

除以方差给出自相关函数的等值如下:

![$$ \rho (k)={\phi}_1\rho \left(k-1\right)+{\phi}_2\rho \left(k-2\right)+\dots +{\phi}_p\rho \left(k-p\right),k=1,\dots, p $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdw.png)

扩展一下(注意 *ρ* (0) = 1 和*ρ*(*k*)=*ρ*(*k*))，我们就有了这个:

![$$ \left\{\begin{array}{c}\rho (1)={\phi}_1\rho (0)+{\phi}_2\rho \left(-1\right)+\dots +{\phi}_p\rho \left(1-p\right)={\phi}_1+{\phi}_2\rho (1)+\dots +{\phi}_p\rho \left(p-1\right)\\ {}\rho (2)={\phi}_1\rho (1)+{\phi}_2\rho (0)+\dots +{\phi}_p\rho \left(2-p\right)={\phi}_1\rho (1)+{\phi}_2+\dots +{\phi}_p\rho \left(p-2\right)\\ {}\vdots \end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdx.png)

或者在矩阵形式中，我们有这样的:

![$$ \left[\begin{array}{cccc}1&amp; \rho (1)&amp; \cdots &amp; \rho \left(p-1\right)\\ {}\rho (1)&amp; 1&amp; \cdots &amp; \rho \left(p-2\right)\\ {}\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\ {}\rho \left(p-1\right)&amp; \rho \left(p-2\right)&amp; \cdots &amp; 1\end{array}\right]\left[\begin{array}{c}{\phi}_1\\ {}{\phi}_2\\ {}\vdots \\ {}{\phi}_p\end{array}\right]=\left[\begin{array}{c}\rho (1)\\ {}\rho (2)\\ {}\vdots \\ {}\rho (p)\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdy.png)

这就是众所周知的尤尔-沃克方程。

以 AR(2)为例，我们有这样的:

![$$ \left[\begin{array}{cc}1&amp; \rho (1)\\ {}\rho (1)&amp; 1\end{array}\right]\left[\begin{array}{c}{\phi}_1\\ {}{\phi}_2\end{array}\right]=\left[\begin{array}{c}\rho (1)\\ {}\rho (2)\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equdz.png)

求解这个线性方程组得到如下:

![$$ \left\{\begin{array}{c}{\phi}_1=\frac{\rho (1)\left(1-\rho (2)\right)}{1-{\rho}^2(1)}\\ {}{\phi}_2=\frac{\rho (2)-{\rho}^2(1)}{1-{\rho}^2(1)}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equea.png)

为了估计![$$ {\hat{\phi}}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq20.png)，我们简单地将公式中的 *ρ* ( *i* )替换为来自数据的估计自相关![$$ \hat{\rho}(i) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq21.png)。

在 NM Dev 中，我们使用最大似然法来估计系数。类`ConditionalSumOfSquares`实现了这个估计算法。下面的代码演示了从数据中估计系数。它首先定义了一个 AR(2)模型。类`ARIMASim`采用 AR 模型，并根据模型生成随机数的时间序列。然后，我们估计另一个 AR(2)模型，首先使用 PACF 识别滞后的阶(它是 2)，然后拟合时间序列。我们期望估计的系数应该与原始模型中的系数相匹配。

```py
// define an AR(2) model
ARModel ar2 = new ARModel(
        new double[]{1.2, -0.35}
);

// create a random number generator from the AR model
ARIMASim sim = new ARIMASim(ar2);
sim.seed(1234567890L);

// generate a random time series
final int T = 500; // length of the time series
double[] x = new double[T];
for (int i = 0; i < T; ++i) {
    // call the RNG to generate random numbers according to the specification
    x[i] = sim.nextDouble();
}

// determine the cutoff lag using partial autocorrelation
SamplePartialAutoCorrelation acf2_hat
        = new SamplePartialAutoCorrelation(new SimpleTimeSeries(x));
for (int i = 1; i < 5; i++) {
    System.out.printf("the empirical pacf of a time series at lag%d: %f%n", i, acf2_hat.evaluate(i));
}

// fit an AR(2) model using the data
ConditionalSumOfSquares fit
        = new ConditionalSumOfSquares(
                x,
                2, // the AR order
                0,
                0);
System.out.printf("phi: %s%n", Arrays.toString(fit.getARMAModel().phi()));
System.out.printf("var of error term: %s%n", fit.var());

```

输出如下所示:

```py
the empirical pacf of a time series at lag1: 0.870717
the empirical pacf of a time series at lag2: -0.361752
the empirical pacf of a time series at lag3: 0.006046
the empirical pacf of a time series at lag4: 0.050507
phi: [1.0, 1.1861775215396104, -0.3622433585852758]
var of error term: 1.0322854887339732

```

用于生成随机时间序列的原始模型是![$$ \left\{\begin{array}{c}{\phi}_1=1.2\\ {}{\phi}_2=-0.35\\ {}{\sigma}^2=1\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq22.png)。

估计系数和估计方差为![$$ \left\{\begin{array}{c}{\hat{\phi}}_1=1.19\\ {}{\hat{\phi}}_2=-0.36\\ {}{\hat{\sigma}}^2=1.03\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq23.png)。他们相当接近。

#### 15.2.1.5 天气预报

给定一个 AR(p)模型，如下图:

![$$ {X}_t={\phi}_0+{\phi}_1{X}_{t-1}+{\phi}_2{X}_{t-2}+\dots +{\phi}_p{X}_{t-p}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equeb.png)

一步预测 *f* <sub>*t* + 1</sub> 是 *X* <sub>*t* + 1</sub> 的条件期望，是上一次 *p* 观测值的线性组合。

![$$ {f}_{t+1}=E\left({X}_{t+1}|{X}_1,\dots, {X}_t\right)={\phi}_0+{\phi}_1{X}_t+{\phi}_2{X}_{t-1}+\dots +{\phi}_p{X}_{t+1-p} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equec.png)

对于两步预测*f*<sub>T3】t+2</sub>，我们没有时间 *t* + 1 的观测值，但是我们有预测 *f* <sub>*t* + 1</sub> 来代替它。也就是我们有了这个:

![$$ {f}_{t+2}=E\left({X}_{t+2}|{X}_1,\dots, {X}_t\right)=E\left({\phi}_0+{\phi}_1{X}_{t+1}+{\phi}_2{X}_t+\dots +{\phi}_p{X}_{t+2-p}+{\varepsilon}_{t+2}|{X}_1,\dots {X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equed.png)

![$$ ={\phi}_0+{\phi}_1E\left({X}_{t+1}|{X}_1,\dots, {X}_t\right)+{\phi}_2{X}_t+\dots +{\phi}_p{X}_{t+2-p} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equee.png)

![$$ ={\phi}_0+{\phi}_1{f}_{t+1}+{\phi}_2{X}_t+\dots +{\phi}_p{X}_{t+2-p} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equef.png)

区分两步预测 *f* <sub>*t* + 2</sub> 和一步之后的一步预测*f*<sub>*t*+2∣*t*+1</sub>非常重要。前者是在没有时间 *t* + 1 的观测的情况下做出的，而后者包含了该信息，因为预测是在该信息出来之后对未来做出的。我们比较它们。这个:

![$$ {f}_{t+2}=E\left({X}_{t+2}|{X}_1,\dots, {X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equeg.png)

对比以下:

![$$ {f}_{t+2\mid t+1}=E\left({X}_{t+2}|{X}_1,\dots, {X}_t,{X}_{t+1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equeh.png)

一般来说，首先，我们使用 *t* 来指代数据尚不可用的第一个时段。我们将已知的前述值*X*<sub>T5】t—*I*</sub>，1 ≤ *i* ≤ *p* 代入自回归方程，同时将误差项 *ε* <sub>*t*</sub> 设置为零(因为我们预测 *X* <sub>*t*</sub> 等于其期望值自回归方程的输出是对第一个未观测期间的预测。接下来，我们再次使用自回归方程来进行预测，只有一个不同之处:在当前预测的一个周期之前的一个周期的*X*<sub>*t*+1</sub>的值是未知的，因此使用其期望值，即从先前的预测步骤中产生的预测值。然后，对于未来周期，使用相同的程序，每次在预测等式的右侧使用一个以上的预测值，直到在 *p* 预测之后，所有 *p* 右侧值都是来自先前步骤的预测值。我们有这样的:

![$$ {f}_{t+3}={\phi}_0+{\phi}_1{f}_{t+2}+{\phi}_2{f}_{t+1}+\dots +{\phi}_p{X}_{t+3-p} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equei.png)

![$$ \vdots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equej.png)

![$$ {f}_{t+s}={\phi}_0+{\phi}_1{f}_{t+\left(s-1\right)}+{\phi}_2{f}_{t+\left(s-2\right)}+\dots +{\phi}_p{X}_{t+\left(s-p\right)},s&gt;p $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equek.png)

在 NM Dev 中，类`ARMAForecast`接受模型规范并计算下一个 n 步预测。该类签名如下:

```py
/**
 * Constructs a forecaster for a time series assuming ARMA model.
 *
 * @param xt   a time series
 * @param arma the ARMA specification
 */
public ARMAForecast(IntTimeTimeSeries xt, ARMAModel arma);

/**
 * Gets the next forecast.
 *
 * @return the next forecast
 */
public Forecast next();

/**
 * Gets the next n-step forecasts.
 *
 * @param nSteps the number of steps to forecast
 * @return all the n-step forecasts
 */
public List<Forecast> next(int nSteps);

```

以下代码片段延续了前面的示例，并计算了接下来的十个 n 步预测:

```py
// make forecast
ARMAForecast forecast_ar2
        = new ARMAForecast(new SimpleTimeSeries(x), ar2);
System.out.println("The forecasts for the AR(2) model are");
for (int j = 0; j < 10; ++j) {
    System.out.println(forecast_ar2.next());
}

```

输出如下所示:

```py
The forecasts for the AR(2) model are
[501]: 0.355169 (1.000000)
[502]: 0.370225 (2.440000)
[503]: 0.319961 (3.628100)
[504]: 0.254374 (4.416644)
[505]: 0.193263 (4.884637)
[506]: 0.142884 (5.144859)
[507]: 0.103819 (5.283771)
[508]: 0.074574 (5.355976)
[509]: 0.053152 (5.392841)
[510]: 0.037681 (5.411433)

```

### 毫安型号

移动平均模型规定，输出变量线性依赖于误差项、随机冲击或白噪声的当前值和各种过去值。与仅当自回归系数满足特定条件时才是平稳的 AR 模型相反，有限 MA 模型总是平稳的。

移动平均模型不应与移动平均函数或方法混淆，后者是一个不同的概念。当人们在金融应用或技术分析中说数据的移动平均时，他们实际上指的是数据的(加权)平均，而不是不可观察误差项的(加权)平均。更令人困惑的是，数据的移动平均(或加权平均)实际上是一个自回归过程。例如，简单移动平均线(SMA)是前 *k* 个数据点的未加权平均值。【T2![$$ {SMA}_k=\frac{x_t+{x}_{t-1}+\dots +{x}_{t-k+1}}{k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equel.png)

这是一个阶为 *k* 的 AR 过程，所有系数等于![$$ \frac{1}{k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq24.png)。

事实上，一大类技术指标或技术规则是由过去价格的不同移动平均线组成的。它们只是过去价格或回报的有限线性组合，因此它们是 ar 模型。Emmanual & Stephen (2002)分析了这些交易规则，并从数学上证明了它们能够盈利的条件。一个必要条件是交易的股票需要有自相关性。但是，股票没有序列依赖性。据我所知，理论(有效市场假说)和经验(没有显著的序列相关性)证据都没有提出除了运气之外，为什么使用技术分析进行交易是有利可图的科学理由。当有足够多的人这样做时，一些人一定会赚钱，就像一场掷硬币的比赛，获胜者是连续获得 20 个头像的人。考虑到自从我出生以来，美国市场一直在上涨，这就更容易了。感兴趣的读者可能会在我的另一本书《量化交易中的*数值方法*中找到更多细节。

#### 马(1)

一阶移动平均线模型 1，MA(1)，模型如下:

![$$ {X}_t={\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equem.png)

其中 *θ* <sub>0</sub> 为常数， *θ* <sub>1</sub> 为自回归系数， *ε* <sub>*t*</sub> 为随机项或随机项或误差项。这是带有以下内容的白噪声:

*   零均值，E[*ε*<sub>T3】t</sub>]= 0

*   恒定方差<sup><sup>、var[**= e[**</sup></sup>

***   独立分布，E[*ε*<sub>*t*</sub>*ε*<sub>*t*—1</sub>= 0** 

 ***X* <sub>*t*</sub> 无条件均值如下:

![$$ \mathrm{E}\left({X}_t\right)=\mathrm{E}\left({\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t\right)=\mathrm{E}\left({\theta}_0\right)+{\theta}_1\mathrm{E}\left({\varepsilon}_{t-1}\right)+\mathrm{E}\left({\varepsilon}_t\right)={\theta}_0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equen.png)

*X*<sub>T3】tT5】的无条件方差如下:</sub>

![$$ \gamma (0)=\operatorname{var}\left({X}_t\right)=\mathrm{E}\left({X}_t^2\right)-{\left[\mathrm{E}\left({X}_t\right)\right]}^2=\mathrm{E}\left({X}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equeo.png)

![$$ =\mathrm{E}\left({\left({\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t\right)}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equep.png)

![$$ =\mathrm{E}\left({\theta}_0^2+{\theta}_1^2{\varepsilon}_{t-1}^2+{\varepsilon}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equeq.png)

![$$ ={\theta}_1^2\mathrm{E}\left({\varepsilon}_{t-1}^2\right)+\mathrm{E}\left({\varepsilon}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equer.png)

![$$ ={\theta}_1^2{\sigma}^2+{\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Eques.png)

![$$ =\left(1+{\theta}_1^2\right){\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equet.png)

被贬低的时间序列如下:

![$$ {\overset{\sim }{X}}_t={X}_t-{\theta}_0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equeu.png)

对于*X*<sub>T3】tT5】的 ACVF 如下:</sub>

![$$ \gamma (1)=\mathrm{E}\left({\overset{\sim }{X}}_t{\overset{\sim }{X}}_t\right)=\mathrm{E}\left(\left({\varepsilon}_t+{\theta}_1{\varepsilon}_{t-1}\right)\left({\varepsilon}_{t-1}+{\theta}_1{\varepsilon}_{t-2}\right)\right)={\theta}_1\mathrm{E}\left({\varepsilon}_{t-1}^2\right)={\theta}_1{\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equev.png)

![$$ \gamma (k)=\mathrm{E}\left({\overset{\sim }{X}}_t{\overset{\sim }{X}}_{t-k}\right)=\mathrm{E}\left(\left({\varepsilon}_t+{\theta}_1{\varepsilon}_{t-1}\right)\left({\varepsilon}_{t-k}+{\theta}_1{\varepsilon}_{t-k-1}\right)\right)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq25.png)，*k*T3】1

*X*<sub>T3】tT5】的 ACF 如下:</sub>

![$$ \rho (0)=\frac{\gamma (0)}{\gamma (0)}=1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equew.png)

![$$ \rho (1)=\frac{\gamma (1)}{\gamma (0)}=\frac{\theta_1{\sigma}^2}{\left(1+{\theta}_1^2\right){\sigma}^2}=\frac{\theta_1}{1+{\theta}_1^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equex.png)

![$$ \rho (k)=\frac{\gamma (k)}{\gamma (0)}=\frac{0}{\left(1+{\theta}_1^2\right){\sigma}^2}=0,k&gt;1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equey.png)

一个 MA(1)模型的例子如下:

![$$ {X}_t=0.8{\varepsilon}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equez.png)

在 NM Dev 中，可以使用类`MAModel`构建 MA 模型。以下代码片段构建了前面的模型:

```py
// define an MA(1) model
MAModel ma1 = new MAModel(
        new double[]{0.8} // theta_1 = 0.8
);

final int nLags = 10;
// compute the autocovariance function for the model
AutoCovariance acvf1 = new AutoCovariance(ma1);
for (int i = 0; i < nLags; i++) {
    System.out.printf("the acvf of the MA(1) model at lag%d = %f%n", i, acvf1.evaluate(i));
}
// compute the autocorrelation function for the model
AutoCorrelation acf1 = new AutoCorrelation(ma1, nLags);
for (int i = 0; i < nLags; i++) {
    System.out.printf("the acv of the MA(1) model at lag%d = %f%n", i, acf1.evaluate(i));
}

```

输出如下所示:

```py
the acvf of the MA(1) model at lag0 = 1.640000
the acvf of the MA(1) model at lag1 = 0.800000
the acvf of the MA(1) model at lag2 = 0.000000
the acvf of the MA(1) model at lag3 = 0.000000
the acvf of the MA(1) model at lag4 = 0.000000
the acvf of the MA(1) model at lag5 = 0.000000
the acvf of the MA(1) model at lag6 = 0.000000
the acvf of the MA(1) model at lag7 = 0.000000
the acvf of the MA(1) model at lag8 = 0.000000
the acvf of the MA(1) model at lag9 = 0.000000
the acf of the MA(1) model at lag0 = 1.000000
the acf of the MA(1) model at lag1 = 0.487805
the acf of the MA(1) model at lag2 = 0.000000
the acf of the MA(1) model at lag3 = 0.000000
the acf of the MA(1) model at lag4 = 0.000000
the acf of the MA(1) model at lag5 = 0.000000
the acf of the MA(1) model at lag6 = 0.000000
the acf of the MA(1) model at lag7 = 0.000000
the acf of the MA(1) model at lag8 = 0.000000
the acf of the MA(1) model at lag9 = 0.000000

```

注意滞后 1 后 ACVF 和 ACF 都为 0， *γ* ( *k* ) = 0， *k* > 1。这是一个有用的属性，我们可以用它来识别 MA 模型的顺序。见图 [15-13](#Fig13) 。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig13_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig13_HTML.jpg)

图 15-13

MA(1)过程的 ACF 当*θ*<sub>T3】1T5】=*0.8*</sub>

#### 马

一般情况下，订单为 *q* 的安 MA( *q* )模型如下:

![$$ {X}_t={\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\theta}_2{\varepsilon}_{t-2}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfa.png)

其中 *θ* <sub>*t*</sub> 为移动平均系数。

等价地，我们可以用后移运算符来写这个:

![$$ {X}_t={\theta}_0+{\varepsilon}_t+{\theta}_1B{\varepsilon}_t+{\theta}_2{B}^2{\varepsilon}_t+\dots +{\theta}_q{B}^q{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfb.png)

![$$ {X}_t={\theta}_0+\underset{\theta (L)}{\underbrace{\left(1+{\theta}_1B+{\theta}_2{B}^2+\dots +{\theta}_q{B}^q\right)}}{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfc.png)

![$$ {X}_t={\theta}_0+\theta (B){\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfd.png)

其中 *θ* <sub>0</sub> 为过程在时间 0 的位置， *ε* <sub>*t*</sub> 为白噪声。

*X* <sub>*t*</sub> 的意思如下:

![$$ \mathrm{E}\left({X}_t\right)=\mathrm{E}\left({\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\theta}_2{\varepsilon}_{t-2}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t\right)=\mathrm{E}\left({\theta}_0\right)={\theta}_0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfe.png)

*X*<sub>T3】tT5】的方差如下:</sub>

![$$ \operatorname{var}\left({X}_t\right)=\operatorname{var}\left({\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\theta}_2{\varepsilon}_{t-2}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equff.png)

![$$ =\mathrm{E}\left({\left({\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\theta}_2{\varepsilon}_{t-2}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t\right)}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfg.png)

![$$ =\left(1+{\theta}_1^2+\dots +{\theta}_q^2\right){\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfh.png)

将两者结合起来，这就是说 MA 过程随着时间的推移只是在它开始的地方上下跳动 *θ* <sub>0</sub> 并具有恒定的方差![$$ \left(1+{\theta}_1^2+\dots +{\theta}_q^2\right){\sigma}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq26.png)。移动平均模型本质上是应用于白噪声的有限脉冲响应滤波器，并对其进行了一些额外的解释。随机冲击在 MA 模型中的作用与它们在 AR 模型中的作用在两个方面不同。首先，它们被直接传播到时间序列的未来值；例如，在 MA 模型中，类似于*ε*T7*t*1 的过去冲击直接出现在 *X* <sub>* t *</sub> 的等式右侧。相比之下，在 AR 模型中，*ε*<sub>*t*—1</sub>不会出现在 *X* <sub>* t *</sub> 方程的右侧。它确实出现在*X*<sub>*t*—1</sub>方程的右侧，并且*X*<sub>*t*—1</sub>出现在 *X* <sub>* t *</sub> 方程的右侧，只给出了*ε*<sub>*t*—1</sub>的间接效果第二，在 MA 模型中，冲击只影响当前时期和未来时期的时间序列；相比之下，在 AR 模型中，冲击会永久且无限地影响未来的时间序列值，因为 *ε* <sub>* t *</sub> 会影响 *X* <sub>* t *</sub> ，进而影响*X*<sub>*t*+1</sub>

ACVF 如下:

![$$ \gamma (k)=\left\{\begin{array}{c}{\sigma}^2\sum \limits_{i=0}^{q-k}{\theta}_i{\theta}_{i+k},k\le q\\ {}0,k&gt;q\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfi.png)

其中*θ*T2 0= 1。

例如，对于马②，我们有如下的:

![$$ \left\{\begin{array}{c}\gamma (0)=\left(1+{\theta}_1^2+{\theta}_2^2\right){\sigma}^2\\ {}\gamma (1)=\left({\theta}_1+{\theta}_1{\theta}_2\right){\sigma}^2\\ {}\gamma (2)={\theta}_2^2{\sigma}^2\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfj.png)

而 ACF 如下:

![$$ \left\{\begin{array}{c}\rho (0)=1\\ {}\rho (1)=\frac{\left({\theta}_1+{\theta}_1{\theta}_2\right)}{1+{\theta}_1^2+{\theta}_2^2}\\ {}\rho (2)=\frac{\theta_2^2{\sigma}^2}{1+{\theta}_1^2+{\theta}_2^2}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfk.png)

下面的代码构造这个 MA(2)模式并计算 ACVF 和 ACF，如下所示:

![$$ {X}_t={\varepsilon}_t-0.2{\varepsilon}_{t-1}+0.01{\varepsilon}_{t-2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfl.png)

```py
// define an MA(2) model
MAModel ma2 = new MAModel(
        new double[]{-0.2, 0.01} // the moving-average coefficients
);
AutoCovariance acvf2 = new AutoCovariance(ma2);
for (int i = 1; i < 10; i++) {
    System.out.printf("the acvf of the MA(2) model at lag%d: %f%n", i, acvf2.evaluate(i));
}
AutoCorrelation acf2 = new AutoCorrelation(ma2, 10);
for (int i = 0; i < 10; i++) {
    System.out.printf("the acf of the MA(2) model at lag%d: %f%n", i, acf2.evaluate(i));
}

```

输出如下所示:

```py
the acvf of the MA(2) model at lag1: -0.202000
the acvf of the MA(2) model at lag2: 0.010000
the acvf of the MA(2) model at lag3: 0.000000
the acvf of the MA(2) model at lag4: 0.000000
the acvf of the MA(2) model at lag5: 0.000000
the acvf of the MA(2) model at lag6: 0.000000
the acvf of the MA(2) model at lag7: 0.000000
the acvf of the MA(2) model at lag8: 0.000000
the acvf of the MA(2) model at lag9: 0.000000
the acf of the MA(2) model at lag0: 1.000000
the acf of the MA(2) model at lag1: -0.194212
the acf of the MA(2) model at lag2: 0.009614
the acf of the MA(2) model at lag3: 0.000000
the acf of the MA(2) model at lag4: 0.000000
the acf of the MA(2) model at lag5: 0.000000
the acf of the MA(2) model at lag6: 0.000000
the acf of the MA(2) model at lag7: 0.000000
the acf of the MA(2) model at lag8: 0.000000
the acf of the MA(2) model at lag9: 0.000000

```

请注意，滞后大于 2 的 MA(2)模型的 PACF 和 ACF 都为零。参见图 [15-14](#Fig14) 。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig14_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig14_HTML.jpg)

图 15-14

*<sub>*1*</sub>=*0.2*，*θ*<sub>*2*</sub>=*0.01*时 MA(2)过程的 ACF*

 *#### 15.2.2.3 可逆性和因果性

考虑一个 MA(1)模型:

![$$ {X}_t={\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfm.png)

使用 backshift 运算符编写的，我们有这样的:

![$$ {X}_t={\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t={\theta}_0+{\theta}_1B{\varepsilon}_t+{\varepsilon}_t={\theta}_0+\left(1+{\theta}_1B\right){\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfn.png)

或者等价地，

![$$ {\varepsilon}_t=\frac{X_t-{\theta}_0}{1-\left(-{\theta}_1B\right)} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfo.png)

我们可以把多项式除法写成一个无穷级数的和。

![$$ \sum \limits_{i=0}^{\infty }{a}^i=\frac{1}{1-a},\left|a\right|&lt;1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfp.png)T2】

当| *a* | < 1 时级数收敛。

这里*a*=(*θ*<sub>1</sub>*L*)。当| *θ* <sub>1</sub> | < 1，那么我们就有了这个:

![$$ {\varepsilon}_t=\left({X}_t-{\theta}_0\right)\sum \limits_{i=0}^{\infty }{\left(-{\theta}_1B\right)}^i=\left({X}_t-{\theta}_0\right)\left(1-{\theta}_1B+{\theta}_1^2{B}^2-{\theta}_1^3{B}^3+\dots \right)=\left({X}_t-{\theta}_0\right)-{\theta}_1B\left({X}_t-{\theta}_0\right)+{\theta}_1^2{B}^2\left({X}_t-{\theta}_0\right)-{\theta}_1^3{B}^3\left({X}_t-{\theta}_0\right)+\dots =\left({X}_t-{\theta}_0\right)-{\theta}_1\left({X}_{t-1}-{\theta}_0\right)+{\theta}_1^2\left({X}_{t-2}-{\theta}_0\right)-{\theta}_1^3\left({X}_{t-3}-{\theta}_0\right)+\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfq.png)

注意这是一个无穷阶的 AR 过程，AR(∞)。

如果一个 MA 模型在代数上等价于一个收敛的无限阶 AR 模型，则称它是可逆的。通过收敛，我们意味着 AR 系数是绝对可加和的![$$ \sum \limits_{i=0}^{\infty}\left|{\theta}_1^i\right|&lt;\infty $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq27.png)。当|*θ*T3】1|<1 时，马(1)成立。我们通常施加可逆性条件，以确保对于给定的自相关函数存在唯一的 MA 过程。这是从数据中估计移动平均系数的一个限制。

另一方面，考虑 AR(1)过程(为简单起见，平均值为零)。

![$$ {X}_t={\phi}_1{X}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfr.png)T2】

我们可以通过递归替换过去的误差项来扩展它。

![$$ {X}_t={\phi}_1{X}_{t-1}+{\varepsilon}_t={\phi}_1\left({\phi}_1{X}_{t-2}+{\varepsilon}_{t-1}\right)+{\varepsilon}_t={\phi}_1^2{X}_{t-2}+{\phi}_1{\varepsilon}_{t-1}+{\varepsilon}_t=={\phi}_1^3{X}_{t-3}+{\phi}_1^2{\varepsilon}_{t-2}+{\phi}_1{\varepsilon}_{t-1}+{\varepsilon}_t=\dots \sum \limits_{i=0}^{\infty }{\phi}_1^i{\varepsilon}_{t-i} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfs.png)T2】

如果 AR(1)过程可以写成无穷多个过去误差项的和，并且 MA 系数序列绝对可和![$$ \sum \limits_{i=0}^{\infty}\left|{\phi}_1^i\right|&lt;\infty $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq28.png)，则称其为因果过程。因果性是指一个过程可以用一个线性的冲击过程来表达， *ε* <sub>* t *</sub> 。一般来说，有限阶 MA 是无限阶 AR，有限阶 AR 是无限阶 MA。

#### 15.2.2.4 估计

为了使一组数据符合 MA 模型，我们首先通过查看 ACF 来确定顺序 *q* 。MA(q)过程的 ACF 在滞后 *q* + 1 及以上时为零。因此，我们通过检查样本自相关函数来确定估计的适当的最大滞后，以查看对于超过某个滞后的所有滞后，它在哪里变得不显著地不同于零，该滞后被指定为最大滞后 *q* 。

找到 MA 系数并不容易，因为滞后误差项是不可观测的。在 NM Dev 中，我们使用最大似然法来估计系数。类`ConditionalSumOfSquares`实现了这个估计算法。下面的代码演示了从数据中估计系数。它首先定义了一个 MA(2)模型。类`ARIMASim`采用 MA 模型，并根据该模型生成随机数的时间序列。然后，我们估计另一个 MA(2)模型，首先使用 ACF 识别滞后的阶(是 2)，然后拟合时间序列。我们期望估计的系数应该与原始模型中的系数相匹配。

```py
// define an MA(2) model
MAModel ma3 = new MAModel(
        0.1, // the mean
        new double[]{-0.5, 0.01}, // the moving-average coefficients
        10\. // the standard deviation
);

// create a random number generator from the MA model
ARIMASim sim = new ARIMASim(ma3);
sim.seed(1234567890L);

// generate a random time series
final int T = 500; // length of the time series
double[] x = new double[T];
for (int i = 0; i < T; ++i) {
    // call the RNG to generate random numbers according to the specification
    x[i] = sim.nextDouble();
}

// determine the cutoff lag using autocorrelation
SampleAutoCorrelation acf3_hat
        = new SampleAutoCorrelation(new SimpleTimeSeries(x));
for (int i = 0; i < 5; i++) {
    System.out.printf("the empirical acf of a time series at lag%d: %f%n", i, acf3_hat.evaluate(i));
}

// fit an MA(2) model using the data
ConditionalSumOfSquares fit
        = new ConditionalSumOfSquares(
                x,
                0,
                0,
                2); // the MA order
System.out.printf("theta: %s%n", Arrays.toString(fit.getARMAModel().theta()));
System.out.printf("var of error term: %s%n", fit.var());

```

输出如下所示:

```py
the empirical acf of a time series at lag0: 1.000000
the empirical acf of a time series at lag1: -0.400610
the empirical acf of a time series at lag2: 0.021983
the empirical acf of a time series at lag3: -0.056620
the empirical acf of a time series at lag4: 0.034655
theta: [1.0, -0.4990165791512235, -0.00881872629264049]
var of error term: 98.13651792771375

```

用于生成随机时间序列的原始模型是![$$ \left\{\begin{array}{c}{\phi}_1=-0.5\\ {}{\phi}_2=0.01\\ {}{\sigma}^2=100\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq29.png)。

估计系数和估计方差为![$$ \left\{\begin{array}{c}{\hat{\phi}}_1=-0.4990\\ {}{\hat{\phi}}_2=-0.0088\\ {}{\hat{\sigma}}^2=98.1365\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq30.png)。他们相当接近。

#### 15.2.2.5 天气预报

给定一个 MA(q)过程:

![$$ {X}_t={\theta}_0+{\theta}_1{\varepsilon}_{t-1}+{\theta}_2{\varepsilon}_{t-2}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equft.png)

单步预测如下:

![$$ {f}_{t+1}=E\left({X}_{t+1}|{X}_1,\dots, {X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfu.png)

![$$ =E\left({\theta}_0+{\theta}_1{\varepsilon}_t+{\theta}_2{\varepsilon}_{t-1}+\dots +{\theta}_q{\varepsilon}_{t-q+1}+{\varepsilon}_{t+1}\ |\ {X}_1,\dots, {X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfv.png)

![$$ ={\theta}_0+{\theta}_1{\varepsilon}_t+{\theta}_2{\varepsilon}_{t-1}+\dots +{\theta}_q{\varepsilon}_{t-q+1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfw.png)

同样，对于两步预测 *f* <sub>*t* + 2</sub> ，我们有这样的:

![$$ {f}_{t+2}=E\left({X}_{t+2}\ |\ {X}_1,\dots, {X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfx.png)

![$$ =E\left({\theta}_0+{\theta}_1{\varepsilon}_{t+1}+{\theta}_2{\varepsilon}_t+\dots +{\theta}_q{\varepsilon}_{t-q+2}+{\varepsilon}_{t+2}\ |\ {X}_1,\dots {X}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfy.png)

![$$ ={\theta}_0+{\theta}_2{\varepsilon}_t+\dots +{\varepsilon}_q{\varepsilon}_{t-q+2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equfz.png)

我们需要计算过去的误差项(创新)。任何未来误差项的期望值为 0。因此，对于一个 n 步预测，其中 *n* > *q* ，预测是过程 *θ* <sub>0</sub> 的均值。

![$$ {f}_{t+n}={\theta}_0,n&gt;p $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equga.png)

在 NM Dev 中，类`ARMAForecast`接受模型规范并计算下一个 n 步预测。以下代码片段延续了前面的示例，并计算接下来的 10 个 n 步预测:

```py
// make forecast
ARMAForecast forecast_ma3
        = new ARMAForecast(new SimpleTimeSeries(x), ma3);
System.out.println("The forecasts for the MA(2) model are");
for (int j = 0; j < 10; ++j) {
    System.out.println(forecast_ma3.next());
}

```

输出如下所示:

```py
The forecasts for the MA(2) model are
[1001]: -3.918696 (1.000000)
[1002]: 0.180772 (1.250000)
[1003]: 0.100000 (1.250100)
[1004]: 0.100000 (1.250100)
[1005]: 0.100000 (1.250100)
[1006]: 0.100000 (1.250100)
[1007]: 0.100000 (1.250100)
[1008]: 0.100000 (1.250100)
[1009]: 0.100000 (1.250100)
[1010]: 0.100000 (1.250100)

```

注意，接下来两个预测之外的所有预测都只是平均值 *θ* <sub>0</sub> = 0.1。

### ARMA 模型

ARMA 模型结合了 AR 模型和 MA 模型，其中未来值取决于过去的观察值和过去的创新值(误差项)。

#### 15.2.3.1 ARMA(1，1)

最简单的情况是 ARMA(1，1)模型，它结合了 AR(1)和 MA(1)。模型结构如下(假设 *μ* = 0 或贬低*X*<sub>T5】t</sub>—*μ*):

![$$ {X}_t={\phi}_1{X}_{t-1}+{\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgb.png)

或者经常这样写，AR 项在等式左边，MA 项在右边:

![$$ {X}_t-{\phi}_1{X}_{t-1}={\theta}_1{\varepsilon}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgc.png)

其中*ε*<sub>T3】tT5】为 i.i.d .白噪声。</sub>

当*<sub>1</sub>≦*θ*<sub>1</sub>时，我们可以用后移算子:*

*![$$ \left(1-{\phi}_1B\right){X}_t=\left(1+{\theta}_1B\right){\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgd.png)*

*来写模型

或者相当于，

![$$ {X}_t=\frac{\left(1+{\theta}_1B\right)}{\left(1-{\phi}_1B\right)}{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equge.png)

否则，通过将(1*ϕ*T2】1T4】b 或(1+*θ*t8】1*b*)分两边，模型就变成了白噪声。

展开如下:

![$$ \frac{\left(1+{\theta}_1B\right)}{\left(1-{\phi}_1B\right)}=\left(1+{\phi}_1B+{\phi}_1^2{B}^2+{\phi}_1^3{B}^3+\dots \right)\left(1+{\theta}_1B\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgf.png)

![$$ =1+{\phi}_1B+{\phi}_1^2{B}^2+{\phi}_1^3{B}^3+\dots +{\theta}_1B+{\phi}_1{\theta}_1{B}^2+{\phi}_1^2{\theta}_1{B}^3+{\phi}_1^3{\theta}_1{B}^4+\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgg.png)

![$$ =1+\left({\phi}_1+{\theta}_1\right)B+\left({\phi}_1^2+{\phi}_1{\theta}_1\right){B}^2+\left({\phi}_1^3+{\phi}_1^2{\theta}_1\right){B}^3+\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgh.png)

![$$ =1+\left({\phi}_1+{\theta}_1\right)B+\left({\phi}_1+{\theta}_1\right){\phi}_1{B}^2+\left({\phi}_1+{\theta}_1\right){\phi}_1^2{B}^3+\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgi.png)

![$$ =\sum \limits_{i=0}^{\infty }{\psi}_i{B}^i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgj.png)

其中*ψ*T2 0= 1 和![$$ {\psi}_i=\left({\phi}_1+{\theta}_1\right){\phi}_1^{i-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq31.png)。

因此，MA(∞)表示如下:

![$$ {X}_t={\varepsilon}_t+\left({\phi}_1+{\theta}_1\right)\sum \limits_{i=1}^{\infty }{\phi}_1^{i-1}{\varepsilon}_{t-i} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgk.png)

这个表示只有当| *ϕ* <sub>1</sub> | < 1 时才有效，所以*ψ*<sub>T7】I</sub>不会因为大 *i* 而爆炸。也就是说，ARMA(1，1)的因果条件(因此是平稳性)是| *ϕ* <sub>1</sub> | < 1。

另外，我们可以这样写:

![$$ {\varepsilon}_t=\frac{\left(1-{\phi}_1B\right)}{\left(1+{\theta}_1B\right)}{X}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgl.png)

考虑这个幂级数展开:

![$$ \frac{1}{1+{\theta}_1x}=\sum \limits_{i=0}^{\infty }{\left(-{\theta}_1\right)}^i{x}^i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgm.png)

结合这两个方程，我们有如下:

![$$ {\varepsilon}_t=\sum \limits_{i=0}^{\infty }{\left(-{\theta}_1\right)}^i{B}^i\left(1-{\phi}_1B\right){X}_t={X}_t-\left({\phi}_1+{\theta}_1\right)\sum \limits_{i=1}^{\infty }{\left(-{\theta}_1\right)}^{i-1}{X}_{t-i} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgn.png)

该表达式仅在| *θ* <sub>1</sub> | < 1 时有效，因此 AR 系数不会爆炸。这是 ARMA(1，1)的可逆条件。我们总结了 ARMA(1，1)过程的因果性和可逆性条件以及它的容许参数，如图 [15-15](#Fig15) 所示。

![$$ \left\{\begin{array}{c}-1&lt;{\phi}_1&lt;1\\ {}-1&lt;{\theta}_1&lt;1\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgo.png)

我们通常假设 ARMA 过程是平稳的、因果的和可逆的，因此我们可以在时间序列的 AR 和 MA 表示之间切换。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig15_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig15_HTML.jpg)

图 15-15

ARMA(1，1)的容许参数区域

我们可以使用 MA 形式计算 ARMA(1，1)的 ACVF。

![$$ {X}_t=\sum \limits_{i=0}^{\infty }{\psi}_i{\varepsilon}_{t-i} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgp.png)T2】

然后 ACVF 如下:

![$$ \gamma (k)=\mathrm{E}\left({X}_t{X}_{t-k}\right)=\mathrm{E}\left(\sum \limits_{i=0}^{\infty }{\psi}_i{\varepsilon}_{t-i}\sum \limits_{i=0}^{\infty }{\psi}_i{\varepsilon}_{t-k-i}\right)={\sigma}^2\sum \limits_{i=o}^{\infty }{\psi}_i{\psi}_{i+k} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgq.png)

![$$ \gamma (0)={\sigma}^2\sum \limits_{i=o}^{\infty }{\psi}_i^2={\sigma}^2\left[1+{\left({\phi}_1+{\theta}_1\right)}^2\sum \limits_{i=1}^{\infty }{\phi}_1^{2\left(i-1\right)}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgr.png)

![$$ ={\sigma}^2\left[1+\frac{{\left({\phi}_1+{\theta}_1\right)}^2}{1-{\phi}_1^2}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgs.png)

![$$ \gamma (1)={\sigma}^2\sum \limits_{i=o}^{\infty }{\psi}_i{\psi}_{i+1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgt.png)

![$$ ={\sigma}^2\left[\left({\phi}_1+{\theta}_1\right)+\left({\phi}_1+{\theta}_1\right)\left({\phi}_1+{\theta}_1\right){\phi}_1+\left({\phi}_1+{\theta}_1\right){\phi}_1\left({\phi}_1+{\theta}_1\right){\phi}_1^2+\left({\phi}_1+{\theta}_1\right){\phi}_1^2\left({\phi}_1+{\theta}_1\right){\phi}_1^3+\dots \right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgu.png)

![$$ ={\sigma}^2\left[\left({\phi}_1+{\theta}_1\right)+{\left({\phi}_1+{\theta}_1\right)}^2{\phi}_1\left(1+{\phi}_1^2+{\phi}_1^4+\dots \right)\right]={\sigma}^2\left[\left({\phi}_1+{\theta}_1\right)+{\left({\phi}_1+{\theta}_1\right)}^2{\phi}_1\sum \limits_{i=0}^{\infty }{\phi}_1^{2i}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgv.png)

![$$ ={\sigma}^2\left[\left({\phi}_1+{\theta}_1\right)+\frac{{\left({\phi}_1+{\theta}_1\right)}^2{\phi}_1}{1-{\phi}_1^2}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgw.png)

![$$ \gamma (k)={\phi}_1^{k-1}\gamma (1) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgx.png)

ACF 就是将 *γ* ( *k* )除以 *γ* (0)。

![$$ \rho (1)=\frac{\gamma (1)}{\gamma (0)}=\frac{\sigma^2\left[\left({\phi}_1+{\theta}_1\right)+\frac{{\left({\phi}_1+{\theta}_1\right)}^2{\phi}_1}{1-{\phi}_1^2}\right]}{\sigma^2\left[1+\frac{{\left({\phi}_1+{\theta}_1\right)}^2}{1-{\phi}_1^2}\right]} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgy.png)

![$$ =\frac{\left({\phi}_1+{\theta}_1\right)\left(1+{\phi}_1{\theta}_1\right)}{1+2{\phi}_1{\theta}_1+{\theta}_1^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equgz.png)

![$$ \rho (k)={\phi}_1^{k-1}\rho (1) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equha.png)

注意当*ϕ*<sub>1</sub>=*θ*<sub>1</sub>，*γ*(1)=*γ*(*k*)=*ρ*(1)=*ρ*(*k*)= 0 时。过程只是白噪音。

在 NM Dev 中，我们使用类`ARMAModel`来构造 ARMA 过程。该类签名如下:

```py
public class ARMAModel extends ARIMAModel {

    /**
     * Construct a univariate ARMA model.
     *
     * @param mu    the intercept (constant) term
     * @param AR    the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficients
     * @param MA    the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficients
     * @param sigma the white noise variance
     */
    public ARMAModel(double mu, double[] AR, double[] MA, double sigma) {
        super(mu, AR, 0, MA, sigma);
    }

    /**
     * Construct a univariate ARMA model with unit variance.
     *
     * @param mu the intercept (constant) term
     * @param AR the AR coefficients (excluding the initial 1); {@code null} if
     *           no AR coefficients
     * @param MA the MA coefficients (excluding the initial 1); {@code null} if
     *           no MA coefficients
     */
    public ARMAModel(double mu, double[] AR, double[] MA) {
        this(mu, AR, MA, 1);
    }

    /**
     * Construct a univariate ARMA model with zero-intercept (mu).
     *
     * @param AR    the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficients
     * @param MA    the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficients
     * @param sigma the white noise variance
     */
    public ARMAModel(double[] AR, double[] MA, double sigma) {
        this(0, AR, MA, sigma);
    }

    /**
     * Construct a univariate ARMA model with unit variance and zero-intercept
     * (mu).
     *
     * @param AR the AR coefficients (excluding the initial 1); {@code null} if
     *           no AR coefficients
     * @param MA the MA coefficients (excluding the initial 1); {@code null} if
     *           no MA coefficients
     */
    public ARMAModel(double[] AR, double[] MA) {
        this(AR, MA, 1);
    }

    /**
     * Copy constructor.
     *
     * @param that a univariate ARMA model
     */
    public ARMAModel(ARMAModel that) {
        super(that);
    }

    /**
     * Compute the univariate ARMA conditional mean, given all the lags.
     *
     * @param arLags the AR lags
     * @param maLags the MA lags
     * @return the conditional mean
     */
    public double conditionalMean(double[] arLags, double[] maLags);

    /**
     * Compute the multivariate ARMA unconditional mean.
     *
     * @return the unconditional mean
     */
    public double unconditionalMean();

    /**
     * Get the demeaned version of the time series model.
     * \[
     * Y_t = (X_t - \mu) = \sum_{i=1}^p \phi_i (X_{t-i} - \mu) + \sum_{i=1}^q
     * \theta_j \epsilon_{t-j} + \epsilon_t
     * \]
     * &mu; is the unconditional mean.
     *
     * @return the demeaned time series
     */
    public ARMAModel getDemeanedModel();

```

以下代码为以下 ARMA(1，1)模型构造了一个实例，并计算其 ACVF 和 ACF:

![$$ {X}_t=0.2{X}_{t-1}+{\varepsilon}_t+1.1{\varepsilon}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhb.png)

```py
// build an ARMA(1, 1)
ARMAModel arma11 = new ARMAModel(
        new double[]{0.2}, // the AR coefficients
        new double[]{1.1} // the MA coefficients
);

// compute the autocovariance function for the model
AutoCovariance acvf = new AutoCovariance(arma11);
for (int i = 1; i < 10; i++) {
    System.out.printf("the acvf of the ARMA(1,1) model at lag%d: %f%n", i, acvf.evaluate(i));
}

// compute the autocorrelation function for the model
AutoCorrelation acf = new AutoCorrelation(arma11, 10);
for (int i = 0; i < 10; i++) {
    System.out.printf("the acf of the ARMA(1,1) model at lag%d: %f%n", i, acf.evaluate(i));
}

```

输出如下所示:

```py
the acvf of the ARMA(1,1) model at lag1: 1.652083
the acvf of the ARMA(1,1) model at lag2: 0.330417
the acvf of the ARMA(1,1) model at lag3: 0.066083
the acvf of the ARMA(1,1) model at lag4: 0.013217
the acvf of the ARMA(1,1) model at lag5: 0.002643
the acvf of the ARMA(1,1) model at lag6: 0.000529
the acvf of the ARMA(1,1) model at lag7: 0.000106
the acvf of the ARMA(1,1) model at lag8: 0.000021
the acvf of the ARMA(1,1) model at lag9: 0.000004
the acf of the ARMA(1,1) model at lag0: 1.000000
the acf of the ARMA(1,1) model at lag1: 0.598491
the acf of the ARMA(1,1) model at lag2: 0.119698
the acf of the ARMA(1,1) model at lag3: 0.023940
the acf of the ARMA(1,1) model at lag4: 0.004788
the acf of the ARMA(1,1) model at lag5: 0.000958
the acf of the ARMA(1,1) model at lag6: 0.000192
the acf of the ARMA(1,1) model at lag7: 0.000038
the acf of the ARMA(1,1) model at lag8: 0.000008
the acf of the ARMA(1,1) model at lag9: 0.000002

```

图 [15-16](#Fig16) 根据输出绘制了模型的 ACF。注意 ACF(和 PACF)在滞后 1 后并不消失，尽管它们衰减到 0。对于 ARMA 模型，ACF 和 PACF 没有截止滞后。它们只是 AR 和 MA 顺序的指示。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig16_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig16_HTML.jpg)

图 15-16

ARMA(1，1)过程的 ACF 用*ϕ*<sub>*1*</sub>=*0.2*，*θ*<sub>*1*</sub>=*1.1*

#### 15.2.3.2 武器(p、q)

ARMA(p，q)模型结合了 AR(p)模型和 MA(q)模型。前者将自己过去的行为作为模型的输入，以解释金融交易市场中经常观察到的动量效应和均值回复效应。后者包含了冲击效应，如影响过程的意外事件，如意外收益公告、战争和新冠肺炎。因此，ARMA 模型在对时间序列建模时试图捕捉这两个方面。请注意，AR、MA 和 ARMA 都模拟过程的一阶(水平),而不是二阶(波动),如波动聚类，这是许多金融时间序列的一个关键经验现象。这将是第 [15.2.5](#Sec33) 节的主题。

ARMA(p，q)模型被定义为 AR(p)模型和 MA(q)模型的和，其中 *p* 是 AR 模型的阶，而 *q* 是 MA 模型的阶。模型结构如下(假设 *μ* = 0 或贬低*X*<sub>*t*</sub>—*μ*):

![$$ {X}_t={\phi}_1{X}_{t-1}+\dots +{\phi}_p{X}_{t-p}+{\theta}_1{\varepsilon}_{t-1}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhc.png)

或者经常这样写，AR 项在方程左边，MA 项在右边:

![$$ {X}_t-{\phi}_1{X}_{t-1}-\dots -{\phi}_p{X}_{t-p}={\varepsilon}_t+{\theta}_1{\varepsilon}_{t-1}+\dots +{\theta}_q{\varepsilon}_{t-q} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhd.png)

其中*ε*<sub>T3】tT5】为 i.i.d .白噪声。</sub>

我们可以用后移算子来写这个模型:

![$$ \left(1-\sum \limits_{i=1}^p{\phi}_i{B}^i\right){X}_t=\left(1+\sum \limits_{i=1}^q{\theta}_i{B}^i\right){\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhe.png)

或者等价地，

![$$ {X}_t=\frac{\left(1+\sum \limits_{i=1}^q{\theta}_i{B}^i\right)}{\left(1-\sum \limits_{i=1}^p{\phi}_i{B}^i\right)}{\varepsilon}_t=\frac{\theta (B)}{\phi (B)}{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhf.png)

其中 *B* 是滞后算子， *ε* <sub>*t*</sub> 误差项， *ϕ* <sub>*t*</sub> 自回归系数， *θ* <sub>*t*</sub> 移动平均系数。

这个模型需要对 *θ* ( *B* )和 *ϕ* ( *B* )施加若干条件。它们如下:

*   多项式 *ϕ* ( *B* )和 *θ* ( *B* )没有共同零点的可辨识性条件；否则，我们将![$$ \frac{0}{0} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq32.png)除以两个多项式。

*   *ϕ* (0) = *θ* (0) = 1 的归一化条件。

*   {*X*<sub>T3】tT5】}是静止的。</sub>

*   {*X*<sub>T3】tT5】}是可逆的。</sub>

*   {*X*<sub>T3】tT5】}是因果。</sub>

最后一个因果条件是指存在一个绝对可和的系数序列{ *ψ* <sub>*i*</sub> }使得 *X* <sub>*t*</sub> 可以写成无穷多个项的和。这种白噪声的无限线性组合称为时间序列的线性表示。

![$$ {X}_t=\sum \limits_{i=0}^{\infty }{\psi}_i{\varepsilon}_{t-i}=\underset{\psi (B)}{\underbrace{\left(\sum \limits_{i=0}^{\infty }{\psi}_i{B}^i\right)}}{\varepsilon}_t=\psi (B){\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhg.png)

![$$ \psi (B)=\frac{\theta (B)}{\phi (B)}=\sum \limits_{i=0}^{\infty }{\psi}_i{B}^i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhh.png)让:

我们可以使用下面的等式求解*ψ*<sub>T3】IT5】的值:</sub>

![$$ \psi (B)\phi (B)=\theta (B) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhi.png)

即

![$$ \left({\psi}_0+{\psi}_1B+{\psi}_2{B}^2+\dots \right)\left(1-{\phi}_1B-\dots \right)=\left(1+{\theta}_1B+{\theta}_2{B}^2+\dots \right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhj.png)

![$$ {\psi}_0-{\psi}_0{\phi}_1B+{\psi}_1B+{\psi}_2{B}^2-{\psi}_1{\phi}_1{B}^2+\dots =1+{\theta}_1B+{\theta}_2{B}^2+\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhk.png)

![$$ {\psi}_0+\left(-{\psi}_0{\phi}_1+{\psi}_1\right)B+\left({\psi}_2-{\psi}_1{\phi}_1\right){B}^2+\dots =1+{\theta}_1B+{\theta}_2{B}^2+\dots $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhl.png)

通过匹配 *B* 的系数，我们得到如下结果。

对于滞后 0，我们有这样的:

![$$ {\psi}_0=1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhm.png)

![$$ -{\psi}_0{\phi}_1+{\psi}_1={\theta}_1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhn.png)

![$$ {\psi}_1={\theta}_1+{\psi}_0{\phi}_1={\theta}_1+{\phi}_1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equho.png)

为滞后 1

对于一个 ARMA(1，1)过程，其中*ψ*<sub>*I*</sub>=*θ*<sub>*I*</sub>= 0， *i* ≥ 2，我们有如下。

对于滞后 2，我们有这样的:

![$$ {\psi}_2-{\psi}_1{\phi}_1=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhp.png)

![$$ {\psi}_2={\phi}_1{\psi}_1={\phi}_1\left({\theta}_1+{\phi}_1\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhq.png)

对于滞后 *k* 其中 *k* ≥ 2，我们有这样的:

![$$ {\psi}_k-{\psi}_{k-1}\phi =0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhr.png)

![$$ {\psi}_k={\phi}_1{\psi}_{k-1}={\psi}_1{\phi_1}^{k-1}=\left({\theta}_1+{\phi}_1\right){\phi_1}^{k-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhs.png)

在 NM Dev 中，类`LinearRepresentation`计算 ARMA 过程的线性表示，并计算 *ψ* <sub>*k*</sub> 的值。假设我们有这个:

![$$ {X}_t-0.2{X}_{t-1}={\varepsilon}_t+1.1{\varepsilon}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equht.png)

*<sub>【1】</sub>= 0.2，*= 1.1。**

 **以下代码求解前 20 个滞后的 *ψ* <sub>*k*</sub> :

```py
// build an ARMA(1, 1)
ARMAModel arma11 = new ARMAModel(
        new double[]{0.2}, // the AR coefficients
        new double[]{1.1} // the MA coefficients
);

// compute the linear representation
LinearRepresentation ma = new LinearRepresentation(arma11);
for (int i = 1; i < 20; i++) {
    System.out.printf("the coefficients of the linear representation at lag %d = %f%n", i, ma.AR(i));
}

```

输出如下所示:

```py
the coefficients of the linear representation at lag 1 = 1.300000
the coefficients of the linear representation at lag 2 = 0.260000
the coefficients of the linear representation at lag 3 = 0.052000
the coefficients of the linear representation at lag 4 = 0.010400
the coefficients of the linear representation at lag 5 = 0.002080
the coefficients of the linear representation at lag 6 = 0.000416
the coefficients of the linear representation at lag 7 = 0.000083
the coefficients of the linear representation at lag 8 = 0.000017
the coefficients of the linear representation at lag 9 = 0.000003
the coefficients of the linear representation at lag 10 = 0.000001
the coefficients of the linear representation at lag 11 = 0.000000
the coefficients of the linear representation at lag 12 = 0.000000
the coefficients of the linear representation at lag 13 = 0.000000
the coefficients of the linear representation at lag 14 = 0.000000
the coefficients of the linear representation at lag 15 = 0.000000
the coefficients of the linear representation at lag 16 = 0.000000
the coefficients of the linear representation at lag 17 = 0.000000
the coefficients of the linear representation at lag 18 = 0.000000
the coefficients of the linear representation at lag 19 = 0.000000
the coefficients of the linear representation at lag 20 = 0.000000

```

因为系数是绝对可和的，所以最终会收敛到 0。

ARMA 的线性表示是移动平均项的无限和。使用 15.2.3.2 的结果，我们可以计算 ARMA 的自协方差函数。【T2![$$ \gamma \left(\left|k\right|\right)=\sum \limits_{i=0}^{\infty }{\psi}_i{\psi}_{i+\left|k\right|} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhu.png)

自相关如下:

![$$ \rho (k)=\frac{\gamma (k)}{\gamma (0)} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhv.png)

可以证明序列{ *γ* ( *k* )}也是绝对可和的。换句话说，我们有这个:

![$$ \sum \limits_{k=-\infty}^{\infty}\left|\gamma (k)\right|&lt;\infty $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhw.png)

因此，随着滞后数变大，自协方差收敛到 0。换句话说，我们有这个:

![$$ \underset{k\to \infty }{\lim}\gamma (k)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhx.png)

以下代码计算 ARMA(2，3)模型的线性表示、自协方差和自相关:

![$$ {X}_t=0.6{X}_{t-1}-0.23{X}_{t-2}+0.1{\varepsilon}_{t-1}+0.2{\varepsilon}_{t-2}+0.4{\varepsilon}_{t-3}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhy.png)

```py
// build an ARMA(2, 3)
ARMAModel arma23 = new ARMAModel(
        new double[]{0.6, -0.23}, // the AR coefficients
        new double[]{0.1, 0.2, 0.4} // the MA coefficients
);

// compute the linear representation
LinearRepresentation ma = new LinearRepresentation(arma23);
for (int i = 1; i <= 20; i++) {
    System.out.printf("the coefficients of the linear representation at lag %d = %f%n", i, ma.AR(i));
}

// compute the autocovariance function for the model
AutoCovariance acvf = new AutoCovariance(arma23);
for (int i = 1; i < 10; i++) {
    System.out.printf("the acvf of the ARMA(2,3) model at lag%d: %f%n", i, acvf.evaluate(i));
}

// compute the autocorrelation function for the model
AutoCorrelation acf = new AutoCorrelation(arma23, 10);
for (int i = 0; i < 10; i++) {
    System.out.printf("the acf of the ARMA(2,3) model at lag%d: %f%n", i, acf.evaluate(i));
}

```

输出如下所示:

```py
the coefficients of the linear representation at lag 1 = 0.700000
the coefficients of the linear representation at lag 2 = 0.390000
the coefficients of the linear representation at lag 3 = 0.473000
the coefficients of the linear representation at lag 4 = 0.194100
the coefficients of the linear representation at lag 5 = 0.007670
the coefficients of the linear representation at lag 6 = -0.040041
the coefficients of the linear representation at lag 7 = -0.025789
the coefficients of the linear representation at lag 8 = -0.006264
the coefficients of the linear representation at lag 9 = 0.002173
the coefficients of the linear representation at lag 10 = 0.002745
the coefficients of the linear representation at lag 11 = 0.001147
the coefficients of the linear representation at lag 12 = 0.000057
the coefficients of the linear representation at lag 13 = -0.000230
the coefficients of the linear representation at lag 14 = -0.000151
the coefficients of the linear representation at lag 15 = -0.000038
the coefficients of the linear representation at lag 16 = 0.000000
the coefficients of the linear representation at lag 17 = 0.000000
the coefficients of the linear representation at lag 18 = 0.000000
the coefficients of the linear representation at lag 19 = 0.000000
the coefficients of the linear representation at lag 20 = 0.000000
the acvf of the ARMA(2,3) model at lag1: 1.251651
the acvf of the ARMA(2,3) model at lag2: 0.792637
the acvf of the ARMA(2,3) model at lag3: 0.587703
the acvf of the ARMA(2,3) model at lag4: 0.170315
the acvf of the ARMA(2,3) model at lag5: -0.032983
the acvf of the ARMA(2,3) model at lag6: -0.058962
the acvf of the ARMA(2,3) model at lag7: -0.027791
the acvf of the ARMA(2,3) model at lag8: -0.003113
the acvf of the ARMA(2,3) model at lag9: 0.004524
the acf of the ARMA(2,3) model at lag0: 1.000000
the acf of the ARMA(2,3) model at lag1: 0.656730
the acf of the ARMA(2,3) model at lag2: 0.415890
the acf of the ARMA(2,3) model at lag3: 0.308362
the acf of the ARMA(2,3) model at lag4: 0.089363
the acf of the ARMA(2,3) model at lag5: -0.017306
the acf of the ARMA(2,3) model at lag6: -0.030937
the acf of the ARMA(2,3) model at lag7: -0.014582
the acf of the ARMA(2,3) model at lag8: -0.001634
the acf of the ARMA(2,3) model at lag9: 0.002374

```

图 [15-17](#Fig17) 描绘了 ARMA(2，3)过程的 ACF。虽然 ACF(和 PACF)在滞后 *q* (和 *p* )之后指数收敛到 0，但是 arMA 没有明确的截止滞后来确定 *p* 或 *q* ，这与 AR 或 MA 模型的曲线不同。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig17_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig17_HTML.jpg)

图 15-17

ARMA(2，3)过程的 ACF

#### 15.2.3.3 天气预报

给定所有观测值{ *X* <sub>1</sub> ， *X* <sub>2</sub> ，对下一步![$$ {\hat{X}}_{n+1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq33.png)进行预测，...，*X*<sub>*n*</sub>}对于一个(零均值或贬低)ARMA 模型与计算条件均值相同，如下图:

![$$ {\hat{X}}_{n+1}=g\left({X}_1,{X}_2,\dots, {X}_n\right)=\mathrm{E}\left({X}_{n+1}\ |\ {X}_1,{X}_2,\dots, {X}_n\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equhz.png)

使得均方误差最小:

![$$ \underset{g}{\min}\mathrm{E}{\left({X}_{n+1}-\mathrm{g}\left({X}_1,{X}_2,\dots, {X}_n\right)\right)}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equia.png)

一般来说， *g* 是一个非线性函数，但我们会希望找到一个(最佳)线性预测器。也就是说， *g* 是过去观测值的线性组合，使得以下为真:

![$$ \underset{\boldsymbol{a}}{\min}\mathrm{E}{\left({X}_{n+1}-\sum \limits_{i=1}^n{a}_i{X}_{n+1-i}\right)}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equib.png)

为了求解 ***a*** ，我们将使用预测误差和观测值不相关的等价公式。

![$$ \mathrm{E}\left({X}_{n+1}-{\hat{X}}_{n+1}\right){X}_j=0,j=1,2,\dots, n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equic.png)

将![$$ {\hat{X}}_{n+1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq34.png)替换为线性预测值，如下图:

![$$ \mathrm{E}\left({X}_{n+1}-\sum \limits_{i=1}^n{a}_i{X}_{n+1-i}\right){X}_j=0,j=1,2,\dots, n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equid.png)

展开它，如下图:

![$$ \mathrm{E}\left({X}_{n+1}{X}_j\right)=\mathrm{E}\left({X}_j\sum \limits_{i=1}^n{a}_i{X}_{n+1-i}\right),j=1,2,\dots, n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equie.png)

![$$ \mathrm{E}\left({X}_{n+1}{X}_j\right)=\sum \limits_{i=1}^n{a}_i\mathrm{E}\left({X}_j{X}_{n+1-i}\right),j=1,2,\dots, n $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equif.png)

![$$ \left\{\begin{array}{c}\mathrm{E}\left({X}_{n+1}{X}_1\right)=\sum \limits_{i=1}^n{a}_i\mathrm{E}\left({X}_1{X}_{n+1-i}\right)\\ {}\mathrm{E}\left({X}_{n+1}{X}_2\right)=\sum \limits_{i=1}^n{a}_i\mathrm{E}\left({X}_2{X}_{n+1-i}\right)\\ {}\vdots \end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equig.png)

在 ACF 方面，我们有这样的:

![$$ \left\{\begin{array}{c}\gamma (n)=\sum \limits_{i=1}^n{a}_i\gamma \left(n-i\right)\\ {}\gamma \left(n-i\right)=\sum \limits_{i=1}^n{a}_i\gamma \left(n-i-1\right)\\ {}\vdots \end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equih.png)

在矩阵符号中，我们有这样的:

![$$ \boldsymbol{\gamma} ={\boldsymbol{\Gamma}}_{\boldsymbol{n}}\boldsymbol{a} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equii.png)

其中****<sub>*【ij】*</sub>**=******

 ****求解这个矩阵方程将给出下一步预测的最佳线性预测器。

![$$ {\hat{X}}_{n+1}=\sum \limits_{i=1}^n{a}_i{X}_{n+1-i} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq35.png)，其中![$$ \boldsymbol{a}={\boldsymbol{\Gamma}}_{\boldsymbol{n}}^{-\mathbf{1}}\boldsymbol{\gamma} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq36.png)

在实践中，我们使用迭代算法来求解**，而不是求解数值上困难的矩阵方程，特别是当 *n* 很大时。迭代将为 *j* = 1，2，...、 *n* 、 *n* + 1。这个 Yule-Walker 方程可以扩展到一步以上的预测。**

 **在 NM Dev 中，类`ARMAForecastOneStep`实现迭代创新算法来计算一步预测。(类`ARMAForecastMultiStep`计算 h 步预测。)它采用一系列的观察和模型规范，并输出随时间变化的条件期望。例如，以下代码根据 ARMA(1，1)模型生成随机时间序列，并计算每个时间步长的条件期望:

```py
// define an ARMA(1, 1)
ARMAModel arma11 = new ARMAModel(
        new double[]{0.2}, // the AR coefficients
        new double[]{1.1} // the MA coefficients
);

// create a random number generator from the ARMA model
ARIMASim sim = new ARIMASim(arma11);
sim.seed(1234567890L);

// generate a random time series
final int T = 50; // length of the time series
double[] x = new double[T];
for (int i = 0; i < T; ++i) {
    // call the RNG to generate random numbers according to the specification
    x[i] = sim.nextDouble();
}

// compute the one-step conditional expectations for the model
ARMAForecastOneStep forecaset = new ARMAForecastOneStep(x, arma11);
double[] x_hat = new double[T];
double[] residuals = new double[T];
for (int i = 0; i < T; ++i) {
    // the one-step conditional expectations
    x_hat[i] = forecaset.xHat(i);
    // the errors
    residuals[i] = x[i] - x_hat[i];
}

System.out.println(Arrays.toString(x));
System.out.println(Arrays.toString(x_hat));
System.out.println(Arrays.toString(residuals));

```

输出如下所示:

![../images/500382_1_En_15_Chapter/500382_1_En_15_Figb_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Figb_HTML.jpg)

图 [15-18](#Fig18) 描绘了输出。观测值是红线，一步预测是蓝线。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig18_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig18_HTML.png)

图 15-18

观察值(红色)与条件期望值(蓝色)

图 [15-19](#Fig19) 描绘了观察值和条件期望值之间的误差或差异。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig19_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig19_HTML.png)

图 15-19

错误

#### 15.2.3.4 估计

一般来说，给定一个数据集，我们将使用 ACF 和 PACF 图来确定一个模型来拟合数据。如果 PACF 曲线在 *p* 显著滞后之后急剧下降，并且 ACF 曲线逐渐下降，这是 AR(p)过程的良好指示。如果 ACF 曲线在 *q* 显著滞后之后急剧下降，并且 PACF 曲线逐渐下降，这是 MA(q)过程的良好指示。另一方面，如果 ACF 和 PACF 曲线都逐渐下降，那么应该考虑使用 ARMA 过程进行建模。虽然 ACF 和 PACF 没有截止延迟，但是它们在哪里减小可以指示正确的顺序。例如，如果 ACF 和 PACF 在滞后 1 后都很小，我们可以尝试 ARMA(1，1)。我们还应该尝试其他一些竞争模型，如 ARMA(0，1)，ARMA(1，0)，ARMA(2，1)，ARMA(1，2)和 ARMA(2，2)。我们将数据拟合到这些模型中的每一个，并通过选择具有最小 AIC、AICc(或 BIC)的模型来选择池中的最佳模型。然后，我们检查拟合优度来验证选择。

AIC 的定义如下:

![$$ AIC=-2\ln (L)+2k $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equij.png)

其中 ln( *L* )是模型的对数似然函数， *k* 是参数的数量。

AICc 定义如下:

![$$ AICc=-2\ln (L)+2k+\frac{2k\left(k+1\right)}{n-k-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equik.png)

其中 ln( *L* )为模型的对数似然函数， *k* 为参数个数， *n* 为样本量。

为了适应每个可能的模型，NM Dev 类`ConditionalSumOfSquares`使用条件平方和方法。最大似然法是利用数据中的所有信息，而不是像矩法那样只利用一阶和二阶矩。NM Dev 使用的似然函数，根据 ARMA 模型参数{***【ϕ】***、 ***θ*** 、 *σ* <sup>2</sup> }，如下:

![$$ L\left(\boldsymbol{\phi}, \boldsymbol{\theta}, {\sigma}^2\right)=n\log \left({\sigma}^2\right)+\frac{1}{\sigma^2}\sum \limits_{t=1}^n{\left({X}_t-{\hat{X}}_t\right)}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equil.png)

它所做的是根据 AR 系数**找到 ARMA(p，q)模型的完整规范；**【θ】**，MA 系数；和*σ*T10】2，误差项的方差；从而使观察值 *X* <sub>*t*</sub> 和预测值/期望值![$$ {\hat{X}}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq39.png)之间的平方差最小化。此外，该类为模型选择计算 AIC 和 AICc。该类签名如下:**

```py
public class ConditionalSumOfSquares implements ARMAFit {

    /**
     * Fit an ARIMA model for the observations using CSS. Note that the
     * algorithm fits only an ARMA model. {@code d} is taken as an input. If the
     * differenced input time series is not zero-mean, it is first demeaned
     * before running the algorithm as in Brockwell and Davis. When reporting
     * the model, we compute the intercept to match the mean.
     *
     * @param x             the time series of observations
     * @param p             the number of AR terms
     * @param d             the order of integration
     * @param q             the number of MA terms
     * @param maxIterations the maximum number of iterations
     */
    public ConditionalSumOfSquares(
            double[] x,
            final int p,
            final int d,
            final int q,
            int maxIterations
    );

    /**
     * Fit an ARIMA model for the observations using CSS. Note that the
     * algorithm fits only an ARMA model. {@code d} is taken as an input. If the
     * differenced input time series is not zero-mean, it is first demeaned
     * before running the algorithm as in Brockwell and Davis. When reporting
     * the model, we compute the intercept to match the mean.
     *
     * @param x the time series of observations
     * @param p the number of AR terms
     * @param d the order of integration
     * @param q the number of MA terms
     */
    public ConditionalSumOfSquares(
            double[] x,
            final int p,
            final int d,
            final int q
    );

    /**
     * Get the number of parameters for the estimation/fitting. They are the AR
     * terms, MA terms, and variance (sigma^2).
     *
     * @return the number of parameters
     */
    public int nParams();

    /**
     * Get the fitted ARIMA model.
     *
     * @return the fitted ARIMA model
     */
    @Override
    public ARIMAModel getModel();

    /**
     * Get the fitted ARMA model.
     *
     * @return the fitted ARMA model
     */
    public ARMAModel getARMAModel();

    @Override
    public double var();

    /**
     * Get the asymptotic covariance matrix of the estimated parameters,
     * <i>&phi;</i> and <i>&theta;</i>. The estimators are asymptotically
     * normal.
     *
     * @return the asymptotic covariance matrix
     * @see "P. J. Brockwell and R. A. Davis, "Eq. 10.8.27, Thm. 10.8.2, Chapter
     * 10.8, Model Building and Forecasting with ARIMA Processes," Time Series:
     * Theory and Methods, Springer, 2006."
     */
    @Override
    public Matrix covariance();

    /**
     * Get the asymptotic standard errors of the estimated parameters,
     * <i>&phi;</i> and <i>&theta;</i>. The estimators are asymptotically
     * normal.
     *
     * @return the asymptotic errors
     * @see "P. J. Brockwell and R. A. Davis, "Eq. 10.8.27, Thm. 10.8.2, Chapter
     * 10.8, Model Building and Forecasting with ARIMA Processes," Time Series:
     * Theory and Methods, Springer, 2006."
     */
    @Override
    public ImmutableVector stderr();

    /**
     * Compute the AIC, a model selection criterion.
     *
     * @return the AIC
     * @see
     * <a href="http://en.wikipedia.org/wiki/Akaike_information_criterion">Wikipedia:
     * Akaike
     * information criterion</a>
     */
    @Override
    public double AIC();

    /**
     * Compute the AICc, a model selection criterion.
     *
     * @return the AICc
     * @see "P. J. Brockwell and R. A. Davis, "Eq. 9.2.1, Chapter 9.2, Model
     * Building and Forecasting with ARIMA Processes," Time Series: Theory and
     * Methods, Springer, 2006."
     */
    @Override
    public double AICC();
}

```

在拟合模型参数之后，为了确定所选择的 ARMA(p，q)模型是否是对数据的良好拟合，我们验证残差![$$ {r}_t={X}_t-{\overline{X}}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq40.png)应该是没有序列相关性的白噪声过程。我们可以对残差进行 Ljung-Box 检验，以检查任何非零自相关。![$$ {\upchi}_m^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq41.png)测试的自由度是*m*=*l*(*p*+*q*)，这是要检查的滞后数减去模型参数数。如果检验的 p 值小于所需的显著性，比如说 5 %,则残差中存在拟合模型无法解释的自相关。我们需要选择不同的模式。否则，我们可以得出结论，残差是独立的白噪声，因此是一个很好的模型选择。

下面的代码演示了我们如何将模型拟合到数据中，并测试其拟合度。我们首先从一个(已知的)模型中创建一个随机时间序列{ *X* <sub>*t*</sub> }。然后我们用 ARMA(1，1)模型来拟合数据。(此时我们只是猜测 *p* = *q* = 1。如果它没有通过拟合优度测试，我们将不得不选择另一对订单。)使用拟合模型，我们计算拟合值![$$ \left\{{\overline{X}}_t\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq42.png)和残差![$$ {r}_t={X}_t-{\overline{X}}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq43.png)。最后，我们使用类`LjungBox`直到前四个滞后来测试残差是否是白噪声。无效假设是所有四个滞后的 ACF 都为零。因此，自由度为(4(1+1))= 2。(由于 ARMA(1，1)模型中模型参数的数量，自由度减少了 2。)

```py
// define an ARMA(1, 1)
ARMAModel arma11 = new ARMAModel(
        new double[]{0.2}, // the AR coefficients
        new double[]{1.1} // the MA coefficients
);

// create a random number generator from the ARMA model
ARIMASim sim = new ARIMASim(arma11);
sim.seed(1234567890L);

// generate a random time series
final int T = 50; // length of the time series
double[] x = new double[T];
for (int i = 0; i < T; ++i) {
    // call the RNG to generate random numbers according to the specification
    x[i] = sim.nextDouble();
}

// fit an ARMA(1,1) model
ConditionalSumOfSquares css
        = new ConditionalSumOfSquares(x, 1, 0, 1);
ARMAModel arma11_css = css.getARMAModel();
System.out.printf("The fitted ARMA(1,1) model is %s%n", arma11_css);
System.out.printf("The fitted ARMA(1,1) model, demeanded, is %s%n", arma11_css.getDemeanedModel());
System.out.printf("AIC = %f%n", css.AIC());

// compute the fitted values using the fitted model
ARMAForecastOneStep forecaset = new ARMAForecastOneStep(x, arma11_css);
double[] x_hat = new double[T];
double[] residuals = new double[T];
for (int i = 0; i < T; ++i) {
    // the fitted value
    x_hat[i] = forecaset.xHat(i);
    // the residuals
    residuals[i] = x[i] - x_hat[i];
}

System.out.println(Arrays.toString(x));
System.out.println(Arrays.toString(x_hat));
System.out.println(Arrays.toString(residuals));

// run the goodness-of-fit test
LjungBox test = new LjungBox(
        residuals,
        4, // check up to the 4-th lag
        2 // number of parameters
);
System.out.printf("The test statistic = %f%n", test.statistics());
System.out.printf("The p-value = %f%n", test.pValue());

```

输出如下所示:

```py
The fitted ARMA(1,1) model is x_t = -0.25855664657157695 + (0.4087316816737802*x_{t-1}) + (1.0193696854247496*e_{t-1}) + e_t; var(e_t) = 0.886664, d = 0
The fitted ARMA(1,1) model, demeanded, is x_t = 0.0 + (0.4087316816737802*x_{t-1}) + (1.0193696854247496*e_{t-1}) + e_t; var(e_t) = 1.000000, d = 0
AIC = 93.971130
The test statistic = 2.686421
The p-value = 0.261006

```

真实过程如下:

![$$ \left\{\begin{array}{c}\mu =0\\ {}{\phi}_1=0.2\\ {}{\theta}_1=1.1\\ {}{\sigma}^2=1\end{array}\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equim.png)

拟合过程如下:

![$$ \left\{\begin{array}{c}\mu =-0.2586\\ {}{\phi}_1=0.4087\\ {}{\theta}_1=1.0194\\ {}{\sigma}^2=0.8867\end{array}\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equin.png)

检验统计量是 2.686421。p 值为 0.261006，大于 5%的显著性水平。因此，我们不能拒绝零，即在滞后 4 之前没有一个自相关系数为零。我们断定残差是随机白噪声。拟合模型是一个很好的拟合。请注意，尽管拟合的模型与生成数据的真实模型不完全一致，特别是在*ϕ*T3】1 上，但它与数据拟合得很好。结果受所使用的数值优化、其实施和样本大小的影响。如果我们在模拟中将样本大小`T`增加到 1000，那么拟合的模型将与真实模型很好地匹配。

图 [15-20](#Fig20) 描绘了观察值(红色)和拟合模型拟合值(蓝色)的时间序列。图 [15-21](#Fig21) 描绘了残差，它看起来很像白噪声。因此，模型与数据吻合得很好。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig21_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig21_HTML.png)

图 15-21

拟合 ARMA(1，1)模型的残差

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig20_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig20_HTML.jpg)

图 15-20

观察值(红色)与拟合值(蓝色)

### ARIMA 模型

到目前为止，我们讨论的 ar、MA 和 ARMA 过程都是平稳过程。它们是均值回归过程，当出现偏差时，有回归均值的趋势。它们的平均值是恒定的，方差也是恒定的。很多现实生活中的数据，比如金融，并不是那样的。例如，图 [15-22](#Fig22) 、*Y*<sub>T5】t</sub>中的标准普尔 500 价格明显呈现(随机)趋势，因此(价格)水平随着时间的推移而上升。价格似乎没有回到均值或水平。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig22_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig22_HTML.jpg)

图 15-22

2015 年至 2019 年标准普尔 500 房价

#### 15.2.4.1 单位根

考虑一个简单的 AR(1)过程(零均值或贬低):

![$$ {Y}_t={\phi}_1{Y}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equio.png)

不同系列如下:

![$$ \Delta {Y}_t={Y}_t-{Y}_{t-1}=\left({\phi}_1-1\right){Y}_{t-1}+{\varepsilon}_t=\lambda {Y}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equip.png)

如果 *λ* = 0，那么当前电平*Y*<sub>T5】t1</sub>对未来值 *Y* <sub>*t*</sub> 没有影响。那么![$$ {Y}_t=\sum \limits_{i=1}^t{\varepsilon}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq44.png)仅仅是白噪声之和，因此是随机游走。另一方面，如果 *λ* < 0，那么当前值*Y*<sub>*t*-1</sub>越正，下一个增量∈*Y*<sub>*t*</sub>越负。另外，当前值*Y*<sub>*t*—1</sub>越负，下一个增量∈*Y*<sub>*t*</sub>越正。因此，我们有均值回归。注意，当 *λ* < 0 时，我们有 *ϕ* <sub> 1 </sub> < 1，这是 AR(1)的(部分)平稳条件。另一方面，当 *λ* = 0 时，我们得到 *ϕ* <sub> 1 </sub> = 1。据说这个过程有一个单位根，并且是非平稳的。

当*ϕ*T2】1= 1 时，有三种单位根过程:无漂移或时间趋势的单位根，有漂移的单位根，有漂移和确定性时间趋势的单位根。

给定一个白噪声过程{*ε*<sub>T3】t</sub>}即同分布且均值为零且方差恒定*σ*T8】2，一个没有漂移或时间趋势的单位根过程如下:

![$$ {Y}_t={Y}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equiq.png)

或者等价地，

![$$ {Y}_t={Y}_0+\sum \limits_{i=1}^t{\varepsilon}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equir.png)

于是，我们有了这个:

![$$ \left\{\begin{array}{c}\mathrm{E}\left(Y\ |\ {Y}_0\right)={Y}_0\\ {}\operatorname{var}\left({Y}_t\ |\ {Y}_0\right)={\sigma}^2t\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equis.png)

也就是说，当*ϕ*T2】1= 1 时，过程的方差是时间 *t* 的线性函数，因此是非平稳的。

一个有漂移 *α* 的单位根过程如下:

![$$ {Y}_t=\alpha +{Y}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equit.png)

或者等价地，

![$$ {Y}_t={Y}_0+\alpha t+\sum \limits_{i=1}^t{\varepsilon}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equiu.png)

于是，我们有了这个:

![$$ \left\{\begin{array}{c}\mathrm{E}\left({Y}_t\ |\ {Y}_0\right)={Y}_0+\alpha t\\ {}\operatorname{var}\left({Y}_t\ |\ {Y}_0\right)={\sigma}^2t\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equiv.png)

也就是说，当 *ϕ* <sub>1</sub> = 1 时，过程的均值和方差都是时间 *t* 的线性函数，因此是非平稳的。

具有漂移和确定性时间趋势的单位根过程如下:

![$$ {Y}_t=\alpha +\beta t+{Y}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equiw.png)

或者等价地，

![$$ {Y}_t={Y}_0+\alpha t+\beta \sum \limits_{i=1}^ti+\sum \limits_{i=1}^t{\varepsilon}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equix.png)

然后，看起来是这样的:

![$$ \left\{\begin{array}{c}\mathrm{E}\left({Y}_t\ |\ {Y}_0\right)={Y}_0+\alpha t+\beta \sum \limits_{i=1}^ti\\ {}\operatorname{var}\left({Y}_t\ |\ {Y}_0\right)={\sigma}^2t\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equiy.png)

也就是说，当 *ϕ* <sub>1</sub> = 1 时，过程的均值和方差都是时间 *t* 的线性函数，因此是非平稳的。漂移和确定性趋势可以通过差分或对数据进行多项式拟合来消除，以获得残差的时间序列。原始时间序列被称为趋势平稳的。

假设检验 Dickey-Fuller (DF)通过检验*ϕ*T2】1= 1 来检查数字单位根。扩展的 Dickey-Fuller (ADF)检验将这一思想推广到更一般的自回归模型，如下所示:

![$$ \Delta {Y}_t=\alpha +\beta t+\lambda {Y}_{t-1}+{\delta}_1\Delta {Y}_{t-1}+\dots +{\delta}_{p-1}\Delta {Y}_{t-p+1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equiz.png)

其中 *α* 为常数漂移， *β* 为时间趋势的系数， *p* 为自回归过程的滞后阶。ADF 测试检验零假设，即 *λ* = 0 或存在单位根。另一个假设是*λ*T13】0。

![$$ \left\{\begin{array}{c}{H}_0:\lambda =0\\ {}{H}_1:\lambda &lt;0\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equja.png)

为了计算检验统计量，我们首先在*Y*T9】t1 上回归*Y*<sub>T3】tT5，得到估计的![$ \hat{\lambda} $](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq45.png)(或![$ {\hat{\phi}}_1 $](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq46.png))及其样本标准差![$ {\hat{\sigma}}_{\hat{\lambda}} $](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq47.png)。测试统计如下:</sub>

![$$ {DF}_{\lambda }=\frac{\hat{\lambda}}{{\hat{\sigma}}_{\hat{\lambda}}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjb.png)

将测试统计数据与来自 Dickey-Fuller 分布的相关临界值进行比较。因为这个测试是单边测试，我们只关心测试统计的负值。如果计算出的检验统计量小于(更负)临界值，那么 *λ* = 0 的零假设被拒绝，我们得出结论，没有单位根，因此平稳性。

NM Dev 类`AugmentedDickeyFuller`实现 ADF 测试。对于我们之前提到的三种情况，有三种不同的 Dickey-Fuller 分布:无漂移或时间趋势( *α* = *β* = 0)，有漂移( *α* ≠ 0， *β* = 0)，有漂移和确定性时间趋势( *α* ≠ 0， *β* ≠ 0)。对于这些情况，临界值是不同的。标志`TrendType.NO_CONSTANT`、`TrendType.CONSTANT`和`TrendType.CONSTANT_TIME`分别代表这三种情况。以下代码演示了如何运行 ADF 测试:

```py
double[] sample = new double[]{0.2, 0.3, -0.1, 0.4, -0.5, 0.6, 0.1, 0.2, 0.2, 0.3, -0.1, 0.4, -0.5, 0.6, 0.1, 0.2};
AugmentedDickeyFuller adf
        = new AugmentedDickeyFuller(
                sample,
                TrendType.CONSTANT, // constant drift term
                4, // the lag order
                null
        );

System.out.println(adf.getNullHypothesis());
System.out.println(adf.getAlternativeHypothesis());
System.out.printf("the p-value for the test = %f%n", adf.pValue());
System.out.printf("the statistics for the test = %f%n", adf.statistics());

```

输出如下所示:

```py
the statistics = -2.641969
the p-value = 0.100000

```

p 值 0.1，太大了。我们无法在 5%的显著性水平上拒绝零假设。我们得出结论，这个数据有一个单位根，并且不是平稳的。

我们在 r 中运行同样的例子。

```py
there is a unit root in the process, hence non-stationarity
there is no unit root in the process, hence stationarity
the p-value for the test = 0.100000
the statistics for the test = -2.641969

```

R 输出如下所示:

```py
        Augmented Dickey-Fuller Test

data:  c(x, x)
Dickey-Fuller = -2.642, Lag order = 4, p-value = 0.3278
alternative hypothesis: stationary

```

虽然来自两个代码片段的统计数据匹配，但是 p 值非常不同(NM Dev 的 0.1 对 R 的 0.3278)。我相信 R 的结果是错误的，因为 R 实际上没有实现 Dickey-Fuller 分布。r 只有一些临界值的表格。为了计算统计的 p 值，R 使用表中几个临界值的插值。这里是 R 的计算:

![$$ \frac{0.9-0.1}{3.24-1.14}=\frac{x-0.1}{3.24-2.642} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjc.png)

![$$ x=\frac{0.8}{3.24-1.14}\left(3.24-2.642\right)+0.1=0.3278 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjd.png)

值-3.24 和-1.14 来自 Banerjee、Dolado、Galbraith 和 Hendry (1993 年)的表 4.2c。

相反，NM Dev 实现了三个 Dickey-Fuller 发行版。p 值是每次根据分布计算的，而不是根据表中的几个临界值进行查找和插值。

继续我们在图 [15-22](#Fig22) 中的标准普尔 500 例子，下面的代码测试在每日价格中是否有单位根:

```py
AugmentedDickeyFuller adf
        = new AugmentedDickeyFuller(spx.toArray());
System.out.println(adf.getNullHypothesis());
System.out.println(adf.getAlternativeHypothesis());
System.out.printf("the p-value for the test = %f%n", adf.pValue());
System.out.printf("the statistics for the test = %f%n", adf.statistics());

```

输出如下所示:

```py
the p-value for the test = 0.200000
the statistics for the test = -2.767399

```

结果显示 p 值为 0.200，因此我们无法在 5%的显著性水平上拒绝空值。我们得出结论，标准普尔 500 的数据有一个单位根，并且不是稳定的。

#### 15.2.4.2 ARIMA(p、d、q)

根据 ADF 检验，标准普尔 500 价格不是稳定的。然而，如 15.1 节所示，价格差异∈*Y*<sub>T3】tT5】像白噪声一样是平稳的。</sub>

![$$ \Delta {Y}_t={Y}_t-{Y}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equje.png)

我们可以把 *Y* <sub>*t*</sub> 写成差分数列的一阶累积和。

![$$ {Y}_t=\sum \limits_{k=1}^t\Delta {Y}_k $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjf.png)

*Y* <sub>*t*</sub> 被称为具有一阶积分或者将被一阶积分。在数学中，积分这个词意味着求和。在微积分中，积分是无穷小元素的和；这里是时间序列的总和。

更一般地，如果需要 *d* 个差值来获得协方差平稳序列，则时间序列被积分为 *d* 阶，表示为 *I* ( *d* )。也就是下面的:

![$$ {\Delta }^d{Y}_k={\left(1-B\right)}^d{Y}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjg.png)

是静止的。

*Y* <sub>*t*</sub> 是差分数列的第 *d* 阶累计和，如下图:

![$$ {Y}_t=\sum \limits_{k=1}^t\dots \sum \limits_{k=1}^t{\Delta }^d{Y}_k $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjh.png)

实际上， *d* 很难超过 2。

一般来说，一个 ARIMA(p，d，q)过程 *Y* <sub>*t*</sub> 是这样的，如果我们做差分 *d* 次，新的时间序列∈<sup>*d*</sup>*Y*<sub>*k*</sub>是平稳的 ARMA 过程。字母 *I* 代表“整合”例如，ARIMA(0，1，0)是对误差项求和的纯随机游走(尽管误差项可能有不同的方差，正如我们将在第 [15.2.5 节](#Sec33)中看到的)。NM Dev 类`ARIMAModel`构建了这样一个时间序列。该类签名如下:

```py
public class ARIMAModel extends ARIMAXModel {

    /**
     * Construct a univariate ARIMA model.
     *
     * @param mu    the intercept (constant) term
     * @param AR    the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficients
     * @param d     the order of integration
     * @param MA    the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficients
     * @param sigma the white noise variance
     */
    public ARIMAModel(double mu, double[] AR, int d, double[] MA, double sigma);

    /**
     * Construct a univariate ARIMA model with unit variance.
     *
     * @param mu the intercept (constant) term
     * @param AR the AR coefficients (excluding the initial 1); {@code null} if
     *           no AR coefficients
     * @param d  the order of integration
     * @param MA the MA coefficients (excluding the initial 1); {@code null} if
     *           no MA coefficients
     */
    public ARIMAModel(double mu, double[] AR, int d, double[] MA);

    /**
     * Construct a univariate ARIMA model with zero-intercept (mu).
     *
     * @param AR    the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficients
     * @param d     the order of integration
     * @param MA    the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficients
     * @param sigma the white noise variance
     */
    public ARIMAModel(double[] AR, int d, double[] MA, double sigma);

    /**
     * Construct a univariate ARIMA model with unit variance and zero-intercept
     * (mu).
     *
     * @param AR the AR coefficients (excluding the initial 1); {@code null} if
     *           no AR coefficients
     * @param d  the order of integration
     * @param MA the MA coefficients (excluding the initial 1); {@code null} if
     *           no MA coefficients
     */
    public ARIMAModel(double[] AR, int d, double[] MA);

    /**
     * Copy constructor.
     *
     * @param that a univariate ARIMA model
     */
    public ARIMAModel(ARIMAModel that);

    /**
     * Get the ARMA part of this ARIMA model, essentially ignoring the
     * differencing.
     *
     * @return the ARMA part
     */
    public ARMAModel getARMA();
}

```

NM Dev 类`ARIMASim`根据 ARIMA 规范构造了一个随机数生成器。它生成一个随机数序列，该序列具有基于模型的分布，可以是 AR、MA、ARMA 或 ARIMA。该类签名如下:

```py
public class ARIMASim implements RandomNumberGenerator {

    /**
     * Construct an ARIMA model.
     *
     * @param arima   an ARIMA model
     * @param lags    the lags of AR length; {@code lags[0]} is \(x_{t-1}\)
     * @param innovations the innovations of MA length; {@code innovations[0]}
     *                    is \(e_{t-1}\)
     * @param rng         a random number generator to generate innovations
     */
    public ARIMASim(
            ARIMAModel arima,
            double[] lags,
            double[] innovations,
            RandomNumberGenerator rng
    );

    /**
     * Construct an ARIMA model.
     * The lags and innovations are initialized to 0.
     *
     * @param arima an ARIMA model
     * @param rng   a random number generator to generate innovations
     */
    public ARIMASim(
            ARIMAModel arima,
            RandomNumberGenerator rng
    );

    /**
     * Construct an ARIMA model, using random standard Gaussian innovations.
     *
     * @param arima an ARIMA model
     */
    public ARIMASim(ARIMAModel arima);

    @Override
    public void seed(long... seeds);

    @Override
    public double nextDouble();

```

#### 15.2.4.3 阿里克斯(p、d、q)

类`ARIMAModel`扩展了代表 ARIMAX 模型的类`ARIMAXModel`。ARIMAX 过程是这样的，如果我们做差分 *d* 次，新的时间序列∈<sup>*d*</sup>*Y*<sub>*k*</sub>是具有外生或独立变量的平稳 ARMA 过程。字母 *X* 代表“外源性”数学上，我们有

![$$ {\Delta }^d{Y}_k={\left(1-B\right)}^d{Y}_t={X}_t={\phi}_1{X}_{t-1}+\dots +{\phi}_p{X}_{t-p}+{\theta}_1{\varepsilon}_{t-1}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t+\boldsymbol{\psi} {\boldsymbol{D}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equji.png)

![$$ \phi (B){X}_t=\theta (B){\varepsilon}_t+\boldsymbol{\psi} {\boldsymbol{D}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjj.png)

处理这样一个模型的一种方法是重新解释为对***D***<sub>***t***</sub>加平稳均值回复 ARMA 误差 *u* <sub>*t*</sub> 的线性回归，如下图:

![$$ {X}_t=\boldsymbol{\psi} {\boldsymbol{D}}_{\boldsymbol{t}}+{u}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjk.png)

![$$ {u}_t={\phi}_1{X}_{t-1}+\dots +{\phi}_p{X}_{t-p}+{\theta}_1{\varepsilon}_{t-1}+\dots +{\theta}_q{\varepsilon}_{t-q}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjl.png)

其中***D***<sub>***t***</sub>是一个 *m* × 1 的向量，包含时间 *t* 的所有 *m* 外生变量(不包括截距项)，其系数由一个*m****ψ***表示。

ARIMAX 模型的一个用途是将产品线增长建模为年通货膨胀率、年 GDP 和年人口增长率的线性函数。这个例子中的外生因素是年通货膨胀率、年 GDP 和年人口增长率。线性回归的残差可以建模为 ARMA 过程。NM Dev 类`ARIMAXModel`代表一个 ARIMAX 模型。我们可以通过指定 *ϕ* <sub>*i*</sub> ， *θ* <sub>*j*</sub> ， ***ψ*** 来构造这样一个 ARIMAX 模型。该类签名如下:

```py
public class ARIMAXModel {

    /**
     * Construct a univariate ARIMAX model.
     *
     * @param mu    the intercept (constant) term
     * @param AR    the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param MA    the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param psi   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     * @param sigma the white noise variance
     */
    public ARIMAXModel(
            double mu,
            double[] AR,
            int d,
            double[] MA,
            double[] psi,
            double sigma
    );

    /**
     * Construct a univariate ARIMAX model with unit variance.
     *
     * @param mu  the intercept (constant) term
     * @param AR  the AR coefficients (excluding the initial 1); {@code null} if
     *            no AR coefficient
     * @param d   the order of integration
     * @param MA  the MA coefficients (excluding the initial 1); {@code null} if
     *            no MA coefficient
     * @param psi the coefficients of the deterministic terms (excluding the
     *            intercept term)
     */
    public ARIMAXModel(
            double mu,
            double[] AR,
            int d,
            double[] MA,
            double[] psi
    );

    /**
     * Construct a univariate ARIMAX model with zero-intercept (mu).
     *
     * @param AR    the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param MA    the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param psi   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     * @param sigma the white noise variance
     */
    public ARIMAXModel(
            double[] AR,
            int d,
            double[] MA,
            double[] psi,
            double sigma
    );

    /**
     * Construct a univariate ARIMAX model with unit variance and zero-intercept
     * (mu).
     *
     * @param AR  the AR coefficients (excluding the initial 1); {@code null} if
     *            no AR coefficient
     * @param d   the order of integration
     * @param MA  the MA coefficients (excluding the initial 1); {@code null} if
     *            no MA coefficient
     * @param psi the coefficients of the deterministic terms (excluding the
     *            intercept term)
     */
    public ARIMAXModel(
            double[] AR,
            int d,
            double[] MA,
            double[] psi
    );

    /**
     * Copy constructor.
     *
     * @param that a univariate ARIMAX model
     */
    public ARIMAXModel(ARIMAXModel that);

    /**
     * Get the intercept (constant) term.
     *
     * @return the intercept (constant) term
     */
    public double mu();

    /**
     * Get the <i>i</i>-th AR coefficient; AR(0) = 1.
     *
     * @param i an index
     * @return the <i>i</i>-th AR coefficient
     */
    public double AR(int i);

    /**
     * Get all the AR coefficients.
     *
     * @return all the AR coefficients
     */
    public double[] phi();

    /**
     * Get the polynomial <i>(1 - &phi;)</i>.
     * The coefficients (except the initial 1) have the opposite signs to
     * {@link #AR(int)} and
     * {@link #phi()}.
     *
     * @return the polynomial <i>(1 - &phi;)</i>
     */
    public Polynomial phiPolynomial();

    /**
     * Get the <i>i</i>-th MA coefficient; MA(0) = 1.
     *
     * @param i an index
     * @return the <i>i</i>-th MA coefficient
     */
    public double MA(int i);

    /**
     * Get all the MA coefficients.
     *
     * @return all the MA coefficients
     */
    public double[] theta();

    /**
     * Get the polynomial <i>(1 + &theta;)</i>.
     *
     * @return the polynomial <i>(1 + &theta;)</i>
     */
    public Polynomial thetaPolynomial();

    /**
     * Get the coefficients of the deterministic terms.
     *
     * @return the coefficients of the deterministic terms; could be
     *         {@code null}
     */
    public double[] psi();

    /**
     * Get the order of integration.
     *
     * @return the order of integration
     */
    public int d();

    /**
     * Get the number of AR terms.
     *
     * @return the number of AR terms
     */
    public int p();

    /**
     * Get the number of MA terms.
     *
     * @return the number of MA terms
     */
    public int q();

    /**
     * Get the maximum of AR length or MA length.
     *
     * @return max(# AR terms, # MA terms)
     */
    public int maxPQ();

    /**
     * Get the white noise variance.
     *
     * @return the white noise variance
     */
    public double sigma();

    /**
     * Get the ARMAX part of this ARIMAX model, essentially ignoring the
     * differencing.
     *
     * @return the ARMAX part
     */
    public ARMAXModel getARMAX();

    @Override
    public String toString();

```

#### 15.2.4.4 估计

给定一个数据集，NM Dev 类`AutoARIMAFit`自动构建一个最适合该数据的模型。它生成一个具有不同模型参数{ *p* 、 *d* 、 *q* }的候选库，然后根据 AIC 或 AICc 选择最好的一个。如第[节 15.2.3.4](#Sec26)所述，使用最大似然法对每个候选数据进行拟合。该类签名如下:

```py
public class AutoARIMAFit {

    /**
     * Automatically selects and estimates the ARIMA model using custom
     * parameters.
     *
     * @param x            the time series
     * @param maxP         maximum number of AR order considered
     * @param maxD         maximum number of integration order considered
     * @param maxQ         maximum number of MA order considered
     * @param minP         minimum number of AR order considered
     * @param minQ         minimum number of MA order considered
     * @param maxIteration maximum number of iterations for optimization
     */
    public AutoARIMAFit(
            double[] x,
            int maxP,
            int maxD,
            int maxQ,
            int minP,
            int minQ,
            int maxIteration
    );

    /**
     * Automatically selects and estimates the ARIMA model using default
     * parameters.
     *
     * @param x the time series
     */
    public AutoARIMAFit(double[] x);

    /**
     * Selects the optimal ARIMA model by AIC.
     *
     * @return the optimal ARIMA model
     */
    public ARIMAModel optimalModelByAIC();

    /**
     * Selects the optimal ARIMA model by AICC.
     *
     * @return the optimal ARIMA model
     */
    public ARIMAModel optimalModelByAICC();
}

```

继续我们使用标准普尔 500 的例子，下面的代码片段从标准普尔 500 每日价格和日志回报构建了一个 ARIMA 模型。由于我们已经知道数据有一个来自第[节 15.2.4.1](#Sec28)的单位根，我们期望在合成模型中积分的阶是 1，但是我们还不知道滞后的 AR 和 MA 阶。另一方面，由于数据是静态的，我们希望对数回归的积分阶数为 0。代码将自动找到 lag 的最佳 AR 和 MA 订单。

```py
// auto fit an ARIMA model to S&P 500 prices
AutoARIMAFit fit_sp500_1 = new AutoARIMAFit(spx.toArray());
ARIMAModel arima1 = fit_sp500_1.optimalModelByAIC();
ARIMAModel arima2 = fit_sp500_1.optimalModelByAICC();
System.out.println("The optimal model for S&P500 prices by AIC is:");
System.out.println(arima1);
System.out.println("The optimal model for S&P500 prices by AICc is:");
System.out.println(arima2);

// auto fit an ARIMA model to S&P 500 log returns
AutoARIMAFit fit_sp500_2 = new AutoARIMAFit(log_returns, 5, 1, 5, 0, 0, 500);
ARIMAModel arima3 = fit_sp500_2.optimalModelByAIC();
ARIMAModel arima4 = fit_sp500_2.optimalModelByAICC();
System.out.println("The optimal model for S&P500 log returns by AIC is:");
System.out.println(arima3);
System.out.println("The optimal model for S&P500 log returns by AICc is:");
System.out.println(arima4);

```

输出如下所示:

```py
The optimal model for S&P500 prices by AIC is:
x_t = 1.7922553356473905 + (-0.8770604472900667*x_{t-1}+-0.05836375140117205*x_{t-2}) + (0.857937953677179*e_{t-1}) + e_t; var(e_t) = 416.996308, d = 1
The optimal model for S&P500 prices by AICc is:
x_t = 1.7922553356473905 + (-0.8770604472900667*x_{t-1}+-0.05836375140117205*x_{t-2}) + (0.857937953677179*e_{t-1}) + e_t; var(e_t) = 416.996308, d = 1
The optimal model for S&P500 log returns by AIC is:
x_t = 1.906712718546103E-5 + (0.5853547135786259*x_{t-1}+0.36118328122948645*x_{t-2}) + (-0.6148623312793726*e_{t-1}+-0.41230588621083164*e_{t-2}+0.0547444231494261*e_{t-3}) + e_t; var(e_t) = 0.000073, d = 0
The optimal model for S&P500 log returns by AICc is:
x_t = 1.906712718546103E-5 + (0.5853547135786259*x_{t-1}+0.36118328122948645*x_{t-2}) + (-0.6148623312793726*e_{t-1}+-0.41230588621083164*e_{t-2}+0.0547444231494261*e_{t-3}) + e_t; var(e_t) = 0.000073, d = 0

```

AIC 和 AICc 选择相同的价格和对数收益模型。标准普尔 500 价格选择的模型如下:

![$$ \Delta {Y}_t=1.7923-0.8771{X}_{t-1}-0.0584{X}_{t-2}+0.8579{\varepsilon}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjm.png)

这是一个 ARIMA(2，1，1)模型。

标准普尔 500 对数收益选择的模型如下:

![$$ {X}_t=0.00002+0.5854{X}_{t-1}+0.3612{X}_{t-2}-0.6149{\varepsilon}_{t-1}-0.4123{\varepsilon}_{t-2}+0.0547{\varepsilon}_{t-3}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjn.png)

这是一个 ARMA(2，3)模型。请注意，误差项的方差似乎非常小，为 0.000073。

#### 15.2.4.5 天气预报

NM Dev 类`ARIMAForecast`使用创新算法对 ARIMA 时间序列进行预测，如第[节 15.2.3.3](#Sec25)中所述。继续 S & P 500 的例子，下面的代码片段预测了接下来的十个价格:

```py
// make price forecasts based on the fitted model
ARIMAForecast forecast_prices = new ARIMAForecast(spx, arima1);
System.out.println("The next 10 price forecasts for sp500 using the ARIMA(2,1,1) model is");
for (int i = 0; i < 10; i++) {
    System.out.println(forecast_prices.next());
}

```

输出如下所示:

```py
The next 10 price forecasts for sp500 using the ARIMA(2,1,1) model is:
[1258]: 3222.504320 (0.000006)
[1259]: 3224.324729 (0.000011)
[1260]: 3224.449506 (0.000016)
[1261]: 3226.026079 (0.000022)
[1262]: 3226.428302 (0.000027)
[1263]: 3227.775769 (0.000032)
[1264]: 3228.362739 (0.000038)
[1265]: 3229.561543 (0.000043)
[1266]: 3230.268117 (0.000048)
[1267]: 3231.370697 (0.000054)

```

图 [15-23](#Fig23) 描绘了结果。顶部的蓝色线是实际价格，底部的橙色线是来自 ARIMA(2，1，1)模型的预测。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig23_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig23_HTML.jpg)

图 15-23

标准普尔 500 未来十天，实际价格与预测

以下代码片段预测接下来的十个日志返回:

```py
// make log return forecasts based on the fitted model
ARIMAForecast forecast_returns = new ARIMAForecast(new SimpleTimeSeries(log_returns), arima4);
System.out.println("The next 10 log return forecasts for sp500 using the ARIMA(2,1,1) model is:");
for (int i = 0; i < 10; i++) {
    System.out.println(forecast_returns.next());
}

```

输出如下所示:

```py
The next 10 price forecasts for sp500 using the ARMA(2,3) model is:
[1257]: -0.000121 (1.000000)
[1258]: 0.000000 (1.000871)
[1259]: -0.000305 (1.005549)
[1260]: -0.000160 (1.005565)
[1261]: -0.000185 (1.006064)
[1262]: -0.000147 (1.006198)
[1263]: -0.000134 (1.006419)
[1264]: -0.000112 (1.006586)
[1265]: -0.000095 (1.006752)
[1266]: -0.000077 (1.006901)

```

图 [15-24](#Fig24) 描绘了结果。更不稳定的蓝色线是实际的对数收益，而更稳定的橙色线是来自 ARMA(2，3)模型的预测。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig24_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig24_HTML.png)

图 15-24

标准普尔 500 未来十天，实际日志回报与预测

在图 [15-23](#Fig23) 和图 [15-24](#Fig24) 中，很明显预测或模型严重低估了数据的波动性。这是下一节的主题。

### GARCH 模型

到目前为止，我们已经介绍了分析时间序列条件均值的模型。我们现在将介绍研究时间序列波动性或方差的工具。波动性在估计预测误差和置信区间时很重要。在金融领域，波动性通常被用来衡量风险。图 [15-25](#Fig25) 描绘了标准普尔 500 指数的收益。我们已经在[第 15.1.6 节](#Sec7)中说明了收益是白噪声，但是它们的波动性会随着时间而变化。此外，大幅波动期之后往往是大幅波动期；小波动期之后是小波动期。这被称为波动聚类。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig25_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig25_HTML.jpg)

图 15-25

标准普尔 500 回归

在[15.2.4.4](#Sec31)部分，我们校准了回报率的 ARMA 模型。即返回的*r*<sub>T5】t</sub>遵循 ARMA(p，q)过程。

![$$ {r}_t={\phi}_0+\sum \limits_{i=1}^p{\phi}_i{r}_{t-i}+\sum \limits_{j=1}^q{\theta}_j{\varepsilon}_{t-j}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjo.png)

returns 的条件均值*μ*<sub>T3】tT5】如下:</sub>

![$$ {\mu}_t=\mathrm{E}\left({r}_t\ |\ {r}_1,\dots {r}_{t-1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjp.png)

![$$ ={\phi}_0+\sum \limits_{i=1}^p{\phi}_i{r}_{t-i}+\sum \limits_{j=1}^q{\theta}_j{\varepsilon}_{t-j} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjq.png)

![$$ {r}_t={\mu}_t+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjr.png)

条件方差![$$ {\sigma}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq48.png)如下:

![$$ {\sigma}_t^2=\operatorname{var}\left({r}_t\ |\ {r}_1,\dots {r}_{t-1}\right)=\mathrm{E}\left({\left({r}_t-{\mu}_t\right)}^2\ |\ {r}_1,\dots {r}_{t-1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjs.png)

![$$ =\mathrm{E}\left({\varepsilon}_t^2\ |\ {r}_1,\dots {r}_{t-1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjt.png)

#### 15.2.5.1 拱门(q)

错误术语如下:

![$$ {\varepsilon}_t={r}_t-{\mu}_t={r}_t-\mathrm{E}\left({r}_t\ |\ {r}_1,\dots {r}_{t-1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equju.png)

这些 *ε* <sub>*t*</sub> 值被分解成一个随机块 *z* <sub>*t*</sub> 和一个依赖于时间的标准差 *σ* <sub>*t*</sub> 来表征项的典型大小，这样我们就有了

![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjv.png)

其中 *z* <sub>*t*</sub> 为均值和单位方差为零的独立同分布白噪声。

如果我们画出*ε*<sub>T3】t</sub><sup>2</sup>，我们会发现 PACF 衰变到零的速度比 ACF 快得多。这表明 AR 流程适用于建模![$$ {\sigma}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq49.png)。自回归条件异方差(ARCH)模型是时间序列的统计模型，它将当前误差项或新息的方差描述为先前误差项实际大小的函数。

![$$ {\sigma}_t^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2+\dots +{\alpha}_p{\varepsilon}_{t-q}^2={\alpha}_0+\sum \limits_{i=1}^q{\alpha}_i{\varepsilon}_{t-i}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjw.png)

其中*α*0>0， *α* <sub>*i*</sub> ≥ 0， *i* = 1，2，...、 *q* 、var(*ε*<sub>*t*</sub>)<∞。

可以使用普通最小二乘回归来估计 ARCH(q)模型。ARCH 效应的滞后长度 *q* 的假设检验如下。首先，估计数据上的最佳拟合自回归模型 AR(q)。【T2![$$ {y}_t={a}_0+{a}_1{y}_{t-1}+\dots +{a}_q{y}_{t-q}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjx.png)

然后，获得误差![$$ {\hat{\varepsilon}}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq50.png)的平方，并对常数和 *q* 滞后值进行回归。

![$$ {\hat{\varepsilon}}_t^2={\hat{\alpha}}_0^2+\sum \limits_{i=1}^q{\hat{\alpha}}_i{\hat{\varepsilon}}_{t-i}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjy.png)

其中 *q* 是拱形滞后的长度。

最后，无效假设是，在没有拱门效应的情况下，我们有所有的 *i* = 1，...，*问*。

![$$ {H}_0:{\hat{\alpha}}_1=\dots ={\hat{\alpha}}_q=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equjz.png)

另一个假设是，在存在 ARCH 效应的情况下，至少一个估计的![$$ {\hat{\alpha}}_i $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq52.png)系数必须是有效的(非零)。在一个样本的 *T* 残差无 ARCH 误差的零假设下，检验统计量如下:

![$$ s=\left(T-q\right){R}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equka.png)

其中*R*T2 2 是![$$ {\hat{\varepsilon}}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq53.png)回归的 R 平方。

检验统计量遵循自由度为 *q* 的 *χ* <sup>2</sup> 分布。如果 *s* 大于卡方表值，我们拒绝零假设，得出 ARMA 模型中存在 ARCH 效应的结论。如果 *s* 小于卡方表值，我们不拒绝零假设。

{ *r* <sub>*t*</sub> }的条件方差可以写成过去的误差或创新的总和。

![$$ \operatorname{var}\left({r}_t\ |\ {r}_1,\dots {r}_{t-1}\right)={\sigma}_t^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2+\dots +{\alpha}_p{\varepsilon}_{t-q}^2={\alpha}_0+\sum \limits_{i=1}^q{\alpha}_i{\varepsilon}_{t-i}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkb.png)

对于拱门①，我们有这样的:

![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkc.png)

![$$ {\sigma}_t^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkd.png)

其中 *α* <sub>0</sub> > 0，0<T4】α<sub>1</sub><1。

无条件含义如下:

![$$ \mathrm{E}\left({\varepsilon}_t\right)=\mathrm{E}\left(\mathrm{E}\left({\varepsilon}_t\ |\ {r}_1,\dots {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equke.png)

![$$ =\mathrm{E}\left(\mathrm{E}\left({\sigma}_t{z}_t\ |\ {r}_1,\dots {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkf.png)

![$$ =\mathrm{E}\left({\sigma}_t\mathrm{E}\left({z}_t\ |\ {r}_1,\dots {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkg.png)

![$$ ={\sigma}_t\mathrm{E}\left(\mathrm{E}\left({z}_t\ |\ {r}_1,\dots {r}_{t-1}\right)\right)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkh.png)

因为*z*<sub>T3】tT5】是均值为 0 的 i.i.d .噪声。</sub>

无条件方差如下:

![$$ \operatorname{var}\left({\varepsilon}_t\right)=\mathrm{E}\left({\varepsilon}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equki.png)

![$$ =\mathrm{E}\left(\mathrm{E}\left({\varepsilon}_t^2\ |\ {r}_1,\dots {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkj.png)

![$$ =\mathrm{E}\left(\mathrm{E}\left({\sigma}_t^2{z}_t^2\ |\ {r}_1,\dots {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkk.png)

![$$ =\mathrm{E}\left({\sigma}_t^2\mathrm{E}\left({z}_t^2\ |\ {r}_1,\dots {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkl.png)

![$$ =\mathrm{E}\left({\sigma}_t^2\right)=\mathrm{E}\left({\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkm.png)

![$$ ={\alpha}_0+{\alpha}_1\mathrm{E}\left({\varepsilon}_{t-1}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkn.png)

设置![$$ \operatorname{var}\left({\varepsilon}_t\right)=\operatorname{var}\left({\varepsilon}_{t-1}\right)=\mathrm{E}\left({\varepsilon}_{t-1}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq54.png)，我们有以下:

![$$ \operatorname{var}\left({\varepsilon}_t\right)=\frac{\alpha_0}{1-{\alpha}_1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equko.png)

自协方差函数如下:

![$$ \gamma (k)=\operatorname{cov}\left({\varepsilon}_t,{\varepsilon}_{t-k}\right)=\mathrm{E}\left({\varepsilon}_t{\varepsilon}_{t-k}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkp.png)

![$$ =\mathrm{E}\left({\sigma}_t{z}_t{\sigma}_{t-k}{z}_{t-k}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkq.png)

![$$ =\mathrm{E}\left({z}_t\right)\mathrm{E}\left({\sigma}_t{\sigma}_{t-k}{z}_{t-k}\right)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkr.png)

因为， *z* <sub>*t*</sub> 是均值为 0 的 i.i.d .噪声。

假设数据是一个 AR(1)模型，我们有:

![$$ {X}_t={\phi}_0+{\phi}_1{X}_{t-1}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equks.png)

还有*ε*<sub>T3】tT5】跟随着 ARCH。</sub>

该过程的无条件均值如下:

![$$ \mathrm{E}\left({X}_t\right)={\phi}_0+{\phi}_1\mathrm{E}\left({X}_{t-1}\right)+\mathrm{E}\left({\varepsilon}_t\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkt.png)

既然 E(*X*<sub>*t*</sub>)= E(*X*<sub>*t*—1</sub>)和 E(*ε*<sub>*t*</sub>)= 0，我们就有了这个:

![$$ \mathrm{E}\left({X}_t\right)=\frac{\phi_0}{1-{\phi}_1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equku.png)

过程的无条件方差如下:

![$$ \operatorname{var}\left({X}_t\right)=\frac{\operatorname{var}\left({\varepsilon}_t\right)}{1-{\phi}_1^2}=\frac{1}{1-{\phi}_1^2}\frac{\alpha_0}{1-{\alpha}_1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkv.png)

#### 15.2.5.2·加尔奇

如果 ARCH 模型需要一个大的 *q* 或一个高阶，那么广义自回归条件异方差(GARCH)模型可能会更节省，因此更容易识别和估计。GARCH 模型是 ARCH 模型的扩展，它将过去方差的移动平均分量与自回归分量结合在一起。具体而言，GARCH(p，q)模型包括方差项的 *p* 滞后(例如，如果对另一过程的白噪声残差进行建模，则为观察值)，以及来自过程的残差的 *q* 滞后。

![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkw.png)

![$$ {\sigma}_t^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2+{\alpha}_2{\varepsilon}_{t-2}^2+\dots +{\alpha}_q{\varepsilon}_{t-q}^2+{\beta}_1{\sigma}_{t-1}^2+{\beta}_2{\sigma}_{t-2}^2+\dots +{\beta}_p{\sigma}_{t-p}^2={\alpha}_0+\sum \limits_{i=1}^q{\alpha}_i{\varepsilon}_{t-i}^2+\sum \limits_{ij1}^p{\beta}_j{\sigma}_{t-j}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkx.png)T11】

其中 *z* <sub>*t*</sub> 为均值和单位方差为零的独立同分布白噪声。 *α* <sub>0</sub> > 0，*α*<sub>*t*—*I*</sub>≥0 为 *i* = 1，...、 *q* 和*β*<sub>*t*—*j*</sub>≥0 为 *j* = 1、...， *p* 。

GARCH(p，q)过程中的滞后长度 *p* 可以分三步建立。首先，估计数据上的最佳拟合自回归模型 AR(q)。【T2![$$ {y}_t={a}_0+{a}_1{y}_{t-1}+\dots +{a}_q{y}_{t-q}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equky.png)

然后计算并绘制*ε*T2 2 的自相关函数如下:

![$$ \rho (i)=\frac{\sum \limits_{t=i+1}^T\left({\hat{\varepsilon}}_t^2-{\hat{\sigma}}_t^2\right)\left({\hat{\varepsilon}}_{t-1}^2-{\hat{\sigma}}_{t-1}^2\right)}{\sum \limits_{t=1}^T{\left({\hat{\varepsilon}}_t^2-{\hat{\sigma}}_t^2\right)}^2} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equkz.png)

最后是渐近，也就是对于大样本来说， *ρ* ( *i* )的标准差是![$$ 1/\sqrt{T} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq55.png)。大于该值的单个值表示 GARCH 误差。

最好的识别工具可能是绘制时间序列。通常很容易发现数据中各处变化增加的时期。看看 *y* <sub>*t*</sub> 和![$$ {y}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq56.png)的 ACF 和 PACF 都会有用。例如，如果 *y* <sub>* t *</sub> 看起来是白噪声，而![$$ {y}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq57.png)看起来是 AR(1)，那么方差的 ARCH(1)模型可能是合适的。如果![$$ {y}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq58.png)的 PACF 在滞后 *q* 后切断，则 ARCH(q)可能工作。如果 ACF 和 PACF 都衰减慢，那么我们可以试试 GARCH。

给定一个 GARCH(1，1)过程为:

![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equla.png)

![$$ {\sigma}_t^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2+{\beta}_1{\sigma}_{t-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlb.png)

条件意义如下:

![$$ \mathrm{E}\left({\varepsilon}_t\ |\ {r}_1,\dots, {r}_{t-1}\right)=\mathrm{E}\left({\sigma}_t{z}_t\ |\ {r}_1,\dots, {r}_{t-1}\right)={\sigma}_t\mathrm{E}\left({z}_t\ |\ {r}_1,\dots, {r}_{t-1}\right)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlc.png)

无条件含义如下:

![$$ \mathrm{E}\left({\varepsilon}_t\right)=\mathrm{E}\left(\mathrm{E}\left({\varepsilon}_t\ |\ {r}_1,\dots, {r}_{t-1}\right)\right)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equld.png)

无条件方差如下:

![$$ \operatorname{var}\left({\varepsilon}_t\right)=\mathrm{E}\left({\varepsilon}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equle.png)

![$$ =\mathrm{E}\left(\mathrm{E}\left({\varepsilon}_t^2\ |\ {r}_1,\dots, {r}_{t-1}\right)\right)=\mathrm{E}\left(\mathrm{E}\left({\sigma}_t^2{z}_t^2\ |\ {r}_1,\dots, {r}_{t-1}\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlf.png)

![$$ =\mathrm{E}\left({\sigma}_t^2\mathrm{E}\left({z}_t^2\ |\ {r}_1,\dots, {r}_{t-1}\right)\right)=\mathrm{E}\left({\sigma}_t^2\mathrm{E}\left({z}_t^2\right)\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlg.png)

![$$ =\mathrm{E}\left({\sigma}_t^2\right)=\mathrm{E}\left({\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2+{\beta}_1{\sigma}_{t-1}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlh.png)

![$$ ={\alpha}_0+{\alpha}_1\mathrm{E}\left({\varepsilon}_{t-1}^2\right)+{\beta}_1\mathrm{E}\left({\sigma}_{t-1}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equli.png)

![$$ ={\alpha}_0+\left({\alpha}_1+{\beta}_1\right)\mathrm{E}\left({\varepsilon}_{t-1}^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlj.png)

![$$ \operatorname{var}\left({\varepsilon}_t\right)=\frac{\alpha_0}{1-{\alpha}_1-{\beta}_1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlk.png)

在 NM Dev 中，我们可以使用类`GARCHModel`构建 GARCH 模型和 ARCH 模型。该类签名如下:

```py
public class GARCHModel {

    /**
     * Construct a GARCH model.
     *
     * @param a0 the constant term
     * @param a  the ARCH coefficients
     * @param b  the GARCH coefficients
     */
    public GARCHModel(double a0, double[] a, double[] b);

    /**
     * Copy constructor.
     *
     * @param that a GARCH model
     */
    public GARCHModel(GARCHModel that);

    /**
     * Get the constant term.
     *
     * @return the constant term
     */
    public double a0();

    /**
     * Get the ARCH coefficients.
     *
     * @return the ARCH coefficients; could be {@code null}
     */
    public double[] alpha();

    /**
     * Get the GARCH coefficients.
     *
     * @return the GARCH coefficients; could be {@code null}
     */
    public double[] beta();

    /**
     * Get the number of GARCH terms.
     *
     * @return the number of GARCH terms
     */
    public int p();

    /**
     * Get the number of ARCH terms.
     *
     * @return the number of ARCH terms
     */
    public int q();

    /**
     * Get the maximum of the ARCH length or GARCH length.
     *
     * @return max(# ARCH terms, # GARCH terms)
     */
    public int maxPQ();

    /**
     * Compute the unconditional variance of the GARCH model.
     *
     * @return the unconditional variance
     */
    public double var();

    /**
     * Compute the conditional variance based on the past information.
     *
     * @param e2         the last <i>q</i> squared observations
     * @param sigma2_lag the last <i>p</i> conditional variances
     * @return the conditional variance, <i>h(t | F<sub>t</sub>)</i>
     */
    public double sigma2(double[] e2, double[] sigma2_lag);

    @Override
    public String toString();
}

```

例如，下面的代码片段构建了这个 ARCH(1)流程:

![$$ {\sigma}_t^2=0.2+0.212{\varepsilon}_{t-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equll.png)

```py
GARCHModel arch1
        = new GARCHModel(
                0.2, // constant
                new double[]{0.212}, // ARCH terms
                new double[]{} // no GARCH terms
        );
System.out.println(arch1);
System.out.printf("conditional variance = %f%n", arch1.var());

```

输出如下所示:

```py
0.2+ 0.212000 * e_{t-1}
conditional variance = 0.253807

```

下面的代码片段构造了这个 GARCH(1，1)过程:

![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlm.png)

![$$ {\sigma}_t^2=0.2+0.212{\varepsilon}_{t-1}^2+0.106{\sigma}_{t-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equln.png)

```py
// σ_t^2= 0.2+0.212ε_(t-1)^2+0.106σ_(t-1)^2
GARCHModel garch11
        = new GARCHModel(
                0.2, // constant
                new double[]{0.212}, // ARCH terms
                new double[]{0.106} // GARCH terms
        );
System.out.println(garch11);
System.out.printf("conditional variance = %f%n", garch11.var());

```

输出如下所示:

```py
0.2+ 0.212000 * e_{t-1}+ 0.106000 * h_{t-1}
conditional variance = 0.293255

```

NM Dev 类`GARCHSim`从 GARCH 模型构造一个随机数生成器。它生成一个随机数序列，其分布基于模型，无论是 ARCH 还是 GARCH。该类签名如下:

```py
public class GARCHSim implements RandomNumberGenerator {

    /**
     * Simulate an GARCH model.
     *
     * @param model a GARCH model
     * @param z     the innovations; size = q
     * @param rng   a random number generator
     */
    public GARCHSim(
            GARCHModel model,
            double[] z,
            RandomNumberGenerator rng
    );

    /**
     * Simulate an GARCH model.
     * The innovations are initialized to 0.
     *
     * @param model a GARCH model
     * @param rng   a random number generator
     */
    public GARCHSim(
            GARCHModel model,
            RandomNumberGenerator rng
    );

    /**
     * Simulate an GARCH model.
     * The innovations are initialized to 0.
     *
     * @param model a GARCH model
     */
    public GARCHSim(GARCHModel model);

    @Override
    public void seed(long... seeds);

    @Override
    public double nextDouble();

    /**
     * Get the next random (e2_t, h_t).
     *
     * @return the next random (e2_t, h_t)
     */
    public Pair nextPair();
}

```

注意，函数`nextPair()`生成下一个随机对![$$ \left({\varepsilon}_t^2,{\sigma}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq59.png)。

下面的代码为前面的 GARCH(1，1)过程生成一个序列![$$ \left\{{\varepsilon}_t^2\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq60.png):

```py
// σ_t^2= 0.2+0.212ε_(t-1)^2+0.106σ_(t-1)^2
GARCHModel garch11
        = new GARCHModel(
                0.2, // constant
                new double[]{0.212}, // ARCH terms
                new double[]{0.106} // GARCH terms
        );
System.out.println(garch11);

// simulate the GARCH process
GARCHSim sim = new GARCHSim(garch11);
sim.seed(1234567890L);
double[] series = RNGUtils.nextN(sim, 200);
System.out.println(Arrays.toString(series));

```

图 [15-26](#Fig26) 显示了输出。另见绘制输出的图 [15-27](#Fig27) 。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig27_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig27_HTML.png)

图 15-27

绘制结果

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig26_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig26_HTML.jpg)

图 15-26

一个模拟 GARCH 过程的***ε***<sub>***t***</sub>=***σ***<sub>***t***</sub>***z***<sub>***t***</sub>，![$$ {\boldsymbol{\sigma}}_{\boldsymbol{t}}^{\mathbf{2}}=\mathbf{0.2}+\mathbf{0.212}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\mathbf{1}}^{\mathbf{2}}+\mathbf{0.106}{\boldsymbol{\sigma}}_{\boldsymbol{t}-\mathbf{1}}^{\mathbf{2}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq61.png)

#### 15.2.5.3 估计

ARMA(或 ARIMA)模型给出了时间序列的(条件)均值，GARCH(或 ARCH)模型给出了(条件)方差。有两种方法来估计模型的参数。一种方法是分别估计，先 ARMA 再 GARCH。另一种方法是同时联合估计它们。

下面是分别估计 ARMA 和 GARCH 模型的步骤:

1.  用 ARMA 模型拟合给定的时间序列{ *X* <sub>*t*</sub> }。

2.  计算安装值![$$ \left\{{\hat{X}}_t\right\} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq62.png)。

3.  得到残差![$$ {Z}_t={X}_t-{\hat{X}}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq63.png)。

4.  用 GARCH 模型拟合残差{ *Z* <sub>*t*</sub> }。

我们将通过继续第 [15.2.5](#Sec33) 节中的标准普尔 500 示例来说明这些步骤。

**第一步**

在这一部分，我们已经用 ARMA 模型拟合了指数数据的对数收益。标准普尔 500 对数收益率的模型是 ARMA(2，3)模型。

![$$ {X}_t=0.00002+0.5854{X}_{t-1}+0.3612{X}_{t-2}-0.6149{\varepsilon}_{t-1}-0.4123{\varepsilon}_{t-2}+0.0547{\varepsilon}_{t-3}+{\varepsilon}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlo.png)T2】

**第二步**

在第[节 15.2.3.3](#Sec25)中，我们已经展示了如何使用类`ARMAForecastOneStep`来计算拟合值。以下代码片段计算了每个 ARMA 模型的对数回报的拟合值:

```py
// compute the conditional means of the model at each time
ARMAForecastOneStep log_returns_hat
        = new ARMAForecastOneStep(log_returns, arima4.getARMA());

```

**第三步**

残差只是观察值和拟合值之间的差异。

```py
// compute the residuals = observations - fitted values
double[] residuals = new double[log_returns.length];
for (int t = 0; t < log_returns.length; ++t) {
    residuals[t] = log_returns[t] - log_returns_hat.xHat(t);
}
System.out.println("residuals:");
System.out.println(Arrays.toString(residuals));

```

图 [15-28](#Fig28) 绘制了残差图。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig28_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig28_HTML.jpg)

图 15-28

残差

**第四步**

最后，我们使用 NM Dev 类`GARCHFit`将残差拟合到 GARCH(1，1)模型。

```py
// fit the residuals to a GARCH(1,1) model
GARCHFit garch_fit = new GARCHFit(residuals, 1, 1);
GARCHModel garch = garch_fit.getModel();
System.out.printf("the residual GARCH(1,1) model is: %s%n", garch);

```

综上所述，输出如下:

```py
residuals:
[-0.018803861662403516, -0.009667995537079697, 0.009867948291772356, 0.017230524405766275, -0.008052457343284872, -0.00802263763874365, -0.00388207620190564, -0.006538145657867553, -0.010089298244179472, 0.012219831049269827, 6.923295906500515E-4, 0.0049467495116336125, 0.014384919218676588, -0.005355196442542493, 0.0027100743427746175, -0.014354852007562454, -0.01389617168273286, 0.007807679503488708, -0.013934967193129357, 0.01256537802026989, 0.01290446728032751, -0.003443932600304114, ......]
the residual GARCH(1,1) model is: 8.526563917448361E-6 + 0.240668 * e_{t-1}^2 + 0.603932 * h_{t-1}^2

```

拟合残差数据的 GARCH 模型如下:

![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlp.png)

![$$ {\sigma}_t^2=0.000008+0.240668{\varepsilon}_{t-1}^2+0.603932{\sigma}_{t-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlq.png)

因此，使用两步法的标准普尔 500 对数收益的完整 ARMA-GARCH 模型如下:

![$$ \left\{\begin{array}{c}{X}_t=0.00002+0.5854{X}_{t-1}+0.3612{X}_{t-2}-0.6149{\varepsilon}_{t-1}-0.4123{\varepsilon}_{t-2}+0.0547{\varepsilon}_{t-3}+{\varepsilon}_t\\ {}{\varepsilon}_t={\sigma}_t{z}_t\\ {}{\sigma}_t^2=0.000008+0.240668{\varepsilon}_{t-1}^2+0.603932{\sigma}_{t-1}^2\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlr.png)

或者，NM Dev 类`ARMAGARCHFit`可以一次将数据同时拟合到 ARMA 模型和 GARCH 模型。请注意，该算法将给出与两步方法(稍微)不同的结果。`ARMAGARCHFit`使用准最大似然估计(QMLE)。它假设创新为正态分布(在我们的实现中),并使用稳健的标准误差进行推断。以下是代码片段:

```py
// fit both the ARMA and GARCH models in one go
ARMAGARCHFit arma_garch_fit
        = new ARMAGARCHFit(
                log_returns, // the input series
                2, // the order for AR in ARMA model
                3, // the order for MA in ARMA model
                1, // the order for GARCH in GARCH model
                1 // the order for ARCH in GARCH model
        );
System.out.println("the ARMA model is:");
System.out.println(arma_garch_fit.getARMAGARCHModel().getARMAModel());
System.out.println("the GARCH model is:");
System.out.println(arma_garch_fit.getARMAGARCHModel().getGARCHModel());

```

输出如下:

![$$ \left\{\begin{array}{c}{X}_t=0.00001907+0.5185{X}_{t-1}+0.4511{X}_{t-2}-0.6107{\varepsilon}_{t-1}-0.4{\varepsilon}_{t-2}+0.0318{\varepsilon}_{t-3}+{\varepsilon}_t\\ {}{\varepsilon}_t={\sigma}_t{z}_t\\ {}{\sigma}_t^2=0.000003356+0.203885{\varepsilon}_{t-1}^2+0.749625{\sigma}_{t-1}^2\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equls.png)

```py
the ARMA model is:
x_t = 1.906712718546103E-5 + (0.5185474463591396*x_{t-1}+0.4510540652006832*x_{t-2}) + (-0.6106836970210202*e_{t-1}+-0.39996126652483494*e_{t-2}+0.03177641621643222*e_{t-3}) + e_t; var(e_t) = 1.000000, d = 0
the GARCH model is:
3.355640148051882E-6+ 0.203885 * e_{t-1}+ 0.749625 * h_{t-1}

```

#### 15.2.5.4 天气预报

ARMA-GARCH 模型描述了随机过程的动态，预测条件均值和条件方差。也就是

![$$ {X}_t\sim N\left({\hat{X}}_t,{\sigma}_t^2\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Eqult.png)

用 ARMA 预测![$$ {\hat{X}}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq64.png)已经在[15.2.3.3](#Sec25)节讨论过了。我们将展示 GARCH(1，1)模型的预测![$$ {\sigma}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq65.png)是如何工作的。![$$ {\varepsilon}_t={\sigma}_t{z}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlu.png)

![$$ {\sigma}_t^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t-1}^2+{\beta}_1{\sigma}_{t-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlv.png)

单步预测如下:

![$$ {\sigma}_{t+1}^2={\alpha}_0+{\alpha}_1{\varepsilon}_t^2+{\beta}_1{\sigma}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlw.png)

常数 *α* <sub>0</sub> 对应长期平均值。第二个术语![$$ {\alpha}_1{\varepsilon}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq66.png)是在做出先前预测时不可用的新信息。第三项![$$ {\beta}_1{\sigma}_t^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq67.png)是上一期的预测。这三项的权重决定了方差随新信息变化的速度，以及它回复到长期均值的速度。

两步预测如下:

![$$ {\sigma}_{t+2}^2={\alpha}_0+{\alpha}_1{\varepsilon}_{t+1}^2+{\beta}_1{\sigma}_{t+1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlx.png)

![$$ ={\alpha}_0+{\alpha}_1{\sigma}_{t+1}^2{z}_{t+1}^2+{\beta}_1{\sigma}_{t+1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equly.png)

![$$ ={\alpha}_0+\left({\alpha}_1{z}_{t+1}^2+{\beta}_1\right){\sigma}_{t+1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equlz.png)

![$$ ={\alpha}_0+\left({\alpha}_1+{\beta}_1\right){\sigma}_{t+1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equma.png)

一般来说，对于 *h* ≥ 2，我们有*h*-步预测如下:

![$$ {\sigma}_{t+h}^2={\alpha}_0+\left({\alpha}_1+{\beta}_1\right){\sigma}_{t+h-1}^2 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmb.png)

## 15.3 多元时间序列

许多现实生活中的时间序列最好相互结合起来考虑，因为它们相互交织，密切相关。例如，空气质量数据集可能由温度、压力、风速和风向随时间的时间序列组成。每个时间序列本身并不能告诉我们太多关于空气质量的信息，但是这些成分序列一起给了我们一个更完整的现实图景。考虑多个时间序列的联合属性也可以告诉我们一些新的东西，如果我们单独考虑每个时间序列，这是不可能的。图 [15-29](#Fig29) 绘制了从 1981 年 1 月 1 日到 2019 年 12 月 12 日，S & P 500 和 APPL(苹果股票)的价格。我们看到 AAPL 开始成为市场的主要参与者，并且从 2008 年开始追随标准普尔 500 指数。这是 iPhone 3 问世的一年。APPL 经历了三次大规模抛售。从 2012 年 9 月到 2013 年 5 月，该指数下跌了 46.8%，而同期标准普尔 500 指数上涨了 11.7%。当 APPL 从 2015 年 2 月到 2016 年 5 月下跌 25.8%时，标准普尔 500 指数持平。在 AAPL 从 2018 年 10 月的历史高点下跌 36%至 2019 年 1 月收盘期间，标准普尔 500 指数没有变动。当我们说 APPL 被高估(或低估)时，当我们将其与标准普尔 500 指数等基准指数进行比较时，这更有意义。我们想一起研究几个时间序列(AAPL，S & P 500 ),研究它们的相互依赖和共同运动。为单变量时间序列开发的许多概念和技术，如自回归、移动平均、平稳性、自协方差、估计和预测，可以自然地扩展到多变量时间序列。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig29_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig29_HTML.jpg)

图 15-29

1981 年至 2019 年标准普尔 500 和 AAPL 的月度价格

一个多元时间序列{***X***<sub>***t***</sub>}由 *m* 时间序列{*X*<sub>*ti*</sub>， *t* = 0，1，2、...}， *i* = 1，...， *m* 使得***X***<sub>***t***</sub>中的每一行都是一个单变量时间序列。

T35】T36】

一个联合平稳过程{***X***<sub>***t***</sub>}意味着每一个单变量分量过程{*X*<sub>*ti*</sub>}都是平稳的。

在 NM Dev 中，表示多元时间序列的数据结构如图 [15-30](#Fig30) 所示，反映了单变量时间序列的数据结构。顶层接口是`MultivariateTimeSeries`。根据时间戳或指数的类型，我们有`MultivariateGenericTimeTimeSeries`用于任何指数类型，只要它是可比较的，`MultivariateRealization`用于实值时间，如连续时间随机过程，以及`MultivariateIntTimeTimeSeries`和`MultivariateSimpleTimeSeries`用于整数指数时间序列。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig30_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig30_HTML.jpg)

图 15-30

表示多元时间序列的类的层次结构

在本节中，我们将主要使用类`MultivariateSimpleTimeSeries`,因为我们正在研究等时数据。类签名及其支持的操作如下:

```py
public class MultivariateSimpleTimeSeries implements MultivariateIntTimeTimeSeries {

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries}.
     *
     * @param values a matrix representation of the time series
     */
    public MultivariateSimpleTimeSeries(Matrix values);

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries}.
     *
     * @param values a double array representation of the time series
     */
    public MultivariateSimpleTimeSeries(double[]... values);

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries}.
     *
     * @param values a vector representation of the time series
     */
    public MultivariateSimpleTimeSeries(Vector... values);

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries} from a
     * univariate time series.
     *
     * @param ts a univariate time series
     */
    public MultivariateSimpleTimeSeries(IntTimeTimeSeries ts);

    @Override
    public Matrix toMatrix();

    @Override
    public int size();

    @Override
    public int dimension();

    @Override
    public Iterator<Entry> iterator();

    @Override
    public Vector get(int t);

    /**

     * Construct an instance of {@code MultivariateSimpleTimeSeries} by dropping
     * the leading {@code nItems} entries.
     *
     * @param nItems the number of leading entries to be dropped
     * @return a {@code MultivariateSimpleTimeSeries}
     */
    public MultivariateSimpleTimeSeries drop(int nItems);

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries} by taking
     * the first difference {@code d} times.
     *
     * @param d the number of differences
     * @return {@code diff(x, lag = 1, differences = d)} as in DoubleUtils
     */
    public MultivariateSimpleTimeSeries diff(int d);

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries} by lagging
     * the time series. This operation makes sense only for equi-distant data
     * points.
     *
     * @param nLags  the number of lags
     * @param length the length of the lagged time series
     * @return a lagged time series
     */
    public MultivariateSimpleTimeSeries lag(int nLags, int length);

    /**
     * Construct an instance of {@code MultivariateSimpleTimeSeries} by lagging
     * the time series. This operation makes sense only for equi-distant data
     * points.
     *
     * @param nLags the number of lags
     * @return a lagged time series
     */
    public MultivariateSimpleTimeSeries lag(int nLags);

    @Override

    public String toString();
}

```

例如，下面的代码片段构造并操作一个整数索引的二元时间序列。时间序列中的每个时间或行都由一对实数组成。请注意，NM Dev 代码与数学符号有不同的约定，在数学符号中，每一行都是一个单变量时间序列。

```py
// construct a bivariate time series
MultivariateSimpleTimeSeries X_T0
        = new MultivariateSimpleTimeSeries(
                new double[][]{
                    {-1.875, 1.693},
                    {-2.518, -0.03},
                    {-3.002, -1.057},
                    {-2.454, -1.038},
                    {-1.119, -1.086},
                    {-0.72, -0.455},
                    {-2.738, 0.962},
                    {-2.565, 1.992},
                    {-4.603, 2.434},
                    {-2.689, 2.118}
                });
System.out.println("X_T0: " + X_T0);

// first difference of the bivariate time series
MultivariateSimpleTimeSeries X_T1 = X_T0.diff(1);
System.out.println("diff(1): " + X_T1);

// first order lagged time series
MultivariateSimpleTimeSeries X_T2 = X_T0.lag(1);
System.out.println("lag(1): " + X_T2);

// drop the first two items
MultivariateSimpleTimeSeries X_T3 = X_T0.drop(1);
System.out.println("drop(1): " + X_T3);

```

输出如下所示:

```py
X_T0: [[-1.875000, 1.693000] , [-2.518000, -0.030000] , [-3.002000, -1.057000] , [-2.454000, -1.038000] , [-1.119000, -1.086000] , [-0.720000, -0.455000] , [-2.738000, 0.962000] , [-2.565000, 1.992000] , [-4.603000, 2.434000] , [-2.689000, 2.118000] ]
diff(1): [[-0.643000, -1.723000] , [-0.484000, -1.027000] , [0.548000, 0.019000] , [1.335000, -0.048000] , [0.399000, 0.631000] , [-2.018000, 1.417000] , [0.173000, 1.030000] , [-2.038000, 0.442000] , [1.914000, -0.316000] ]
lag(1): [[-1.875000, 1.693000] , [-2.518000, -0.030000] , [-3.002000, -1.057000] , [-2.454000, -1.038000] , [-1.119000, -1.086000] , [-0.720000, -0.455000] , [-2.738000, 0.962000] , [-2.565000, 1.992000] , [-4.603000, 2.434000] ]
drop(1): [[-2.518000, -0.030000] , [-3.002000, -1.057000] , [-2.454000, -1.038000] , [-1.119000, -1.086000] , [-0.720000, -0.455000] , [-2.738000, 0.962000] , [-2.565000, 1.992000] , [-4.603000, 2.434000] , [-2.689000, 2.118000] ]

```

以下代码读入标准普尔 500 和 AAPL 的月度价格数据，并计算它们的对数回报:

```py
// read the monthly S&P 500 data from a csv file
double[][] spx_arr
        = DoubleUtils.readCSV2d(
                this.getClass().getClassLoader().getResourceAsStream("sp500_monthly.csv"),
                true,
                true
        );
// convert the csv file into a matrix for manipulation
Matrix spx_M = new DenseMatrix(spx_arr);
// extract the column of adjusted close prices
Vector spx_v = spx_M.getColumn(5); // adjusted closes

// read the monthly S&P 500 data from a csv file
double[][] appl_arr
        = DoubleUtils.readCSV2d(
                this.getClass().getClassLoader().getResourceAsStream("AAPL_monthly.csv"),
                true,
                true
        );
// convert the csv file into a matrix for manipulation
Matrix aapl_M = new DenseMatrix(appl_arr);
// extract the column of adjusted close prices
Vector aapl_v = aapl_M.getColumn(5); // adjusted closes

// combine SPX and AAPL to form a bivariate time series
MultivariateSimpleTimeSeries mts
        = new MultivariateSimpleTimeSeries(cbind(spx_v, aapl_v));
System.out.println("(spx, aapl) prices: \n" + mts);

// compute the bivariate time series of log returns
Matrix p1 = mts.drop(1).toMatrix();
Matrix p = mts.toMatrix();
Matrix log_returns_M = p1.ZERO(); // allocate space for the new matrix
for (int i = 1; i <= p1.nRows(); i++) { // matrix and vector index starts from 1
    double r = log(p1.get(i, 1)) - log(p.get(i, 1));
    log_returns_M.set(i, 1, r);
    r = log(p1.get(i, 2)) - log(p.get(i, 2));
    log_returns_M.set(i, 2, r);
}
// convert a matrix to a multivariate time series
MultivariateSimpleTimeSeries log_returns
        = new MultivariateSimpleTimeSeries(log_returns_M);
System.out.println("(spx, aapl) log_returns: \n" + log_returns);

```

输出如下所示:

![../images/500382_1_En_15_Chapter/500382_1_En_15_Figc_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Figc_HTML.jpg)

图 [15-31](#Fig31) 和图 [15-32](#Fig32) 绘出了输出结果。图 [15-33](#Fig33) 在同一个图表上绘制了这两种股票的月收益率的对数。它清楚地显示了两个时间序列的共同运动。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig33_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig33_HTML.jpg)

图 15-33

标准普尔 500 和 AAPL 对数月收益率散点图

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig32_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig32_HTML.jpg)

图 15-32

AAPL 从 1980 年到 2019 年的日志月度回报

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig31_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig31_HTML.jpg)

图 15-31

标准普尔 500 从 1980 年到 2019 年的日志月度回报

让![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1t}\\ {}\vdots \end{array}}{X_{mt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq68.png)，那么***X***<sub>***t***</sub>的意思就是

![$$ \boldsymbol{\mu} =\mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}}\right)=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\mu}_1\\ {}\vdots \end{array}}{\mu_n}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmd.png)

*X* <sub>*it*</sub> 和 *X* <sub>*jt*</sub> 之间的互协方差函数是滞后距离*k*=∣*I*j∣.的函数它是超前滞后之间的协方差，也是成对分量之间的协方差。

![$$ \boldsymbol{\Gamma} (k)=\operatorname{cov}\left({\boldsymbol{X}}_{\boldsymbol{t}},{\boldsymbol{X}}_{\boldsymbol{t}+\boldsymbol{k}}\right)=\mathrm{E}\left(\left({\boldsymbol{X}}_{\boldsymbol{t}}-\boldsymbol{\mu} \right){\left({\boldsymbol{X}}_{\boldsymbol{t}+\boldsymbol{k}}-\boldsymbol{\mu} \right)}^{\prime}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equme.png)

![$$ =\mathrm{E}\left(\left(\begin{array}{c}{X}_{1t}-{\mu}_1\\ {}\vdots \\ {}{X}_{mt}-{\mu}_m\end{array}\right){\left(\begin{array}{c}{X}_{1t+k}-{\mu}_1\\ {}\vdots \\ {}{X}_{mt+k}-{\mu}_m\end{array}\right)}^{\prime}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmf.png)

![$$ =\left[\begin{array}{cccc}\operatorname{cov}\left({X}_{1t},{X}_{1\left(t+k\right)}\right)&amp; \operatorname{cov}\left({X}_{1t},{X}_{2\left(t+k\right)}\right)&amp; \dots &amp; \operatorname{cov}\left({X}_{1t},{X}_{m\left(t+k\right)}\right)\\ {}\operatorname{cov}\left({X}_{2t},{X}_{1\left(t+k\right)}\right)&amp; \operatorname{cov}\left({X}_{2t},{X}_{2\left(t+k\right)}\right)&amp; &amp; \operatorname{cov}\left({X}_{2t},{X}_{m\left(t+k\right)}\right)\\ {}\vdots &amp; &amp; \ddots &amp; \vdots \\ {}\operatorname{cov}\left({X}_{mt},{X}_{1\left(t+k\right)}\right)&amp; \operatorname{cov}\left({X}_{mt},{X}_{2\left(t+k\right)}\right)&amp; \dots &amp; \operatorname{cov}\left({X}_{mt},{X}_{m\left(t+k\right)}\right)\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmg.png)

![$$ =\left[\begin{array}{cccc}{\gamma}_{11}(k)&amp; {\gamma}_{12}(k)&amp; \dots &amp; {\gamma}_{1m}(k)\\ {}{\gamma}_{21}(k)&amp; {\gamma}_{22}(k)&amp; &amp; {\gamma}_{2m}(k)\\ {}\vdots &amp; &amp; \ddots &amp; \vdots \\ {}{\gamma}_{m1}(k)&amp; {\gamma}_{m2}(k)&amp; \dots &amp; {\gamma}_{mm}(k)\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmh.png)

其中 *i* = 1，2，...、 *m* 、 *j* = 1、2、...、 *m* 及以下:

![$$ {\gamma}_{ij}(k)=E\left[\left({X}_{it}-{\mu}_i\right)\ \left({X}_{j\left(t+k\right)}-{\mu}_j\right)\right]=E\left[\left({X}_{i\left(t-k\right)}-{\mu}_i\right)\left({X}_{jt}-{\mu}_j\right)\right]={\gamma}_{ij}\left(-k\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmi.png)

**γ**(*k*)称为向量过程{***X***<sub>***t***</sub>}的互协方差矩阵函数。*γ*<sub>*ij*</sub>(*k*)称为交叉滞后协方差。第 *i* 个分量的自协方差为*γ*<sub>*ii*</sub>(*k*)。矩阵**γ**(0)是过程的同生方差-协方差矩阵。第*I*th 和第*j*th 分量之间的协方差为*γ*<sub>*ij*</sub>(0)。第 *i* 个分量的方差为*γ*<sub>*ii*</sub>(0)。

向量过程的互相关矩阵函数如下:

![$$ \boldsymbol{\rho} (k)={\boldsymbol{D}}^{-\frac{1}{2}}\boldsymbol{\Gamma} (k){\boldsymbol{D}}^{-\frac{1}{2}}=\left[{\boldsymbol{\rho}}_{ij}(k)\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmj.png)

对于 *i* = 1，2，...、 *m* 和 *j* = 1，2，...， *m* 。

***D*** 是对角矩阵，其中第 *i* 个对角元素是第 *i* 个分量过程的方差。也就是

![$$ \boldsymbol{D}=\operatorname{diag}\left[{\gamma}_{11}(0),{\gamma}_{22}(0),\dots, {\gamma}_{nn}(0)\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmk.png)

*ρ*<sub>*ij*</sub>(*k*)是 *X* <sub>*it*</sub> 和*X*<sub>*JT*</sub>的互相关函数。

![$$ {\rho}_{ij}(k)=\frac{\gamma_{ij}(k)}{{\left[{\gamma}_{ii}(0){\gamma}_{jj}(0)\right]}^{\frac{1}{2}}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equml.png)

*ρ*<sub>*ii*</sub>(*k*)是第 *i* -th 分量序列*X*<sub>*it*</sub>的自相关函数。

### 风险值模型

向量自回归模型(VAR)是单变量自回归模型对多变量时间序列的自然延伸。它可能比使用单变量自回归模型提供更好的预测，因为 VAR 包含了组成时间序列之间的结构或依赖关系。

#### 15.3.1.1 风险值(1)

考虑这个 VAR(1)模型:

![$$ \left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1t}\\ {}\vdots \end{array}}{X_{mt}}\right)=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\mu}_1\\ {}\vdots \end{array}}{\mu_m}\right)+{\boldsymbol{\phi}}_{\mathbf{1}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1\left(t-1\right)}\\ {}\vdots \end{array}}{X_{m\left(t-1\right)}}\right)+\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1t}\\ {}\vdots \end{array}}{\varepsilon_{mt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmm.png)

在矩阵形式中，看起来是这样的:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +{\boldsymbol{\phi}}_{\mathbf{1}}{\boldsymbol{X}}_{\boldsymbol{t}-\mathbf{1}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmn.png)

其中***x***<sub>***t***</sub>是一个( *m* × 1)向量， ***μ*** 是一个( *m* × 1)向量，***ϕ***<sub>**1**</sub>是一个(*m*×*m*

 ****ε***<sub>***t***</sub>是一个具有零均值和协方差矩阵结构的( *m* × 1)白噪声向量，如下图:

![$$ \operatorname{cov}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}},{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\left\{\begin{array}{c}\boldsymbol{\Sigma}, k=0\\ {}0,k\ne 0\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmo.png)

其中**σ**是一个( *m* × *m* )对称正定矩阵。

就后移运算符 *B* 而言，我们有这样的:

![$$ \left({\boldsymbol{I}}_m-{\boldsymbol{\phi}}_{\mathbf{1}}B\right){\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Eqump.png)

其中***I***<sub>*m*</sub>为( *m* × *m* )恒等式矩阵。

如果特征方程的根 *z* 位于复单位圆之外，即| *z* | > 1，则 VAR(1)是平稳的。

det(**【我】**<sub>*【m】*</sub>**<sub>**【1】**</sub>**

 **VAR(1)的 ACVF 如下:

![$$ \boldsymbol{\Gamma} (k)=\mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}{\boldsymbol{X}}_{\boldsymbol{t}}^{\prime}\right)=\mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}{\left({\boldsymbol{\phi}}_{\mathbf{1}}{\boldsymbol{X}}_{\boldsymbol{t}-\mathbf{1}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}}\right)}^{\prime}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmq.png)

![$$ =\mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}{\boldsymbol{X}}_{\boldsymbol{t}-\mathbf{1}}^{\prime }{\boldsymbol{\phi}}_{\mathbf{1}}^{\prime }+{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}}^{\prime}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmr.png)

![$$ =\boldsymbol{\Gamma} \left(k-1\right){\boldsymbol{\phi}}_{\mathbf{1}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equms.png)

对于 *k* ≥ 1。

方差**γ**(0)计算如下:

![$$ \operatorname{var}\left({\boldsymbol{X}}_{\boldsymbol{t}}\right)={\boldsymbol{\phi}}_{\mathbf{1}}\operatorname{var}\left({\boldsymbol{X}}_{\boldsymbol{t}-\mathbf{1}}\right){\boldsymbol{\phi}}_{\mathbf{1}}^{\prime }+\operatorname{var}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmt.png)

因此矩阵方程如下:

![$$ \boldsymbol{\Gamma} (0)={\boldsymbol{\phi}}_{\mathbf{1}}\boldsymbol{\Gamma} (0){\boldsymbol{\phi}}_{\mathbf{1}}^{\prime }+\operatorname{var}\left(\boldsymbol{\Sigma} \right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmu.png)

求解**γ**(0)通常表示为移动平均系数的无穷和。

#### 有 15.3.1.2 个字母(p)

更一般地，VAR(p)模型被表示为滞后值的回归。

![$$ \left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1t}\\ {}\vdots \end{array}}{X_{mt}}\right)=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\mu}_1\\ {}\vdots \end{array}}{\mu_m}\right)+{\boldsymbol{\phi}}_{\mathbf{1}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1\left(t-1\right)}\\ {}\vdots \end{array}}{X_{m\left(t-1\right)}}\right)+\dots +{\boldsymbol{\phi}}_{\boldsymbol{p}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1\left(t-p\right)}\\ {}\vdots \end{array}}{X_{m\left(t-p\right)}}\right)+\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1t}\\ {}\vdots \end{array}}{\varepsilon_{mt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmv.png)T2】

其中**<sub>***I***</sub>是一个( *m* × *m* ) AR 系数矩阵。**

 *****ε***<sub>***t***</sub>是一个具有零均值和协方差矩阵结构的( *m* × 1)白噪声向量，如下图:

![$$ \operatorname{cov}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}},{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\left\{\begin{array}{c}\boldsymbol{\Sigma}, k=0\\ {}0,k\ne 0\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmw.png)

其中**σ**是一个( *m* × *m* )对称正定矩阵。

就后移运算符 *B* 而言，我们有如下:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +\left(\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{B}^i\right){\boldsymbol{X}}_{\boldsymbol{t}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmx.png)

或者说多肉植物，我们有以下:

![$$ \left({\boldsymbol{I}}_{\boldsymbol{m}}-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{B}^i\right){\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmy.png)

平稳性条件是特征多项式应该有根， *z* ，位于复单位圆外，即| *z* | > 1。

![$$ \det \left({\boldsymbol{I}}_{\boldsymbol{m}}-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{z}^i\right)=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq69.png) for | * z * | ≤ 1

作为一个例子，一个二元 VAR(p)模型可以写成如下:

![$$ \left(\genfrac{}{}{0pt}{}{X_t}{Y_t}\right)=\left(\genfrac{}{}{0pt}{}{\mu_1}{\mu_2}\right)+\left(\begin{array}{cc}{\phi}_{11}^1&amp; {\phi}_{12}^1\\ {}{\phi}_{21}^1&amp; {\phi}_{22}^1\end{array}\right)\left(\genfrac{}{}{0pt}{}{X_{t-1}}{Y_{t-1}}\right)+\dots +\left(\begin{array}{cc}{\phi}_{11}^p&amp; {\phi}_{12}^p\\ {}{\phi}_{21}^p&amp; {\phi}_{22}^p\end{array}\right)\left(\genfrac{}{}{0pt}{}{X_{t-p}}{Y_{t-p}}\right)+\left(\genfrac{}{}{0pt}{}{\varepsilon_{xt}}{\varepsilon_{yt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equmz.png)

在 NM Dev 中，我们可以使用类`VARModel`构建一个 VAR 模型。该类签名如下:

```py
public class VARModel extends VARMAModel {

    /**
     * Construct a VAR model.
     *
     * @param mu    the intercept (constant) vector
     * @param phi   the AR coefficients (excluding the initial 1)
     * @param sigma the white noise covariance matrix
     */
    public VARModel(Vector mu, Matrix[] phi, Matrix sigma);

    /**
     * Construct a VAR model with unit variance.
     *
     * @param mu  the intercept (constant) vector
     * @param phi the AR coefficients (excluding the initial 1)
     */
    public VARModel(Vector mu, Matrix[] phi);

    /**
     * Construct a VAR model with zero-intercept (mu).
     *
     * @param phi   the AR coefficients (excluding the initial 1)
     * @param sigma the white noise covariance matrix
     */
    public VARModel(Matrix[] phi, Matrix sigma);

    /**
     * Construct a VAR model with unit variance and zero-intercept (mu).
     *
     * @param phi the AR coefficients (excluding the initial 1)
     */
    public VARModel(Matrix[] phi);

    /**
     * Construct a multivariate model from a univariate AR model.
     *
     * @param model a univariate AR model
     */
    public VARModel(dev.nm.stat.timeseries.linear.univariate.stationaryprocess.arma.ARModel model);

    /**
     * Copy constructor.
     *
     * @param that a VAR model
     */
    public VARModel(VARModel that);
}

```

下面的代码片段构建了这个 VAR(1)模型:

![$$ \left\{\begin{array}{c}{X}_{1t}=0.7{X}_{1t-1}+0.12{X}_{2t-1}+{\varepsilon}_t\\ {}{X}_{2t}=0.31{X}_{1t-1}+0.6{X}_{2t-1}+{\varepsilon}_t\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equna.png)

或者等价地，

![$$ \left(\genfrac{}{}{0pt}{}{X_{1t}}{X_{2t}}\right)=\left(\begin{array}{cc}0.7&amp; 0.12\\ {}0.31&amp; 0.6\end{array}\right)\left(\genfrac{}{}{0pt}{}{X_{1\left(t-1\right)}}{X_{2\left(t-1\right)}}\right)+\left(\genfrac{}{}{0pt}{}{\varepsilon_{1t}}{\varepsilon_{2t}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnb.png)

```py
// construct a VAR(1) model
Matrix[] PHI = new Matrix[1];
PHI[0] = new DenseMatrix(
        new double[][]{
            {0.7, 0.12},
            {0.31, 0.6}
        });
VARModel var1 = new VARModel(PHI);
System.out.println("unconditional mean = " + var1.unconditionalMean());

```

输出如下所示:

```py
unconditional mean = [0.000000, 0.000000]

```

#### 15.3.1.3 VARX(p)

VARX 模型是 VAR 模型的扩展，它允许纳入外部变量，如通过线性回归确定的变量。一个 VARX(p)模型定义如下:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}+\boldsymbol{\psi} {\boldsymbol{D}}_{\boldsymbol{t}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnc.png)

其中***D***<sub>***t***</sub>是一个( *m* × 1)向量，包含时间 *t* 的所有外生变量(不包括截距项)，其系数由一个*m*-维向量 ***ψ*** 表示。

在 NM Dev 中，我们可以通过指定***【ϕ】***<sub>***I***</sub>和 ***ψ*** 来使用类`VARXModel`构造一个 VARX 模型。该类签名如下:

```py
public class VARXModel extends VARMAXModel {

    /**
     * Construct a VARX model.
     *
     * @param mu    the intercept (constant) vector
     * @param phi   the AR coefficients (excluding the initial 1)
     * @param psi   the coefficients of the deterministic terms (excluding the
     *              intercept)
     * @param sigma the white noise covariance matrix
     */
    public VARXModel(
            Vector mu,
            Matrix[] phi,
            Matrix psi,
            Matrix sigma
    );

    /**
     * Construct a VARX model with unit variance.
     *
     * @param mu  the intercept (constant) vector
     * @param phi the AR coefficients (excluding the initial 1)
     * @param psi the coefficients of the deterministic terms (excluding the
     *            intercept)
     */
    public VARXModel(
            Vector mu,
            Matrix[] phi,
            Matrix psi
    );

    /**
     * Construct a VARX model with zero-mean.
     *
     * @param phi   the AR coefficients (excluding the initial 1)
     * @param psi   the coefficients of the deterministic terms (excluding the
     *              intercept)
     * @param sigma the white noise covariance matrix
     */
    public VARXModel(
            Matrix[] phi,
            Matrix psi,
            Matrix sigma
    );

    /**
     * Construct a VARX model with unit variance and zero-mean.
     *
     * @param phi the AR coefficients (excluding the initial 1)
     * @param psi the coefficients of the deterministic terms (excluding the
     *            intercept)
     */
    public VARXModel(
            Matrix[] phi,
            Matrix psi
    );

    /**
     * Construct a VARX(p) from a transitory VECM(p).
     *
     * @param vecm a transitory VECM(p)
     */
    public VARXModel(VECMTransitory vecm);

    /**
     * Construct a VARX(p) from a long-run VECM(p).
     *
     * @param vecm a long-run VECM(p)
     */
    public VARXModel(VECMLongrun vecm);

    /**
     * Copy constructor.
     *
     * @param that a VARX model
     */
    public VARXModel(VARXModel that);
}

```

#### 15.3.1.4 估计

VAR(p)模型有多种方法估计模型参数，**，**<sub>***I***</sub>，**σ**。有些涉及最大可能性；有些涉及某种形式的线性回归。最简单的方法是对滞后的观测值，例如{*X*<sub>1(*t*—1)</sub>、*X*<sub>2(*t【T33—1)*</sub>),执行一次一个分量序列的 OLS 回归，例如*X*<sub>1*t*</sub>NM Dev 类`VARFit`实现了这样的估计算法。以下示例适用于由已知 VAR(2)模型随机生成的数据集。然后，我们将估计模型与真实模型进行比较。****

```py
// construct a VAR(2) model
Vector MU = new DenseVector(new double[]{1., 2.});
Matrix[] PHI = new Matrix[]{
    new DenseMatrix(new double[][]{
        {0.2, 0.3},
        {0., 0.4}}),
    new DenseMatrix(new double[][]{
        {0.1, 0.2},
        {0.3, 0.1}})
};
VARModel model0 = new VARModel(MU, PHI);

// construct a RNG from the model
VARIMASim sim = new VARIMASim(model0);
sim.seed(1234567891L);

// generate a random multivariate time series
final int N = 5000;
double[][] ts = new double[N][];
for (int i = 0; i < N; ++i) {
    ts[i] = sim.nextVector();
}
MultivariateIntTimeTimeSeries mts
        = new MultivariateSimpleTimeSeries(ts);

// fit the data to a VAR(2) model
VARModel model1 = new VARFit(mts, 2);
System.out.println("μ = ");
System.out.println(model1.mu());
System.out.println("ϕ_1 =");
System.out.println(model1.AR(1));
System.out.println("ϕ_2 =");
System.out.println(model1.AR(2));
System.out.println("sigma =");
System.out.println(model1.sigma());

```

输出如下所示:

```py
μ =
[1.074960, 1.980312]
ϕ _1 =
2x2
        [,1] [,2]
[1,] 0.214364, 0.275072,
[2,] -0.005042, 0.408162,
ϕ _2 =
2x2
         [,1] [,2]
[1,] 0.106844, 0.197318,
[2,] 0.293868, 0.106817,
sigma =
2x2
         [,1] [,2]
[1,] 1.000000, 0.000000,
[2,] 0.000000, 1.000000,

```

数据生成过程有这些模型参数:

![$$ \left\{\begin{array}{c}\boldsymbol{\mu} =\left[\begin{array}{c}1\\ {}2\end{array}\right]\\ {}{\boldsymbol{\phi}}_{\mathbf{1}}=\left[\begin{array}{cc}0.2&amp; 0.3\\ {}0&amp; 0.4\end{array}\right]\\ {}{\boldsymbol{\phi}}_{\mathbf{2}}=\left[\begin{array}{cc}0.1&amp; 0.2\\ {}0.3&amp; 0.1\end{array}\right]\\ {}\boldsymbol{\Sigma} =\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; 1\end{array}\right]\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Eqund.png)

估计型号如下:

![$$ \left\{\begin{array}{c}\boldsymbol{\mu} =\left[\begin{array}{c}1.074960\\ {}1.980312\end{array}\right]\\ {}{\boldsymbol{\phi}}_{\mathbf{1}}=\left[\begin{array}{cc}0.214364&amp; 0.275072\\ {}-0.005042&amp; 0.408162\end{array}\right]\\ {}{\boldsymbol{\phi}}_{\mathbf{2}}=\left[\begin{array}{cc}0.106844&amp; 0.197318\\ {}0.293868&amp; 0.106817\end{array}\right]\\ {}\boldsymbol{\Sigma} =\left[\begin{array}{cc}1&amp; 0\\ {}0&amp; 1\end{array}\right]\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equne.png)

因此，拟合模型相当接近真实模型。

继续我们的标准普尔 500 和 AAPL 的例子，我们拟合数据的 VAR(1)模型。

```py
// fit the log returns to an VAR(1) model
VARFit fit = new VARFit(log_returns, 1);
System.out.println("the estimated phi_1 for var(1) is");
System.out.println(fit.AR(1));

```

标准普尔 500*X*<sub>T3t</sub>和 AAPL*Y*<sub>*t*</sub>的对数收益率拟合模型如下:

![$$ \left\{\begin{array}{c}{X}_t=0.0149{X}_{t-1}+0.0202{Y}_{t-1}+{\varepsilon}_{Xt}\\ {}{Y}_t=0.0307{X}_{t-1}+0.0599{Y}_{t-1}+{\varepsilon}_{Yt}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnf.png)

#### 15.3.1.5 天气预报

NM Dev 使用新息算法的多元版本对 VAR 模型(或更一般的 VARMA 模型)进行预测，如 15.2.3.3 部分所示。该算法只需要时间序列的自协方差结构进行预测。详见 Brockwell & Davis (2006)。NM Dev 类`MultivariateForecastOneStep`实现了这样一种算法。

为了便于说明，下面的代码对我们视为多变量时间序列的单变量 MA(1)过程进行预测:

![$$ {X}_t={\varepsilon}_t+\theta {\varepsilon}_{t-1} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equng.png)

自协方差函数如下:

![$$ \left\{\begin{array}{c}\gamma (0)={\sigma}^2\left(1+{\theta}^2\right)\\ {}\gamma (1)=\theta {\sigma}^2\\ {}\gamma (k)=0,k&gt;1\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnh.png)

```py
// MA(1) model parameters
final double theta = -0.9;
final double sigma = 1;

// a multivariate time series (although the dimension is just 1)
MultivariateIntTimeTimeSeries Xt
        = new MultivariateSimpleTimeSeries(
                new double[][]{
                    {-2.58},
                    {1.62},
                    {-0.96},
                    {2.62},
                    {-1.36}
                });

// the autocovariance function
MultivariateAutoCovarianceFunction K = new MultivariateAutoCovarianceFunction() {

    @Override
    public Matrix evaluate(double x1, double x2) {
        int i = (int) x1;
        int j = (int) x2;

        double k = 0;

        if (i == j) {
            k = sigma * sigma;
            k *= 1 + theta * theta;
        }

        if (Math.abs(j - i) == 1) {
            k = theta;
            k *= sigma * sigma;
        }

        // γ = 0 otherwise
        DenseMatrix result = new DenseMatrix(new double[][]{{k}});
        return result;
    }
};

// run the innovation algorithm
MultivariateForecastOneStep forecast
        = new MultivariateForecastOneStep(Xt, K);

// making forecasts
for (int i = 0; i <= 5; ++i) {
    System.out.println(Arrays.toString(forecast.xHat(i).toArray()));
}

```

输出如下所示:

```py
[0.0]
[1.2828729281767954]
[-0.22269169944446712]
[0.5459302808535396]
[-1.632259252377928]
[-0.22241089478200632]

```

继续我们在标准普尔 500 和 AAPL 的例子，我们使用创新算法来预测这两个股票的未来对数回报。NM Dev 类`MultivariateAutoCovarianceFunction`从一个(降级的)模型中自动构造自协方差函数。

```py
VARMAModel log_returns2 = fit.getDemeanedModel(); // demeaned version

// predict the future values using the innovation algorithm
MultivariateAutoCovarianceFunction K
        = new VARMAAutoCovariance(log_returns2, log_returns.size());
MultivariateForecastOneStep forecast
        = new MultivariateForecastOneStep(log_returns, K);
for (int i = 0; i <= 5; ++i) {
    System.out.println(Arrays.toString(forecast.xHat(i).toArray()));
}

```

输出如下所示:

```py
[-0.0011136954759254775, -0.0034724968295386954]
[-0.0010870486562220205, -0.0036785428307488867]
[0.002652352403164996, 0.008171489429722277]
[0.0031357055857177477, 0.009321715600157739]
[-0.005096491742666534, -0.014981786357934351]

```

### VMA 模型

向量移动平均(VMA)模型是一系列 *m* 维白噪声随机向量的线性组合。

#### 15.3.2.1·VMA①

考虑一个 VMA①模型:

![$$ \left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1t}\\ {}\vdots \end{array}}{X_{mt}}\right)=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\mu}_1\\ {}\vdots \end{array}}{\mu_m}\right)+{\theta}_1\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1\left(t-1\right)}\\ {}\vdots \end{array}}{\varepsilon_{m\left(t-1\right)}}\right)+\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1t}\\ {}\vdots \end{array}}{\varepsilon_{mt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equni.png)

在矩阵符号中，我们有这样的:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +{\boldsymbol{\phi}}_{\mathbf{1}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\mathbf{1}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnj.png)

其中***X***<sub>***t***</sub>是一个( *m* × 1)向量，***μ***an(*m*×1)向量，***θ***<sub>**1**</sub>an(*n*×*n*

*ε* <sub>*t*</sub> 是一个具有零均值和协方差矩阵结构的( *m* × 1)白噪声向量，如下图:

![$$ \operatorname{cov}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}},{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\left\{\begin{array}{c}\boldsymbol{\Sigma}, k=0\\ {}0,k\ne 0\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnk.png)

其中**σ**是一个( *m* × *m* )对称正定矩阵。

#### 15.3.2.2 VMA(q)

一般来说， *q* 阶的 VMA(q)模型是对之前白噪声的观测值的回归，如下图:

![$$ \left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1t}\\ {}\vdots \end{array}}{X_{mt}}\right)=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\mu}_1\\ {}\vdots \end{array}}{\mu_m}\right)+{\boldsymbol{\theta}}_{\mathbf{1}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1\left(t-1\right)}\\ {}\vdots \end{array}}{\varepsilon_{m\left(t-1\right)}}\right)+\dots +{\boldsymbol{\theta}}_{\boldsymbol{q}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1\left(t-q\right)}\\ {}\vdots \end{array}}{\varepsilon_{m\left(t-q\right)}}\right)+\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1t}\\ {}\vdots \end{array}}{\varepsilon_{mt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnl.png)

其中***θ***<sub>***I***</sub>为( *m* × *m* ) MA 系数矩阵。

***ε***<sub>***t***</sub>是*m*-具有零均值和协方差矩阵结构的多维白噪声随机向量，如下图:

![$$ \operatorname{cov}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}},{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\left\{\begin{array}{c}\boldsymbol{\Sigma}, k=0\\ {}0,k\ne 0\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnm.png)

其中**σ**是一个( *m* × *m* )对称正定矩阵。

就后移运算符 *B* 而言，我们有这样的:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +\left(\boldsymbol{I}+\sum \limits_{i=1}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}{B}^i\right){\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnn.png)

与标量情况一样，任何 VMA(q)过程对于有限的 *q* 都是稳定的。对于 VMA(∞)过程，如果矩阵序列![$$ {\left\{{\boldsymbol{\theta}}_{\boldsymbol{i}}\right\}}_{i=0}^{\infty } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq70.png)是绝对可和的，则它是平稳的。也就是说，对于任何一个 *i* = 1，2，...， *m* 和 *j* = 1，2，...， *m* ，我们有这个:

![$$ {\sum}_{s=0}^{\infty }{\theta}_{ij,s}&lt;\infty $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equno.png)

其中*θ*<sub>T3】ij， *s*</sub> 是矩阵 *θ* <sub>*ij* ， *s*</sub> 的行 *i* 和列 *j* 元素。

在 NM Dev 中，我们可以使用类`VMAModel`构建一个 VMA 模型。该类签名如下:

```py
public class VMAModel extends VARMAModel {

    /**
     * Construct a multivariate MA model.
     *
     * @param mu    the intercept (constant) vector
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param sigma the white noise covariance matrix
     */
    public VMAModel(
            Vector mu,
            Matrix[] theta,
            Matrix sigma
    );

    /**
     * Construct a multivariate MA model with unit variance.
     *
     * @param mu    the intercept (constant) vector
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     */
    public VMAModel(
            Vector mu,
            Matrix[] theta
    );

    /**
     * Construct a multivariate MA model with zero-mean.
     *
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param sigma the white noise covariance matrix
     */
    public VMAModel(
            Matrix[] theta,
            Matrix sigma
    );

    /**
     * Construct a multivariate MA model with unit variance and zero-mean.
     *
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     */
    public VMAModel(Matrix[] theta);

    /**
     * Construct a multivariate MA model from a univariate MA model.
     *
     * @param model a univariate MA model
     */
    public VMAModel(dev.nm.stat.timeseries.linear.univariate.stationaryprocess.arma.MAModel model);

    /**
     * Copy constructor.
     *
     * @param that a multivariate MA model
     */
    public VMAModel(VMAModel that);
}

```

下面的代码显示了如何构建这个 VMA (1)模型:

![$$ \left\{\begin{array}{c}{X}_{1t}=0.5{\varepsilon}_{1t-1}+0.16{\varepsilon}_{2t-1}+{\varepsilon}_{1t}\\ {}{X}_{2t}=-0.7{\varepsilon}_{1t-1}+0.28{\varepsilon}_{2t-1}+{\varepsilon}_{2t}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnp.png)

```py
// construct a VAR(1) model
Matrix[] THETA = new Matrix[1];
THETA[0] = new DenseMatrix(
        new double[][]{
            {0.5, 0.16},
            {-0.7, 0.28}
        });
VMAModel vma1 = new VMAModel(THETA);
System.out.println("unconditional mean = " + vma1.unconditionalMean());

```

输出如下所示:

```py
unconditional mean = [0.000000, 0.000000]

```

### 瓦尔马模型

多元 VARMA 模型是 VAR 和 VMA 模型的组合。也就是

![$$ \left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1t}\\ {}\vdots \end{array}}{X_{mt}}\right)=\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\mu}_1\\ {}\vdots \end{array}}{\mu_m}\right)+{\boldsymbol{\phi}}_{\mathbf{1}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1\left(t-1\right)}\\ {}\vdots \end{array}}{X_{m\left(t-1\right)}}\right)+\dots +{\boldsymbol{\phi}}_{\boldsymbol{p}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{X}_{1\left(t-p\right)}\\ {}\vdots \end{array}}{X_{m\left(t-p\right)}}\right)+{\boldsymbol{\theta}}_{\mathbf{1}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1\left(t-1\right)}\\ {}\vdots \end{array}}{\varepsilon_{m\left(t-1\right)}}\right)+\dots +{\boldsymbol{\theta}}_{\boldsymbol{q}}\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1\left(t-q\right)}\\ {}\vdots \end{array}}{\varepsilon_{m\left(t-q\right)}}\right)+\left(\genfrac{}{}{0pt}{}{\begin{array}{c}{\varepsilon}_{1t}\\ {}\vdots \end{array}}{\varepsilon_{mt}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnq.png)

其中**<sub>***I***</sub>是一个( *m* × *m* ) AR 系数矩阵和***θ***<sub>***j***</sub>an(*m*×*m*)ma 系数矩阵。**

 **在矩阵符号中，我们有这样的:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\mu} +\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}+\sum \limits_{i=1}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnr.png)

***X***<sub>***t***</sub>， ***μ*** ，***ε***<sub>***t***</sub>都是*m*-维向量。

***ε***<sub>***t***</sub>是一个具有零均值和协方差矩阵结构的( *m* × 1)白噪声向量，如下图:

![$$ \operatorname{cov}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}},{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}+\boldsymbol{k}}^{\prime}\right)=\left\{\begin{array}{c}\boldsymbol{\Sigma}, k=0\\ {}0,k\ne 0\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equns.png)

其中**σ**是一个( *m* × *m* )对称正定矩阵。

在 NM Dev 中，我们可以使用类`VARMAModel`构建一个 VARMA 模型。该类签名如下:

```py
public class VARMAModel extends VARIMAModel {

    /**
     * Construct a multivariate ARMA model.
     *
     * @param mu    the intercept (constant) vector
     * @param phi   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param sigma the white noise covariance matrix
     */
    public VARMAModel(
            Vector mu,
            Matrix[] phi,
            Matrix[] theta,
            Matrix sigma
    );

    /**
     * Construct a multivariate ARMA model with unit variance.
     *
     * @param mu    the intercept (constant) vector
     * @param phi   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     */
    public VARMAModel(
            Vector mu,
            Matrix[] phi,
            Matrix[] theta
    );

    /**
     * Construct a multivariate ARMA model with zero-intercept (mu).
     *
     * @param phi   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param sigma the white noise covariance matrix
     */
    public VARMAModel(
            Matrix[] phi,
            Matrix[] theta,
            Matrix sigma
    );

    /**
     * Construct a multivariate ARMA model with unit variance and zero-intercept
     * (mu).
     *
     * @param phi   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param theta the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     */
    public VARMAModel(
            Matrix[] phi,
            Matrix[] theta
    );

    /**
     * Construct a multivariate model from a univariate ARMA model.
     *
     * @param model a univariate ARMA model
     */
    public VARMAModel(dev.nm.stat.timeseries.linear.univariate.stationaryprocess.arma.ARMAModel model);

    /**
     * Copy constructor.
     *
     * @param that a multivariate ARMA model
     */
    public VARMAModel(VARMAModel that);

    /**
     * Compute the multivariate ARMA conditional mean, given all the lags.
     *
     * @param arLags the AR lags
     * @param maLags the MA lags
     * @return the conditional mean
     */
    public Vector conditionalMean(
            Matrix arLags,
            Matrix maLags
    );

    /**
     * Compute the multivariate ARMA unconditional mean.
     *
     * @return the unconditional mean
     */
    public Vector unconditionalMean();

    /**
     * Get the demeaned version of the time-series model.
     * \[
     * Y_t = (X_t - \mu) = \sum_{i=1}^p \phi_i (X_{t-i} - \mu) + \sum_{i=1}^q
     * \theta_j
     * \epsilon_{t-j} + \epsilon_t
     * \]
     * &mu; is the unconditional mean.
     *
     * @return the demeaned time series
     */
    public VARMAModel getDemeanedModel();

```

例如，下面的代码为 *X* <sub>*t*</sub> 和*Y*<sub>*t*</sub>:

![$$ \left\{\begin{array}{c}{X}_t=0.7{X}_{t-1}+0.5{\varepsilon}_{t-1}+0.6{\varepsilon}_{t-2}+{\varepsilon}_X\\ {}{Y}_t=0.6\ {Y}_{t-1}-0.7{\varepsilon}_{t-1}+0.8{\varepsilon}_{t-2}+{\varepsilon}_Y\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnt.png)

构造了这个 VARMA(1，1)

```py
// construct a VARMA(1,1) model
Matrix PHI1 = new DenseMatrix(
        new double[][]{
            {0.7, 0},
            {0, 0.6}
        });
Matrix THETA1 = new DenseMatrix(
        new double[][]{
            {0.5, 0.6},
            {-0.7, 0.8}
        });
VARMAModel varma11 = new VARMAModel(
        new Matrix[]{PHI1},
        new Matrix[]{THETA1}
);
System.out.println("unconditional mean = " + varma11.unconditionalMean());

```

输出如下所示:

```py
unconditional mean = [0.000000, 0.000000]

```

对于贬低的 VARMA(p，q)过程，如下所示:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}+\sum \limits_{i=1}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}+{\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnu.png)

![$$ \left(\boldsymbol{I}-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{B}^i\right){\boldsymbol{X}}_{\boldsymbol{t}}=\left(\boldsymbol{I}+\sum \limits_{i=1}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}{B}^i\right){\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnv.png)

还是多肉的，长这样:

![$$ \boldsymbol{\phi} (B){\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\Theta} (B){\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnw.png)

其中

![$$ \boldsymbol{\phi} (B)=\left(\boldsymbol{I}-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{B}^i\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnx.png)

还有

![$$ \boldsymbol{\Theta} (B)=\left(\boldsymbol{I}+\sum \limits_{i=1}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}{B}^i\right){\boldsymbol{\varepsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equny.png)

***I*** 是单位矩阵。**(*b*)和**θ**(*b*)是矩阵值多项式，这样我们有:**

**![$$ \boldsymbol{\phi} (z)=\boldsymbol{I}-{\boldsymbol{\phi}}_{\mathbf{1}}z-\dots -{\boldsymbol{\phi}}_{\boldsymbol{p}}{z}^p $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equnz.png)**

 **还有这个:

![$$ \boldsymbol{\Theta} (z)=\boldsymbol{I}+{\boldsymbol{\theta}}_{\mathbf{1}}z+\dots +{\boldsymbol{\theta}}_{\boldsymbol{q}}{\boldsymbol{z}}^{\boldsymbol{q}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoa.png)

可以看出，***x***<sub>***t***</sub>是因果的，意思是说***x***<sub>***t***</sub>可以写成一个无限和的马项，当且仅当根，**(*z***

 **也就是说，当且仅当:

det**(*z*)≥0，表示|*|≤1***

 ***于是我们有了这个:

![$$ {\boldsymbol{X}}_{\boldsymbol{t}}=\sum \limits_{i=0}^{\infty }{\boldsymbol{\Psi}}_{\boldsymbol{i}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equob.png)

其中:

![$$ \boldsymbol{\Psi} (z)=\sum \limits_{i=0}^{\infty }{\boldsymbol{\Psi}}_{\boldsymbol{i}}{z}^i={\boldsymbol{\phi}}^{-\mathbf{1}}(z)\boldsymbol{\Theta} (z) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoc.png)

另一方面，可以证明***X***<sub>***t***</sub>是可逆的，意味着***X***<sub>***t***</sub>可以写成 AR 项的无穷和，当且仅当**θ**(*z*

也就是说，当且仅当:

det**θ**(*z*)≠0，for | *z* | ≤ 1

于是我们有了以下:

![$$ {\boldsymbol{\varepsilon}}_{\boldsymbol{t}}=\sum \limits_{i=0}^{\infty }{\boldsymbol{\Pi}}_{\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equod.png)

其中:

![$$ \boldsymbol{\Pi} (z)=\sum \limits_{i=0}^{\infty }{\boldsymbol{\Pi}}_{\boldsymbol{i}}{z}^i={\boldsymbol{\Theta}}^{-\mathbf{1}}(z)\boldsymbol{\phi} (z) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoe.png)

我们通常假设***X***<sub>***t***</sub>是平稳的、因果的、可逆的。

要求过程的自协方差函数，**γ**(*k*，考虑将 ARMA 方程的两边乘以![$$ {\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq71.png)，取期望值。ARMA 方程如下:

![$$ \left(\sum \limits_{i=0}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}\right)=\left(\sum \limits_{i=0}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equof.png)

![$$ {\boldsymbol{\phi}}_{\mathbf{0}}={\boldsymbol{\theta}}_{\mathbf{0}}=\boldsymbol{I} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equog.png)

这就给出了如下:

![$$ \sum \limits_{i=0}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}^{\prime}\right)=\sum \limits_{i=0}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}^{\prime}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoh.png)

为了计算![$$ \mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}^{\prime}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_IEq72.png)，我们可以使用 ARMA 过程(因果关系)的无限阶移动平均表示。

![$$ {\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}=\sum \limits_{j=0}^{\infty }{\boldsymbol{\Psi}}_{\boldsymbol{j}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{k}-\boldsymbol{j}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoi.png)

把这两个方程放在一起，我们就有了这个:

![$$ \sum \limits_{i=0}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}^{\prime}\right)=\sum \limits_{i=0}^q\sum \limits_{j=0}^{\infty }{\boldsymbol{\theta}}_{\boldsymbol{i}}\mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{k}-\boldsymbol{j}}^{\prime}\right){\boldsymbol{\Psi}}_{\boldsymbol{j}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoj.png)

注意以下:

![$$ \mathrm{E}\left({\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{X}}_{\boldsymbol{t}-\boldsymbol{k}}^{\prime}\right)=\boldsymbol{\Gamma} \left(k-i\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equok.png)

![$$ \mathrm{E}\left({\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{i}}{\boldsymbol{\varepsilon}}_{\boldsymbol{t}-\boldsymbol{k}-\boldsymbol{j}}^{\prime}\right)=\left\{\begin{array}{c}\boldsymbol{\Sigma}, j=i-k\\ {}\mathbf{0},j\ne i-k\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equol.png)

我们可以将方程简化为:

![$$ \sum \limits_{i=0}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\boldsymbol{\Gamma} \left(k-i\right)=\sum \limits_{i=k}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}\boldsymbol{\Sigma} {\boldsymbol{\Psi}}_{\boldsymbol{i}-\boldsymbol{k}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equom.png)

因果 ARMA 过程的自协方差函数可以通过求解 Yule-Walker 方程组递归确定:

![$$ \boldsymbol{\Gamma} (k)=\left\{\begin{array}{c}-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\boldsymbol{\Gamma} \left(k-i\right)+\sum \limits_{i=k}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}\boldsymbol{\Sigma} {\boldsymbol{\Psi}}_{\boldsymbol{i}-\boldsymbol{k}}^{\prime },k\le q\\ {}-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\boldsymbol{\Gamma} \left(k-i\right),k&gt;q\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equon.png)

在纯自回归过程的情况下， *p* ，*T3】θ*<sub>***I***</sub>***=*****0**为 *i* > 1，有以下几种:

![$$ \left\{\begin{array}{c}\boldsymbol{\Gamma} (0)=-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\boldsymbol{\Gamma} (i)+\boldsymbol{\Sigma} \\ {}\boldsymbol{\Gamma} (k)=-\sum \limits_{i=1}^p{\boldsymbol{\phi}}_{\boldsymbol{i}}\boldsymbol{\Gamma} \left(k-i\right)\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoo.png)

在纯移动平均过程的情况下， *q* ，***ϕ***<sub>***I***</sub>***=*****0**为 *i* > 0，有以下几种:

![$$ \boldsymbol{\Gamma} (k)=\sum \limits_{i=k}^q{\boldsymbol{\theta}}_{\boldsymbol{i}}\boldsymbol{\Sigma} {\boldsymbol{\theta}}_{\boldsymbol{i}-\boldsymbol{k}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equop.png)

对于 *k* = 0，...，*问*。

在 NM Dev 中，类`VARMAAutoCovariance`计算因果 VARMA 过程的自协方差函数。类`VARMAAutoCorrelation`计算自相关函数。我们在《15.3.1.5》一节中看到了如何计算标准普尔 500 指数对数收益的自协方差函数。以下是计算 VARMA 模型的自协方差函数的另一个示例:

```py
// the AR coefficients
Matrix[] AR = new Matrix[1];
AR[0] = new DenseMatrix(
        new double[][]{
            {0.5, 0.5},
            {0, 0.5}});

// the MA coefficients
Matrix[] MA = new Matrix[1];
MA[0] = AR[0].t();

// SIGMA
Matrix SIGMA
        = new DenseMatrix(
                new double[][]{
                    {1, 0.2},
                    {0.2, 1}
                });

// define a VARMA(1,1) model
VARMAModel varma11 = new VARMAModel(AR, MA, SIGMA);

// comptue the autocovariance function for a VARMA process up to a certian number of lags
VARMAAutoCovariance GAMMA
        = new VARMAAutoCovariance(
                varma11,
                10 // number of lags
        );

// print out the autocovariance function
for (int i = 0; i <= 5; ++i) {
    System.out.printf("GAMMA(%d) = %n", i);
    System.out.println(GAMMA.evaluate(1));
    System.out.println();
}

```

输出如下所示:

```py
GAMMA(0) =
2x2
         [,1] [,2]
[1,] 5.598667, 3.897333,
[2,] 3.524000, 3.241333,

GAMMA(1) =
2x2
         [,1] [,2]
[1,] 5.598667, 3.897333,
[2,] 3.524000, 3.241333,

GAMMA(2) =
2x2
         [,1] [,2]
[1,] 5.598667, 3.897333,
[2,] 3.524000, 3.241333,

GAMMA(3) =
2x2
         [,1] [,2]
[1,] 5.598667, 3.897333,
[2,] 3.524000, 3.241333,

GAMMA(4) =
2x2
         [,1] [,2]
[1,] 5.598667, 3.897333,
[2,] 3.524000, 3.241333,

GAMMA(5) =
2x2
         [,1] [,2]
[1,] 5.598667, 3.897333,
[2,] 3.524000, 3.241333,

```

### 15.3.4 瓦里马模型

与标量时间序列的情况一样，当存在单位根或数据不稳定时，我们可以取第一个差，并对差进行建模。一个 VARIMA(p，d，q)过程是一个多元时间序列***Y***<sub>***t***</sub>这样我们就有了这个:

![$$ \left\{\begin{array}{c}{\boldsymbol{X}}_{\boldsymbol{t}}={\left(\boldsymbol{I}-B\right)}^{\boldsymbol{d}}{\boldsymbol{Y}}_{\boldsymbol{t}}\\ {}\boldsymbol{\phi} (B){\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\Theta} (B){\boldsymbol{\varepsilon}}_{\boldsymbol{t}}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoq.png)

在 NM Dev 中，类`VARIMAModel`代表了这样一个模型。该类签名如下:

```py
public class VARIMAModel extends VARIMAXModel {

    /**
     * Construct a multivariate ARIMA model.
     *
     * @param MU    the intercept (constant) vector
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param SIGMA the white noise covariance matrix
     */
    public VARIMAModel(
            Vector MU,
            Matrix[] PHI,
            int d,
            Matrix[] THETA,
            Matrix SIGMA
    );

    /**
     * Construct a multivariate ARIMA model with unit variance.
     *
     * @param MU    the intercept (constant) vector
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     */
    public VARIMAModel(
            Vector MU,
            Matrix[] PHI,
            int d,
            Matrix[] THETA
    );

    /**
     * Construct a multivariate ARIMA model with zero-intercept (mu).
     *
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param SIGMA the white noise covariance matrix
     */
    public VARIMAModel(
            Matrix[] PHI,
            int d,
            Matrix[] THETA,
            Matrix SIGMA
    );

    /**
     * Construct a multivariate ARIMA model with unit variance and
     * zero-intercept (mu).
     *
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     */
    public VARIMAModel(
            Matrix[] PHI,
            int d,
            Matrix[] THETA
    );

    /**
     * Construct a multivariate model from a univariate ARIMA model.
     *
     * @param model a univariate ARIMA model
     */
    public VARIMAModel(dev.nm.stat.timeseries.linear.univariate.arima.ARIMAModel model);

    /**
     * Copy constructor.
     *
     * @param that a multivariate ARIMA model
     */
    public VARIMAModel(VARIMAModel that);

    /**
     * Get the ARMA part of this ARIMA model, essentially ignoring the
     * differencing.
     *
     * @return the ARMA part
     */
    public VARMAModel getVARMA();
}

```

例如，下面的代码构造了这个 VARIMA 过程:

![$$ \left\{\begin{array}{c}\Delta {\boldsymbol{Y}}_{\boldsymbol{t}}={\boldsymbol{Y}}_{\boldsymbol{t}}-{\boldsymbol{Y}}_{\boldsymbol{t}-\mathbf{1}}=\boldsymbol{c}+{\boldsymbol{X}}_{\boldsymbol{t}}\\ {}{X}_{1t}=0.3{X}_{1t-1}-0.2{X}_{2t-1}+0.2{\varepsilon}_{1t-1}+{\varepsilon}_{1t}\\ {}{X}_{2t}=0.05{X}_{1t-1}+0.04{X}_{2t-1}+0.5{\varepsilon}_{2t-1}+{\varepsilon}_{2t}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equor.png)

```py
// the AR coefficients
Matrix[] PHI_1 = new Matrix[4];
PHI_1[0] = new DenseMatrix(new DenseVector(new double[]{0.3}));
PHI_1[1] = new DenseMatrix(new DenseVector(new double[]{-0.2}));
PHI_1[2] = new DenseMatrix(new DenseVector(new double[]{0.05}));
PHI_1[3] = new DenseMatrix(new DenseVector(new double[]{0.04}));

// the MA coefficients
Matrix[] THETA_1 = new Matrix[2];
THETA_1[0] = new DenseMatrix(new DenseVector(new double[]{0.2}));
THETA_1[1] = new DenseMatrix(new DenseVector(new double[]{0.5}));

// the order of integration
int d = 1;

// construct a VARIMA(1,1,1) model
VARIMAModel varima111 = new VARIMAModel(PHI_1, d, THETA_1);

```

我们也可以在等式中加入外生变量或因素。一个 VARIMAX(p，d，q)模型是这样的，我们有这个:

![$$ \left\{\begin{array}{c}{\boldsymbol{X}}_{\boldsymbol{t}}={\left(\boldsymbol{I}-B\right)}^{\boldsymbol{d}}{\boldsymbol{Y}}_{\boldsymbol{t}}\\ {}\boldsymbol{\phi} (B){\boldsymbol{X}}_{\boldsymbol{t}}=\boldsymbol{\Theta} (B){\boldsymbol{\varepsilon}}_{\boldsymbol{t}}+{\boldsymbol{\psi}}_{\boldsymbol{t}}{\boldsymbol{D}}_{\boldsymbol{t}}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equos.png)

其中***D***<sub>***t***</sub>是包含时间 *t* (不含截距项)所有外生变量的向量，其系数表示为向量***ψ***<sub>***t***</sub>。

在 NM Dev 中，类`VARIMAXModel`代表了这样一个模型。该类签名如下:

```py
public class VARIMAXModel {

    /**
     * Construct a multivariate ARIMAX model.
     *
     * @param MU    the intercept (constant) vector
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param PSI   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     * @param SIGMA the white noise covariance matrix
     */
    public VARIMAXModel(
            Vector MU,
            Matrix[] PHI,
            int d,
            Matrix[] THETA,
            Matrix PSI,
            Matrix SIGMA
    );

    /**
     * Construct a multivariate ARIMAX model with unit variance.
     *
     * @param MU    the intercept (constant) vector
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param PSI   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     */
    public VARIMAXModel(
            Vector MU,
            Matrix[] PHI,
            int d,
            Matrix[] THETA,
            Matrix PSI
    );

    /**
     * Construct a multivariate ARIMAX model with zero-intercept (mu).
     *
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param PSI   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     * @param SIGMA the white noise covariance matrix
     */
    public VARIMAXModel(
            Matrix[] PHI,
            int d,
            Matrix[] THETA,
            Matrix PSI,
            Matrix SIGMA
    );

    /**
     * Construct a multivariate ARIMAX model with unit variance and
     * zero-intercept (mu).
     *
     * @param PHI   the AR coefficients (excluding the initial 1); {@code null}
     *              if no AR coefficient
     * @param d     the order of integration
     * @param THETA the MA coefficients (excluding the initial 1); {@code null}
     *              if no MA coefficient
     * @param PSI   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     */
    public VARIMAXModel(
            Matrix[] PHI,
            int d,
            Matrix[] THETA,
            Matrix PSI
    );

    /**
     * Copy constructor.
     *
     * @param that a multivariate ARIMAX model
     */
    public VARIMAXModel(VARIMAXModel that);

    /**
     * Construct a multivariate ARIMAX model from a univariate ARIMAX model.
     *
     * @param model a univariate ARIMAX model
     */
    public VARIMAXModel(
            dev.nm.stat.timeseries.linear.univariate.arima.ARIMAXModel model
    );

    /**
     * Get the intercept (constant) vector.
     *
     * @return the intercept (constant) vector
     */
    public ImmutableVector mu();

    /**
     * Get the <i>i</i>-th AR coefficient; AR(0) = 1.
     *
     * @param i an index
     * @return the <i>i</i>-th AR coefficient
     */
    public ImmutableMatrix AR(int i);

    /**
     * Get all the AR coefficients.
     *
     * @return all the AR coefficients
     */
    public ImmutableMatrix[] phi();

    /**
     * Get the <i>i</i>-th MA coefficient; MA(0) = 1.
     *
     * @param i an index
     * @return the <i>i</i>-th MA coefficient
     */
    public ImmutableMatrix MA(int i);

    /**
     * Get all the MA coefficients.
     *
     * @return all the MA coefficients
     */
    public ImmutableMatrix[] theta();

    /**
     * Get the coefficients of the deterministic terms.
     *
     * @return the coefficients of the deterministic terms; could be
     *         {@code null}
     */
    public ImmutableMatrix psi();

    /**
     * Get the order of integration.
     *
     * @return the order of integration
     */
    public int d();

    /**
     * Get the dimension of multivariate time series.
     *
     * @return the dimension of multivariate time series
     */
    public int dimension();

    /**
     * Get the number of AR terms.
     *
     * @return the number of AR terms
     */
    public int p();

    /**
     * Get the number of MA terms.
     *
     * @return the number of MA terms
     */
    public int q();

    /**
     * Get the maximum of AR length or MA length.
     *
     * @return max(# AR terms, # MA terms)
     */
    public int maxPQ();

    /**
     * Get the white noise covariance matrix.
     *
     * @return the white noise covariance matrix
     */
    public ImmutableMatrix sigma();

    /**
     * Get the ARMAX part of this ARIMAX model, essentially ignoring the
     * differencing.
     *
     * @return the ARMAX part
     */
    public VARMAXModel getVARMAX();
}

```

NM Dev 类`VARIMASim`采用 VARIMA 模型(或它的任何变体)并构建一个随机数生成器，该生成器生成一个随机向量序列，该序列遵循模型的概率分布。这里有一个例子:

```py
// number of random numbers to generate
int T = 100000;

// the mean
Vector MU = new DenseVector(new double[]{1., 1.});
// the AR coefficients
Matrix[] PHI = new Matrix[]{
    new DenseMatrix(
    new double[][]{
        {0.5, 0.5},
        {0., 0.5}
    })};
// the MA coefficients
Matrix[] THETA = new Matrix[]{PHI[0]};
// the white noise covariance structure
Matrix SIGMA
        = new DenseMatrix(
                new double[][]{
                    {1, 0.2},
                    {0.2, 1}
                });

// construct a VARMA model
VARMAModel VARMA = new VARMAModel(MU, PHI, THETA, SIGMA);

// construct a random number generator from a VARMA model
VARIMASim SIM = new VARIMASim(VARMA);
SIM.seed(1234567890L);

// produce the random vectors
Vector[] data = new Vector[T];
for (int i = 0; i < T; ++i) {
    data[i] = new DenseVector(SIM.nextVector());
}

// statistics about the simulation
System.out.printf("each vector size = %d%n", data[0].size());
System.out.printf("sample size = %d%n", data.length);

// compute the theoretical mean of the data
double[] theoretical_mean = new Inverse(new DenseMatrix(2, 2).ONE().minus(VARMA.AR(1))).multiply(new DenseVector(MU)).toArray();
System.out.println("theoretical mean =");
System.out.println(Arrays.toString(theoretical_mean));

// cast the random data in matrix form for easy manipulation
Matrix dataM = MatrixFactory.rbind(data);
// compute the sample mean of the data
double sample_mean1 = new Mean(dataM.getColumn(1).toArray()).value();
double sample_mean2 = new Mean(dataM.getColumn(2).toArray()).value();
System.out.printf("sample mean of the first variable = %f%n", sample_mean1);
System.out.printf("sample mean of the second variable = %f%n", sample_mean2);

// compute the theoretical covariance of the data
Matrix cov_theoretical = new DenseMatrix(
        new double[][]{
            {811\. / 135., 101\. / 45.},
            {101\. / 45., 7\. / 3.}
        });
System.out.println("theoretical covariance =");
System.out.println(cov_theoretical);

// compute the sample covariance of the data
SampleCovariance sample_cov = new SampleCovariance(dataM);
System.out.println("sample covariance =");
System.out.println(sample_cov);

```

输出如下所示:

```py
each vector size = 2
sample size = 100000
theoretical mean =
[4.0, 2.0]
sample mean of the first variable = 3.994879
sample mean of the second variable = 2.005700
theoretical covariance =
2x2
         [,1] [,2]
[1,] 6.007407, 2.244444,
[2,] 2.244444, 2.333333,
sample covariance =
2x2
         [,1] [,2]
[1,] 5.315639, 1.790519,
[2,] 1.790519, 2.340646,

```

我们看到模拟数据的样本统计与理论统计相当匹配。

## 15.4 协整

在时间序列分析和预测中，我们通常使用平稳数据，这样它们的均值和方差就不会变化。如果它们的统计特性一直在变化，就很难做出任何预测。然而，许多现实生活中的数据，如金融数据，并不是静态的。虽然我们可以做一阶差分使它们稳定，但这将丢失数据中的任何长期信息。更重要的是，差异不允许我们发现数据之间的任何(长期)关系。

考虑这几个假设的数列:

![$$ \left\{\begin{array}{c}{Y}_{1t}=\sum \limits_{i=1}^t{\varepsilon}_{1i}\\ {}{Y}_{2t}={Y}_{1t}+{\varepsilon}_{2t}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equot.png)

显然，无论是*Y*<sub>1*t*T5】还是*Y*T8】2*t*T11】都是随机游走的。如果我们分别研究它们中的每一个，我们将首先使用差分使它们中的每一个都是稳定的。但是我们得到的是两个白噪声过程。我们对他们一无所知。我们肯定会忽略它们实际上是紧密耦合的，甚至共享一个共同的(随机)趋势，即*Y*T14】1*t*T17】。</sub>

![$$ \left\{\begin{array}{c}\Delta {Y}_{1t}={\varepsilon}_{1t}\\ {}\Delta {Y}_{2t}={\varepsilon}_{1t}+\left({\varepsilon}_{2t}-{\varepsilon}_{2\left(t-1\right)}\right)\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equou.png)

在金融领域，如果我们单独观察价格时间序列的每个组成部分，就会发现它们非常像随机漫步。然而，经济理论告诉我们，同一领域的资产往往具有相同的共同市场趋势。例如，在大牛市中，所有大牌科技股，如 GOOD、M$FT、AAPL 和 AMZN，往往会一起上涨；当处于熊市时，所有人都会同时抛售。CAPM 理论推广了股票“beta”的概念。股票的贝塔系数 *β* 衡量股票对市场运动的敏感程度。就是股票的(超额)收益*R*<sub>T5】I</sub>对(超额)市场收益 *R* <sub>*M*</sub> 的敏感度。换句话说，市场上的所有股票都有一个共同的(随机)市场趋势。

![$$ \mathrm{E}\left({R}_i\right)-{R}_f={\beta}_i\left[\mathrm{E}\left({R}_M\right)-{R}_f\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equov.png)

图 [15-34](#Fig34) 绘制了 2008 年至 2019 年 S & P 500 和 AAPL 的价格。它们中的每一个看起来都像随机漫步(很可能是)。然而，人们不禁要问，这两者之间是否有关系。他们之间的距离看起来或多或少是稳定的。虽然众所周知，预测股市未来的走向很难，但预测两者之间的距离似乎相当容易。事实上，如果我们用标准普尔 500 指数减去(换算后的)AAPL 价格，它们的差异确实是固定的。这揭示了两种股票都有一个共同的随机趋势。图 [15-35](#Fig35) 描绘了不同之处。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig35_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig35_HTML.jpg)

图 15-35

标准普尔 500 和缩放 AAPL 之间的差异

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig34_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig34_HTML.jpg)

图 15-34

2008 年至 2019 年标准普尔 500 和 AAPL 的月度价格

### 15.4.1 VEC 模型

考虑这个简单的 VAR 例子:

![$$ \left\{\begin{array}{c}{x}_t={a}_{11}{x}_{t-1}+{a}_{12}{y}_{t-1}+{\varepsilon}_{xt}\\ {}{y}_t={a}_{21}{x}_{t-1}+{a}_{22}{y}_{t-1}+{\varepsilon}_{yt}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equow.png)

取第一个区别，如下图:

![$$ \left\{\begin{array}{c}{x}_t-{x}_{t-1}=\left({a}_{11}-1\right){x}_{t-1}+{a}_{12}{y}_{t-1}+{\varepsilon}_{xt}\\ {}{y}_t-{y}_{t-1}={a}_{21}{x}_{t-1}+\left({a}_{22}-1\right){y}_{t-1}+{\varepsilon}_{yt}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equox.png)

或者等价地，这里显示:

![$$ \left[\begin{array}{c}\varDelta {x}_t\\ {}\varDelta {y}_t\end{array}\right]=\left[\begin{array}{cc}{a}_{11}-1&amp; {a}_{12}\\ {}{a}_{21}&amp; {a}_{22}-1\end{array}\right]\left[\begin{array}{c}{x}_{t-1}\\ {}{y}_{t-1}\end{array}\right]+\left[\begin{array}{c}{\varepsilon}_{xt}\\ {}{\varepsilon}_{yt}\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoy.png)

假设我们有这个:

![$$ {a}_{11}=\frac{\left(1-{a}_{22}\right)-{a}_{12}{a}_{21}}{1-{a}_{22}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equoz.png)

于是，我们有了这个:

![$$ \left[\begin{array}{c}\varDelta {x}_t\\ {}\varDelta {y}_t\end{array}\right]=\left[\begin{array}{cc}\frac{-{a}_{12}{a}_{21}}{1-{a}_{22}}&amp; {a}_{12}\\ {}{a}_{21}&amp; {a}_{22}-1\end{array}\right]\left[\begin{array}{c}{x}_{t-1}\\ {}{y}_{t-1}\end{array}\right]+\left[\begin{array}{c}{\varepsilon}_{xt}\\ {}{\varepsilon}_{yt}\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpa.png)

重新整理术语，我们有这样的:

![$$ \left\{\begin{array}{c}\varDelta {x}_t={\alpha}_x\left({x}_{t-1}-\beta {y}_{t-1}\right)+{\epsilon}_{xt}\\ {}\varDelta {y}_t={\alpha}_y\left({x}_{t-1}-\beta {y}_{t-1}\right)+{\epsilon}_{yt}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpb.png)

其中:

![$$ \left\{\begin{array}{c}{\alpha}_x=\frac{-{a}_{12}{a}_{21}}{1-{a}_{22}}\\ {}{\alpha}_y={a}_{21}\\ {}\beta =\frac{1-{a}_{22}}{a_{21}}\end{array}\right. $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpc.png)

我们知道*δx*<sub>*t*</sub>，*δy*<sub>*t*</sub>，*ϵ*<sub>*XT*</sub>，*ϵ*<sub>*yt*</sub>都是静止的，所以公因数(*x*<sub>*t*1 其实是既有 *x* <sub>*t*</sub> 和 *y* <sub>*t*</sub> 背后的长期均衡。 *β* 称为协整系数。 *x* <sub>*t*</sub> 和 *y* <sub>*t*</sub> 被称为是协整的，并且这种协整关系*x*<sub>*t*</sub>-*βy*<sub>*t*</sub>是平稳的。假设 *β* 跨越的长期均衡为 0(或预期为 0)；那么*δx*<sub>*t*</sub>和*δy*<sub>*t*</sub>都只对冲击做出反应。 *α* <sub>*x*</sub> 和 *α* <sub>*y*</sub> 称为调整速度。假设*α*<sub>*x*</sub><0 和*α*<sub>*y*</sub>>0；然后{*x*<sub>*t*</sub>}响应于正偏离平衡而减少，并且{*y*<sub>*t*</sub>}响应于正偏离而增加。换句话说，每当其中一个组分系列偏离长期平衡时， *α* 就会像统计引力一样将其拉回到平衡状态。图 [15-36](#Fig36) 引出了协整的概念。</sub>

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig36_HTML.jpg](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig36_HTML.jpg)

图 15-36

***x***<sub>**1**</sub>和***x***<sub>**2**</sub>关于一个长期均衡的跨越由**<sub>⊥</sub>**

 **一般来说，我们可以像前面的简单例子一样，在(暂时性)向量误差修正模型(VECM)中编写一个 VAR 模型***Y***<sub>***t***</sub>。一个 VECM 有这样的形式:

![$$ \Delta {\boldsymbol{Y}}_{\boldsymbol{t}}=\boldsymbol{\mu} +\boldsymbol{\Pi} {\boldsymbol{Y}}_{\boldsymbol{t}-\mathbf{1}}+\sum \limits_{i=1}^{p-1}{\boldsymbol{\Gamma}}_{\boldsymbol{i}}{\boldsymbol{Y}}_{\boldsymbol{t}-\boldsymbol{i}}+\boldsymbol{\Psi} {\boldsymbol{D}}_{\boldsymbol{t}}+{\boldsymbol{\epsilon}}_{\boldsymbol{t}} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpd.png)

其中 ***μ*** ，***y***<sub>***t***</sub>和**<sub>***t***</sub>都是*m*-维向量。滞后时间序列的影响矩阵**π**和系数**γ**<sub>***I***</sub>为( *m* × *m* )矩阵。***D***<sub>***t***</sub>是包含时间 *t* 所有外生变量的向量(不包括截距项)。它的系数由矩阵**ψ**表示，比如说，来自线性回归。**

 **如果***Y***<sub>***t***</sub>协整，那么 *β* 存在，一个 VECM 存在。此外，影响矩阵可以分解为:

![$$ \boldsymbol{\Pi} =\boldsymbol{\alpha} {\boldsymbol{\beta}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpe.png)

在我们简单的例子中，我们有如下:

![$$ \left[\begin{array}{c}\varDelta {x}_t\\ {}\varDelta {y}_t\end{array}\right]=\left[\begin{array}{c}{\alpha}_x\\ {}{\alpha}_y\end{array}\right]\left[1\kern0.5em -\beta \right]\left[\begin{array}{c}{x}_t\\ {}{y}_t\end{array}\right]+\left[\begin{array}{c}{\varepsilon}_{xt}\\ {}{\varepsilon}_{yt}\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpf.png)

在 NM Dev 中，类`VECMTransitory`表示暂时的 VECM。该类签名如下:

```py
public class VECMTransitory extends VECM {

    /**
     * Construct a transitory VECM(p) model.
     *
     * @param MU    the intercept (constant) vector
     * @param PI    the impact matrix
     * @param GAMMA the AR coefficients of the lagged differences; {@code null}
     *              if <i>p = 1</i>
     * @param PSI   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     * @param SIGMA the white noise covariance matrix
     */
    public VECMTransitory(
            Vector MU,
            Matrix PI,
            Matrix[] GAMMA,
            Matrix PSI,
            Matrix SIGMA
    );

    /**
     * Construct a transitory VECM(p) model with zero-intercept (mu).
     *
     * @param PI    the impact matrix
     * @param GAMMA the AR coefficients of the lagged differences; {@code null}
     *              if <i>p = 1</i>
     * @param PSI   the coefficients of the deterministic terms (excluding the
     *              intercept term)
     * @param SIGMA the white noise covariance matrix
     */
    public VECMTransitory(
            Matrix PI,
            Matrix[] GAMMA,
            Matrix PSI,
            Matrix SIGMA
    );

    /**
     * Construct a transitory VECM(p) from a VARX(p).
     *
     * @param varx a VARX model
     */
    public VECMTransitory(VARXModel varx);

    /**
     * Copy constructor.
     *
     * @param that a transitory VECM model
     */
    public VECMTransitory(VECMTransitory that);
}

```

它提供了过渡 VECM(p)和 VARX(p)模型之间的转换方法。这里有一个例子:

```py
// define a VAR(2) model
VARXModel var = new VARXModel(
        new Matrix[]{
            new DenseMatrix(
                    new double[][]{
                        {-0.210, 0.167},
                        {0.512, 0.220}
                    }),
            new DenseMatrix(
                    new double[][]{
                        {0.743, 0.746},
                        {-0.405, 0.572}
                    })
        },
        null);

// construct a VECM fron a VAR
VECMTransitory vecm = new VECMTransitory(var);

System.out.println("dimension = " + vecm.dimension());
System.out.println("PI, the impact matrix = ");
System.out.println(vecm.pi());
System.out.println("GAMMA = ");
System.out.println(vecm.gamma(1));

```

输出如下所示:

```py
dimension = 2
PI, the impact matrix =
2x2
         [,1] [,2]
[1,] -0.467000, 0.913000,
[2,] 0.107000, -0.208000,
GAMMA =
2x2
         [,1] [,2]
[1,] -0.743000, -0.746000,
[2,] 0.405000, -0.572000,

```

考虑一个 VAR(p)模型，使得成分序列 *y* <sub>1 *t*</sub> ， *y* <sub>2 *t*</sub> ，...、*y*<sub>*kt*</sub>均为一阶非平稳。 *D* <sub>*t*</sub> 是外生向量，代表确定性趋势项、截距项等。

![$$ {y}_t={A}_1{y}_{t-1}+{A}_2{y}_{t-2}+\dots +{A}_p{y}_{t-p}+\Psi {D}_t+{\mu}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpg.png)

一阶 *I* (1)过程取一阶差分后成为零阶 *I* (0)平稳过程。

![$$ \Delta {y}_t=\Pi {y}_{t-1}+\sum \limits_{i=1}^{p-1}{\Gamma}_i\Delta {y}_{t-i}+\Psi {D}_t+{\mu}_t $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equph.png)

通过匹配系数，我们有以下:

![$$ \Pi =\sum \limits_{i=1}^p{A}_i-I $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpi.png)

![$$ {\Gamma}_i=-\sum \limits_{j=i+1}^p{A}_j $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpj.png)

∈*y*<sub>T3】tT5】和∈*y*<sub>*t*—*j*</sub>， *j* = 1，2，....、 *p* ，均为 *I* (0)。如果π*y*<sub>*t*—1</sub>也是 *I* (0)，那么*y*<sub>1*t*</sub>，*y*<sub>2*t*</sub>，...，*y*<sub>*kt*</sub>。我们通过协整将一个 *I* (1)过程简化为一个 *I* (0)过程。</sub>

总的来说， 如果考虑的时间序列具有相同的积分顺序*y*<sub>T3】itT5】~*I*(*d*)并且存在某种线性组合(协整向量 ***β*** ) 那就把组合的时间序列降低到一个较低的整合阶次**<sup>’</sup>***Y***<sub>***t***</sub>~*I*(*d*-*b*)，那么就可以说这些时间序列之间存在显著的协整关系。 换句话说，一个 *m* 的分量——维向量**<sub>***t***</sub>=(*Y*<sub>1*t*</sub>，*Y*<sub>2*t*</sub>，...、*Y*<sub>*mt*</sub>)<sup>′</sup>被称为( *d* 、*b*)——顺序协整，记为***Y***<sub>***t***</sub>~ CI(【T82****</sub>

 ****### 15.4.2 约翰逊协整检验

让我们继续简单的 VAR 示例。

![$$ \left[\begin{array}{c}\varDelta {x}_t\\ {}\varDelta {y}_t\end{array}\right]=\left[\begin{array}{cc}\frac{-{a}_{12}{a}_{21}}{1-{a}_{22}}&amp; {a}_{12}\\ {}{a}_{21}&amp; {a}_{22}-1\end{array}\right]\left[\begin{array}{c}{x}_{t-1}\\ {}{y}_{t-1}\end{array}\right]+\left[\begin{array}{c}{\varepsilon}_{xt}\\ {}{\varepsilon}_{yt}\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpk.png)T2】

影响矩阵如下:

![$$ \boldsymbol{\Pi} =\left[\begin{array}{cc}\frac{-{a}_{12}{a}_{21}}{1-{a}_{22}}&amp; {a}_{12}\\ {}{a}_{21}&amp; {a}_{22}-1\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpl.png)

请注意，这些行不是线性独立的。具体来说，我们有以下:

![$$ \left[\frac{-{a}_{12}{a}_{21}}{1-{a}_{22}}\kern0.5em {a}_{12}\right]\times \frac{-\left(1-{a}_{22}\right)}{a_{12}}=\left[\begin{array}{cc}{a}_{21}&amp; {a}_{22}-1\end{array}\right] $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpm.png)

一般来说，影响矩阵**π**的秩决定了成分序列之间是否存在协整关系以及存在多少协整关系。如果**π**是满秩的，那么 VAR 系统(按级别)已经是稳定的。如果秩为零，则组成时间序列之间不存在协整关系。有趣的情况是当秩不是满秩时 *r* < *m* 。确定**π**、 *k* 的秩，就是确定**π**的非零特征值的个数。在数值计算中，我们不只是检查一个数是否为 0。**π**通常从数据的数值 VAR 估计中获得。使用数值程序计算**π**的特征值。经过一长串的数值计算后，它很可能永远不会是 0。因此，我们需要一种有效的方法来确定特征值的数值。

**痕迹测试**

设矩阵的特征根或特征值**π**为*λ*<sub>1</sub>>T6】λ<sub>2</sub>>...>T10】λT12】T13】mT15】。非零特征值的个数 *r* 是协整向量的个数。剩下的*m*—*r*非整特征值，*λ*<sub>*r*+1</sub>，... *λ* <sub>*m*</sub> ，应该是 0。跟踪假设测试，对于每个 *r* ，测试以下:

![$$ {H}_{r0}:{\lambda}_{r+1}=0 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpn.png)

![$$ {H}_{r1}:{\lambda}_{r+1}&gt;0,r=0,1,\dots, k-1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpo.png)

对应的测试统计如下:

![$$ {\eta}_r=-T\sum \limits_{i=r+1}^m\ln \left(1-{\lambda}_i\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpp.png)

*η*<sub>T3】rT5】称为特征根迹统计。</sub>

我们在循环中测试 *r* 。如果 *η* <sub>0</sub> 不显著，我们接受*H*<sub>00</sub>(*r*= 0)，意味着存在 0 协整向量(即不存在协整关系)。我们停下来。如果 *η* <sub>0</sub> 显著，拒绝 *H* <sub>00</sub> 意味着至少有一个协整向量。我们接下来测试*η*T22】1 的意义。如果 *η* <sub>1</sub> 不显著，我们接受 *H* <sub>10</sub> ，意味着只有一个协整向量。我们停下来。否则，我们重复同样的过程，直到*H*<sub>*r*0</sub>被接受，意味着有 *r* 个协整向量。这些 *r* 协整向量对应最大的 *r* 特征值。

**最大特征值测试**

对于 Johansen 协整检验，有另一个类似的假设检验来确定 *r* 。

T3

T5![$$ {H}_{r1}:{\lambda}_{r+1}&gt;0,r=0,1,\dots, m-1 $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpr.png)T7】

测试统计如下:

![$$ {\xi}_r=-T\ln \left(1-{\lambda}_{r+1}\right) $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equps.png)

我们以迭代的方式再次测试不同的 *r* ，直到我们确定最大的 *r* 。

假设**π**的秩是 *r* 。那么我们可以把**π**分解成如下:

![$$ \boldsymbol{\Pi} =\boldsymbol{\upalpha} {\boldsymbol{\beta}}^{\prime } $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpt.png)

使得**π**为( *m* × *m* )矩阵， **α** ( *m* × *r* )和***β***<sup>’</sup>(*r*×*m*)。

***β*** 可以通过最大化 Johansen (1995)中非常复杂且长的对数似然函数来估计。在 NM Dev 中，类`JohansenTest`实现 Johansen 的算法，并测试寻找 ***β*** 。它计算迹统计和特征统计。它支持许多趋势假设。

1.  `NO_CONSTANT`:这是趋势类型一:没有常数，没有线性趋势。

2.  `RESTRICTED_CONSTANT`:这是趋势类型二:没有限制常数，没有线性趋势。

3.  `CONSTANT`:这是趋势类型三:常数，没有线性趋势。

4.  `CONSTANT_RESTRICTED_TIME`:这是趋势类型四:恒定、受限的线性趋势。

5.  `CONSTANT_TIME`:这是趋势类型 V:常数，线性趋势。

以下代码计算标准普尔 500 和 AAPL 之间的协整关系:

```py
// read the monthly S&P 500 data from a csv file
double[][] spx_arr
        = DoubleUtils.readCSV2d(
                this.getClass().getClassLoader().getResourceAsStream("sp500_monthly.csv"),
                true,
                true
        );
// convert the csv file into a matrix for manipulation
Matrix spx_M1 = new DenseMatrix(spx_arr);
// remove the data before 2008
Matrix spx_M2 = MatrixFactory.subMatrix(spx_M1, 325, spx_M1.nRows(), 1, spx_M1.nCols());
// extract the column of adjusted close prices
Vector spx_v = spx_M2.getColumn(5); // adjusted closes

// read the monthly AAPL data from a csv file
double[][] appl_arr
        = DoubleUtils.readCSV2d(
                this.getClass().getClassLoader().getResourceAsStream("AAPL_monthly.csv"),
                true,
                true
        );
// convert the csv file into a matrix for manipulation
Matrix aapl_M1 = new DenseMatrix(appl_arr);
// remove the data before 2008
Matrix aapl_M2 = MatrixFactory.subMatrix(aapl_M1, 325, aapl_M1.nRows(), 1, aapl_M1.nCols());
// extract the column of adjusted close prices
Vector aapl_v = aapl_M2.getColumn(5); // adjusted closes

// combine SPX and AAPL to form a bivariate time series
MultivariateSimpleTimeSeries mts
        = new MultivariateSimpleTimeSeries(cbind(spx_v, aapl_v));
//        System.out.println("(spx, aapl) prices: \n" + mts);

// run cointegration on all combinations of available test and trend types
for (Test test : Test.values()) {
    for (dev.nm.stat.cointegration.JohansenAsymptoticDistribution.TrendType trend
            : dev.nm.stat.cointegration.JohansenAsymptoticDistribution.TrendType.values()) {
        CointegrationMLE coint = new CointegrationMLE(mts, true);
        JohansenTest johansen
                = new JohansenTest(test, trend, coint.getEigenvalues().size());
        System.out.println("alpha:");
        System.out.println(coint.alpha());
        System.out.println("beta:");
        System.out.println(coint.beta());
        System.out.println("Johansen test: "
                + test.toString()
                + "\t" + trend.toString()
                + "\t eigenvalues: " + coint.getEigenvalues()
                + "\t statistics: " + johansen.getStats(coint)
        );
    }
}

// run ADF test to check if the cointegrated series is indeed stationary
double[] betas = new double[]{-12.673296, -6.995392};
for (double beta : betas) {
    System.out.printf("testing for beta = %f%n", beta);
    Vector ci = spx_v.add(aapl_v.scaled(beta));
    AugmentedDickeyFuller adf
            = new AugmentedDickeyFuller(
                    ci.toArray(),
                    TrendType.CONSTANT, // constant drift term
                    4, // the lag order
                    null
            );

    System.out.println("H0: " + adf.getNullHypothesis());
    System.out.println("H1: " + adf.getAlternativeHypothesis());
    System.out.printf("the p-value for the test = %f%n", adf.pValue());
    System.out.printf("the statistics for the test = %f%n", adf.statistics());
}

```

输出如下所示:

```py
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: EIGEN   NO_CONSTANT    eigenvalues: [0.027251, 0.006941]     statistics: [3.923298, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: EIGEN   RESTRICTED_CONSTANT    eigenvalues: [0.027251, 0.006941]     statistics: [3.923298, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: EIGEN   CONSTANT    eigenvalues: [0.027251, 0.006941]     statistics: [3.923298, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: EIGEN   CONSTANT_RESTRICTED_TIME    eigenvalues: [0.027251, 0.006941]     statistics: [3.923298, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: EIGEN   CONSTANT_TIME    eigenvalues: [0.027251, 0.006941]     statistics: [3.923298, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: TRACE   NO_CONSTANT    eigenvalues: [0.027251, 0.006941]     statistics: [4.912388, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: TRACE   RESTRICTED_CONSTANT    eigenvalues: [0.027251, 0.006941]     statistics: [4.912388, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: TRACE   CONSTANT    eigenvalues: [0.027251, 0.006941]     statistics: [4.912388, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: TRACE   CONSTANT_RESTRICTED_TIME    eigenvalues: [0.027251, 0.006941]     statistics: [4.912388, 0.989090]
alpha:
2x2
         [,1] [,2]
[1,] 0.014356, -0.025999,
[2,] 0.005514, -0.000736,
beta:
2x2
         [,1] [,2]
[1,] 1.000000, 1.000000,
[2,] -6.995392, -12.673296,
Johansen test: TRACE   CONSTANT_TIME    eigenvalues: [0.027251, 0.006941]     statistics: [4.912388, 0.989090]
testing for beta = -12.673296
H0: there is a unit root in the process, hence non-stationarity
H1: there is no unit root in the process, hence stationarity
the p-value for the test = 0.520000
the statistics for the test = -1.520184
testing for beta = -6.995392
H0: there is a unit root in the process, hence non-stationarity
H1: there is no unit root in the process, hence stationarity
the p-value for the test = 0.000000
the statistics for the test = -3.683306

```

根据统计，只有一个协整关系。协整β为-6.995392。协整关系如下:

![$$ SPX-6.995392\times \mathrm{AAPL} $$](../images/500382_1_En_15_Chapter/500382_1_En_15_Chapter_TeX_Equpu.png)

我们对协整时间序列进行 ADF 检验。p 值为 0，意味着我们拒绝空值。我们得出结论，标准普尔 500 和 AAPL 之间的“距离”确实是静止的。当 AAPL 偏离统计平衡时，这可能意味着一个交易信号。对于强均值回归的股票对，我们可以围绕它们设计交易策略。你可以在我的另一本书《量化交易中的数值方法》中找到更多细节。见图 [15-37](#Fig37) 。

![../images/500382_1_En_15_Chapter/500382_1_En_15_Fig37_HTML.png](../images/500382_1_En_15_Chapter/500382_1_En_15_Fig37_HTML.png)

图 15-37

SPX 和 AAPL 是协整的****************************************************