# 7.常微分方程

常微分方程(ODE)是一个包含一个独立变量导数的方程。术语“普通”与术语“偏微分方程(PDE)”形成对比，后者涉及一个以上的独立变量。微分方程出现在许多数学和科学领域。通常，描述一个系统的变化、动态或变化比描述系统本身更容易。系统本身可能很复杂，但它的动力学可能很简单(或更简单)。例如，一开始就找出一个物体的轨迹并不总是容易的(甚至是可行的)。相比之下，牛顿著名的第二运动定律可以用一首颂歌用简单的表达式描述任何物体从足球到行星的轨迹。

![$$ F\left(x(t)\right)=m{a}^2=m\frac{d^2x(t)}{d{t}^2} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equa.png)T2】

此外，许多现象从根本上将不同的微分量联系在一起，例如，变化率或梯度，或曲率。例如，前面的 ODE 连接了这些量:位置(或位移)随时间的变化 *x* ( *t* )，力 *F* ，时间 *t* ，质量 *m* 。位置函数对时间的一阶导数是速度；二阶导数是加速度， *a* 。常微分方程在几乎所有的科学中都是普遍存在的，例如物理学和天文学(天体力学)、气象学(天气建模)、化学(反应速率)、生物学(传染病、基因变异)、生态学和种群建模(种群竞争)、经济学(股票趋势、利率和市场均衡价格变化)。

常微分方程的数值解法是计算数学中解决常微分方程问题的一个分支。也就是说，我们找到一个满足 ODE 的函数。数值解很重要，因为许多常微分方程无法解析求解。即使可以，这些解也不能用初等函数来表示。在这些情况下，我们只能求助于数值求解。数值解是常微分方程在某些离散点上的真实解的近似值。我们需要研究这种数值解的存在性、唯一性和稳定性。

## 7.1 单步方法

初值问题是一类常微分方程问题。初值问题(IVP)是一个常微分方程和一个初始条件，它指定了未知函数在定义域中给定点的值。在物理学或其他科学中对一个系统建模经常等同于求解一个 IVP。在这种情况下，微分方程是在给定系统在时间零点的初始条件的情况下，说明系统如何随时间演变的方程。数学上，一个初值问题就是一个微分方程，如下图:

![$$ {y}^{\prime }(t)=f\left(t,y(t)\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equb.png)

连同初始条件，如下所示:

![$$ {y}_0=y\left({t}_0\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equc.png)

IVP 的解是函数 *y* ,它是微分方程的解，并满足初始条件。通过把导数作为一个独立的函数来处理，这个概念可以推广到更高阶。对于一首二阶颂歌，我们有这样的:

![$$ {y}^{\prime \prime }(t)=f\left(t,y(t),{y}^{\prime }(t)\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equd.png)

一般情况下，假设函数 *f* ( *x* ， *y* )满足李普希茨条件，如下图:

![$$ \left|f\left(x,y\right)-f\Big(x,\bar{y}\Big)\right|\le L\left|y-\bar{y}\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Eque.png)

*L* 是常数。条件基本上是说函数 *f* 不能变化太快。这个条件保证了 ODE 有且只有一个解。

例如，我们可以找到下面这首颂歌的解法:

![$$ \left\{\begin{array}{c}{y}^{\prime }=1-2 xy\\ {}y(0)=0\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equf.png)

数值解法给出了一组离散点上的近似值， *y* <sub>1</sub> ， *y* <sub>2</sub> ，…， *y* <sub>*n*</sub> ，*y*<sub>*n*+1</sub>， *y* ( *x* )，如下所示:

*h*<sub>*I*</sub>=*x*<sub>*I*+1</sub>—*x*<sub>*I*</sub>称为*步长*。除非另有说明，否则我们假设步长相等且等距。

从概念上讲，我们可以用以下方式求解一个 ODE。我们已经从初始条件知道了值*y*(*x*<sub>0</sub>)=*y*<sub>0</sub>。要求*y*(*x*<sub>1</sub>)=*y*(*x*<sub>0</sub>+*h*)，我们可以用一个近似值:∈*y*(*x*)≈*y*<sup>′</sup>(*x 所以，我们有了这个:*

*![$$ y\left({x}_1\right)=y\left({x}_0+h\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equh.png)*

*![$$ =y\left({x}_0\right)+\Delta  y\left({x}_0\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equi.png)*

*![$$ =y\left({x}_0\right)+{y}^{\prime}\left({x}_0\right)h $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equj.png)*

我们可以重复这个来迭代为*y*(*x*<sub>2</sub>)=*y*(*x*T10】1【T11)+*y*<sup>’</sup>(*x*<sub>1</sub>)*h*和*y*(*x*T26】3<sub>这是如何数值求解一个 ODE 的一般思路。这种方法被称为逐步方法。图 [7-1](#Fig1) 显示了该问题的数值解。</sub>

![img/500382_1_En_7_Chapter/500382_1_En_7_Fig1_HTML.jpg](img/500382_1_En_7_Chapter/500382_1_En_7_Fig1_HTML.jpg)

图 7-1

用逐步方法求解 IVP 的数值解

### 7.1.1 欧拉法(多边形法)

欧拉法是求解给定初值的常微分方程的一阶数值程序。它是常微分方程数值积分最基本的显式方法，也是最简单的龙格-库塔法(在 7.1.2 节讨论)。作为一阶方法，其局部误差(每步误差)与步长的平方成正比，全局误差(给定时间或值的误差)与步长成正比。准确率不高。它还存在稳定性问题。由于这些原因，欧拉方法在实践中不常使用。然而，它阐明了数值积分的一些基本思想。欧拉方法是构造更复杂方法的基础。

#### 7.1.1.1 欧拉公式

我们可以用泰勒展开式推导欧拉公式。

![$$ y\left({x}_{n+1}\right)=y\left({x}_n+h\right)=y\left({x}_n\right)+{y}^{\prime}\left({x}_n\right)h+\frac{h^2}{2!}{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq1.png)、***<sub>、</sub>***

 ***![$$ y\left({x}_{n+1}\right)=y\left({x}_n\right)+ hf\left[{x}_n,y\left({x}_n\right)\right]+\frac{h^2}{2!}{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq2.png)， *n* = 0，1，2，⋯

当 *h* 足够小时，我们可以忽略高阶项![$$ \frac{h^2}{2!}{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq3.png)，得到一个近似值，如下图:

![$$ y\left({x}_{n+1}\right)\approx y\left({x}_n\right)+ hf\left[{x}_n,y\left({x}_n\right)\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equk.png)

使用符号*y*<sub>*n*+1</sub>≈*y*(*x*<sub>*n*+1</sub>)，欧拉公式如下:

*和*<sub>*【n】*+1</sub>=*和**+*【HF】**

 *该公式的局部截断误差为第 *n* 步的误差，由![$$ \frac{h^2}{2!}{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq4.png)给出，与步长*h*T5】2 的平方成正比。另一方面，全局误差是从开始到当前步骤累积的误差。见图 [7-2](img/#Fig2) 。

![img/500382_1_En_7_Chapter/500382_1_En_7_Fig2_HTML.jpg](img/500382_1_En_7_Chapter/500382_1_En_7_Fig2_HTML.jpg)

图 7-2

欧拉方法及其近似误差

欧拉法是折线法而不是切线法。除了第一个点是曲线上的切线之外，该函数由分段折线近似。

#### 7.1.1.2 隐式欧拉公式

我们可以推导出欧拉方法的隐式公式或反向公式。差商如下:

![$$ {y}^{\prime}\left({x}_{n+1}\right)\approx \frac{y\left({x}_{n+1}\right)-y\left({x}_n\right)}{x_{n+1}-{x}_n}=\frac{y\left({x}_{n+1}\right)-y\left({x}_n\right)}{h_n} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equl.png)

假设*y*<sub>*n*</sub>=*y*(*x*<sub>*n*</sub>)并且我们已经知道*y*<sup>’</sup>(*x*<sub>*n*+1【T23)=*f*(*x*</sub>

 **和*<sub>*【n】*+1</sub>=*和**+*【HF】**

 *这个公式被称为隐式公式，因为它的左右两边都有 *y* <sub>*n* + 1</sub> 。与显式公式不同，在显式公式中，您只需要插入数字来计算 *y* <sub>*n* + 1</sub> ，使用隐式公式进行计算涉及到求解*y*<sub>*n*+1</sub>的方程。

求解该方程的一种方法是使用迭代法。我们先来初步猜测一下 *y* <sub>*n* + 1</sub> 可能是什么，![$$ {y}_{n+1}^{(0)} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq5.png)。然后我们将它插入右边，计算下一个猜测值![$$ {y}_{n+1}^{(1)} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq6.png)。我们重复，直到它收敛。具体来说，迭代公式如下:

![$$ \left\{\begin{array}{c}{y}_{n+1}^{(0)}={y}_n+ hf\left({x}_n,{y}_n\right)\\ {}{y}_{n+1}^{\left(k+1\right)}={y}_n+ hf\left({x}_{n+1},{y}_{n+1}^{(k)}\right)\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq7.png)， *k* = 0，1，

![$$ \left|{y}_{n+1}^{\left(k+1\right)}-{y}_{n+1}^{(k)}\right|&lt;\varepsilon $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equ1.png)

我们研究了隐式公式的局部截断误差。鉴于此:

![$$ {y}_{n+1}={y}_n+ hf\left({x}_{n+1},{y}_{n+1}\right)={y}_n+h{y}^{\prime}\left({x}_{n+1}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equm.png)

![$$ {y}^{\prime}\left({x}_{n+1}\right)={y}^{\prime}\left({x}_n+h\right)={y}^{\prime}\left({x}_n\right)+{y}^{{\prime\prime}}\left({\xi}_n\right)h $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equn.png)

将第二个等式代入第一个等式，我们得到如下:

![$$ {y}_{n+1}={y}_n+h{y}^{\prime}\left({x}_n\right)+{h}^2{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equo.png)

我们还有这个:

![$$ y\left({x}_{n+1}\right)=y\left({x}_n\right)+ hf\left({x}_n,y\left({x}_n\right)\right)+\frac{h^2}{2!}{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equp.png)

假设*y*<sub>*n*</sub>=*y*(*x*<sub>*n*</sub>)从第二个方程中减去第一个方程，我们有局部截断误差，如下所示:

![$$ y\left({x}_{n+1}\right)-{y}_{n+1}=-\frac{h^2}{2}{y}^{{\prime\prime}}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equq.png)

或者，隐式欧拉公式的局部截断误差近似为:

![$$ -\frac{h^2}{2!}{y}^{{\prime\prime}}\left({x}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equr.png)

#### 7.1.1.3 梯形公式

注意，显式和隐式方法的局部截断误差仅在负号上有所不同。即

![$$ {y}_{n+1}={y}_n+ hf\left({x}_n,{y}_n\right)+\frac{h^2}{2!}{y}^{{\prime\prime}}\left({x}_n\right)+o\left({h}^3\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equs.png)

![$$ {y}_{n+1}={y}_n+ hf\left({x}_{n+1},{y}_{n+1}\right)-\frac{h^2}{2!}{y}^{{\prime\prime}}\left({x}_n\right)+o\left({h}^3\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equt.png)

把这两个方程加在一起，除以 2，我们消去![$$ \frac{h^2}{2!}{y}^{{\prime\prime}}\left({x}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq8.png)得到这个:

![$$ {y}_{n+1}={y}_n+\frac{h}{2}\left[f\left({x}_n,{y}_n\right)+f\left({x}_{n+1},{y}_{n+1}\right)\right]+o\left({h}^3\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equu.png)

梯形公式如下(通过忽略*o*(*h*<sup>3</sup>):

![$$ {y}_{n+1}={y}_n+\frac{h}{2}\left[f\left({x}_n,{y}_n\right)+f\left({x}_{n+1},{y}_{n+1}\right)\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equv.png)

梯形公式也是隐式公式。它可以通过使用如下迭代方法来求解:

![$$ \left\{\begin{array}{c}{y}_{n+1}^{(0)}={y}_n+ hf\left({x}_n,{y}_n\right)\\ {}{y}_{n+1}^{\left(k+1\right)}={y}_n+\frac{h}{2}\left[f\left({x}_n,{y}_n\right)+f\left({x}_{n+1},{y}_{n+1}^{(k)}\right)\right]\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq9.png)， *k* = 0，1，⋯

这种迭代方法会因为

![$$ \left|{y}_{n+1}-{y}_{n+1}^{\left(k+1\right)}\right|=\frac{h}{2}\left|f\left({x}_{n+1},{y}_{n+1}\right)-f\Big({x}_{n+1},{y}_{n+1}^{(k)}\Big)\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equw.png)

而收敛

已经假设 *f* ( *x* ， *y* )满足李普希茨条件。

![$$ \left|f\left(x,y\right)-f\Big(x,\bar{y}\Big)\right|\le L\left|y-\bar{y}\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equx.png)

也就是

![$$ \left|{y}_{n+1}-{y}_{n+1}^{\left(k+1\right)}\right|\le \frac{Lh}{2}\left|{y}_{n+1}-{y}_{n+1}^{(k)}\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equy.png)

取![$$ \frac{Lh}{2}&lt;1 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq10.png)然后下面:

![$$ \left|{y}_{n+1}-{y}_{n+1}^{\left(k+1\right)}\right|\le \left|{y}_{n+1}-{y}_{n+1}^{(k)}\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equz.png)

因此，我们有(条件)收敛。梯形公式比显式公式和隐式公式都要精确(一阶精度 *o* ( *h* <sup>2</sup> ))，并且具有二阶精度 *o* ( *h* <sup>3</sup> )。

#### 7.1.1.4 预测校正法

梯形公式虽然精度好 *o* ( *h* <sup>3</sup> )，但是工作量太大。预测校正法通过使用梯形公式，但只进行一轮迭代，改进了欧拉公式。具体来说，我们有这个:

*   预测:![$$ {\bar{y}}_{n+1}={y}_n+ hf\left({x}_n,{y}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq11.png)

*   更正:![$$ {y}_{n+1}={y}_n+\frac{h}{2}\left[f\left({x}_n,{y}_n\right)+f\left({x}_{n+1},{\bar{y}}_{n+1}\right)\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq12.png)

这个公式也被称为改进的欧拉公式。

一般而言，预测-校正系统使用显式公式来进行预测，并将来自显式和隐式公式的结果组合起来以给出更好的结果。

![$$ \left\{\begin{array}{c}{y}_p={y}_n+ hf\left({x}_n,{y}_n\right)\\ {}{y}_c={y}_n+ hf\left({x}_{n+1},{y}_p\right)\\ {}{y}_{n+1}=\frac{1}{2}\left({y}_p+{y}_c\right)\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equaa.png)T2】

这是另一个使用预测校正系统的例子。让我们用中心差商来重新推导隐式欧拉公式。

![$$ \frac{y\left({x}_{n+1}\right)-y\left({x}_{n-1}\right)}{2h}\approx {y}^{\prime}\left({x}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equab.png)T2】

取出近似值，重新排列项，如下图:

![$$ y\left({x}_{n+1}\right)-y\left({x}_{n-1}\right)=2 hf\left({x}_n,{y}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equac.png)

由此，我们有了以下:

![$$ {y}_{n+1}={y}_{n-1}+2 hf\left({x}_n,{y}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equad.png)

这个显式公式给出了预测值。将其与隐式梯形公式相结合，我们得到以下预测-校正系统:

*   预测:![$$ {\bar{y}}_{n+1}={y}_{n-1}+2 hf\left({x}_n,{y}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq13.png)

*   更正:![$$ {y}_{n+1}={y}_n+\frac{h}{2}\left[f\left({x}_n,{y}_n\right)+f\left({x}_{n+1},{\bar{y}}_{n+1}\right)\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq14.png)

这是一个两步公式的例子，它同时涉及到了*y*<sub>*n*—1</sub>和 *y* <sub>*n*</sub> 。(前面的公式都是单步公式。)两步或更一般的多步公式需要一个单步公式来从头开始计算 *n* = 1。

NM Dev 库支持广泛的常微分方程解算器。ODE 可以通过实现接口`DerivativeFunction`来构造。签名如下:

```py
public interface DerivativeFunction {

    /**
     * Computes the derivative at the given point, <i>x</i>.
     *
     * @param x the independent variable, <i>x</i>
     * @param y the dependent variable, <i>y</i>
     * @return the derivative <i>F(x, y)</i>
     */
    Vector evaluate(double x, Vector y);

    /**
     * Gets the dimension of <i>y</i>.
     *
     * @return the dimension of <i>y</i>
     */
    int dimension();
}

```

利用常微分方程的定义以及初始条件和积分区间，我们可以构造一个初值问题。类`ODE1stOrder`构造了一个 IVP。

```py
/**
 * Constructs a first order ODE with the given vector-valued function and
 * its initial values. Solves
 * \[
 * y' = F(x, y) \\
 * y(x_0) = y_0
 * \]
 *
 * @param dy the first order derivative function <i>y' = F(x, y)</i>
 * @param y0 <i>y<sub>0</sub></i>
 * @param x0 the start point of the integrating interval <i>[x<sub>0</sub>,
 *           x<sub>1</sub>]</i>
 * @param x1 the end point of the integrating interval <i>[x<sub>0</sub>,
 *           x<sub>1</sub>]</i>
 */
public ODE1stOrder(DerivativeFunction dy, Vector y0, double x0, double x1)

```

以下示例代码使用欧拉方法求解该 IVP:

![$$ \left\{\begin{array}{c}{y}^{\prime }=1-2 xy\\ {}y(0)=0\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq15.png)， *x* ∈ [0，1]

```py
// define the ODE to solve
DerivativeFunction dy = new DerivativeFunction() {

    @Override
    public Vector evaluate(double x, Vector y) {

        Vector dy = y.scaled(-2\. * x);
        return dy.add(1); // y' = 1 - 2xy
    }

    @Override
    public int dimension() {
        return 1;
    }
};
// initial condition, y0=0
Vector y0 = new DenseVector(0.);

double x0 = 0, x1 = 1.; // solution domain
double h = 0.1; // step size

// define an IVP
ODE1stOrder ivp = new ODE1stOrder(dy, y0, x0, x1);
// construt an ODE solver using Euler's method
ODESolver solver = new EulerMethod(h);
// solve the ODE
ODESolution soln = solver.solve(ivp);
// print out the solution function, y, at discrete points
double[] x = soln.x();
Vector[] y = soln.y();
for (int i = 0; i < x.length; ++i) {
    System.out.println(String.format("y(%f) = %s", x[i], y[i]));
}

```

输出如下(见图 [7-3](#Fig3) ):

![img/500382_1_En_7_Chapter/500382_1_En_7_Fig3_HTML.jpg](img/500382_1_En_7_Chapter/500382_1_En_7_Fig3_HTML.jpg)

图 7-3

用欧拉方法求解 IVP

```py
y(0.000000) = [0.000000]
y(0.100000) = [0.100000]
y(0.200000) = [0.198000]
y(0.300000) = [0.290080]
y(0.400000) = [0.372675]
y(0.500000) = [0.442861]
y(0.600000) = [0.498575]
y(0.700000) = [0.538746]
y(0.800000) = [0.563322]
y(0.900000) = [0.573190]
y(1.000000) = [0.570016]

```

类`ODESolver`求解一阶 IVP。签名如下:

```py
public interface ODESolver {

    /**
     * Solves an IVP problem.
     *
     * @param ivp an IVP problem
     * @return a solution
     */
    ODESolution solve(ODE1stOrder ivp);
}

```

### 7.1.2 龙格库塔族

在推导欧拉公式时，我们略去了泰勒展开式中的 *o* ( *h* <sup>2</sup> )项。一般来说，我们在积分公式中包含的(高阶)项越多，公式就越精确。假设我们使用第一个 *p* 导数构造一个显式公式。

![$$ {y}_{n+1}={y}_n+h{y}_n^{\prime }+\frac{h^2}{2!}{y}_n^{{\prime\prime} }+\cdots +\frac{h^p}{p!}{y}_n^{(p)} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equae.png)

阶为*o*(*h*<sup>T5】p+1</sup>的局部截断误差如下:

![$$ y\left({x}_{n+1}\right)-{y}_{n+1}=\frac{h^{p+1}}{\left(p+1\right)!}{y}^{\left(p+1\right)}\left({\xi}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq16.png)、***<sub>、</sub>***

 ***我们说这个积分公式具有阶精度 *p* 。显式欧拉公式的阶精度为 1；隐式欧拉公式也是 1。梯形公式具有二阶精度。然而，在实践中，这个公式很少使用，因为找到 *y* 的高阶导数并不总是容易的。

龙格-库塔法采用了不同的方法。根据中值定理，有 0 θ ![$$ \frac{y\left({x}_{n+1}\right)-y\left({x}_n\right)}{h}={y}^{\prime}\left({x}_n+\theta h\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equaf.png)

![$$ {y}^{\prime}\left({x}_n+\theta h\right)=f\left({x}_n+\theta h,y\left({x}_n+\theta h\right)\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equag.png)

所以，我们有了这个:

![$$ y\left({x}_{n+1}\right)=y\left({x}_n\right)+ hf\left({x}_n+\theta h,y\left({x}_n+\theta h\right)\right)=y\left({x}_n\right)+h{K}^{\ast } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equah.png)

设*K*<sup>∫</sup>=*f*(*x*<sub>*n*</sub>+*θh*，*y*(*x*<sub>*n*</sub>+*θh*)称为区间内的平均斜率[ *x* <sub>*利用*K*T38】∫的不同定义，我们能够构造不同的积分公式。如果 *θ* = 0，则该点的斜率( *x* <sub>*n*</sub> ， *y* <sub>*n*</sub> )作为整个区间的平均斜率 *x* <sub>*n*</sub> ， *x* <sub>*n* 然后*K*<sup>∫</sup>=*f*(*x*<sub>*n*</sub>， *y* <sub>*n*</sub> )，积分公式为*y*<sub>*+1*</sub>=【1】这是欧拉公式。如果 *θ* = 1，则点处的斜率(*x*<sub>*n*+1</sub>，*y*<sub>*n*+1</sub>)取为整个区间的平均斜率*x*<sub>*n*</sub>然后*K*<sup>∫</sup>=*f*(*x*<sub>*n*+1</sub>，*y*<sub>*n*+1</sub>)，积分公式为 *y* <sub>*n 这就是隐式/向后欧拉公式。设*K*<sub>1</sub>=*f*(*x*<sub>*n*</sub>，*y*<sub>*n*</sub>)和*K*<sub>2</sub>=*f*定义![$ {K}^{\ast }=\frac{1}{2}\left({K}_1+{K}_2\right) $](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq17.png)。 *K* 我们用它作为整个区间的平均斜率[*x*<sub>*n*</sub>，*x*<sub>*n*+1</sub>]。那么积分公式就是梯形公式，![$ {y}_{n+1}={y}_n+\frac{h}{2}\left({K}_1+{K}_2\right) $](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq18.png)。我们知道梯形公式具有二阶精度，而显式和隐式欧拉公式只有一阶精度。可以看出，使用两点斜率的算术平均值作为积分区间的平均斜率比使用任一端点的斜率更精确。因此，可以想象，如果我们使用[*x*<sub>*n*</sub>，*x*<sub>*n*+1</sub>]中多个点的斜率的加权平均值作为平均斜率*K*<sup>∫</sup>，就有可能构造出精度更高的积分公式。这是龙格-库塔方法的基本思想。***</sub></sub>*</sub>

#### 7.1.2.1 二阶龙格-库塔法

梯形公式是二阶龙格-库塔法的特例。它使用两个端点*x*<sub>T3】nT5】和 *x* <sub>*n* + 1</sub> 的斜率值，并让区间*K*<sup>∫</sup>的平均斜率是它们的线性组合。我们不必使用端点*x*<sub>*n*+1</sub>。假设 0 < *p* ≤ 1，*K*<sub>1</sub>=*f*(*x*<sub>*n*</sub>， *y* <sub>*n*</sub> )，以及*K*<sub>2</sub>=*f*(【T48 其中*x*<sub>*n*+*p*</sub>***∈***(*x*<sub>*n*</sub>、*x*<sub>*n*+1</sub>、y *积分公式如下:*</sub>

*![$$ \left\{\begin{array}{c}{K}_1=f\left({x}_n,{y}_n\right)={f}_n\\ {}{K}_2=f\left({x}_{n+p},{y}_n+ ph{K}_1\right)\\ {}{y}_{n+1}={y}_n+h\left({\lambda}_1{K}_1+{\lambda}_2{K}_2\right)\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equai.png)*

这个系统有三个待定参数:*λ*<sub>1</sub>*λ*<sub>2</sub>*p*。我们想找到一组参数，使积分公式达到二阶精度。我们先利用泰勒展开将*K*<sub>2</sub>at(*x*<sub>*n*</sub>， *y* <sub>*n*</sub> )展开为一个二元函数。

![$$ {K}_2=f\left({x}_n,{y}_n\right)+ ph\left({f}_x+{f}_y\right)+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equaj.png)

将 *K* <sub>1</sub> 和 *K* <sub>2</sub> 代入积分公式，我们就有了这个:

![$$ {y}_{n+1}={y}_n+h\left({\lambda}_1{K}_1+{\lambda}_2{K}_2\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equak.png)

![$$ ={y}_n+h\left[{\lambda}_1{f}_n+{\lambda}_2{f}_n+{\lambda}_2 ph\left({f}_x+{f}_y\right)+\cdots \right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equal.png)

![$$ ={y}_n+\left({\lambda}_1+{\lambda}_2\right)h{f}_n+{\lambda}_2p{h}^2\left({f}_x+{f}_y\right)+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equam.png)

将系数比作二阶泰勒展开式，我们有这样的:

![$$ {y}_{n+1}={y}_n+h{y}_n^{\prime }+\frac{h^2}{2!}{y}_n^{{\prime\prime} } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equan.png)

我们看到三个待定参数 *λ* <sub>1</sub> 、 *λ* <sub>2</sub> 、 *p* 必须满足以下:

![$$ \left\{\begin{array}{c}{\lambda}_1+{\lambda}_2=1\\ {}{\lambda}_2p=\frac{1}{2}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equao.png)

任何满足前述条件的积分公式称为*二阶*龙格-库塔公式。梯形公式是![$$ {\lambda}_1={\lambda}_2=\frac{1}{2} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq19.png)和 *p* = 1 时的特例。

#### 7.1.2.2 三阶龙格-库塔法

我们可以使用三个点而不是两个点来进一步提高精度。设三个点分别是*x*<sub>T3】nT5、*x*<sub>T9】n+*p*</sub>和*x*<sub>*n*+*q*</sub>in*x*<sub>*n*</sub>、 *x* <sub>设这三点的斜率为 *K* <sub>1</sub> 、 *K* <sub>2</sub> 、 *K* <sub>3</sub> 。平均斜率*K*T52】∫是它们的线性组合。我们定义如下:</sub></sub>

![$$ \left\{\begin{array}{c}{K}_1=f\left({x}_n,{y}_n\right)\\ {}{K}_2=f\left({x}_{n+p},{y}_n+ ph{K}_1\right)\\ {}{K}_3=f\left({x}_{n+q},{y}_{n+q}\right)=f\left({x}_n+ qh,{y}_n+ qh\left(r{K}_1+s{K}_2\right)\right)\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equap.png)

注意对于 *K* <sub>3</sub> ，*y*<sub>*n*+*q*</sub>是根据 *K* <sub>1</sub> 和 *K* <sub>2</sub> 的平均斜率定义的。三阶积分公式如下:

![$$ {y}_{n+1}={y}_n+h\left({\lambda}_1{K}_1+{\lambda}_2{K}_2+{\lambda}_3{K}_3\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equaq.png)

待定参数为 *λ* <sub>1</sub> 、 *λ* <sub>2</sub> 、 *λ* <sub>3</sub> 、 *p* 、 *q* 、 *r* 、 *s* 。我们可以重复用于推导二阶公式的类似过程来推导三阶公式。我们先对 *K* <sub>1</sub> 、 *K* <sub>2</sub> 、 *K* <sub>3</sub> 做泰勒展开，代入*y*<sub>*n*+1</sub>。通过将系数与*y*<sub>*n*+1</sub>的三阶泰勒展开式进行比较，可以推导出参数必须满足的方程组。

T45

任何满足这些条件的积分公式称为*三阶龙格-库塔公式*。

#### 7.1.2.3 高阶龙格-库塔法

一般来说，任何阶的龙格-库塔积分公式都是多个选定点的斜率的线性组合。

![$$ \left\{\begin{array}{c}{y}_{n+1}={y}_n+h{\sum}_{i=1}^r{\lambda}_i{K}_i\\ {}{K}_1=f\left({x}_n,{y}_n\right)\\ {}{K}_i=f\left({x}_n+{p}_ih,{y}_n+h{\sum}_{j=1}^{i-1}{r}_{ij}{K}_j\right),\kern0.5em i=2,3,\cdots, r\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equas.png)T2】

例如，当 *r* = 4 时，四阶龙格-库塔公式如下:

![$$ \left\{\begin{array}{c}{y}_{n+1}={y}_n+\frac{h}{6}\left({K}_1+2{K}_2+2{K}_3+{K}_4\right)\\ {}{K}_1=f\left({x}_n,{y}_n\right)\\ {}{K}_2=f\left({x}_n+\frac{h}{2},{y}_n+\frac{h}{2}{K}_1\right)\\ {}{K}_3=f\left({x}_n+\frac{h}{2},{y}_n+\frac{h}{2}{K}_2\right)\\ {}{K}_4=f\left({x}_n+h,{y}_n+h{K}_3\right)\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equat.png)

可以证明截断误差为 *o* ( *h* <sup>5</sup> )。

重要的是要注意，因为龙格-库塔公式是从泰勒展开式导出的，所以它假设解函数 *y* ( *x* )足够光滑，并且高阶导数存在。否则，使用高阶龙格-库塔公式可能不如使用低阶龙格-库塔公式有效。

NM Dev 支持一套龙格-库塔公式来求解常微分方程。类`RungeKutta`接受一个实现龙格-库塔公式的`RungeKuttaStepper`对象。例如，`RungeKutta2`实现了二阶龙格-库塔积分公式。`RungeKutta`的签名如下:

```py
/**
 * Constructs a Runge-Kutta algorithm with the given integrator and the
 * constant step size.
 *
 * @param stepper the integrator algorithm
 * @param h       constant step size
 */
public RungeKutta(RungeKuttaStepper stepper, final double h)

```

下面的代码使用许多龙格-库塔公式对 *x* ∈ [0，1]的 IVP 进行数值求解:

![$$ \left\{\begin{array}{c}{y}^{\prime }=y-x+1\\ {}y(0)=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equau.png)

解析解如下:

![$$ y={e}^x+x $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equav.png)

```py
// define the ODE to solve
DerivativeFunction dy = new DerivativeFunction() {

    @Override
    public Vector evaluate(double x, Vector v) {
        double y = v.get(1);
        double dy = y - x + 1;
        return new DenseVector(dy);
    }

    @Override
    public int dimension() {
        return 1;
    }
};
// initial condition, y0=1
Vector y0 = new DenseVector(1.);

double x0 = 0, x1 = 1.; // solution domain
double h = 0.1; // step size

// the analytical solution
UnivariateRealFunction y = new AbstractUnivariateRealFunction() {
    @Override
    public double evaluate(double x) {
        double y = exp(x) + x;
        return y;
    }
};

// define an IVP

ODE1stOrder ivp = new ODE1stOrder(dy, y0, x0, x1);

// using first order Runge-Kutta formula
RungeKuttaStepper stepper1 = new RungeKutta1();
ODESolver solver1 = new RungeKutta(stepper1, h);
ODESolution soln1 = solver1.solve(ivp);

// using second order Runge-Kutta formula
RungeKuttaStepper stepper2 = new RungeKutta2();
ODESolver solver2 = new RungeKutta(stepper2, h);
ODESolution soln2 = solver2.solve(ivp);

// using third order Runge-Kutta formula
RungeKuttaStepper stepper3 = new RungeKutta3();
ODESolver solver3 = new RungeKutta(stepper3, h);
ODESolution soln3 = solver3.solve(ivp);

double[] x = soln1.x();
Vector[] y1 = soln1.y();
Vector[] y2 = soln2.y();
Vector[] y3 = soln3.y();
for (int i = 0; i < x.length; ++i) {
    double yx = y.evaluate(x[i]); // the analytical solution
    double diff1 = yx - y1[i].get(1); // the first order error
    double diff2 = yx - y2[i].get(1); // the second order error
    double diff3 = yx - y3[i].get(1); // the third order error
    System.out.println(
            String.format("y(%f) = %s (%.16f); = %s (%.16f); = %s (%.16f)",
                    x[i], y1[i], diff1,
                    y2[i], diff2,
                    y3[i], diff3
            ));
}

```

输出如下所示:

```py
y(0.000000) = [1.000000]  (0.0000000000000000); = [1.000000]  (0.0000000000000000); = [1.000000]  (0.0000000000000000)
y(0.100000) = [1.200000]  (0.0051709180756478); = [1.205000]  (0.0001709180756477); = [1.205167]  (0.0000042514089811)
y(0.200000) = [1.410000]  (0.0114027581601699); = [1.421025]  (0.0003777581601696); = [1.421393]  (0.0000093970490587)
y(0.300000) = [1.631000]  (0.0188588075760032); = [1.649233]  (0.0006261825760030); = [1.649843]  (0.0000155779880402)
y(0.400000) = [1.864100]  (0.0277246976412704); = [1.890902]  (0.0009226470162702); = [1.891802]  (0.0000229550749731)
y(0.500000) = [2.110510]  (0.0382112707001285); = [2.147447]  (0.0012745047595035); = [2.148690]  (0.0000317115406090)
y(0.600000) = [2.371561]  (0.0505578003905094); = [2.420429]  (0.0016901240261187); = [2.422077]  (0.0000420559260470)
y(0.700000) = [2.648717]  (0.0650356074704770); = [2.711574]  (0.0021790200878256); = [2.713698]  (0.0000542253798352)
y(0.800000) = [2.943589]  (0.0819521184924685); = [3.022789]  (0.0027520039346389); = [3.025472]  (0.0000684893686271)
y(0.900000) = [3.257948]  (0.1016554201569502); = [3.356182]  (0.0034213495205484); = [3.359518]  (0.0000851538519182)
y(1.000000) = [3.593742]  (0.1245393683590454); = [3.714081]  (0.0042009818508215); = [3.718177]  (0.0001045659774346)

```

输出显示使用一阶、二阶和三阶龙格-库塔公式的近似值。括号内为近似值，括号内为误差。我们确实看到高阶公式给出了更精确的结果(更小的误差)。

图 [7-4](#Fig4) 比较了解析解与一阶龙格-库塔近似的结果。

![img/500382_1_En_7_Chapter/500382_1_En_7_Fig4_HTML.jpg](img/500382_1_En_7_Chapter/500382_1_En_7_Fig4_HTML.jpg)

图 7-4

解析解与一阶龙格-库塔法的比较

图 [7-5](#Fig5) 比较了解析解(蓝色)与一阶(黑色)、二阶(红色)和三阶(绿色)龙格-库塔近似的结果。二阶和三阶结果都很好。我们几乎看不到这些线，因为它们几乎与精确解(蓝线)重叠。

![img/500382_1_En_7_Chapter/500382_1_En_7_Fig5_HTML.jpg](img/500382_1_En_7_Chapter/500382_1_En_7_Fig5_HTML.jpg)

图 7-5

解析解与龙格-库塔法的比较

### 趋同性

对于单步方法，我们说一个积分公式，*y*<sub>*n*+1</sub>=*y*<sub>*n*</sub>+*hϕ*(*x*<sub>*n*</sub>，*y**n*， *h* )收敛

例如，考虑以下:

![$$ \left\{\begin{array}{c}{y}^{\prime }=\lambda y\\ {}y(0)={y}_0\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equax.png)

欧拉对这首颂歌的公式如下:

*和*<sub>*【n】*+1</sub>=*和**+*【hy】**

 *所以，我们有了这个:

![$$ {y}_n={\left(1+\lambda h\right)}^n{y}_0 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equay.png)

设 *x* <sub>0</sub> = 0 和*x*<sub>*n*</sub>=*NH*，如下图:

![$$ {y}_n={\left[{\left(1+\lambda h\right)}^{\frac{1}{\lambda h}}\right]}^{\lambda h n}{y}_0={\left[{\left(1+\lambda h\right)}^{\frac{1}{\lambda h}}\right]}^{\lambda {x}_n}{y}_0 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equaz.png)

![$$ \underset{h\to 0}{\lim }{y}_n={y}_0{e}^{\lambda {x}_n}=y\left({x}_n\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equba.png)

所以，欧拉公式对于这首颂歌是收敛的。

假设单步方法具有 *p* 阶精度。还假设增量函数 *ϕ* ( *x* ， *y* ， *h* )相对于 *y* 满足李普希茨条件。也就是说，对于任何一个 *y* 和![$$ \bar{y} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq20.png)，都有一个常数*L*T20】0，使得以下为真:

![$$ \left|\phi \left(x,y,h\right)-\phi \Big(x,\bar{y},h\Big)\right|\le L\left|y-\bar{y}\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbb.png)

可以证明这种单步方法是收敛的，总体截断误差如下:

![$$ y\left({x}_n\right)-{y}_n=o\left({h}^p\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbc.png)

我们可以应用这个定理来证明梯形公式的收敛性。梯形公式的增量函数如下:

![$$ \phi \left(x,y,h\right)=\frac{1}{2}\left[f\left(x,y\right)+f\left(x+h,y+ hf\left(x,y\right)\right)\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbd.png)

又如下:

![$$ \phi \left(x,\bar{y},h\right)=\frac{1}{2}\left[f\left(x,\bar{y}\right)+f\left(x+h,\bar{y}+ hf\left(x,\bar{y}\right)\right)\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Eqube.png)

两个方程相减，我们得到这个:

![$$ \left|\phi \left(x,y,h\right)-\phi \Big(x,\bar{y},h\Big)\right|\le \frac{1}{2}\left|f\left(x,y\right)-f\Big(x,\bar{y}\Big)\right|+\frac{1}{2}\left|f\Big(x+h,y+ hf\left(x,y\right)\left)-f\right(x+h,\bar{y}+ hf\Big(x,\bar{y}\left)\right)\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbf.png)

因为函数 *f* ( *x* ， *y* )相对于 *y* 满足李普希兹条件，不等式变成如下:

![$$ \left|\phi \left(x,y,h\right)-\phi \Big(x,\bar{y},h\Big)\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbg.png)

![$$ \le \frac{L}{2}\left|y-\bar{y}\right|+\frac{L}{2}\left|y+ hf\left(x,y\right)-\bar{y}- hf\Big(x,\bar{y}\left)\right)\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbh.png)

重新排列术语得到这个:

![$$ \left|\phi \left(x,y,h\right)-\phi \Big(x,\bar{y},h\Big)\right|\le \left\{\frac{L}{2}+\frac{L}{2}+\frac{h{L}^2}{2}\right\}\left|y-\bar{y}\right|={L}_{\phi}\left|y-\bar{y}\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbi.png)

因此，梯形公式的增量函数相对于 *y* 满足 Lipschitz 条件，因此存在收敛性。

### 稳定性

如果误差(真实解和近似解之间的差异)不增加，则称常微分方程的解是稳定的。

以这首简单的颂歌为例:

*和*<sup>=*，*<0**</sup>

 **解析解如下:

![$$ {y}_{n+1}^{\ast }=\left(1+\lambda h\right){y}_n^{\ast } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbj.png)

利用欧拉公式，数值解如下:

![$$ {y}_{n+1}={y}_n+ h\lambda {y}_n=\left(1+\lambda h\right){y}_n $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbk.png)

定义错误如下:

![$$ {\varepsilon}_n={y}_n^{\ast }-{y}_n $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbl.png)

误差的递归关系如下:

![$$ {\varepsilon}_{n+1}=\left(1+\lambda h\right){\varepsilon}_n $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbm.png)

保证稳定的条件如下:

![$$ \left|{\varepsilon}_{n+1}\right|\le \left|{\varepsilon}_n\right| $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbn.png)

也就是

![$$ \left|1+\lambda h\right|\le 1 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbo.png)

因此，(显式)欧拉公式的稳定区域如下:

![$$ -2\le \lambda h\le 0 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbp.png)

我们可以对隐式欧拉公式进行类似的分析。

解析解如下:

![$$ {y}_{n+1}^{\ast }={y}_n^{\ast }+ h\lambda {y}_{n+1}^{\ast } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbq.png)

利用隐式欧拉公式，数值解如下:

![$$ {y}_{n+1}={y}_n+ h\lambda {y}_{n+1} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbr.png)

稳定性方程(两方程相减得到)如下:

![$$ {\varepsilon}_{n+1}={\varepsilon}_n+ h\lambda {\varepsilon}_{n+1} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbs.png)

重新排列术语，我们得到这个:

![$$ {\varepsilon}_{n+1}=\frac{1}{1-\lambda h}{\varepsilon}_n $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbt.png)

因为*λ*T11】0，![$$ \frac{1}{1-\lambda h}\le 1 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq21.png)为任意步长*h*T12】0。即稳定区域为∞<T5】λh≤0 或*h*T14】0。我们说隐式欧拉公式是无条件稳定的。显式和隐式欧拉公式都有一阶精度。后者是优选的，因为无论步长大小，它都是无条件稳定的，而前者仅在 *h* 的特定值上稳定。事实上,(常、偏)微分方程数值解中的许多隐式方法都是无条件稳定的。例如，求解偏微分方程的克兰克-梁君诺方法是一种隐式方法，并且是无条件稳定的。因此，隐式方法通常比显式方法更受青睐。

## 7.2 线性多步法

单步方法(如欧拉方法)的局限性在于，它只使用最后一个节点的信息(值和导数)来计算当前节点。尽管像 Runge-Kutta 公式这样的方法利用了多个点，但它们仅将这些点作为中间点，并在处理下一个节点之前将其丢弃。相反，多步法试图通过保留和使用为先前节点计算的信息(值和导数)来提高精度。在线性多步法的情况下，使用多个先前节点的值和导数的线性组合来确定当前节点的值。一般线性多步法的积分公式如下:

![$$ {y}_{n+1}={\sum}_{k=0}^r{\alpha}_k{y}_{n-k}+h{\sum}_{k=-1}^r{\beta}_k{y}_{n-k}^{\prime } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbu.png)

![$$ {y}_{n-k}^{\prime }=f\left({x}_{n-k},{y}_{n-k}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbv.png)

如果*<sub>—1</sub>= 0，则积分公式为显式公式( *y* <sub>*n* + 1</sub> 不在右边)；如果*β*<sub>—1</sub>≠0，则该公式为隐式公式。通过适当选择待定参数，可以构造一族线性多步公式。类似于推导龙格-库塔公式族，我们可以通过将系数与泰勒展开式进行比较来确定参数。让*

*![$$ {y}_{n-k}=y\left({x}_{n-k}\right)=y\left({x}_n- kh\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbw.png)*

 *![$$ {y}_{n-k}^{\prime }={y}^{\prime}\left({x}_{n-k}\right)={y}^{\prime}\left({x}_n- kh\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbx.png)

对两个*y*<sub>*n*-*k*</sub>和![$$ {y}_{n-k}^{\prime } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq22.png)，在*x*<sub>T3】nT5 处进行泰勒展开。</sub>

![$$ {y}_{n-k}={\sum}_{j=0}^p\frac{{\left(- kh\right)}^j}{j!}{y}_n^{(j)}+\frac{{\left(- kh\right)}^{p+1}}{\left(p+1\right)!}{y}_n^{\left(p+1\right)}+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equby.png)

![$$ {y}_{n-k}^{\prime }={\sum}_{j=1}^p\frac{{\left(- kh\right)}^{j-1}}{\left(j-1\right)!}{y}_n^{(j)}+\frac{{\left(- kh\right)}^p}{p!}{y}_n^{\left(p+1\right)}+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equbz.png)

把它们代入积分公式，重新排列项，如下图:

![$$ {y}_{n+1}=\left({\sum}_{k=0}^r{\alpha}_k\right){y}_n+{\sum}_{j=1}^p\frac{h^j}{j!}\left[{\sum}_{k=1}^r{\left(-k\right)}^j{\alpha}_k+j{\sum}_{k=-1}^r{\left(-k\right)}^{j-1}{\beta}_k\right]{y}_n^{(j)}+\frac{h^{p+1}}{\left(p+1\right)!}\left[{\sum}_{k=1}^r{\left(-k\right)}^{p+1}{\alpha}_k+\left(p+1\right){\sum}_{k=-1}^r{\left(-k\right)}^p{\beta}_k\right]{y}_n^{\left(p+1\right)}+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equca.png)

我们还对*y*(*x*<sub>T5】n+1</sub>)在 *x* <sub>*n*</sub> 做泰勒展开，得到如下:

![$$ y\left({x}_{n+1}\right)={\sum}_{j=0}^p\frac{h^j}{j!}{y}_n^{(j)}+\frac{h^{p+1}}{\left(p+1\right)!}{y}_n^{\left(p+1\right)}+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcb.png)

为了使积分公式为*p*-阶精度，即局部截断误差为*O*(*h*<sup>*p*+1</sup>)，我们将*y*<sub>*n*+1</sub>和*y*(*x*<sub>*n*+1</sub>的系数匹配为 up 下面的参数方程组必须成立:

![$$ \left\{\begin{array}{c}{\sum}_{k=0}^r{\alpha}_k=1\\ {}{\sum}_{k=1}^r{\left(-k\right)}^j{\alpha}_k+j{\sum}_{k=-1}^r{\left(-k\right)}^{j-1}{\beta}_k=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcc.png)

局部截断误差如下:

![$$ y\left({x}_{n+1}\right)-{y}_{n+1}=\frac{h^{p+1}}{\left(p+1\right)!}\left[1-{\sum}_{k=1}^r{\left(-k\right)}^{p+1}{\alpha}_k-\left(p+1\right){\sum}_{k=-1}^r{\left(-k\right)}^p{\beta}_k\right]{y}_n^{\left(p+1\right)}+\cdots $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcd.png)

### 7.2.1 亚当斯-巴什福斯方法

Adams-Bashforth 方法是一类线性多步法。让我们考虑一个使用四个步骤(即，使用最后四个节点)的显式公式(即，在公式的右侧没有 *y* <sub>*n* + 1</sub> )。积分公式(参数待定)如下:

![$$ {y}_{n+1}={\alpha}_0{y}_n+{\alpha}_1{y}_{n-1}+{\alpha}_2{y}_{n-2}+h\left({\beta}_0{y}_n^{\prime }+{\beta}_1{y}_{n-1}^{\prime }+{\beta}_2{y}_{n-2}^{\prime }+{\beta}_3{y}_{n-3}^{\prime}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equce.png)

为了使该公式具有四阶精度(在线性多步框架中设置 *r* = 3)，系数必须满足:

![$$ \left\{\begin{array}{c}{\alpha}_0+{\alpha}_1+{\alpha}_2=1\\ {}-{\alpha}_1-2{\alpha}_2+{\beta}_0+{\beta}_1+{\beta}_2+{\beta}_3=1\\ {}{\alpha}_1+4{\alpha}_2-2{\beta}_1-4{\beta}_2-6{\beta}_3=1\\ {}-{\alpha}_1-8{\alpha}_2+3{\beta}_1+12{\beta}_2+27{\beta}_3=1\\ {}{\alpha}_1+16{\alpha}_2-4{\beta}_1-32{\beta}_2-108{\beta}_3=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcf.png)

因为有七个未知数，只有五个方程，所以方程组的解不是唯一的。一个约定就是设置*α*<sub>1</sub>=*α*<sub>2</sub>= 0。然后我们有了这个:

![$$ {\alpha}_0=1,{\beta}_0=\frac{55}{24},{\beta}_1=-\frac{59}{24},{\beta}_2=\frac{37}{24},{\beta}_3=-\frac{9}{24} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcg.png)

积分公式变成如下:

![$$ {y}_{n+1}={y}_n+\frac{h}{24}\left(55{f}_n-59{f}_{n-1}+37{f}_{n-2}-9{f}_{n-3}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equch.png)

![$$ {f}_{n-k}=f\left({x}_{n-k},{y}_{n-k}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equci.png)

这就是四阶的四步 Adams-Bashforth 显式公式。

一阶公式和欧拉公式一样。

![$$ {y}_{k+1}={y}_k+h{f}_k $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcj.png)T2】

二阶公式如下:

![$$ {y}_{k+1}={y}_k+\frac{h}{2}\left[3{f}_k-{f}_{k-1}\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equck.png)

三阶公式如下:

![$$ {y}_{k+1}={y}_k+\frac{h}{12}\left[23{f}_k-16{f}_{k-1}+5{f}_{k-2}\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcl.png)

虽然这些公式是显式的，因此容易计算，但它们的稳定性很差。

#### 7.2.1.1·亚当斯-巴什福斯隐式公式

考虑下面的四步隐式公式(基本上是用![$$ {y}_{n+1}^{\prime } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq24.png)代替![$$ {y}_{n-3}^{\prime } $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_IEq23.png)):

![$$ {y}_{n+1}={\alpha}_0{y}_n+{\alpha}_1{y}_{n-1}+{\alpha}_2{y}_{n-2}+h\left({\beta}_{-1}{y}_{n+1}^{\prime }+{\beta}_0{y}_n^{\prime }+{\beta}_1{y}_{n-1}^{\prime }+{\beta}_2{y}_{n-2}^{\prime}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcm.png)

为使该积分公式具有四阶精度，系数应满足:

![$$ \left\{\begin{array}{c}{\alpha}_0+{\alpha}_1+{\alpha}_2=1\\ {}-{\alpha}_1-2{\alpha}_2+{\beta}_{-1}+{\beta}_0+{\beta}_1+{\beta}_2=1\\ {}{\alpha}_1+4{\alpha}_2+2{\beta}_{-1}-2{\beta}_1-4{\beta}_2=1\\ {}-{\alpha}_1-8{\alpha}_2++3{\beta}_{-1}+3{\beta}_1+12{\beta}_2=1\\ {}{\alpha}_1+16{\alpha}_2+4{\beta}_{-1}-4{\beta}_1-32{\beta}_2=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcn.png)

有七个未知数，只有五个方程，所以解不是唯一的。典型的约定是设置*α*<sub>1</sub>=*α*<sub>2</sub>= 0。然后我们有了这个:

![$$ {\alpha}_0=1,{\beta}_{-1}=\frac{9}{24},{\beta}_0=\frac{19}{24},{\beta}_1=-\frac{5}{24},{\beta}_2=\frac{1}{24} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equco.png)

积分公式如下:

![$$ {y}_{n+1}={y}_n+\frac{h}{24}\left(9{f}_{n+1}+19{f}_n-5{f}_{n-1}+{f}_{n-2}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcp.png)

![$$ {f}_{n-k}=f\left({x}_{n-k},{y}_{n-k}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcq.png)

一阶 Adams-Bashforth 隐式公式与隐式 Euler 公式相同。

![$$ {y}_{k+1}={y}_k+h{f}_{k+1} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcr.png)T2】

二阶和梯形公式一样。

![$$ {y}_{k+1}={y}_k+\frac{h}{2}\left[{f}_{k+1}+{f}_k\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcs.png)T2】

三阶公式如下:

![$$ {y}_{k+1}={y}_k+\frac{h}{12}\left[5{f}_{k+1}+8{f}_k-{f}_{k-1}\right] $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equct.png)

注意，亚当斯-巴什福斯公式不是自启动的。单步方法，如龙格-库塔公式，用于计算前几个点。

NM Dev 支持 Adams-Bashforth 公式的前五阶。以下代码求解第 7.1.2.3 节中给出的相同 IVP:

```py
// define the ODE to solve
DerivativeFunction dy = new DerivativeFunction() {

    @Override
    public Vector evaluate(double x, Vector v) {
        double y = v.get(1);
        double dy = y - x + 1;
        return new DenseVector(dy);
    }

    @Override
    public int dimension() {
        return 1;
    }
};
// initial condition, y0=1
Vector y0 = new DenseVector(1.);

double x0 = 0, x1 = 1.; // solution domain
double h = 0.1; // step size

// the analytical solution
UnivariateRealFunction y = new AbstractUnivariateRealFunction() {
    @Override
    public double evaluate(double x) {
        double y = exp(x) + x;
        return y;
    }
};

// define an IVP
ODE1stOrder ivp = new ODE1stOrder(dy, y0, x0, x1);

// using first order Adams-Bashforth formula
ODESolver solver1 = new AdamsBashforthMoulton(new ABMPredictorCorrector1(), h);
ODESolution soln1 = solver1.solve(ivp);

// using second order Adams-Bashforth formula
ODESolver solver2 = new AdamsBashforthMoulton(new ABMPredictorCorrector2(), h);
ODESolution soln2 = solver2.solve(ivp);

// using third order Adams-Bashforth formula
ODESolver solver3 = new AdamsBashforthMoulton(new ABMPredictorCorrector3(), h);
ODESolution soln3 = solver3.solve(ivp);

// using forth order Adams-Bashforth formula
ODESolver solver4 = new AdamsBashforthMoulton(new ABMPredictorCorrector4(), h);
ODESolution soln4 = solver4.solve(ivp);

// using fifth order Adams-Bashforth formula
ODESolver solver5 = new AdamsBashforthMoulton(new ABMPredictorCorrector5(), h);
ODESolution soln5 = solver5.solve(ivp);

double[] x = soln1.x();
Vector[] y1 = soln1.y();
Vector[] y2 = soln2.y();
Vector[] y3 = soln3.y();
Vector[] y4 = soln4.y();
Vector[] y5 = soln5.y();
for (int i = 0; i < x.length; ++i) {
    double yx = y.evaluate(x[i]); // the analytical solution
    double diff1 = yx - y1[i].get(1); // the first order error
    double diff2 = yx - y2[i].get(1); // the second order error
    double diff3 = yx - y3[i].get(1); // the third order error
    double diff4 = yx - y4[i].get(1); // the forth order error
    double diff5 = yx - y5[i].get(1); // the fifth order error
    System.out.println(
            String.format("y(%f) = %s (%.16f); = %s (%.16f); = %s (%.16f); = %s (%.16f); = %s (%.16f)",
                    x[i], y1[i], diff1,
                    y2[i], diff2,
                    y3[i], diff3,
                    y4[i], diff4,
                    y5[i], diff5
            ));
}

```

输出如下所示:

```py
y(0.000000) = [1.000000]  (0.0000000000000000); = [1.000000]  (0.0000000000000000); = [1.000000]  (0.0000000000000000); = [1.000000]  (0.0000000000000000); = [1.000000]  (0.0000000000000000)
y(0.100000) = [1.210000]  (-0.0048290819243522); = [1.205000]  (0.0001709180756477); = [1.205000]  (0.0001709180756477); = [1.205000]  (0.0001709180756477); = [1.205000]  (0.0001709180756477)
y(0.200000) = [1.432100]  (-0.0106972418398301); = [1.421288]  (0.0001152581601698); = [1.421025]  (0.0003777581601696); = [1.421025]  (0.0003777581601696); = [1.421025]  (0.0003777581601696)
y(0.300000) = [1.667631]  (-0.0177721924239969); = [1.649813]  (0.0000454013260032); = [1.649443]  (0.0004159690343364); = [1.649443]  (0.0004159690343364); = [1.649443]  (0.0004159690343364)
y(0.400000) = [1.918070]  (-0.0262457123587299); = [1.891865]  (-0.0000404310306048); = [1.891369]  (0.0004556955886803); = [1.891369]  (0.0004556955886803); = [1.891369]  (0.0004556955886803)
y(0.500000) = [2.185058]  (-0.0363368843998719); = [2.148866]  (-0.0001448257883485); = [2.148222]  (0.0004994814440833); = [2.148222]  (0.0004994814440833); = [2.148222]  (0.0004994814440833)
y(0.600000) = [2.470415]  (-0.0482957517704916); = [2.422390]  (-0.0002707386487995); = [2.421571]  (0.0005474439430126); = [2.421571]  (0.0005474439430126); = [2.421571]  (0.0005474439430126)
y(0.700000) = [2.776160]  (-0.0624074454282342); = [2.714174]  (-0.0004215417743363); = [2.713153]  (0.0005999698250871); = [2.713153]  (0.0005999698250871); = [2.713153]  (0.0005999698250871)
y(0.800000) = [3.104538]  (-0.0789968412251016); = [3.026142]  (-0.0006010786985646); = [3.024883]  (0.0006574888333333); = [3.024883]  (0.0006574888333333); = [3.024883]  (0.0006574888333333)
y(0.900000) = [3.458037]  (-0.0984338132295521); = [3.360417]  (-0.0008137261840067); = [3.358883]  (0.0007204702609296); = [3.358883]  (0.0007204702609296); = [3.358883]  (0.0007204702609296)
y(1.000000) = [3.839421]  (-0.1211391576099716); = [3.719346]  (-0.0010644638780861); = [3.717492]  (0.0007894268678772); = [3.717492]  (0.0007894268678772); = [3.717492]  (0.0007894268678772)

```

输出使用一阶、二阶、三阶、四阶和五阶 Adams-Bashforth 公式显示近似值。括号内为近似值，括号内为误差。我们确实看到高阶公式给出了更精确的结果(更小的误差)。对于本例，三阶、四阶和五阶公式产生相同的结果。

## 7.3 不同方法的比较

我们总结了用本章所介绍的不同方法解决下面初值问题的结果。IVP 如下:

![$$ \left\{\begin{array}{c}{y}^{\prime }=-y+x+1,0&lt;x\le 0.6\\ {}y(0)=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcu.png)

解析解如下:

![$$ y={e}^{-x}+x $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcv.png)

我们用步长 *h* = 0.1，所以*x*<sub>T5】k</sub>=*KH*(*k*= 0，1，…，6)。每种方法的计算结果和绝对误差如下表所示。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"> <col class="tcol6 align-left"></colgroup> 
| 

**四步亚当斯-巴什福斯公式**

 |
| --- |
| ***n*** | ***x***<sub>***n***</sub> | **显式公式** | **隐式公式** |
| *y*<sub>T3】nT5】</sub> | ε | *y*<sub>T3】nT5】</sub> | ε |
| four | Zero point four | 1.070323 | 2006 年 2.90 年 | 1.07032 | 2007 年 3.90 年 |
| five | Zero point five | 1.106535 | 4.80e-06 | 1.10653 | 2007 年 5 月 20 日 |
| six | Zero point six | 1.148815 | 6.80 年 6 月 | 1.148811 | 6.50 年 7 月 |

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"> <col class="tcol6 align-left"> <col class="tcol7 align-left"></colgroup> 
|   | 

**欧拉方法**

 | 

**梯形公式**

 | 

**四阶龙格-库塔公式**

 |
| --- | --- | --- | --- |
| 

*x*<sub>T3】nT5】</sub>

 | 

*y*<sub>T3】nT5】</sub>

 | 

ε

 | 

*y*<sub>T3】nT5】</sub>

 | 

ε

 | 

*y*<sub>T3】nT5】</sub>

 | 

ε

 |
| --- | --- | --- | --- | --- | --- | --- |
| Zero | one | Zero | one | Zero | one | Zero |
| Zero point one | one | 4.80e-03 | One point zero zero five | 1.60e-04 | 1.0048375 | 08 年 8 月 00 日 |
| Zero point two | One point zero one | 8.70e-03 | 1.019025 | 2004 年 2.90 年 | 1.0187309 | 1.50e-07 |
| Zero point three | One point zero two nine | 1.20e-03 | 1.041218 | 2004 年 4 月 | 1.04081842 | 07 年 2 月 0e 日 |
| Zero point four | 1.0561 | 1.40e-03 | 1.070802 | 4.80 年 4 月 | 1.07032029 | 2.40 年 7 月 |
| Zero point five | 1.09049 | 1.60e-03 | 1.107076 | 5.50e-04 | 1.10653093 | 2.70 年 7 月 |
| Zero point six | 1.131441 | 1.80e-03 | 1.149404 | 5.90 年 4 月 | 1.14881193 | 2.90 年至 2007 年 |

一般来说，方法的阶数越高，解的精度越高。一阶欧拉公式的精度最低，而四阶龙格-库塔公式的精度最高，事实上要好得多(1e-7 对 1e-3)。对于四阶 Adams-Bashforth 方法，隐式公式比显式公式略精确。

就计算量而言，四阶龙格-库塔法的计算量最大。函数 *f* 在每一步中被评估四次。相比之下，具有类似精度的 Adams-Bashforth 方法仅评估该函数两次。因此，后者更为可取。但是，它是一个四步方法，因此起始值必须由另一个方法提供。计算过程稍微复杂一些。

考虑用欧拉公式求解以下 IVP:

![$$ \left\{\begin{array}{c}{y}^{\prime }=-1000\left(y-{x}^2\right)+2x\\ {}y(0)=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcw.png)

注意精确解说 *y* (1) = 1。

取这些步长:*h*= 10<sup>—1</sup>，*h*= 10<sup>—2</sup>，*h*= 10<sup>—3</sup>，*h*= 10<sup>—4</sup>。结果如下表所示。第一，对于*h*= 10<sup>—1</sup>和*h*= 10<sup>—2</sup>，结果完全失真。第二，从*h*= 10<sup>—3</sup>到*h*= 10<sup>—4</sup>，计算工作量增加了十倍，但精度并没有提高。*h*= 10<sup>—4</sup>再细的步长都是浪费计算。

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

***h***

 | 

***y***

 |
| --- | --- |
| 10<sup>—1</sup> | 0.904382 × 10 <sup>16</sup> |
| 10<sup>2</sup> | > 10 <sup>38</sup> |
| 10<sup>3</sup> | 0.999999000001 |
| 10<sup>4</sup> | 0.999999000000 |

对于*h*= 10<sup>-1</sup>和*h*= 10<sup>-2</sup>的垃圾结果的原因是因为稳定区域。如 7.1.4 节所述， *h* 需要满足以下:

![$$ -2&lt;-1000h&lt;0 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcx.png)

或者等价地，

![$$ 0&lt;h&lt;2\times {10}^{-3} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcy.png)

前两个步长在稳定区域之外。

这些例子表明，在选择适当的方法和参数来求解微分方程时，有许多考虑因素。这些选择会影响准确性、计算工作量和稳定性。步长太大时，解可能失真；当它太小时，它不必要地增加了计算量。好的选择不仅取决于所用的数值方法，还取决于要求解的微分方程的特性。

## 7.4 常微分方程和高阶常微分方程系统

考虑一个 *N* 的一阶常微分方程组和初始条件，如下图:

![$$ \left\{\begin{array}{c}{y}_1^{\prime }={f}_1\left(x,{y}_1,\cdots, {y}_N\right)\\ {}{y}_2^{\prime }={f}_2\left(x,{y}_1,\cdots, {y}_N\right)\\ {}\begin{array}{c}\vdots \\ {}{y}_N^{\prime }={f}_N\left(x,{y}_1,\cdots, {y}_N\right)\\ {}\begin{array}{c}{y}_1\left({x}_0\right)={y}_1^0\\ {}{y}_2\left({x}_0\right)={y}_2^0\\ {}\begin{array}{c}\vdots \\ {}{y}_N\left({x}_0\right)={y}_N^0\end{array}\end{array}\end{array}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equcz.png)

为了解决这个系统的颂歌，我们写下:

![$$ \boldsymbol{Y}=\left(\begin{array}{c}{y}_1\\ {}\vdots \\ {}{y}_N\end{array}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equda.png)

![$$ \boldsymbol{F}=\left(\begin{array}{c}{f}_1\\ {}\vdots \\ {}{f}_N\end{array}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdb.png)

那么《诗经》的体系就可以用向量的形式来写:

![$$ \left\{\begin{array}{c}{\boldsymbol{Y}}^{\prime }=\boldsymbol{F}\left(x,\boldsymbol{Y}\right)\\ {}\boldsymbol{Y}\left({x}_0\right)={\boldsymbol{Y}}_{\mathbf{0}}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdc.png)

注意，除了变量和函数现在是向量之外，这个 IVP 和我们在本章讨论的任何其他常微分方程具有相同的形式。NM Dev 类`DerivativeFunction`和`ODE1stOrder`已经支持向量形式。因此，我们可以将所有的方法应用于求解常微分方程组。比如矢量形式的欧拉公式如下:

![$$ {\boldsymbol{Y}}_{\boldsymbol{n}+\mathbf{1}}={\boldsymbol{Y}}_{\boldsymbol{n}}+h\boldsymbol{F}\left({x}_n,{\boldsymbol{Y}}_{\boldsymbol{n}}\right) $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdd.png)

组件如下:

![$$ \left\{\begin{array}{c}{y}_{1,n+1}={y}_{1,n}+h{f}_1\left({x}_n,{y}_{1,n},\cdots, {y}_{N,n}\right)\\ {}{y}_{2,n+1}={y}_{2,n}+h{f}_2\left({x}_n,{y}_{1,n},\cdots, {y}_{N,n}\right)\\ {}\begin{array}{c}\vdots \\ {}{y}_{N,n+1}={y}_{N,n}+h{f}_N\left({x}_n,{y}_{1,n},\cdots, {y}_{N,n}\right)\end{array}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equde.png)

例如，下面的代码解决了这个系统的颂歌:

![$$ \left\{\begin{array}{c}\frac{dx}{dt}=3x-4y\\ {}\frac{dy}{dt}=4x-7y\\ {}x(0)=y(0)=1\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdf.png)

解析解如下:

![$$ \left\{\begin{array}{c}x=\frac{2}{3}{e}^t+\frac{1}{3}{e}^{-5t}\\ {}y=\frac{1}{3}{e}^t+\frac{2}{3}{e}^{-5t}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdg.png)

```py
// define the system of ODEs to solve
DerivativeFunction dY = new DerivativeFunction() {

    @Override
    public Vector evaluate(double t, Vector v) {
        double x = v.get(1);
        double y = v.get(2);

        double dx = 3\. * x - 4\. * y;
        double dy = 4\. * x - 7\. * y;
        return new DenseVector(new double[]{dx, dy});
    }

    @Override
    public int dimension() {
        return 2;
    }
};
// initial condition, x0=y0=1
Vector Y0 = new DenseVector(1., 1.);

double x0 = 0, x1 = 1.; // solution domain
double h = 0.1; // step size

// the analytical solution
RealVectorFunction F
        = new AbstractRealVectorFunction(1, 2) {
    @Override
    public Vector evaluate(Vector v) {
        double t = v.get(1);
        double x = 2\. / 3 * exp(t) + 1\. / 3 * exp(-5\. * t);
        double y = 1\. / 3 * exp(t) + 2\. / 3 * exp(-5\. * t);
        return new DenseVector(x, y);
    }
};

// define an IVP
ODE1stOrder ivp = new ODE1stOrder(dY, Y0, x0, x1);
// construt an ODE solver using Euler's method
ODESolver solver = new EulerMethod(h);
// solve the ODE
ODESolution soln = solver.solve(ivp);
// print out the solution function, y, at discrete points
double[] t = soln.x();
Vector[] v = soln.y();
for (int i = 0; i < t.length; ++i) {
    System.out.println(String.format(
            "y(%f) = %s vs %s",
            t[i],
            v[i],
            F.evaluate(new DenseVector(t[i]))
    ));
}

```

输出如下所示:

```py
y(0.000000) = [1.000000, 1.000000]  vs [1.000000, 1.000000]
y(0.100000) = [0.900000, 0.700000]  vs [0.938957, 0.772744]
y(0.200000) = [0.890000, 0.570000]  vs [0.936895, 0.652387]
y(0.300000) = [0.929000, 0.527000]  vs [0.974283, 0.598706]
y(0.400000) = [0.996900, 0.529700]  vs [1.039662, 0.587498]
y(0.500000) = [1.084090, 0.557670]  vs [1.126509, 0.604297]
y(0.600000) = [1.186249, 0.600937]  vs [1.231342, 0.640564]
y(0.700000) = [1.301749, 0.654781]  vs [1.352568, 0.691382]
y(0.800000) = [1.430361, 0.717134]  vs [1.489799, 0.754057]
y(0.900000) = [1.572616, 0.787285]  vs [1.643438, 0.827274]
y(1.000000) = [1.729487, 0.865232]  vs [1.814434, 0.910586]

```

向量的第一列由数值解组成，第二列包含解析解。我们可以使用其他更先进的方法来提高精确度。

考虑一个包含高阶导数的常微分方程，这里显示:

![$$ \left\{\begin{array}{c}{y}^{(m)}=f\left(x,y,{y}^{\prime },\cdots, {y}^{\left(m-1\right)}\right)\\ {}y\left({x}_0\right)={y}_0\\ {}{y}^{\prime}\left({x}_0\right)={y}_0^{\prime}\\ {}\vdots \\ {}{y}^{\left(m-1\right)}\left({x}_0\right)={y}_0^{\left(m-1\right)}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdh.png)

我们可以通过设置 *y* <sub>1</sub> = *y* ，*y*<sub>2</sub>=*y*<sup>′</sup>，*y*<sub>*m*</sub>=*y*<sup>(【T25 具体来说，这里有一个例子:</sup>

![$$ y={y}_1 $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdi.png)

![$$ \left\{\begin{array}{c}{y}_1^{\prime }={y}_2\\ {}{y}_2^{\prime }={y}_3\\ {}\begin{array}{c}\vdots \\ {}{y}_{m-1}^{\prime }={y}_m\\ {}{y}_m^{\prime }=f\left(x,{y}_1,{y}_2,\cdots, {y}_m\right)\end{array}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdj.png)

我们已经可以使用`DerivativeFunction`和`ODE1stOrder`以及任何 NM Dev ODE 求解器来求解一阶常微分方程组。

比如下面的代码求解这个二阶颂歌:

![$$ \left\{\begin{array}{c}{y}^{\prime \prime }-{y}^{\prime }-6y=0\\ {}y(0)=1\\ {}{y}^{\prime }(0)=2\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdk.png)

解析解如下:

![$$ y=\frac{4}{5}{e}^{3t}+\frac{1}{5}{e}^{-2t} $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdl.png)

我们首先可以用一阶常微分方程组改写 IVP。

假设 *y* <sub>1</sub> = *y* 和*y*<sub>2</sub>=*y*<sup>’</sup>，我们有如下:

![$$ \left\{\begin{array}{c}\frac{d{y}_1}{dt}={y}_2\\ {}\frac{d{y}_2}{dt}={y}_2+6{y}_1\\ {}\begin{array}{c}{y}_1(0)=1\\ {}{y}_2(0)=2\end{array}\end{array}\right. $$](img/500382_1_En_7_Chapter/500382_1_En_7_Chapter_TeX_Equdm.png)

我们首先用欧拉方法求解这个系统。

```py
// define the equivalent system of ODEs to solve
DerivativeFunction dY = new DerivativeFunction() {

    @Override
    public Vector evaluate(double t, Vector v) {
        double y_1 = v.get(1);
        double y_2 = v.get(2);

        double dy_1 = y_2;
        double dy_2 = y_2 + 6\. * y_1;
        return new DenseVector(new double[]{dy_1, dy_2});
    }

    @Override
    public int dimension() {
        return 2;
    }
};
// initial condition, y1(0) = 1, y2(0) = 2
Vector Y0 = new DenseVector(1., 2.);

double t0 = 0, t1 = 1.; // solution domain
double h = 0.1; // step size

// the analytical solution
UnivariateRealFunction f
        = new AbstractUnivariateRealFunction() {
    @Override
    public double evaluate(double t) {
        double f = 0.8 * exp(3\. * t);
        f += 0.2 * exp(-2\. * t);
        return f;
    }
};

// define an IVP
ODE1stOrder ivp = new ODE1stOrder(dY, Y0, t0, t1);
// construt an ODE solver using Euler's method
ODESolver solver = new EulerMethod(h);
// construt an ODE solver using the third order Runge-Kutta formula
//        RungeKuttaStepper stepper3 = new RungeKutta3();
//        ODESolver solver = new RungeKutta(stepper3, h);

// solve the ODE
ODESolution soln = solver.solve(ivp);
// print out the solution function, y, at discrete points
double[] t = soln.x();
Vector[] v = soln.y();
for (int i = 0; i < t.length; ++i) {
    double y1 = v[i].get(1); // the numerical solution
    System.out.println(String.format(
            "y(%f) = %f vs %f",
            t[i],
            y1,
            f.evaluate(t[i])
    ));
}

```

输出如下所示:

```py
y(0.000000) = 1.000000 vs 1.000000
y(0.100000) = 1.200000 vs 1.243633
y(0.200000) = 1.480000 vs 1.591759
y(0.300000) = 1.860000 vs 2.077445
y(0.400000) = 2.366800 vs 2.745959
y(0.500000) = 3.035880 vs 3.658927
y(0.600000) = 3.913876 vs 4.899957
y(0.700000) = 5.061824 vs 6.582255
y(0.800000) = 6.559400 vs 8.858920
y(0.900000) = 8.510443 vs 11.936845
y(1.000000) = 11.050154 vs 16.095497

```

我们注意到使用欧拉公式的精度很差。(我认为这是我的代码中的一个错误，但在代码中找不到任何问题。)

让我们使用三阶龙格-库塔公式再次尝试一下。

```py
// define the equivalent system of ODEs to solve
DerivativeFunction dY = new DerivativeFunction() {

    @Override
    public Vector evaluate(double t, Vector v) {
        double y_1 = v.get(1);
        double y_2 = v.get(2);

        double dy_1 = y_2;
        double dy_2 = y_2 + 6\. * y_1;
        return new DenseVector(new double[]{dy_1, dy_2});
    }

    @Override
    public int dimension() {
        return 2;
    }
};
// initial condition, y1(0) = 1, y2(0) = 2
Vector Y0 = new DenseVector(1., 2.);

double t0 = 0, t1 = 1.; // solution domain
double h = 0.1; // step size

// the analytical solution
UnivariateRealFunction f
        = new AbstractUnivariateRealFunction() {
    @Override
    public double evaluate(double t) {
        double f = 0.8 * exp(3\. * t);
        f += 0.2 * exp(-2\. * t);
        return f;
    }
};

// define an IVP
ODE1stOrder ivp = new ODE1stOrder(dY, Y0, t0, t1);
// construt an ODE solver using Euler's method
//        ODESolver solver = new EulerMethod(h);
// construt an ODE solver using the third order Runge-Kutta formula
RungeKuttaStepper stepper3 = new RungeKutta3();
ODESolver solver = new RungeKutta(stepper3, h);

// solve the ODE
ODESolution soln = solver.solve(ivp);
// print out the solution function, y, at discrete points
double[] t = soln.x();
Vector[] v = soln.y();
for (int i = 0; i < t.length; ++i) {
    double y1 = v[i].get(1); // the numerical solution
    System.out.println(String.format(
            "y(%f) = %f vs %f",
            t[i],
            y1,
            f.evaluate(t[i])
    ));
}

```

输出如下所示:

```py
y(0.000000) = 1.000000 vs 1.000000
y(0.100000) = 1.243333 vs 1.243633
y(0.200000) = 1.590963 vs 1.591759
y(0.300000) = 2.075850 vs 2.077445
y(0.400000) = 2.743108 vs 2.745959
y(0.500000) = 3.654136 vs 3.658927
y(0.600000) = 4.892215 vs 4.899957
y(0.700000) = 6.570082 vs 6.582255
y(0.800000) = 8.840160 vs 8.858920
y(0.900000) = 11.908375 vs 11.936845
y(1.000000) = 16.052815 vs 16.095497

```

用龙格-库塔法计算的结果是令人满意的。*************