# 9.无约束最优化

无约束优化寻找一个变量(或一组变量),使目标函数最小化或最大化，而对它们的值没有限制。数学上，它说，求*x*<sup>∫</sup>使得函数*f*(*x*<sup>∫</sup>)取最小值。

![$$ {x}^{\ast }=\underset{x}{\min }f(x) $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equa.png)

*x* 可能是标量(在*ℝ*T4【1】t5)也可能是矢量(在 *ℝ* <sup>*n*</sup> )。 *f* ( *x* )始终是标量(在*ℝ*1)。无约束最优化在许多科学分支中都有应用。在金融学中，构建收益率曲线包括寻找一组参数，以最小化债券的理论价格和市场价格之间的差异。通过将约束优化问题的约束转换成等价的无约束优化问题的目标函数中的罚项，约束优化问题也可以公式化为无约束优化问题。此外，许多约束优化解算器或算法涉及将无约束优化问题作为子问题来求解。NM Dev 有一套优化器或最小化器来解决无约束优化问题，包括单变量和多变量问题，有或没有导数信息。我们的实施和讨论基本上是基于&陆(2007)。

## 9.1 暴力搜索

最简单也可能是最容易理解的求解器是强力搜索。也就是说，我们简单地遍历函数定义域中所有可能的值， *x* ，枚举出 *f* ( *x* )所有可能的值。然后我们挑最小的 *f* ( *x* )对应的 *x* 。可能有不止一个解决方案。但是，这种方法很少使用，因为它不实用。一个要求是域必须是可枚举的。大多数实际的优化问题都是在一个连续的区域上解决的，比如实数。我们无法列举无限多的数字。解决这个问题的一个方法是离散化。我们从无限域中选择有限数量的点。比如我们可以把单位区间[0，1]离散成 11 个离散值，0，0.1，0.2，…，1.0。离散化最明显的缺点是，当选择的点不包含最优解时，我们可能(很可能)得到一个次优解。事实上，如果区域是无界的，(∞，+∞)，如何选择包含解的点并不明显。此外，对于除了小问题之外的任何问题，性能都非常慢。假设我们有 10 个变量需要求解；那么问题的维度就是*n*T14】10，其中 *n* 是每个维度选择的离散点数。问题的复杂性呈指数增长。尽管如此，强力搜索还是很容易理解的。因此，我们先从它开始。

下面的 NM Dev 代码大体上说明了我们如何使用这个库来解决一个优化问题。假设我们要最小化函数*f*(*x*)=*x*<sup>2</sup>—4。

```py
// define the optimization problem using an objective function
OptimProblem problem = new OptimProblem() {

    @Override
    public int dimension() {
        return 1;
    }

    @Override
    public RealScalarFunction f() {
        return new RealScalarFunction() {

            // the objective function
            @Override
            public Double evaluate(Vector v) {
                double x = v.get(1);
                Polynomial polynomial = new Polynomial(1, 0, -4); // f(x) = x^2 - 4
                double fx = polynomial.evaluate(x);
                return fx;
            }

            @Override
            public int dimensionOfDomain() {
                return 1;
            }

            @Override
            public int dimensionOfRange() {
                return 1;
            }
        };
    }
};

// set up the solver to use and the solution
DoubleBruteForceMinimizer solver = new DoubleBruteForceMinimizer(true);
BruteForceMinimizer.Solution soln = solver.solve(problem);

// for brute force search, we need to explicitly enumerate the values in the domain
List<Vector> domain = new ArrayList<>();
domain.add(new DenseVector(-2.));
domain.add(new DenseVector(-1.));
domain.add(new DenseVector(0.)); // the minimizer
domain.add(new DenseVector(1.));
domain.add(new DenseVector(2.));
soln.setDomain(domain);

System.out.println(String.format("f(%s) = %f", soln.minimizer(), soln.min()));

```

输出如下所示:

```py
f([0.000000] ) = -4.000000

```

使用 NM Dev 中的求解器解决优化问题有许多步骤。

1.  通过实现接口`OptimProblem`定义一个优化问题。我们在实现中给出了目标函数。

2.  构建一个求解器来使用，如`DoubleBruteForceMinimizer`。

3.  调用`solve`函数，使用优化问题从求解器构建一个`Solution`对象。换句话说，求解器对象是一个为优化问题`OptimProblem`创建解决方案`Solution`的工厂。虽然规划求解可重复用于其他问题，但一个解决方案仅对应于一个问题。

4.  向`Solution`对象提供任何与问题相关的信息。在这个强力搜索的例子中，我们需要给出一个可能的搜索值列表。

5.  调用`minimizer`函数运行算法计算最小值*x*<sup>∫</sup>，或者调用`min`函数返回函数*f*(*x*<sup>∫</sup>)的最小值。

前面的过程适用于 NM Dev 库中的所有解算器。所有 NM 解算器都做最小化。要实现最大化，我们只需将目标函数乘以-1 即可。一般来说，`OptimProblem`、解算器和`Solution`的签名如下:

```py
public interface OptimProblem {

    /**
     * Get the number of variables.
     *
     * @return the number of variables.
     */
    public int dimension();

    /**
     * Get the objective function.
     *
     * @return the objective function
     */
    public RealScalarFunction f();
}

public interface MultivariateMinimizer<P extends OptimProblem, S extends MinimizationSolution<Vector>> extends Minimizer<P, S> {

    /**
     * Solve an optimization problem, e.g., {@link OptimProblem}.
     *
     * @param problem an optimization problem
     * @return a solution to the optimization problem
     * @throws Exception when there is an error solving the problem
     */
    public S solve(P problem) throws Exception;
}

public interface MinimizationSolution<T> {

    /**
     * Get the (approximate) minimum found.
     *
     * @return the (approximate) minimum found
     */
    public double minimum();

    /**
     * Get the minimizer (solution) to the minimization problem.
     *
     * @return the minimizer
     */
    public T minimizer();
}

```

`DoubleBruteForceMinimizer`有以下签名:

```py
public DoubleBruteForceMinimizer(boolean isParallel);

@Override
public BruteForceMinimizer.Solution solve(OptimProblem problem) throws Exception

```

当`isParallel`标志被设置为`true`时，代码使用多线程代码并行运行搜索，以在所有可用线程上搜索所有提供的域值。

强力搜索可用于解决单变量优化问题，如在前面的例子中，以及多变量优化问题。以下是求解的示例:

*f* ( *x* 、*y*)=*x*<sup>2</sup>+*y*<sup>2</sup>

```py
OptimProblem problem = new OptimProblem() {

    @Override
    public int dimension() {
        return 2;
    }

    @Override
    public RealScalarFunction f() {
        return new RealScalarFunction() {

            @Override
            public Double evaluate(Vector v) {
                double x = v.get(1);
                double y = v.get(2);

                double fx = x * x + y * y;
                return fx;
            }

            @Override
            public int dimensionOfDomain() {
                return 2;
            }

            @Override
            public int dimensionOfRange() {
                return 1;
            }
        };
    }
};

DoubleBruteForceMinimizer bf = new DoubleBruteForceMinimizer(true);
BruteForceMinimizer.Solution soln = bf.solve(problem);
List<Vector> domain = new ArrayList<>();
domain.add(new DenseVector(-2., -2.));
domain.add(new DenseVector(-1., -1.));
domain.add(new DenseVector(0., 0.)); // the minimizer
domain.add(new DenseVector(1., 1.));
domain.add(new DenseVector(2., 2.));
soln.setDomain(domain);

System.out.println(String.format("f(%s) = %f", soln.minimizer(), soln.min()));

```

输出如下所示:

```py
f([0.000000, 0.000000] ) = 0.000000

```

如本例所示，除非我们神奇地知道解，在本例中为(0，0)，并将其放入域列表中，否则暴力搜索不会找到解。但是在这种情况下，如果我们知道答案，我们就不需要优化器了。

## 9.2 C <sup>2</sup> 最优压缩问题

`OptimProblem`类设置起来有些困难，并且在大多数情况下不方便使用。一个 C <sup>0</sup> 函数是一个连续函数。A C <sup>1</sup> 函数是一个平滑函数。C <sup>2</sup> 函数是连续的、光滑的、有二阶导数的函数。它也被称为二次可微函数。如果我们要优化这样一个函数，`C2OptimProblemImpl`提供了一个方便的包装器来创建一个`OptimProblem`对象。其签名如下:

```py
/**
 * Construct an optimization problem with an objective function.
 * This uses a numerical gradient and a numerical Hessian, if needed.
 *
 * @param f the objective function to be minimized
 */
public C2OptimProblemImpl(RealScalarFunction f)

```

我们可以用更简单的代码重写前面的例子。

对于一元函数*f*(*x*)=*x*T6】24，我们有这个:

```py
// set up the solver to use and the solution
DoubleBruteForceMinimizer solver = new DoubleBruteForceMinimizer(false);
BruteForceMinimizer.Solution soln
        = solver.solve(new C2OptimProblemImpl(new Polynomial(1, 0, -4))); // f(x) = x^2 - 4

// for brute force search, we need to explicitly enumerate the values in the domain
List<Vector> domain = new ArrayList<>();
domain.add(new DenseVector(-2.));
domain.add(new DenseVector(-1.));
domain.add(new DenseVector(0.)); // the minimizer
domain.add(new DenseVector(1.));
domain.add(new DenseVector(2.));
soln.setDomain(domain);

System.out.println(String.format("f(%s) = %f", soln.minimizer(), soln.min()));

```

输出如下所示:

```py
f([0.000000] ) = -4.000000

```

对于一个多元函数 *f* ( *x* ，*y*)=*x*<sup>2</sup>+*y*<sup>2</sup>，我们有这样的:

```py
DoubleBruteForceMinimizer bf = new DoubleBruteForceMinimizer(true);
BruteForceMinimizer.Solution soln = bf.solve(
        new C2OptimProblemImpl(
                new AbstractBivariateRealFunction() {
            @Override
            public double evaluate(double x, double y) {
                double fx = x * x + y * y;
                return fx;
            }
        }));

List<Vector> domain = new ArrayList<>();
domain.add(new DenseVector(-2., -2.));
domain.add(new DenseVector(-1., -1.));
domain.add(new DenseVector(0., 0.)); // the minimizer
domain.add(new DenseVector(1., 1.));
domain.add(new DenseVector(2., 2.));
soln.setDomain(domain);

System.out.println(String.format("f(%s) = %f", soln.minimizer(), soln.min()));

```

输出如下所示:

```py
f([0.000000, 0.000000] ) = 0.000000

```

## 9.3 分类方法

一元方法解决一元无约束优化问题。快速单变量方法在最优化中是至关重要的。一个多变量约束优化问题通常可以转化为一个等价的多变量无约束优化问题。求解多变量无约束优化问题通常涉及求解多个单变量无约束优化问题，例如线搜索。在后面的章节中讨论的许多多元无约束优化算法使用线搜索。

一种最简单的单变量算法是括号搜索法。假设我们有一个包含最小值的三点包围区间，*x*<sub>*L*</sub><*x*<sub>*a*</sub><*x*<sub>*U*</sub>，并假设[*x*<sub>*L*</sub>*x*<sub>*U*我们计算第四个点， *x* <sub>*b*</sub> ，根据一个区间划分表，形成两个重叠的子区间，*x*<sub>T39】L</sub>， *x* <sub>*a*</sub> 和*x*<sub>b</sub>，*x*选择包含新最小值的较小子区间。重复该过程以划分区间，直到收敛，即当所选择的子区间足够小时。该算法对于区间[*x*<sub>*L*</sub>，*x*<sub>*U*</sub>]内的单峰函数最为有效。单峰函数是从 *x* <sub>*L*</sub> 增加(或减少)到某一点，然后向 *x* <sub>*U*</sub> 减少(增加)的函数。它在区间中正好包含一个最小值(或最大值)。**</sub>

考虑在[ *x* <sub>*L*</sub> ， *x* <sub>*U*</sub> ]中有最小值的单峰函数。这个区间称为不确定度范围。用四个点，*f*(*x*<sub>*L*</sub>)，*f*(*x*<sub>*a*</sub>)，*f*(*x*<sub>*b*</sub>)，以及 *f* ( *x 【T39)一个二分法搜索说如果*f*(*x*<sub>*a*</sub>)<*f*(*x*<sub>*b*</sub>)，*x*<sup>∫</sup>位于 *x* <sub>*有两种可能:要么是蓝色曲线中的*x*<sub>*L*</sub><*x*<sup>∫</sup><*x*<sub>*b*</sub>要么是蓝色曲线中的*x*<sub>*a*</sub><*x*将它们组合起来就得到*x*<sub>*L*</sub><*x*<sup>∵</sup><*x*<sub>*b*</sub>。见图 [9-1](#Fig1) 。*</sub>*

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig1_HTML.png](img/500382_1_En_9_Chapter/500382_1_En_9_Fig1_HTML.png)

图 9-1

左侧音程中的***x***<sup>∫</sup>

同样，如果*f*(*x*<sub>T5】a</sub>)>*f*(*x*<sub>*b*</sub>)，我们就有*x*<sub>*a*</sub><*x*<sup>∵</sup><*x*

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig2_HTML.png](img/500382_1_En_9_Chapter/500382_1_En_9_Fig2_HTML.png)

图 9-2

***x***<sup>∫</sup>在正确的区间

如果*f*(*x*<sub>*【a】*</sub>=*【f】*(*x**见图 [9-3](#Fig3) 。*

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig3_HTML.png](img/500382_1_En_9_Chapter/500382_1_En_9_Fig3_HTML.png)

图 9-3

***x***<sub>***【a】***</sub><

 **一个简单的二分法搜索每次可以简单地将区间粗略地分成两部分。(子)间隔的大小呈指数下降(每次迭代减半)。在大约七次迭代之后，间隔大小减小到小于初始间隔的 1%。由于每次迭代需要两次计算，总共有 14 次函数求值，*f*(*x*<sub>T5】a</sub>)和*f*(*x*<sub>*b*</sub>)。NM Dev 实现了两个更复杂的时间间隔划分计划。

### 9.3.1 斐波那契搜索法

让我们从分析区间大小开始。为了简单起见，让我们假设左右子区间长度相同。参见图 [9-4](#Fig4) 。

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig4_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig4_HTML.jpg)

图 9-4

迭代 k，k+1，k+2 中的子间隔

我们有以下:

![$$ {I}_{k+1}={I}_{k+1}^L={I}_{k+1}^R $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equb.png)

![$$ {I}_k={I}_{k+1}^L+{I}_{k+2}^R={I}_{k+1}+{I}_{k+2} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equc.png)

对于 *n* 次迭代，我们有如下递归关系:

![$$ {I}_1={I}_2+{I}_3 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equd.png)

![$$ {I}_2={I}_3+{I}_4 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Eque.png)

![$$ \cdots $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equf.png)

![$$ {I}_n={I}_{n+1}+{I}_{n+2} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equg.png)

有 *n* 个方程，我们假设*I*T4】1 已知。有 *n* + 2 个变量。我们可以附加一个条件来产生一系列的间隔。

特别是，如果我们假设最后一次迭代中的区间为零，就会生成斐波那契数列。即 *I* <sub>*n* + 2</sub> = 0。

求解前面的方程组给出如下:

![$$ {I}_{n+1}={F}_0{I}_n $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equh.png)

![$$ {I}_n={F}_0{I}_n $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equi.png)

![$$ {I}_k={F}_{n-k+1}{I}_n $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equj.png)

![$$ {I}_1={F}_n{I}_n $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equk.png)

其中

![$$ {F}_k={F}_{k-1}+{F}_{k-2},k\ge 2 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equl.png)

*F*<sub>T3】kT5】是斐波那契数列的定义，{1，1，2，3，5，8，13，…}。</sub>

例如，如果 *n* = 11，*F*<sub>T5】n</sub>= 144。*I*<sub>*n*</sub>=*I*<sub>1</sub>/*F*<sub>*n*</sub>。 *I* <sub>*n*</sub> 降为 *I* <sub>1</sub> 的 0.69%。此外，通过选择左子区间或右子区间，我们已经有了两个端点和中间的一个点，{*x*<sub>*L*</sub>， *x* <sub>*a*</sub> ，*x*<sub>*b*</sub>}或{*x*<sub>*a*</sub>，*我们只需要多一个点，因此只需要计算一次函数。对于 11 次迭代，我们总共需要 14 次计算，而在简单的二分法搜索中需要 22 次。*

使用斐波那契数列的一个主要缺点是它需要预知 *n* 。如果我们想让*x*<sup>∫</sup>在预定的精度内，这是可以的。我们用*I*<sub>*n*</sub>=*I*<sub>1</sub>/*F*<sub>*n*</sub>确定 *n* 。但是，如果我们要使*f*(*x*<sup>∫</sup>)在一定精度内，我们不知道从什么 *n* 开始。

### 黄金分割搜索

与斐波纳契曲线不同，黄金分割搜索会进行迭代，直到达到函数精度。递归关系与斐波那契方法相同:*I*<sub>*k*</sub>=*I*<sub>*k*—1</sub>+*I*<sub>*k*—2</sub>。附加条件是保持两个相邻区间的比值不变。

![$$ \frac{I_k}{I_{k+1}}=K,\forall k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equm.png)

利用这两个方程，我们可以解出 *K* ，如下图:

![$$ {K}^2=K+1 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equn.png)

![$$ K=\frac{1+\sqrt{5}}{2}\approx 1.618034 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equo.png)

这个数字被称为黄金比例。音程顺序如下:

![$$ \left\{\ {I}_1,\frac{I_1}{K},\frac{I_1}{K^2},\dots \dots, \frac{I_1}{K^{n-1}}\right\} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equp.png)

举个例子:{100，61.8，38.2，23.6，14.6，9，…}。这可以在没有预定的 *n* 的情况下继续进行。

我们可以比较黄金分割搜索和斐波那契搜索的效率。*F*<sub>T3】nT5】和 *K* 的关系为![$ {F}_n\approx \frac{K^{n+1}}{\sqrt{5}} $](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq1.png)。斐波纳契搜索中的不确定区域如下:</sub>

![$$ {\Lambda}_F={I}_n=\frac{I_1}{F_n}\approx \frac{\sqrt{5}}{K^{n+1}}{I}_1 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equq.png)

对于黄金分割搜索，如下:

![$$ {\Lambda}_G={I}_n=\frac{I_1}{K^{n+1}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equr.png)

于是，我们有了下面的:

![$$ \frac{\Lambda_G}{\Lambda_F}=\frac{K^2}{\sqrt{5}}=1.17 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equs.png)

因此，黄金分割搜索需要更多的迭代才能达到与斐波那契搜索相同的精度。斐波那契搜索更有效，但是黄金分割搜索不需要先验知识。

### 布伦特的搜索

黄金分割搜索具有线性收敛速度。我们即将讨论的抛物搜索的收敛速度为 1.325；因此，效率更高。在每个包围区间，我们再次选择三个点:*x*<sub>*L*</sub><*x*<sub>*m*</sub><*x*<sub>*U*</sub>。我们用二次多项式(又名抛物线)来近似这个区间中的函数。

![$$ p(x)={a}_0+{a}_1x+{a}_2{x}^2 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equt.png)

有了这三点，我们就可以通过求解三个线性方程组来确定多项式系数。*p*(*x*)![$$ \overline{x} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq2.png)的最小值可以通过求解其一阶导数等于零来容易地确定。

![$$ \overline{x}=-\frac{a_1}{2{a}_2} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equu.png)

借助泰勒展开，![$$ \overline{x} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq3.png)将充分接近*x*<sup>√</sup>；事实上，如果函数是二次的，它将是精确的。通过检查![$$ \overline{x} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq4.png)，我们可以通过拒绝 *x* <sub>* L *</sub> 或 *x* <sub>* U *</sub> 并保留![$$ \overline{x} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq5.png)来选择新的间隔。重复该过程，直到所有三个点足够接近(到*x*T21】∫)。见图 [9-5](img/#Fig5) 。

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig5_HTML.png](img/500382_1_En_9_Chapter/500382_1_En_9_Fig5_HTML.png)

图 9-5

曲线段的抛物线近似

虽然抛物线搜索具有超线性收敛速度，但它并不总是收敛(甚至收敛到局部最小值)。例如，如果三个点共线，则生成的抛物线会退化，因此不会提供新的候选点。因此，这种方法很少单独使用。

布伦特的方法结合了抛物线搜索和黄金分割搜索。Brent 的方法使用抛物线搜索(例如，没有两个点是相同的)。当条件失败时，它切换到使用黄金分割搜索。换句话说，布伦特的方法结合了两个世界的优点:超线性收敛和找到最小值的保证。因此，在实践中，我们几乎总是使用 Brent 的搜索作为单变量优化的默认。参见图 [9-6](#Fig6) 。

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig6_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig6_HTML.jpg)

图 9-6

对数伽马函数

以下 NM Dev 代码使用斐波那契搜索、黄金分割搜索和布伦特搜索来求解 log-gamma 函数:

```py
LogGamma logGamma = new LogGamma(); // the log-gamma function

BracketSearchMinimizer solver1 = new FibonaccMinimizer(1e-8, 15);
UnivariateMinimizer.Solution soln1 = solver1.solve(logGamma);
double x_min_1 = soln1.search(0, 5);
System.out.println(String.format("f(%f) = %f", x_min_1, logGamma.evaluate(x_min_1)));

BracketSearchMinimizer solver2 = new GoldenMinimizer(1e-8, 15);
UnivariateMinimizer.Solution soln2 = solver2.solve(logGamma);
double x_min_2 = soln2.search(0, 5);
System.out.println(String.format("f(%f) = %f", x_min_2, logGamma.evaluate(x_min_2)));

BracketSearchMinimizer solver3 = new BrentMinimizer(1e-8, 10);
UnivariateMinimizer.Solution soln3 = solver3.solve(logGamma);
double x_min_3 = soln3.search(0, 5);
System.out.println(String.format("f(%f) = %f", x_min_3, logGamma.evaluate(x_min_3)));

```

输出如下所示:

```py
f(1.463682) = -0.121484
f(1.460813) = -0.121486
f(1.461632) = -0.121486

```

他们的签名如下:

```py
/**
 * Construct a univariate minimizer using the Fibonacci method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public FibonaccMinimizer(double epsilon, int maxIterations)

/**
 * Construct a univariate minimizer using the Golden method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public GoldenMinimizer(double epsilon, int maxIterations)

/**
 * Construct a univariate minimizer using Brent's algorithm.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public BrentMinimizer(double epsilon, int maxIterations)

/**
 * This is the solution to a univariate minimization problem.
 */
public static interface Solution extends MinimizationSolution<Double> {

    /**
     * Search for a minimum within the interval <i>[lower, upper]</i>.
     *
     * @param lower   the lower bound for the bracketing interval which
     *                contains a minimum
     * @param initial an initial guess
     * @param upper   the upper bound for the bracketing interval which
     *                contains a minimum
     * @return an approximate minimizer
     */
    public double search(double lower, double initial, double upper);

    /**
     * Search for a minimum within the interval <i>[lower, upper]</i>.
     *
     * @param lower the lower bound for the bracketing interval which
     *              contains a minimum
     * @param upper the upper bound for the bracketing interval which
     *              contains a minimum
     * @return an approximate minimizer
     */
    public double search(double lower, double upper);
}

```

我们称之为`search`方法，寻找一元函数最小化的极小值。

## 9.4 最速下降法

搜索最小化的一般思想通常从一个初始点开始，然后修改一些参数来寻找下一个(希望)给出更小函数值的点。如果我们没有信息，盲目的搜索是没有效率的。两条信息是有用的:梯度 ***g*** 和黑森 ***H*** 。

最速下降算法是一系列算法，使用梯度和 Hessian 信息在函数值减少最大的方向上进行搜索。我们首先讨论只使用梯度信息的一阶方法。考虑以下优化问题:

![$$ \min F=f(x)\kern0.75em for\ x\in {E}^n $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equv.png)

泰勒展开式给出了以下内容:

*f*+f*=*f*(**+ **as【**→【0.0】*【f】****【g】***<sup>*】*</sup>*******

 *****对于任意矢量 ***δ*** ，当 *θ* = 0 时，δ*F*最大，这意味着 ***δ*** 与 ***g*** 同向。当 *θ* = *π* 时，δ*F*最小，这意味着 ***δ*** 与 ***g*** 方向相反或者与—***g***方向相反。据说它们分别是最陡上升和最陡下降方向，如图 [9-7](#Fig7) 所示。

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig7_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig7_HTML.jpg)

图 9-7

最陡下降和最陡上升方向

最速下降算法的一般框架如下:

1.  指定一个初始点***x***<sub>**0**</sub>和公差 *ε* 。

2.  计算渐变***g***<sub>***k***</sub>并设置牛顿方向向量***d***<sub>***k***</sub>=***g***<sub>***k***</sub>。

3.  最小化*f*(***x***<sub>***k***</sub>+*α****d***<sub>***k***</sub>)相对于 *α* 计算增量 *α* <sub>*k*</sub> 。

4.  设置下一个点***x***<sub>T5】k+1</sub>=***x***<sub>*k*</sub>+*α*<sub>*k*</sub>***d***<sub>*k*</sub>并计算下一个函数值 *f*

5.  如果∩*α*<sub>*k*</sub>***d***<sub>*k*</sub>∩<*ε*，那么
    1.  完成了。***x***<sup>`∗`</sup>=**+1【t】**

    ***   否则，重复步骤 2。

         **

 **在步骤 3 中， *α* <sub>*k*</sub> 可以通过使用单变量优化算法的线搜索来计算。在我们的实现中，我们使用弗莱彻的不精确线搜索方法。许多优化算法被证明对线搜索的不精确性相当宽容。或者， *α* <sub>*k*</sub> 可以解析计算。

以下 NM Dev 代码使用一阶最速下降法最小化该函数:

![$$ f\left({x}_1,{x}_2,{x}_3,{x}_4\right)={\left({x}_1-4{x}_2\right)}^4+12{\left({x}_3-{x}_4\right)}^4+3{\left({x}_2-10{x}_3\right)}^2+55{\left({x}_1-2{x}_4\right)}^2 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equx.png)

```py
// the objective function
//  the global minimizer is at x = [0,0,0,0]
RealScalarFunction f = new RealScalarFunction() {

    @Override
    public Double evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        double result = pow(x1 - 4 * x2, 4);
        result += 12 * pow(x3 - x4, 4);
        result += 3 * pow(x2 - 10 * x3, 2);
        result += 55 * pow(x1 - 2 * x4, 2);

        return result;
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

// the gradient function
RealVectorFunction g = new RealVectorFunction() {

    @Override
    public Vector evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        double[] result = new double[4];
        result[0] = 4 * pow(x1 - 4 * x2, 3) + 110 * (x1 - 2 * x4);
        result[1] = -16 * pow(x1 - 4 * x2, 3) + 6 * (x2 - 10 * x3);
        result[2] = 48 * pow(x3 - x4, 3) - 60 * (x2 - 10 * x3);
        result[3] = -48 * pow(x3 - x4, 3) - 220 * (x1 - 2 * x4);
        return new DenseVector(result);
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 4;
    }
};

C2OptimProblem problem = new C2OptimProblemImpl(f, g); // only gradient information
SteepestDescentMinimizer firstOrderMinimizer
        = new FirstOrderMinimizer(
                FirstOrderMinimizer.Method.IN_EXACT_LINE_SEARCH, // FirstOrderMinimizer.Method.ANALYTIC
                1e-8,
                40000
        );
IterativeSolution<Vector> soln = firstOrderMinimizer.solve(problem);

Vector xmin = soln.search(new DenseVector(new double[]{1, -1, -1, 1}));
double f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %f", xmin.toString(), f_xmin));

```

输出如下所示:

```py
f([0.046380, 0.016330, 0.001634, 0.023189] ) = 0.000003

```

大约需要 40，000 次迭代，这太慢了。

```py
The signature of FirstOrderMinimizer is as follows.
/**
 * Construct a multivariate minimizer using the First-Order method.
 *
 * @param method        the method to do line search
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public FirstOrderMinimizer(Method method, double epsilon, int maxIterations)

```

`Method`指定我们是使用线搜索还是解析表达式来计算 *α* <sub>*k*</sub> 。

### 9.4.1 牛顿-拉夫森法

二阶方法除了梯度之外还使用(非奇异的)Hessian 来确定最速下降框架中的方向向量**<sub>*k*</sub>和增量 *α* <sub>*k*</sub> 以加速收敛。牛顿-拉夫森方法将泰勒级数展开到二阶。设 ***δ*** 为 ***x*** 的变化，我们有如下:**

**![$$ f\left(x+\delta \right)\approx f(x)+\sum \limits_{j=1}^n\frac{\partial f}{\partial {x}_i}{\delta}_i+\frac{1}{2}\sum \limits_{i=1}^n\sum \limits_{j=1}^n\frac{\partial^2f}{\partial {x}_i\partial {x}_j}{\delta}_i{\delta}_j $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equy.png)**

 **区分*f*(***x***+***δ***)相对于 *δ* <sub>*k*</sub> 为了最小化*f*(***x***+***δ**【T25)，我们有如下:*

*![$$ \frac{\partial f}{\partial {x}_k}+\sum \limits_{i=1}^n\frac{\partial^2f}{\partial {x}_i\partial {x}_j}{\delta}_i=0\kern0.75em for\ k=1,2,\dots, n $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equz.png)*

用矩阵形式改写如下:

![$$ g=-\boldsymbol{H}\delta $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equaa.png)

***x*** 中的最优变化如下:

![$$ \delta =-{\boldsymbol{H}}^{-\mathbf{1}}g $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equab.png)

使用线搜索来计算沿着方向的 *f* ( ***x*** )的最大减少量。下一点***x***<sub>***k+1***</sub>如下:

![$$ {x}_{k+1}={x}_k+{\delta}_k={x}_k+{\alpha}_k{d}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equac.png)

以下哪一项是正确的:

![$$ {d}_k=-{\boldsymbol{H}}_k^{-1}{g}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equad.png)

*α*<sub>T3】kT5】就是最小化 *f* 的*α*(*x*<sub>*k*</sub>+*α****d***<sub>*k*【T25)。</sub></sub>

与一阶方法相比，牛顿-拉夫森方法使用 Hessian 信息来加速收敛，特别是当它接近解时。以下 NM Dev 代码使用 Newton-Raphson 方法最小化相同的函数:

```py
// the objective function
// the global minimizer is at x = [0,0,0,0]
RealScalarFunction f = new RealScalarFunction() {

    @Override
    public Double evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        double result = pow(x1 - 4 * x2, 4);
        result += 12 * pow(x3 - x4, 4);
        result += 3 * pow(x2 - 10 * x3, 2);
        result += 55 * pow(x1 - 2 * x4, 2);

        return result;
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

// the gradient function
RealVectorFunction g = new RealVectorFunction() {

    @Override
    public Vector evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        double[] result = new double[4];
        result[0] = 4 * pow(x1 - 4 * x2, 3) + 110 * (x1 - 2 * x4);
        result[1] = -16 * pow(x1 - 4 * x2, 3) + 6 * (x2 - 10 * x3);
        result[2] = 48 * pow(x3 - x4, 3) - 60 * (x2 - 10 * x3);
        result[3] = -48 * pow(x3 - x4, 3) - 220 * (x1 - 2 * x4);
        return new DenseVector(result);
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 4;
    }
};

C2OptimProblem problem = new C2OptimProblemImpl(f, g); // use numerical Hessian
SteepestDescentMinimizer newtonRaphsonMinimizer
        = new NewtonRaphsonMinimizer(
                1e-8,
                20
        );
IterativeSolution<Vector> soln = newtonRaphsonMinimizer.solve(problem);

Vector xmin = soln.search(new DenseVector(new double[]{1, -1, -1, 1}));
double f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %f", xmin.toString(), f_xmin));

```

输出如下所示:

```py
f([0.000134, -0.000009, -0.000001, 0.000067] ) = 0.000000

```

值得指出的是，牛顿-拉夫逊方法的收敛速度比一阶方法快得多。与 40，000 次迭代相比，它仅使用 20 次迭代就获得了更高的精度。

`NewtonRaphsonMinimizer`的签名如下:

```py
/**
 * Construct a multivariate minimizer using the Newton-Raphson method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public NewtonRaphsonMinimizer(double epsilon, int maxIterations)

```

### 高斯-牛顿法

高斯-牛顿法以如下形式最小化目标函数:

![$$ \boldsymbol{f}={\left[{f}_1(x)\kern0.5em {f}_2(x)\dots \dots \kern0.5em {f}_m(x)\right]}^T $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equae.png)

解决方法是一个点***×点**×点*使得所有的*f*<sub>*p*</sub>(***×点*** )同时归零。

我们可以构造一个实值函数 *F* ，使得如果 *F* 被最小化，那么函数*F*<sub>*p*</sub>(***x***)在最小二乘意义上也被最小化。

![$$ F=\sum \limits_{p=1}^m{f}_p{(x)}^2=\boldsymbol{f}{\boldsymbol{f}}^{\boldsymbol{T}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equaf.png)

梯度的雅可比矩阵如下:

![$$ \mathbf{J}=\left[\begin{array}{ccc}\frac{\partial {f}_1}{\partial {x}_1}&amp; \cdots &amp; \frac{\partial {f}_m}{\partial {x}_1}\\ {}\vdots &amp; \ddots &amp; \vdots \\ {}\frac{\partial {f}_1}{\partial {x}_n}&amp; \cdots &amp; \frac{\partial {f}_m}{\partial {x}_n}\end{array}\right] $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equag.png)

区分 *F* 关于*x*<sub>T5】I</sub>，我们有如下:

![$$ \frac{\partial F}{\partial {x}_i}=\sum \limits_{p=1}^m2{f}_p(x)\frac{\partial {f}_p}{\partial {x}_i} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equah.png)

或者，在矩阵形式中，我们有这样的:

![$$ {g}_F=2{\mathbf{J}}^{\boldsymbol{T}}f $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equai.png)

再区分一下，我们有以下:

![$$ \frac{\partial^2F}{\partial {x}_i\partial {x}_j}\approx 2\sum \limits_{p=1}^m\frac{\partial {f}_p}{\partial {x}_i}\frac{\partial {f}_p}{\partial {x}_j} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equaj.png)

黑森**H**<sub>T3】FT5 如下。它必须是非奇异和正定的。</sub>

![$$ {\mathbf{H}}_F\approx 2{\mathbf{J}}^{\boldsymbol{T}}\mathbf{J} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equak.png)

下一个点是由递归关系给出的:

![$$ {x}_{k+1}={x}_k-{\alpha}_k{\left(2{\mathbf{J}}^{\boldsymbol{T}}\mathbf{J}\right)}^{-1}\left(2{\mathbf{J}}^{\boldsymbol{T}}\mathbf{f}\right) $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equal.png)

以下代码使用高斯-牛顿方法解决了相同的最小化问题:

```py
// the objective function
// the global minimizer is at x = [0,0,0,0]
RealVectorFunction f = new RealVectorFunction() {

    @Override
    public Vector evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        double[] fx = new double[4];
        fx[0] = pow(x1 - 4 * x2, 2);
        fx[1] = sqrt(12) * pow(x3 - x4, 2);
        fx[2] = sqrt(3) * (x2 - 10 * x3);
        fx[3] = sqrt(55) * (x1 - 2 * x4);

        return new DenseVector(fx);
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 4;
    }
};

// the Jacobian
RntoMatrix J = new RntoMatrix() {

    @Override
    public Matrix evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);
        double x3 = x.get(3);
        double x4 = x.get(4);

        Matrix Jx = new DenseMatrix(4, 4);

        double value = 2 * (x1 - 4 * x2);
        Jx.set(1, 1, value);

        value = -8 * (x1 - 4 * x2);
        Jx.set(1, 2, value);

        value = 2 * sqrt(12) * (x3 - x4);
        Jx.set(2, 3, value);
        Jx.set(2, 4, -value);

        Jx.set(3, 2, sqrt(3));
        Jx.set(3, 3, -10 * sqrt(3));

        Jx.set(4, 1, sqrt(55));
        Jx.set(4, 4, -2 * sqrt(55));

        return Jx;
    }

    @Override
    public int dimensionOfDomain() {
        return 4;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

GaussNewtonMinimizer optim1 = new GaussNewtonMinimizer(1e-8, 10);

IterativeSolution<Vector> soln = optim1.solve(f, J);//analytical gradient

Vector xmin = soln.search(new DenseVector(new double[]{1, -1, -1, 1}));
System.out.println(String.format("f(%s) = %s", xmin.toString(), f.evaluate(xmin).toString()));

```

输出如下所示:

```py
f([0.000007, -0.000000, -0.000000, 0.000003] ) = [0.000000, 0.000000, -0.000000, -0.000000]

```

高斯-牛顿法比牛顿-拉夫逊法更有效。前一个问题大约需要 10 次迭代，而前一个问题需要 20 次。

`GaussNewtonMinimizer`的签名如下:

```py
/**
 * Construct a multivariate minimizer using the Gauss-Newton method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public GaussNewtonMinimizer(double epsilon, int maxIterations)

```

## 9.5 共轭方向法

最速下降法中的连续搜索方向可能彼此相关，也可能不相关。而且，它们完全由目标函数的局部性质决定，即梯度和 Hessian (Hestenes & Stiefel，1952)。另一方面，在共轭方向法中，连续搜索方向之间有严格的数学关系。共轭方法被开发用于解决具有以下目标函数的二次优化问题:

![$$ \min {\boldsymbol{x}}^{\boldsymbol{T}}\mathbf{b}+\frac{1}{2}{\mathbf{x}}^{\boldsymbol{T}}\boldsymbol{H}\mathbf{X} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equam.png)

其中 ***H*** 为一个 *n* 变量函数的一个*n*∫*n*对称正定矩阵。

对于二次问题，搜索将在有限次迭代中收敛到最小值。共轭方法已经被扩展到解决更一般的最优化问题。

### 9.5.1 共轭方向

对于一个对称矩阵 ***H*** ，向量的有限集{***d***<sub>**0**</sub>，***d***<sub>**1**</sub>，**，***d***<sub>***k**如果 ***H*** 是正定的，那么向量是线性无关的。如果 ***H = I*** ，则矢量正交。*</sub>**

 **对于之前所示的二次最小化问题，当 ***H*** 为正定时，简单的微积分表明解是唯一的，并且可以通过解线性方程组来解析计算。

![$$ \boldsymbol{H}{\mathbf{x}}^{\ast}=\mathbf{b} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equan.png)

因为共轭向量组是线性独立的，因此跨越了 *n* 维空间*E*<sup>T5】n</sup>，***x***<sup>***∑***</sup>可以写成这些向量的线性组合。

![$$ {\boldsymbol{x}}^{\ast }={\alpha}_0{\boldsymbol{d}}_{\mathbf{0}}+\dots +{\alpha}_{n-1}{\boldsymbol{d}}_{\boldsymbol{n}-\mathbf{1}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equao.png)

两边乘以 ***H*** 并取与**<sub>**I**</sub>的标量积得出:**

**![$$ {\alpha}_i=-\frac{{\boldsymbol{d}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{H}{\boldsymbol{x}}^{\ast }}{{\boldsymbol{d}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{H}{\boldsymbol{d}}_{\boldsymbol{i}}}=-\frac{{\boldsymbol{d}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{b}}{{\boldsymbol{d}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{H}{\boldsymbol{d}}_{\boldsymbol{i}}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equap.png)**

 **或者等价地，

![$$ {\boldsymbol{x}}^{\ast }=\sum \limits_{\boldsymbol{i}=\mathbf{0}}^{\boldsymbol{n}-\mathbf{1}}\frac{{\boldsymbol{d}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{b}}{{\boldsymbol{d}}_{\boldsymbol{i}}^{\boldsymbol{T}}\boldsymbol{H}{\boldsymbol{d}}_{\boldsymbol{i}}}{\boldsymbol{d}}_{\boldsymbol{i}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equaq.png)

这种***x***<sup>***∫***</sup>的展开，可以认为是一个求和或者一个*n*-相加*α*<sub>*I*</sub>***d***<sub>***I***</sub>的分步迭代过程。

**共轭方向定理**

设![$$ {\left\{{\boldsymbol{d}}_{\boldsymbol{i}}\right\}}_{i=0}^{n-1} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq7.png)为一组非零的***H***T5】-正交向量。对于任意一个***x***<sub>0</sub>∈*E*<sup>*n*</sup>，序列{***×x***<sub>*I*</sub>}按照以下方式生成:

![$$ {\boldsymbol{x}}_{\boldsymbol{k}+\mathbf{1}}={\boldsymbol{x}}_{\boldsymbol{k}}+{\alpha}_k{\boldsymbol{d}}_{\boldsymbol{k}},k\ge 0 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equar.png)

同下面:

![$$ {\alpha}_k=-\frac{{\boldsymbol{g}}_{\boldsymbol{k}}^{\boldsymbol{T}}{\boldsymbol{d}}_{\boldsymbol{k}}}{{\boldsymbol{d}}_{\boldsymbol{k}}^{\boldsymbol{T}}\boldsymbol{H}{\boldsymbol{d}}_{\boldsymbol{k}}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equas.png)

还有下面的:

![$$ {\boldsymbol{g}}_{\boldsymbol{k}}=\boldsymbol{b}+\boldsymbol{H}{\boldsymbol{x}}_{\boldsymbol{k}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equat.png)

收敛到唯一解**x**<sup>T3】∫T5**HX = b**经过 *n* 步，即**x**<sub>**n**</sub>**= x**<sup>**∫**</sup>。</sup>

利用这个定理和许多产生共轭向量的方法，可以设计出许多共轭方向法。我们还需要扩展这个定理来解决非二次问题。共轭方向方法非常适合最速下降框架。它们的区别仅在于如何计算方向向量***【d】***<sub>*k*</sub>以及随后的星等 *α* <sub>*k*</sub> 。这里我们用共轭方向代替最陡下降方向。迭代添加一个增量*α*<sub>*k*</sub>***d***<sub>*k*</sub>到一个***x***<sub>*k*</sub>生成***x***<sub>*k*+1</sub>的思路也是一样的。

### 共轭梯度法

Hestenes & Stiefel (1952)提出了共轭梯度法。在这种方法中，新方向是上一个方向和负梯度的加权和。

![$$ {\boldsymbol{d}}_{\mathbf{0}}=-{\boldsymbol{g}}_{\mathbf{0}}=-\left(\boldsymbol{b}+\boldsymbol{H}{\boldsymbol{x}}_{\mathbf{0}}\right) $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equau.png)

![$$ {\boldsymbol{d}}_{\boldsymbol{k}}=-{\boldsymbol{g}}_{\boldsymbol{k}}+{\beta}_k{\boldsymbol{d}}_{\boldsymbol{k}-\mathbf{1}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equav.png)

![$$ {\boldsymbol{g}}_{\boldsymbol{k}}=\boldsymbol{b}+\boldsymbol{H}{\boldsymbol{x}}_{\boldsymbol{k}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equaw.png)

![$$ {\beta}_k=\frac{{\boldsymbol{g}}_k^TH{d}_k}{{\boldsymbol{d}}_k^TH{d}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equax.png)

![$$ {\alpha}_k=-\frac{{\boldsymbol{g}}_k^T{d}_k}{{\boldsymbol{d}}_k^TH{d}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equay.png)

这种方法的优点如下:

*   梯度是有限的，并且与所有先前的方向向量线性无关，除非找到解。

*   计算新的方向向量相对容易。

*   没有线搜索。

*   对于二次问题，它在 *n* 步中收敛。

*   第一个方向与最速下降中的方向相同，***d***<sub>**0**</sub>***= g***<sub>**0**</sub>，它给出了第一个良好的缩减。

*   没有黑森的反转。

以下是缺点:

*   粗麻布必须得到供应、储存和处理。

*   对于非二次问题，不能保证收敛。事实上，如果初始点离一个解很远，搜索可能会徘徊在某个次优区域，因为不可靠的方向会随着迭代而增加。正如我们将在后面的代码示例中看到的，共轭梯度法对于 Himmelblau 函数来说需要最多的迭代次数来收敛。

### 弗莱彻-里维斯法

弗莱彻-里维斯方法是共轭梯度法的一种变体。主要区别在于， *α* <sub>*k*</sub> 是通过最小化*f*(***X***+*α*<sub>*k*</sub>***d***<sub>***k***</sub>)使用线搜索来计算的 而那个***d***<sub>***k***</sub>是共轭方向相对于{***d***<sub>**0**</sub>，***d***<sub>**1**</sub>，**， *因此，该算法类似于共轭梯度法，但是由于线搜索而需要更多的计算，这是一个缺点。然而，有两个优点。***

 ***   该修改对于非二次函数的最小化工作得更好，因为在解的邻域之外的点处，可以在沿着**<sub>*k*</sub>的 *f* ( ***x*** )中实现更大的缩减。**

***   这个算法不需要 Hessian。** 

 **### 鲍威尔法

Powell 算法使用线搜索生成一系列共轭方向。

设![$$ {x}_a^{\ast } $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq8.png)和![$$ {x}_b^{\ast } $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq9.png)为若下列凸二次函数得到的极小值:

![$$ f(x)={x}^Tb+\frac{1}{2}{x}^T\boldsymbol{H}x $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equaz.png)

相对于行 ***上的*α*d***<sub>***a***</sub>和***d***<sub>***b***</sub>:

![$$ x={x}_a+\alpha {\boldsymbol{d}}_{\boldsymbol{a}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equba.png)

还有下面的:

![$$ x={x}_b+\alpha {\boldsymbol{d}}_{\boldsymbol{b}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbb.png)

如果说***d***<sub>***a***</sub>**=*****d***<sub>***b***</sub>，那么矢量![$$ {x}_b^{\ast }-{x}_a^{\ast } $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq10.png)相对于***d***<sub>***a***</sub>。参见图 [9-8](img/#Fig8) 。

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig8_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig8_HTML.jpg)

图 9-8

共轭方向的生成

在这个算法中，一个初始点为 *x* <sub>00</sub> 和 *n* 线性独立的方向{***d***<sub>**0**</sub>，***d***<sub>**1**</sub>，**， ***d*** 在第一次迭代中，*f*(***x***)在方向{***d***<sub>**0**</sub>，***d***<sub>**1*****⋯***， ***d***<sub>***n***</sub>}从点***x***<sub>00***x**<sub>01</sub>， ***x*** <sub>然后一个新的方向***d***<sub>0(*n*+1)</sub>生成如下:</sub>*</sub></sub>**

***![$$ {\boldsymbol{d}}_{0\left(n+1\right)}={x}_{0n}-{x}_{00} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbc.png)***

 **并且 *f* ( ***x*** )在这个方向上被最小化以产生新的点***x***<sub>0(*n*+1)</sub>。通过设置以下内容更新方向(参见图[9-9](#Fig9)):

![$$ {\boldsymbol{d}}_{11}={\boldsymbol{d}}_{02} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbd.png)

![$$ {\boldsymbol{d}}_{12}={\boldsymbol{d}}_{03} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Eqube.png)

![$$ \cdots $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbf.png)

![$$ {\boldsymbol{d}}_{1\left(n-1\right)}={\boldsymbol{d}}_{0n} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbg.png)

![$$ {\boldsymbol{d}}_{1n}={\boldsymbol{d}}_{0\left(n+1\right)} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbh.png)

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig9_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig9_HTML.jpg)

图 9-9

鲍威尔算法的第一次迭代

同样的过程在从点***x***<sub>10</sub>=***x***<sub>0(*n*+1)</sub>开始的第二次迭代中重复。*f*(***x***)按方向依次最小化{***d***<sub>**11**</sub>，***d***<sub>**12**</sub>，***【⋯***， ***d*** 然后生成一个新的方向***d***<sub>1(*n*+1)</sub>(见图 [9-10](#Fig10) ):

![$$ {\boldsymbol{d}}_{1\left(n+1\right)}={x}_{1n}-{x}_{10} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbi.png)

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig10_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig10_HTML.jpg)

图 9-10

鲍威尔算法的第二次迭代

以同样的方式进行，每个新的迭代将增加一个共轭方向并去除另一个方向，因此是一个替换。由于每次迭代需要( *n* + 1)次线搜索，鲍威尔方法在 *n* 次迭代中执行 *n* ( *n* + 1)次线搜索。

鲍威尔方法的优点是它不供应、储存或操纵麻袋。它甚至不需要梯度。但是，它可能不会生成一组跨越 *E* <sup>*n*</sup> 的线性独立方向，算法可能不会收敛到一个解。

### 赞威尔法

赞威尔算法是鲍威尔算法的改进版本。它的修改产生了一组总是线性独立的共轭方向。因此，它消除了鲍威尔算法中的缺点。

修改如下:首先，选择坐标方向组，使得行列式为 1。第二，新方向被归一化为单位长度。第三，方向子站必须保持方向向量矩阵的行列式为正且仍小于或等于 1。最后一项确保方向向量总是线性独立的。

以下代码最小化 Himmelblau 函数(见图 [9-11](#Fig11) ):

![$$ f\left({x}_1,{x}_2\right)={\left({x_1}^2+{x}_2-11\right)}^2+{\left({x}_1+{x_2}^2-7\right)}^2 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbj.png)

![img/500382_1_En_9_Chapter/500382_1_En_9_Fig11_HTML.jpg](img/500382_1_En_9_Chapter/500382_1_En_9_Fig11_HTML.jpg)

图 9-11

具有四个最小值的 Himmelblau 函数

```py
/**
 * The Himmelblau function:
 * f(x) = (x1^2 + x2 - 11)^2 + (x1 + x2^2 - 7)^2
 */
RealScalarFunction f = new RealScalarFunction() {
    @Override
    public Double evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);

        double result = pow(x1 * x1 + x2 - 11, 2);
        result += pow(x1 + x2 * x2 - 7, 2);

        return result;
    }

    @Override
    public int dimensionOfDomain() {
        return 2;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

RealVectorFunction g = new RealVectorFunction() {
    @Override
    public Vector evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);

        double w1 = x1 * x1 + x2 - 11;
        double w2 = x1 + x2 * x2 - 7;

        double[] result = new double[2];
        result[0] = 4 * w1 * x1 + 2 * w2;
        result[1] = 2 * w1 + 4 * w2 * x2;
        return new DenseVector(result);
    }

    @Override
    public int dimensionOfDomain() {
        return 2;
    }

    @Override
    public int dimensionOfRange() {
        return 2;
    }
};

RntoMatrix H = new RntoMatrix() {
    @Override
    public Matrix evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);

        Matrix result = new DenseMatrix(2, 2);
        result.set(1, 1, 12 * x1 * x1 + 4 * x2 - 42);
        result.set(1, 2, 4 * (x1 + x2));
        result.set(2, 1, result.get(1, 2));
        result.set(2, 2, 4 * x1 + 12 * x2 * x2 - 26);

        return result;
    }

    @Override
    public int dimensionOfDomain() {
        return 2;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};
C2OptimProblemImpl problem = new C2OptimProblemImpl(f, g, H);

ConjugateGradientMinimizer ConjugateGradientMinimizer
        = new ConjugateGradientMinimizer(1e-16, 40);
IterativeSolution<Vector> soln1 = ConjugateGradientMinimizer.solve(problem);
Vector xmin1 = soln1.search(new DenseVector(new double[]{6, 6}));
double f_xmin1 = f.evaluate(xmin1);
System.out.println(String.format("f(%s) = %.16f", xmin1.toString(), f_xmin1));

ConjugateGradientMinimizer fletcherReevesMinimizer
        = new FletcherReevesMinimizer(1e-16, 20);
IterativeSolution<Vector> soln2 = fletcherReevesMinimizer.solve(problem);
Vector xmin2 = soln2.search(new DenseVector(new double[]{6, 6}));
double f_xmin2 = f.evaluate(xmin2);
System.out.println(String.format("f(%s) = %.16f", xmin2.toString(), f_xmin2));

SteepestDescentMinimizer powellMinimizer
        = new PowellMinimizer(1e-16, 20);
IterativeSolution<Vector> soln3 = powellMinimizer.solve(problem);
Vector xmin3 = soln3.search(new DenseVector(new double[]{6, 6}));
double f_xmin3 = f.evaluate(xmin3);
System.out.println(String.format("f(%s) = %.16f", xmin3.toString(), f_xmin3));

SteepestDescentMinimizer zangwillMinimizer
        = new ZangwillMinimizer(1e-16, 1e-16, 20);
IterativeSolution<Vector> soln4 = zangwillMinimizer.solve(problem);
Vector xmin4 = soln4.search(new DenseVector(new double[]{6, 6}));
double f_xmin4 = f.evaluate(xmin4);
System.out.println(String.format("f(%s) = %.16f", xmin4.toString(), f_xmin4));

```

输出如下所示:

```py
f([3.000000, 2.000000] ) = 0.0000000000013999
f([3.000002, 1.999998] ) = 0.0000000001278725
f([-2.805114, 3.131310] ) = 0.0000000007791914
f([-2.805117, 3.131311] ) = 0.0000000001359077

```

找到的两个最小值是(3，2)和(2.805118，3.131312)。

这些最小化者的签名如下:

```py
/**
 * Construct a multivariate minimizer using the Conjugate-Gradient method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public ConjugateGradientMinimizer(double epsilon, int maxIterations)

/**
 * Construct a multivariate minimizer using the Fletcher-Reeves method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public FletcherReevesMinimizer(double epsilon, int maxIterations)

/**
 * Construct a multivariate minimizer using the Powell method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is
 *                      considered 0
 * @param maxIterations the maximum number of iterations
 */
public PowellMinimizer(double epsilon, int maxIterations)

/**
 * Construct a multivariate minimizer using the Zangwill method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param epsilon2      a precision parameter to decide whether there is a
 *                      linear dependence among the conjugate directions
 * @param maxIterations the maximum number of iterations
 */
public ZangwillMinimizer(double epsilon, double epsilon2, int maxIterations)

```

## 9.6 拟牛顿法

拟牛顿法是另一种不需要 Hessian 显式表达式的算法框架。它建立在第 9.4.1 节中的牛顿法的基础上，除了搜索方向是基于一个*n*∫*n*矩阵 **S** 之外，它的作用与牛顿法中的逆 Hessian 矩阵相同。也就是

![$$ {x}_{k+1}={x}_k-{\alpha}_k{\boldsymbol{S}}_{\boldsymbol{k}}{g}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbk.png)

当***S***<sub>***k***</sub>=***I***时，是最速下降算法。当***S***<sub>***k***</sub>=**H**<sup>—1</sup>时，就是牛顿法。当 Hessian 不可用时， **S** 从可用数据中得出，是**H**T32】1 的近似值。其实可以看出，前面的算法更新***x***<sub>*k*+1</sub>在***S***<sub>***k***</sub>=**H**<sup>—1</sup>时收敛最快。拟牛顿法结合了最速下降法和共轭方向法的优点以及有效的方向更新规则。在本章讨论的所有方法中，它们是最有效的，并在许多应用中广泛使用。

假设逐次***x***<sub>*k*</sub>的差异如下:

![$$ {\delta}_k={x}_{k+1}-{x}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbl.png)

逐次梯度的区别 *g* <sub>*k*</sub> 如下:

![$$ {\gamma}_k={g}_{k+1}-{g}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbm.png)

于是我们有了这个:

![$$ {\gamma}_k=\boldsymbol{H}{\delta}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbn.png)

牛顿法确定方向向量如下:

![$$ {d}_k=-{\boldsymbol{S}}_{\boldsymbol{k}}{g}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbo.png)

幅度 *α* <sub>*k*</sub> 可以通过最小化函数

![$$ f\left({x}_k+\alpha {d}_k\right) $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbp.png)

的线搜索来确定

我们要避免对一个矩阵求逆，比如计算***S***<sub>***k***</sub>**= H**<sup>—1</sup>并检查***S***<sub>***k***</sub>在每次迭代中都是正定的。我们要一个简单的更新规则为***S***<sub>***k+*****1**</sub>。

![$$ {\boldsymbol{S}}_{\boldsymbol{k}+\mathbf{1}}={\boldsymbol{S}}_{\boldsymbol{k}}+{\boldsymbol{C}}_{\boldsymbol{k}} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbq.png)T38】

**C**<sub>***k***</sub>是一个*n*∑*n*校正矩阵，可以从现有数据中计算出来。在 ***的任何定义中，C***<sub>***k***</sub>，***S***<sub>***k+*****【1**</sub>必须满足这三个性质:

*   **s**<sub>***【k+***</sub>

*   向量{ ***δ*** <sub>0</sub> ， ***δ*** <sub>1</sub> ，***δ****n*—1}必须是共轭方向。

*   一个正定的***S***<sub>***k***</sub>必然产生一个正定的***S***<sub>***k+*****1**</sub>。

第二个性质保证了共轭方向搜索的优良性质也适用于准牛顿搜索。第三个属性确保方向向量在每次迭代中都有效。定义***【C】***<sub>***k***</sub>的方法有很多种，它们产生了拟牛顿法的不同变体。在本章中，我们根据它们如何计算***C***<sub>***k***</sub>或者它们如何更新***S***<sub>***k***</sub>来介绍几种变体。

### 等级一方法

秩一法的特点是校正矩阵**C**<sub>***k***</sub>具有一个秩。

假设如下:

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}{\gamma}_k={\delta}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbr.png)

让

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\beta {\xi}_k{\xi}_k^T $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbs.png)

***ξ***<sub>***k***</sub>为列向量， *β* <sub>*k*</sub> 为常数。校正矩阵![$$ \beta {\xi}_k{\xi}_k^T $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq11.png)是对称的，并且秩为 1。结合这两个等式，我们得到如下:

![$$ {\delta}_k={\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k+\beta {\xi}_k{\xi}_k^T{\gamma}_k $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbt.png)

而我们有以下:

![$$ {\gamma}_k^T\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right)={\beta}_k{\gamma}_k^T{\xi}_k{\xi}_k^T{\gamma}_k={\beta}_k{\left({\xi}_k^T{\gamma}_k\right)}^2 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbu.png)

![$$ \left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right){\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right)}^T={\beta}_k{\left({\xi}_k^T{\gamma}_k\right)}^2{\beta}_k{\xi}_k{\xi}_k^T $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbv.png)

于是我们有了以下:

![$$ {\beta}_k{\xi}_k{\xi}_k^T=\frac{\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right){\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right)}^T}{\gamma_k^T\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right)} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbw.png)

因此，我们有以下:

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\frac{\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right){\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right)}^T}{\gamma_k^T\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right)} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbx.png)

这种方法有两个严重的问题。一、一个正定**S**<sub>***k***</sub>未必给一个正定**S**<sub>***k+*****1**</sub>。如果出现这种情况，下一个方向就不是好的方向。第二，修正公式中的分母可能趋近于零或等于零。如果发生这种情况，该方法就会失败，因为**S**<sub>***k+*****1**</sub>未定义。

### 9.6.2 达维顿-弗莱彻-鲍威尔法

大卫顿-弗莱彻-鲍威尔(DPF)方法类似于秩一方法，但它有一个重要的优点:如果初始矩阵 **S** <sub>**0**</sub> 是正定的，则后续矩阵总是正定的。与秩一方法不同，每个新方向都是下降方向。

DPF 更新公式如下:

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\frac{\delta_k{\delta}_k^T}{\delta_k^T{\gamma}_k}-\frac{{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k{\gamma}_k^T{\mathbf{S}}_{\boldsymbol{k}}}{\gamma_k^T{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equby.png)

校正是一个秩为二的*n*∫*n*对称矩阵。

### 9.6.3 布罗伊登-弗莱彻-戈德法布-尚诺方法

BFGS 更新公式如下:

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\left(1+\frac{\gamma_k^T{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k}{\gamma_k^T{\delta}_k}\right)\frac{\delta_k{\delta}_k^T}{\gamma_k^T{\delta}_k}-\frac{\delta_k{\gamma}_k^T{\mathbf{S}}_{\boldsymbol{k}}+{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k{\delta}_k^T}{\gamma_k^T{\delta}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equbz.png)

BFGS 方法具有以下特性:

1.  **S**<sub>***k+*****1**</sub>变得与**H**<sup>**—1**—1*k****=****n*—1。</sup>

2.  方向{***δ***<sub>T5】I</sub>}<sub>*I*= 1，2，…，*n*—1</sub>形成共轭集。

3.  **S**<sub>***k+*****1**</sub>为正定如果**S**<sub>***k***</sub>为正定。

4.  ![$$ {\delta}_k^T{\gamma}_k={\delta}_k^T{g}_{k+1}-{\delta}_k^T{g}_k&gt;0 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq12.png)。

BFGS 求解器是所有求解器中最好的。在许多 NM 无约束优化应用中默认使用它。

### 9.6.4 黄家族(排名第一，DFP，，Pearson，McCormick)

黄更新公式是包含秩一、DFP、、Pearson 和 McCormick 方法的一般公式。它有这样的形式:

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\frac{\delta_k{\left(\theta {\delta}_k+\phi {\mathbf{S}}_k^T{\gamma}_k\right)}^T}{{\left(\theta {\delta}_k+\phi {\mathbf{S}}_k^T{\gamma}_k\right)}^T{\gamma}_k}-\frac{{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k{\left(\varphi {\delta}_k+\omega {\mathbf{S}}_k^T{\gamma}_k\right)}^T}{{\left(\varphi {\delta}_k+\omega {\mathbf{S}}_k^T{\gamma}_k\right)}^T{\gamma}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equca.png)

*θ* 、 *ϕ* 、 *φ* 、 *ω* 为独立参数。

通过让 *θ* = 1，*ϕ*= 1， *ψ* = 1，*ω*= 1，我们就有了秩一公式。

让 *θ* = 1， *ϕ* = 0， *ψ* = 0， *ω* = 1，我们就有了 DFP 公式。

通过让![$$ \frac{\phi }{\theta }=\frac{-{\gamma}_k{\delta}_k^T}{\gamma_k{\delta}_k^T+{\gamma}_k^T{S}_k{\gamma}_k},\psi =1,\mathrm{and}\ \omega =0 $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_IEq13.png)我们有了 BFGS 公式。

设 *θ* = 1， *ϕ* = 0， *ψ* = 1， *ω* = 0，我们就有了麦考密克公式。

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\frac{\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right){\delta}_k^T}{\delta_k^T{\gamma}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equcb.png)

设 *θ* = 0， *ϕ* = 1， *ψ* = 0， *ω* = 1，我们就有了皮尔逊公式。

![$$ {\mathbf{S}}_{\boldsymbol{k}+\mathbf{1}}={\mathbf{S}}_{\boldsymbol{k}}+\frac{\left({\delta}_k-{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k\right){\gamma}_k^T{\mathbf{S}}_{\boldsymbol{k}}}{\gamma_k^T{\mathbf{S}}_{\boldsymbol{k}}{\gamma}_k} $$](img/500382_1_En_9_Chapter/500382_1_En_9_Chapter_TeX_Equcc.png)

NM Dev 有一套准牛顿方法。以下代码使用不同的拟牛顿法求解图 [9-11](#Fig11) 中的 Himmelblau 函数:

```py
/**
 * The Himmelblau function:
 * f(x) = (x1^2 + x2 - 11)^2 + (x1 + x2^2 - 7)^2
 */
RealScalarFunction f = new RealScalarFunction() {
    @Override
    public Double evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);

        double result = pow(x1 * x1 + x2 - 11, 2);
        result += pow(x1 + x2 * x2 - 7, 2);

        return result;
    }

    @Override
    public int dimensionOfDomain() {
        return 2;
    }

    @Override
    public int dimensionOfRange() {
        return 1;
    }
};

RealVectorFunction g = new RealVectorFunction() {
    @Override
    public Vector evaluate(Vector x) {
        double x1 = x.get(1);
        double x2 = x.get(2);

        double w1 = x1 * x1 + x2 - 11;
        double w2 = x1 + x2 * x2 - 7;

        double[] result = new double[2];
        result[0] = 4 * w1 * x1 + 2 * w2;
        result[1] = 2 * w1 + 4 * w2 * x2;
        return new DenseVector(result);
    }

    @Override
    public int dimensionOfDomain() {
        return 2;
    }

    @Override
    public int dimensionOfRange() {
        return 2;
    }
};
C2OptimProblemImpl problem = new C2OptimProblemImpl(f, g);

QuasiNewtonMinimizer rankOneMinimizer = new RankOneMinimizer(1e-16, 15);
IterativeSolution<Vector> soln1 = rankOneMinimizer.solve(problem);
Vector xmin = soln1.search(new DenseVector(new double[]{6, 6}));
double f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %.16f", xmin.toString(), f_xmin));

QuasiNewtonMinimizer dfpMinimizer = new DFPMinimizer(1e-16, 15);
IterativeSolution<Vector> soln2 = dfpMinimizer.solve(problem);
xmin = soln2.search(new DenseVector(new double[]{6, 6}));
f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %.16f", xmin.toString(), f_xmin));

QuasiNewtonMinimizer bfgsMinimizer = new BFGSMinimizer(false, 1e-16, 15);
IterativeSolution<Vector> soln3 = bfgsMinimizer.solve(problem);
xmin = soln3.search(new DenseVector(new double[]{6, 6}));
f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %.16f", xmin.toString(), f_xmin));

QuasiNewtonMinimizer huangMinimizer = new HuangMinimizer(0, 1, 0, 1, 1e-16, 15);
IterativeSolution<Vector> soln4 = huangMinimizer.solve(problem);
xmin = soln4.search(new DenseVector(new double[]{6, 6}));
f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %.16f", xmin.toString(), f_xmin));

QuasiNewtonMinimizer pearsonMinimizer = new PearsonMinimizer(1e-16, 15);
IterativeSolution<Vector> soln5 = pearsonMinimizer.solve(problem);
xmin = soln5.search(new DenseVector(new double[]{6, 6}));
f_xmin = f.evaluate(xmin);
System.out.println(String.format("f(%s) = %.16f", xmin.toString(), f_xmin));

```

输出如下所示:

```py
f([3.000000, 2.000000] ) = 0.0000000000000000
f([3.000000, 2.000000] ) = 0.0000000000000000
f([3.000000, 2.000000] ) = 0.0000000000000000
f([3.000000, 2.000000] ) = 0.0000000000000000
f([3.000000, 2.000000] ) = 0.0000000000000000

```

拟牛顿法似乎比任何共轭方向法更有效。它们需要的迭代次数少得多，15 次对 20 次，而且精度更高。

这些解算员的签名如下:

```py
/**
 * Construct a multivariate minimizer using the Rank One method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public RankOneMinimizer(double epsilon, int maxIterations)

/**
 * Construct a multivariate minimizer using the DFP method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public DFPMinimizer(double epsilon, int maxIterations)

/**
 * Construct a multivariate minimizer using the BFGS method.
 *
 * @param epsilon          a precision parameter: when a number |x| &le;
 *                         &epsilon;, it is considered 0
 * @param maxIterations    the maximum number of iterations
 * @param isFletcherSwitch indicate whether to use the Fletcher switch
 */
public BFGSMinimizer(boolean isFletcherSwitch, double epsilon, int maxIterations)

/**
 * Construct a multivariate minimizer using Huang's method.
 *
 * @param theta         &theta; in Huang's formula
 * @param phi           &phi; in Huang's formula
 * @param psi           &psi; in Huang's formula
 * @param omega         &omega; in Huang's formula
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public HuangMinimizer(
        double theta,
        double phi,
        double psi,
        double omega,
        double epsilon,
        int maxIterations
)

/**
 * Construct a multivariate minimizer using the Pearson method.
 *
 * @param epsilon       a precision parameter: when a number |x| &le;
 *                      &epsilon;, it is considered 0
 * @param maxIterations the maximum number of iterations
 */
public PearsonMinimizer(double epsilon, int maxIterations)

```*********************