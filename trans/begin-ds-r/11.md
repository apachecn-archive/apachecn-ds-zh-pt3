托马斯 mailund 2017 年

Thomas Mailund,《在 R 开始数据科学》, 10.1007/978-1-4842-2671-1_11

# 11.构建 R 包

Thomas Mailund <sup class="calibre6">1</sup> 的缩写形式

①丹麦奥胡斯

您现在知道了如何用 R 编写函数和创建类，但是函数和类都不是您用来收集和分发 R 代码的单元。那个单元就是*包*。当您编写以下代码时，您加载并导入到您的名称空间中的是包:

```
**library**(something)
```

当你写这个的时候你下载的是包:

```
**install.packages**("something")
```

本章的主题是如何制作自己的包。在有限的空间里，我只能给出 R 包结构的一个非常宽泛的概述，但是这应该足够让你入门了。如果你想读更多，我热烈推荐哈德利·韦翰的书 *R Packages。*

## 创建 R 包

我将假设您为此使用了 RStudio。如果没有，可以看看 devtools 包。它提供了在 RStudio 中通过 GUI 可以做的所有事情的功能。

要创建一个新的包，选择 File ➤ New Project，您应该会看到一个对话框，询问您的新项目是应该在一个新的目录中，还是应该在一个现有的目录中，还是应该从一个版本控制存储库中签出。选择新目录。

之后，您可以在一个空项目、一个包或一个闪亮的应用程序之间进行选择。不出意外，你要挑 R 包。

现在，您将看到一个对话框，您可以在其中设置软件包的详细信息。您可以选择包的类型(您可以选择普通包或使用 Rcpp 进行 C++扩展的包)；您可以指定包的名称；并且您可以提供现有的源文件来包含在包中。此外，您需要选择放置新包的位置，以及您是否希望为包使用 git 存储库。

选择一个普通的包，然后单击 Yes 创建一个 git 存储库(我们稍后再回到 git)。你现在只需要选择一个名字和一个放包裹的地方。把它放在哪里由你决定，但是有一些关于包名的指导原则，下面讨论。

### 包名

包名可以由字母、数字和。，但*必须*以字母开头，不得有。作为最后一个角色。您不能使用其他字符，如下划线或破折号。

每当您构建希望其他人能够使用的软件时，请小心您给它起的名字。给它取一个好记又容易谷歌的名字。

为了试验包，您可以创建一个名为 test 的包。创建它，看看结果。

### R 包的结构

在 RStudio 为您构建的目录中，您应该有两个目录，R 和 man，三个文本文件。Rbuildignore、DESCRIPTION 和 NAMESPACE，以及一个项目文件(其名称将是您的包的名称，后跟。Rproj)。

RStudio 使用最后一个文件，您需要知道的是，如果您在 RStudio 中打开该文件，您将获得上次处理该文件时项目状态的打开版本。

在 R 目录中有一个示例文件，名为 R/hello。r，并且在 man 目录里面，你有一个示例文档 [<sup class="calibre6">1</sup>](#Fn1) 文件，名为 man/hello.Rd

文本文件和两个目录是 R 包外观的一部分，它们必须总是以准确的名称存在。还有几个目录也有标准名称， [<sup class="calibre6">2</sup>](#Fn2) ，但它们不是必需的，我们现在没有它们。

### 。Rbuildignore

您创建的目录包含包的源代码，但它不是实际的*包。您需要从这个源代码中构建和安装这个包。我们将很快讨论如何做到这一点。*

的。Buildignore file 告诉 R 在构建包时不要包含什么。这里没有提到的文件将自动包含在内。这本身并不是一场灾难，但它确实会导致混乱的包供其他人使用，如果你将一个包上传到 CRAN， [<sup class="calibre6">3</sup>](#Fn3) 那里的过滤器会强制执行一个严格的目录和文件结构，不允许你包含不符合该结构的文件或目录。

自动生成的。Buildignore 文件如下所示:

```
^.*\.Rproj$
^\.Rproj\.user$
```

这是两个正则表达式，它们阻止 R 在编译后的包中包含 RStudio 文件。

这里的^字符匹配文件名的开头，而$匹配结尾。一个没有逃脱的。匹配任何字符，而转义符\。匹配一个实际的点。*表示前一个符号可以重复任意次。所以第一个正则表达式指定了任何以。Rproj，第二个表达式指定任何以. Rproj.user 结尾的文件名。

### 描述

这个文件包含关于你的包的元信息。如果您调用您的包测试并在我创建的同一天(2015 年 11 月 11 日)创建它，它现在应该看起来像这样:

```
Package: test
Type: Package
Title: What the Package Does (Title Case)
Version: 0.1
Date: 2015-11-22
Author: Who wrote it
Maintainer: Who to complain to <yourfault@somewhere.net>
Description: More about what it does (maybe more than one line)
License: What license is it under?
LazyData: TRUE
```

您需要更新它来描述您的新软件包。

接下来我会对元数据做一个简短的描述，但是你也可以在 Hadley Wickham 的 *R Packages* 一书中读到更多关于它的内容。

#### 标题

标题字段是不言自明的。你需要给你的包一个标题。在这里，(标题大小写)意味着你需要在单词中使用大写首字母，就像你写书名一样。

如果你在 CRAN 上阅读一个包的文档，它会是这样的:packagename:这是标题。不要在标题中包含包名，因为它会自动添加到文档页面中。你只是想要头衔。

#### 版本

这只是一个跟踪你的软件包版本的号码。每当您对您的包进行更改并发布它们时，这个数字应该会上升。

版本号不仅用于表明您已经更新了一个版本，而且有时对于指定包之间的依赖关系也是必要的。如果一个特性是在 1.2 版中引入的，但在 1.1 版中不存在，那么使用这个特性的其他包需要知道它们是否可以访问 1.2 版或更高版本。我们将在本章后面回到依赖性。

对于版本号有一些约定，但是没有什么是严格执行的。这里的约定是，*发布的*版本的编号方案是 major.minor.patch，因此版本 1.2.3 意味着主版本号是 1，次版本号是 2，这是修补版本 3。补丁是较小的变化，通常是错误修复等，而小的修订通常包括一些新功能。次要版本和主要版本之间的区别是主观的，但是每当接口发生变化时——您更改了调用函数的方式，旧的调用类型现在不正确了——您肯定应该增加主要版本号。

如果您有一个开发版本的包，您正在为那些敢于尝试 beta 版本的人分发，惯例是添加一个开发版本号。然后版本号看起来像 major . minor . patch . develop-number，其中按照惯例，最后一个版本号从 9000 开始，并且随着每个新版本的发布而增加。

您刚刚开始开发您的新包，所以将版本号更改为 0.0.0.9000。

#### 描述

此字段应描述包。它通常是一段简短的描述。为了让 R 正确解析描述文件，您必须缩进 DESCRIPTION 后面的行:如果描述跨越多行。

#### 作者和维护者

删除这两个字段。有一种更好的方法来指定相同的信息，确保它以更结构化的形式提供。您应该使用一个名为 Authors@R:的新字段。

这个字段接受一个 R 表达式，指定一个或多个作者，其中作者信息是通过调用 person 函数提供的——这就是我们如何确保它的结构适当。查看函数(？人)了解更多详情。

你是单身作者，所以你应该这样使用:

```
Authors@R: person("First Name", "Last Name",
                  email = "your.email@your.domain.com",
                  role = c("aut", "cre"))
```

这里的角色是指*作者*和*创作者*。person 函数的文档列出了其他选项。

如果有不止一个人作为作者、维护者或其他类型的贡献者，您可以通过用 c 函数将他们串联起来列出一系列人。

#### 许可证

这指定了发布软件包的软件许可证。它真的可以是任何东西，但是如果你想把你的包放在 CRAN 上，你必须选择一个 CRAN 接受的来自 https://cran.r-project.org/web/licenses/的许可。

您可以通过缩写来指定哪些被认可的许可证，因此要指定您的软件包是在 GPL version 2 许可证下发布的，您可以编写:

```
License: GPL-2
```

#### 类型、日期、延迟日期

Type 和 LazyData 字段不是必需的。如果你愿意，你可以删除它们。Type 只是说你有一个包，但我们已经知道了。LazyData 告诉 R，如果您的包中包含数据，它应该延迟加载。同样，这不是特别重要的事情(除非您计划在包中包含非常大的数据集；如果你这样做了，谷歌一下 LazyData 的文档。

日期当然包括日期。这应该是您最后一次修改软件包，即最后一次更新版本。

#### URL 和错误报告

如果您有软件包的网页和报告错误的 URL，这些是您想要使用的字段。它们并不是软件包所必需的，但是对于用户来说当然非常有用。

#### 属国

如果您的包有依赖项，您可以在三个字段中指定它们:依赖项、导入和建议。 [<sup class="calibre6">4</sup>](#Fn4)

使用 Depends，您可以指定需要安装的包，以及包需要哪个版本的 R 才能工作。不过，对于包来说，使用 Imports 和 Suggests 比使用 Depends 更好，所以使用 Depends 只是为了指定您需要哪个版本的 R。

您可以这样指定它:

```
Depends: R (>= 2.10)
```

这就是说你需要 R 才能工作(这并不奇怪，但是语法对于包来说是一样的)，并且它必须至少是 2.10 版本。

依赖关系的语法是一个逗号分隔的包名列表(或者如前所示的 R ),在包名后面的括号中有可选的版本号要求。

导入和建议字段可能如下所示:

```
Imports:
  ggplot2,
  dplyr (>= 0.4.3),
  pracma
Suggests:
  testthat,
  knitr
```

这指定您导入三个包——gg plot 2、dplyr 和 prac ma——并在一些函数中使用 testthat 和 knitr(如果这些包可用的话)。我们要求 dplyr 的版本至少为 0.4.3，但不要求其他包的版本。

Imports 和 Suggests 的区别在于 Imports *中的需求必须*被安装，这样你的包才能被安装(或者如果你告诉 R 安装依赖项，它们就会被安装)，而 Suggests 中的需求则不需要。

#### 使用导入的包

Imports 或 Suggestslists 列表中的包不会像调用 library(package)时那样导入到您的名称空间中。这是为了避免污染您的包名称空间，您不应该通过自己调用库来破坏它。如果您想使用其他包中的函数，您必须通过它们的包名称空间显式地访问它们，或者在单个函数级别显式地导入它们。

从另一个包中访问函数而不导入包名称空间的方法是使用::符号。如果想在不导入 dplyr 的情况下使用 dplyr 中的 filter 函数，可以使用名称 dplyr::filter 来获得该函数。

如果您从您在 Imports 字段中列出的包中访问名称，那么即使它没有被导入到您的名称空间中，您也知道它是存在的，所以您只需要使用长名称。

导入函数的另一种方法是使用 roxy gen——我们将在本章后面讨论——在这种方法中，您可以导入另一个包的名称空间，或者一次只导入另一个包中单个函数的名称。

#### 使用建议的包

您可以使用::符号访问建议的包(在“建议”字段中命名的包)中的函数，就像您访问导入的包一样。还有一个复杂的问题:软件包可能没有安装在安装了您的软件包的计算机上。这就是建议一个依赖项和通过将它放入 Imports 字段来要求它之间的区别。

建议包而不是导入包的目的是，您的包提供的功能并不严格依赖于另一个包，但是如果有建议的包，您可以做更多的事情，或者更有效地做事。

所以你需要一种方法在你使用一个包之前检查它是否被安装，那就是函数 requireNamespace。如果您请求的名称空间(包)已安装，则返回 TRUE，否则返回 FALSE。你可以这样使用它:

```
if (**requireNamespace**("package", quietly = TRUE)) {
*# use package functionality* 
} else {
*# do something that doesn't involve the package* 
*# or give up and throw an exception with stop()* 
}
```

悄悄地选项是防止它打印警告。您正在处理软件包未安装的情况，因此它没有必要打印警告。

### 命名空间

名称空间文件提供了当用户编写库(测试)时，您在包中实现的哪些函数应该导出到用户的名称空间的信息。

每个包都有自己的名称空间。这类似于每个函数在其主体中都有一个命名空间，我们可以在其中定义和访问局部变量。您在包中编写的函数将首先在包名称空间中查找其他函数，然后在全局名称空间中查找。

想要使用您的包的用户可以通过使用以下命令将您的函数加载到他们的名称空间中来访问您的函数:

```
**library**(test)
```

或者他们可以明确地要求您的名称空间中的函数，如下所示:

```
test::**function_name**()
```

但是它们只能访问显式导出的函数(和其他对象)。 [<sup class="calibre6">5</sup>](#Fn5)

命名空间文件是您指定应该从包中导出什么内容的地方。 [<sup class="calibre6">6</sup>](#Fn6)

自动生成的文件如下所示:

```
exportPattern("^[[:alpha:]]+")
```

它只是导出任何有字母数字名称的东西。这肯定是太多了，但我们现在忽略它。我们不打算手动编辑这个文件，因为我们可以使用 Roxygen 更容易地导出函数(和所有其他对象),就像刚才描述的那样。

### R/和 man/

R/目录是放置所有 R 代码的地方，man/目录是存放软件包文档的地方。在 RStudio 生成您的新包之后，两个目录中都有一个示例文件。您可以查看它们，然后删除它们。

您为一个包编写的所有 R 代码都应该放在 R/目录下的文件中，以便加载到包中。所有文档都将放在 man/中，但是我们不打算在那里手工编写文档。取而代之的是，我们会用 Roxygen 来记录函数，然后 Roxygen 会自动把 man/里进去的文件做出来。

## 配置

Roxygen 是一个为你的包编写文档的系统，如果你熟悉 Javadoc，你会认出它的语法。但是，它还做了一些事情，包括处理名称空间的导入和导出，我们将会看到。

要使用它，首先必须安装它，因此运行以下命令:

```
**install.packages**("roxygen2")
```

现在进入构建菜单并选择配置构建工具。选择构建工具并检查用 Roxygen 生成文档。在弹出的对话框中，选中 Build & Reload。这确保了 Roxygen 用于生成文档，并且文档是在您构建包时生成的。这也将确保 Roxygen 处理名称空间的导入和导出。

### 记录功能

您可以通过一个示例了解 Roxygen 的工作原理:

```
*#' Add two numbers* 
*#'* 
*#' This function adds two numbers together.* 
*#'* 
*#' @param x  A number* 
*#' @param y  Another number* 
*#' @return The sum of x and y* 
*#'* 
*#' @export* 
add <- function(x, y) x + y
```

函数 add 的文档在函数上方的注释中提供，但是注释以字符# '而不是#开头。这就是告诉 Roxygen 这些注释是它应该处理的文档的一部分。

第一行成为函数文档的标题。它后面应该有一个空行(仍然在#注释中)。

下文是对该功能的描述。这个简单函数的文档有点傻，但是通常你会有几段描述这个函数做什么以及应该如何使用它。您可以在这里写尽可能多的文档，只要您认为有必要。

以@标记开始的行—例如@param 和@ return—包含 Roxygen 的信息。它们提供了用于制作文档中单个部分的信息。

@param 标签用于描述参数。该标记后面是参数名，然后是参数的简短描述。

@return 标签提供了函数返回内容的描述。

在你用 Roxygen 写了一些注释之后，你可以通过选择构建➤文档来构建它。在构建文档之后，看一下名称空间文件和 man/目录。在名称空间文件中，您应该看到函数已经导出；在 man/ directory 中，应该有一个记录该功能的文件。

### 进出口

在名称空间文件中，您应该看到您记录的函数被显式导出。这是因为我们在文档中提供了@export 标签。它告诉 Roxygen 从包名称空间导出它。

这是处理名称空间导出的最简单的方法，因此，如果没有别的原因，您应该使用 Roxygen 来完成这个任务，而不是手动编辑名称空间文件。

如果您使用@export 标签，Roxygen 还将确保多态函数和其他类型的对象被正确导出。这需要在名称空间文件中使用不同种类的命令。只要用 Roxygen 就不用担心了。

Roxygen 还可以处理名称空间的导入。请记住，您在描述文件的 Imports 字段中列出的包肯定会安装在安装了您的包的计算机上，但是这些包的名称空间是*而不是*导入的。您必须使用::符号来访问它们。

嗯，使用 Roxygen，您可以使用@importFrom 包对象标记将对象(通常是一个函数)导入到您的命名空间中的一个函数中，您可以将该标记赋予该函数。对于普通函数，我看不出使用这个特性有什么意义，因为它并不比只使用::符号更短。不过，对于中缀函数来说，这使得它们更容易使用，因为这样你就可以把中缀函数当作中缀运算符来使用。

所以在下面的函数中，您可以使用 dplyr 中的%>%操作符，因为您显式地导入了它。否则你无法真正理解中缀运算符。

```
*#' Example of using dplyr* 
*#'* 
*#' @param data A data frame containing a column named A* 
*#' @param p    A predicate function* 
*#' @return The data frame filtered to those rows where p is true on A* 
*#'* 
*#' @importFrom dplyr filter* 
*#' @importFrom dplyr %>%* 
*#' @export* 
filter_on_A <- function(data, p) {
  data %>% **filter**(**p**(A))
}
```

如果您编写的函数使用了包中的大量功能，您还可以导入该包的整个名称空间。这类似于使用 library(package ),是通过@import 标记完成的。

```
*#' @import dplyr* 
*#' @export* 
filter_on_A <- function(data, p) {
  data %>% **filter**(**p**(A))
}
```

### 包范围与全局范围

当您用 library(package)加载一个包时，需要对它的名称空间做一个简短的注释。我已经提到过了，但我只想把它完全说清楚。一个包有它自己的名字空间，它的函数就在这个名字空间中。从包中编写的其他函数调用的函数首先在包名称空间中查找，然后在全局名称空间中查找。

如果你写了一个函数，它使用了你的包中的另一个函数，并且有人在加载你的包后在全局命名空间中重新定义了这个函数，这并不会改变你的包中的函数。

对于这个工作来说，函数是导出的还是包内的并不重要。r 总是先在包命名空间中查找，然后再在全局命名空间中查找。

### 内部功能

您可能不想导出您在包中编写的所有函数。如果有一些函数，你考虑你的包设计的实现细节，你*不应该*导出它们。如果你这样做，人们可能会开始使用它们，如果你不希望它是功能性的，你可能会在以后修改你的包时改变它。

然而，使函数局部化是相当容易的。你只是不使用@export 标签。则在加载包时，它们不会从包名称空间导出，并且不能从包外部访问它们。 [<sup class="calibre6">7</sup>](#Fn7)

### 文件加载顺序

通常，你用多少个文件来编写你的包功能并不重要。如果每个(主要)函数或类都有一个文件，通常最容易找到要编辑的正确文件，但这主要取决于个人喜好。

将各种函数放在哪个文件中也无关紧要——无论是内部函数还是导出函数——因为它们都存在于包名称空间中。如果您坚持使用函数(和 S3 多态函数)，那么在构建包时处理文件的顺序应该无关紧要。

这对于 S4 类来说确实很重要，如果你遇到这种问题，我会很快提到包文件是按字母顺序处理的。不过，根据你所处的环境按字母顺序排列，因为字母顺序实际上取决于你所处的语言，所以你不应该依赖于此。

相反，你可以使用 Roxygen。它还可以确保一个文件在另一个文件之前被处理。您可以使用@include 字段来创建函数和另一个文件之间的依赖关系。

```
*#' @import otherfile.R* 
```

我自己从来没有这个需要，你可能也不会，但是现在你知道了。

## 向包中添加数据

包中包含一些数据并不罕见，这些数据可以是包实现使用的数据，也可以是更常见的用于示例目的的数据。

这些数据放在数据/目录中。在您新制作的包中没有这个目录，但是如果您想在包中包含数据，它是数据应该去的地方。

您不能使用任何旧的数据格式。通常，它必须位于 R 可以读取的文件中。RData 文件。不过，添加数据文件最简单的方法是使用 devtools 包中的功能。如果没有安装，请键入以下内容:

```
**install.packages**("devtools")
```

然后，您可以使用 use_data 函数创建一个数据文件。

例如，在我的混合图包(见[https://github.com/mailund/admixture_graph](https://github.com/mailund/admixture_graph))中有一个小的测试数据集，我是用这个命令制作的:

```
bears <- **read.table**("bears.txt")
devtools::**use_data**(bears)
```

一旦加载了包，就不能直接获得这些数据，但是您可以使用 data 函数来获得它:

```
**library**(admixturegraph)
**data**(bears)
bears
##      W  X      Y      Z      D Z.value
## 1  BLK PB Sweden   Adm1 0.1258    12.8
## 2  BLK PB  Kenai   Adm1 0.0685     5.9
## 3  BLK PB Denali   Adm1 0.0160     1.3
## 4  BLK PB Sweden   Adm2 0.1231    12.2
## 5  BLK PB  Kenai   Adm2 0.0669     6.1
## 6  BLK PB Denali   Adm2 0.0139     1.1
## 7  BLK PB Sweden    Bar 0.1613    14.7
## 8  BLK PB  Kenai    Bar 0.1091     8.9
## 9  BLK PB Denali    Bar 0.0573     4.3
## 10 BLK PB Sweden   Chi1 0.1786    17.7
## 11 BLK PB  Kenai   Chi1 0.1278    11.3
## 12 BLK PB Denali   Chi1 0.0777     6.4
## 13 BLK PB Sweden   Chi2 0.1819    18.3
## 14 BLK PB  Kenai   Chi2 0.1323    12.1
## 15 BLK PB Denali   Chi2 0.0819     6.7
## 16 BLK PB Sweden Denali 0.1267    14.3
## 17 BLK PB  Kenai Denali 0.0571     5.6
## 18 BLK PB Sweden  Kenai 0.0719     9.6
```

您不能直接在数据文件中为数据添加文档，所以您需要将它放在 R/目录下的 R 文件中。我通常有一个文件叫数据。我用它来记录我的包数据。

对于 bears 数据，我的文档如下所示:

```
*#' Statistics for populations of bears* 
*#'* 
*#' Computed $f_4(W,X;Y,Z)$ statistics for different* 
*#' populations of bears.* 
*#'* 
*#' @format A data frame with 19 rows and 6 variables:* 
*#' \describe{* 
*#'  \item{W}{The W population}* 
*#'  \item{X}{The X population}* 
*#'  \item{Y}{The Y population}* 
*#'  \item{Z}{The Z population}* 
*#'  \item{D}{The $D$ ($f_4(W,X;Y,Z)$) statistics}* 
*#'  \item{Z.value}{The blocked jacknife Z values}* 
*#' }* 
*#'* 
*#' @source \url{http://onlinelibrary.wiley.com/doi/10.1111/mec.13038/abstract}* 
*#' @name bears* 
*#' @docType data* 
*#' @keywords data* 
NULL
```

文档后面的 NULL 是必需的，因为 Roxygen 在文档注释后面需要一个对象，但是是@name 标记告诉它这个文档实际上是针对 bears 对象的。@docType 告诉它这是我们正在记录的数据。

@source 标签告诉我们数据来自哪里；如果您已经为自己的包生成了它，那么您不需要这个标签。

@format 标签是这里唯一复杂的标签。它描述了数据，这是一个数据帧，它使用的标记看起来与 Roxygen 标记文本非常不同。R 使用的文档实际上比我们一直使用的格式更接近 LaTeX，数据描述反映了这一点。

您必须将您的描述放在标有\description{}的花括号内，在花括号内，每个数据框列都有一个项目。其格式为\ item {列名} {列说明}。

## 构建 R 包

在 RStudio 右上角的框架中，您应该有一个名为 Build 的选项卡。选择它。

在选项卡内，工具栏中有三个选项—构建和重新加载、检查等等。他们都做了他们所说的事情:第一个构建并(重新)加载您的包，第二个检查它，这意味着如果您编写了任何单元测试，它就运行单元测试，然后检查与 CRAN 规则的一致性，第三个在下拉菜单中为您提供各种其他选项。

当您对包进行更改时，可以使用 Build & Reload 来重新编译包。它加载您所有的 R 代码(和各种其他东西)来构建包，然后安装它并将其重新加载到您的终端中，以便您可以测试新功能。

以这种方式构建和安装的包也可以在以后的其他项目中使用。

当您必须将包发送给某人时，您可以在“更多”下拉菜单中创建一个源包。它创建一个归档文件(. tar.gz)。

## 练习

在上一章中，你编写了处理*形状*和*多项式*的函数。现在试着用文档和函数的正确导出为每一个做一个包。如果您还没有实现这些练习的所有功能，这是您实现的机会。

# 脚注

[1](#Fn1_source) man 代表*手册*，缩写 man 是 UNIX 遗留下来的。

[2](#Fn2_source) 例如，vignettes/用于文档 vignettes，data/用于您希望包含在软件包中的数据，src/用于 C/C++扩展。

CRAN 是 R 包的官方存放处，也是 install.packages 函数找到它们的地方。

还有几个字段，比如用于链接到外部 C/C++代码，但这三个字段是最重要的。

严格地说，这是不正确的。如果使用:::操作符而不是::操作符，您实际上可以访问内部函数。所以如果 function_name 没有导出但是仍然在测试包中实现，可以用 test:::function_name 访问它。但是你不应该。你应该让你该死的脏爪子远离内部函数！

它也用于导入选定的函数或包，但是使用 Roxygen 的@import 和@importFrom 函数是更好的解决方案。

当然，除了通过:::操作符之外，但是使用这个来访问你的包的内部的人知道——或者应该知道——他们正在访问将来可能改变的实现细节，所以如果他们的代码在某个时候出了问题，那是他们自己的错。