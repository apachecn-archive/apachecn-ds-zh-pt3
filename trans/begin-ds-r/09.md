# 九、高级 R 编程

本章更详细地介绍了 R 语言的某些方面。本章之所以被称为“高级 R 编程”只是因为它是对上一章快速介绍的补充。或许，除了最后的函数式编程，我们不会讨论任何概念上比前一章更复杂的内容。这只是我们将深入研究的一些技术细节。

我从哈德利·韦翰的同名优秀著作中剽窃了这个标题(见[http://adv-r.had.co.nz](http://adv-r.had.co.nz)),我在这里提到的大部分内容，他在他的书中也提到了。不过，他确实涵盖了更多内容，所以如果你真的想深入研究 R 编程的高级方面，这是一本你应该买的书。

## 使用向量和矢量化函数

我们从回到表达式开始。在前一章中，你看到了单个(标量)值上的表达式，但是你也看到 R 实际上没有标量值；你所有的原始数据实际上都是数据的向量。这意味着你在 R 中使用的表达式实际上是对向量进行操作，而不是对单个值进行操作。

当你写这个的时候:

```py
(x <- 2 / 3)
## [1] 0.6666667
(y <- x ** 2)
## [1] 0.4444444
```

你写的表达式*是*，当然，对单个值起作用——向量 x 和 y 的长度为 1，但这实际上只是对向量起作用的特例。

```py
(x <- 1:4 / 3)
## [1] 0.3333333 0.6666667 1.0000000 1.3333333
(y <- x ** 2)
## [1] 0.1111111 0.4444444 1.0000000 1.7777778
```

r 使用两条规则处理向量:操作是按元素进行的，向量根据需要重复。

当你写一个像 x + y 这样的表达式时，你实际上是在说你想创建一个新的向量，这个向量由向量 x 和 y 中的元素的元素和组成，所以对于 x 和 y 是这样的:

```py
x <- 1:5
y <- 6:10
```

写这个:

```py
(z <- x + y)
## [1]  7  9 11 13 15
```

相当于这样写:

```py
z <- **vector**(length = **length**(x))
for (i in **seq_along**(x)) {
    z[i] <- x[i] + y[i]
}
z
## [1]  7  9 11 13 15
```

所有算术表达式或涉及| or &(但不是|| or &&)的逻辑表达式都是如此；这些不对向量进行元素方式的操作)。您可以调用的大多数函数也是如此，比如 sqrt 或 sin:

```py
**sqrt**((1:5)**2)
## [1] 1 2 3 4 5
**sin**(**sqrt**((1:5)**2))
## [1]  0.8414710  0.9092974  0.1411200 -0.7568025
## [5] -0.9589243
```

当表达式包含不同长度的向量时，不能直接按元素计算表达式。在这种情况下，R 将尝试重复较短的向量，以创建相同长度的向量。要做到这一点，较短向量的长度应该可以被最长向量的长度整除，也就是说，您应该能够将较短向量重复整数次，以获得最长向量的长度。如果可能，R 根据需要重复向量，使所有向量的长度与最长向量的长度相同，然后按元素进行运算:

```py
x <- 1:10
y <- 1:2
x + y
##  [1]  2  4  4  6  6  8  8 10 10 12
z <- 1:3
x + z
## Warning in x + z: longer object length is not a
## multiple of shorter object length
##  [1]  2  4  6  5  7  9  8 10 12 11
```

如果较短的向量不能重复整数次来匹配，R 仍然会重复所需的次数来匹配最长的向量，但是您会得到一个警告。大多数情况下，这种事情都是由错误的代码引起的。

```py
z <- 1:3
x + z
## Warning in x + z: longer object length is not a
## multiple of shorter object length
##  [1]  2  4  6  5  7  9  8 10 12 11
```

在你不久前看到的表达式中，不同的向量重复出现:

```py
(x <- 1:4 / 3)
## [1] 0.3333333 0.6666667 1.0000000 1.3333333
(y <- x ** 2)
## [1] 0.1111111 0.4444444 1.0000000 1.7777778
```

当我们将 1:4 除以 3 时，我们需要将(长度为 1 的)向量 3 重复四次，以便能够将 1:4 向量除以 3 向量。当我们计算 x ** 2 时，我们也必须重复 2 四次。

每当您考虑编写一个向量循环来为每个元素做一些计算时，您应该总是考虑使用这样的矢量化表达式。它通常更不容易出错，而且因为它包含了由 R 运行时系统处理的隐式循环，所以几乎可以保证比显式循环更快。

### 如果其他

控制结构没有向量化。例如，如果语句不是。例如，如果要从向量 x 计算向量 y，如果 x[i]是偶数，y[I]= = 5；如果 x[i]是奇数，y[i] == 15，则不能将其写成向量表达式:

```py
x <- 1:10
if (x %% 2 == 0) 5 else 15
## Warning in if (x%%2 == 0) 5 else 15: the condition
## has length > 1 and only the first element will be
## used
## [1] 15
```

相反，您可以使用 ifelse 函数，它的工作方式类似于矢量化选择；如果第一个元素中的条件为真，则返回第二个参数中的值；否则，它返回第三个参数中的值。它以向量运算的方式完成这项工作:

```py
x <- 1:10
**ifelse**(x %% 2 == 0, 5, 15)
##  [1] 15  5 15  5 15  5 15  5 15  5
```

### 矢量化函数

当你写你自己的函数时，你可以写它们，这样它们也可以用来处理向量，也就是说，你可以写它们，这样它们可以把向量作为输入，返回向量作为输出。如果以这种方式编写它们，那么它们可以像 sqrt 和 sin 等内置函数一样用于矢量化表达式。

让函数处理向量的最简单的方法是使用处理向量的表达式来编写函数体。

```py
f <- function(x, y) **sqrt**(x ** y)
**f**(1:6, 2)
## [1] 1 2 3 4 5 6
**f**(1:6, 1:2)
## [1] 1.000000 2.000000 1.732051 4.000000 2.236068
## [6] 6.000000
```

如果你写一个函数，你不能用这种方式写它的主体，但是你仍然希望能够在向量表达式中使用它，你通常可以使用矢量化函数。

例如，假设我们有一个将键映射到一些值的表。我们可以想象我们想要将一个类中的名字映射到该类中的参与者所拥有的角色。在 R 中，我们将使用一个列表来实现这种表，并且我们可以很容易地编写一个函数，使用这样的表来将名称映射到角色。

```py
role_table <- **list**("Thomas" = "Instructor",
                   "Henrik" = "Student",
                   "Kristian" = "Student",
                   "Randi" = "Student",
                   "Heidi" = "Student",
                   "Manfred" = "Student")

map_to_role <- function(name) role_table[[name]]
```

当我们用一个名字来调用它时，它应该是这样工作的:

```py
**map_to_role**("Thomas")
## [1] "Instructor"
**map_to_role**("Henrik")
## [1] "Student"
```

但是当我们用一个向量调用这个函数时，它失败了，因为我们不能用这种方式用一个向量索引这个列表。

```py
x <- **c**("Thomas", "Henrik", "Randi")
**map_to_role**(x)
## Error in role_table[[name]]: recursive indexing failed at level 2
```

所以我们有一个函数，它将单个值映射到单个值，但不适用于向量。让这样的函数在向量上工作的简单方法是使用矢量化函数。这个函数将包装你的函数，这样它就可以处理向量，它对这些向量所做的就是你所期望的:它将计算向量中每个元素的值，结果将是所有结果的向量。

```py
map_to_role <- **Vectorize**(map_to_role)
**map_to_role**(x)
##       Thomas       Henrik        Randi
## "Instructor"    "Student"    "Student"
```

在这个特殊的表示例中，失败的原因是我们使用了[[index]操作符。如果我们使用了[操作符，我们会很好(除了结果将是一个列表而不是一个向量)。

```py
role_table[**c**("Thomas", "Henrik", "Randi")]
## $Thomas
## [1] "Instructor"
##
## $Henrik
## [1] "Student"
##
## $Randi
## [1] "Student"
```

所以我们也可以通过不同的索引直接处理向量输入，然后展平列表

```py
map_to_role_2 <- function(names) **unlist**(role_table[names])

x <- **c**("Thomas", "Henrik", "Randi")
**map_to_role_2**(x)
##       Thomas       Henrik        Randi
## "Instructor"    "Student"    "Student"
```

不过，重写一个函数来处理向量输入并不总是那么容易，当我们不能很容易地做到这一点时，矢量化函数会非常有帮助。

顺便提一下，使用[[向量值]的问题不仅仅是它不起作用。它确实工作，但是它做了一些不同于我们在这里试图做的事情。如果你给[[一个索引向量，它被用来做所谓的递归索引。这是使用第一个变量在列表中查找并取出在那里找到的向量或列表的快捷方式。然后，它获取该序列，并使用下一个索引进行查找，依此类推。以下面的代码为例:

```py
x <- **list**("first" = **list**("second" = "foo"), "third" = "bar")
x[[**c**("first", "second")]]
## [1] "foo"
```

这里我们有一个包含两个元素的列表，第一个是包含一个元素的列表。您可以在第一个列表中查找索引“first ”,并获取存储在该索引处的列表。然后，我们可以用“第二个”索引来索引这个列表，以得到“foo”。

结果与此类似:

```py
x[["first"]][["second"]]
## [1] "foo"
```

这可能是一个有用的特性——尽管说实话，我在自己的编程中并没有发现它有多大用处——但这不是我们在映射到角色示例中想要的效果。

### 申请家庭

向量化一个函数可以隐式地在向量上使用它。我们简单地给它一个向量作为输入，然后我们得到一个向量作为输出。请注意，它并不是真正的矢量化函数，因为它将向量作为输入—许多函数将向量作为输入，并返回单个值作为输出，例如 sum 和 mean—但我们使用这些函数的方式与矢量化函数不同。如果你想要那种函数，你*必须明确地处理它如何处理输入的序列。*

矢量化函数可以用完全相同的语法，以与单个值完全相同的方式用于数据矢量。这是一种隐式的向量操作方式。但是当在一个向量中的所有元素上调用一个函数时，你也可以使它更加明确，这给了你更多的控制来精确地*如何*调用它。这反过来又让你可以使用那些函数，不仅可以从向量映射到向量，还可以从向量映射到单个值。

有许多方法可以做到这一点——因为在 R 中这是一件很常见的事情——稍后您将看到一些处理序列和以各种方式调用序列函数的通用函数。不过，在你将读到的大部分代码中，完成这些工作的函数都被命名为带有 apply 的东西，这些函数就是我们将在这里看到的。

先说申请。这是一个对向量、矩阵(二维向量)或数组(高阶维度向量)进行操作的函数。

#### 应用

我认为这个函数最容易用矩阵来解释，所以我们来做一个。

```py
m <- **matrix**(1:6, nrow=2, byrow=TRUE)
m
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
```

apply 函数(至少)接受三个参数。第一个是向量/矩阵/数组，第二个是我们应该边缘化的维度，第三个是我们应该应用的函数。

边缘化在这里的意思是，在维度的某个子集中固定一个索引，然后用这个索引取出所有的值。如果我们对行进行边缘化，我们将提取所有的行，因此对于每一行，我们将有一个每列包含一个元素的向量，这就是我们将传递给函数的内容。

我们可以使用 paste 函数来说明这一点，该函数通过连接它的输入来创建一个字符串。 [<sup class="calibre6">1</sup>](#Fn1)

如果您在行上边缘化，它将在两行中的每一行上被调用，并将产生两个字符串:

```py
**apply**(m, 1, function(x) **paste**(x, collapse = ":"))
## [1] "1:2:3" "4:5:6"
```

如果您在列上边缘化，它将在三列中的每一列上被调用并产生三个字符串:

```py
**apply**(m, 2, function(x) **paste**(x, collapse = ":"))
## [1] "1:4" "2:5" "3:6"
```

如果在行和列上都边缘化，将改为在每个元素上调用它:

```py
**apply**(m, **c**(1, 2), function(x) **paste**(x, collapse = ":"))
##      [,1] [,2] [,3]
## [1,] "1"  "2"  "3"
## [2,] "4"  "5"  "6"
```

这里的输出是二维的。这当然是因为我们在两个维度上被边缘化了，所以我们得到了一个与边际相对应的输出。

我们可以通过其他方式获得更高维的输出。如果函数产生向量(或更高维的向量)作为输出，那么 apply 的输出也将是更高维的。考虑一个函数，它将一个向量作为输入，并通过将它与自身连接来复制它。如果我们将它应用于行或列，我们为每一行/列获得一个向量，因此输出必须是二维的。

```py
**apply**(m, 1, function(x) **c**(x,x))
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
## [4,]    1    4
## [5,]    2    5
## [6,]    3    6
**apply**(m, 2, function(x) **c**(x,x))
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    1    2    3
## [4,]    4    5    6
```

apply 在这里做的是创建一个矩阵作为它的结果，其中应用函数的结果从左到右按列收集。对两行调用函数的结果是一个具有两列的矩阵，第一列包含将函数应用于第一行的结果，第二列包含将函数应用于第二行的结果。同样，对于列，结果是一个包含三列的向量，输入矩阵中的每一列对应一列。

如果你边缘化不止一个维度，并通过它获得多维输出，同时产生不止一个值，这两种效应结合起来，你会获得更高维的输出:

```py
**apply**(m, **c**(1,2), function(x) **c**(x,x))
## , , 1
##
##      [,1] [,2]
## [1,]    1    4
## [2,]    1    4
##
## , , 2
##
##      [,1] [,2]
## [1,]    2    5
## [2,]    2    5
##
## , , 3
##
##      [,1] [,2]
## [1,]    3    6
## [2,]    3    6
```

我承认这个输出看起来相当混乱。然而，发生的事情和你在行或列上边缘化时看到的是一样的。您可以为调用该函数的每个边距获取输出，在本例中，是输入中的六个单元格中的每一个，并且它是“按列”收集的，只不过这是在更高的维度上，所以它是在最高维度上收集的(这是二维矩阵的列)。因此，要获得调用函数所用的六个值的结果，您需要按照它们在输入矩阵中的索引方式对它们进行索引，这就是边距，但是您需要在最高维度中进行索引。因此，您可以通过以下方式获得输入值的六个连接:

```py
x <- **apply**(m, **c**(1,2), function(x) **c**(x,x))
k <- **dim**(x)[3]
n <- **dim**(x)[2]
for (i in 1:n) {
  for (j in 1:k) {
    **print**(x[,i,j])
  }
}
## [1] 1 1
## [1] 2 2
## [1] 3 3
## [1] 4 4
## [1] 5 5
## [1] 6 6
```

那么，如果要应用的函数除了从矩阵中获得的参数之外还接受其他参数，会发生什么呢？

```py
sumpow <- function(x, n) **sum**(x) ** n
**apply**(m, 1, sumpow)
## Error in FUN(newX[, i], ...): argument "n" is missing, with no default
```

如果是这样，您可以将这些参数作为附加参数来应用；它们将按照您指定的应用顺序传递给函数。

```py
**apply**(m, 1, sumpow, 2)
## [1]  36 225
```

不过，显式命名这些参数对可读性有很大帮助。

```py
**apply**(m, 1, sumpow, n = 2)
## [1]  36 225
```

#### 你的纸条

lapply 函数用于映射一个列表。给定一个列表作为输入，它将对列表中的每个元素应用函数，并输出一个与输入长度相同的列表，其中包含应用函数的结果。

```py
(l <- **list**(1, 2, 3))
## [[1]]
## [1] 1
##
## [[2]]
## [1] 2
##
## [[3]]
## [1] 3
**lapply**(l, function(x) x**2)
## [[1]]
## [1] 1
##
## [[2]]
## [1] 4
##
## [[3]]
## [1] 9
```

如果输入列表中的元素有名称，这些名称会保存在输出向量中。

```py
l <- **list**(a=1, b=2, c=3)
**lapply**(l, function(x) x**2)
## $a
## [1] 1
##
## $b
## [1] 4
##
## $c
## [1] 9
```

如果你提供的输入是一个向量而不是一个列表，它将把它转换成一个列表，你将总是得到一个列表作为输出。

```py
**lapply**(1:3, function(x) x**2)
## [[1]]
## [1] 1
##
## [[2]]
## [1] 4
##
## [[3]]
## [1] 9
```

当然，如果列表的元素比单个数字更复杂，您仍然只需要对元素应用函数。

```py
**lapply**(**list**(a=1:3, b=4:6), function(x) x**2)
## $a
## [1] 1 4 9
##
## $b
## [1] 16 25 36
```

#### 轻快活泼

sapply 函数的功能与 lapply 相同，但它试图简化输出。本质上，它试图将从 lapply 返回的列表转换成某种向量。它对此使用一些启发法，并猜测您想要的输出，尽可能地简化，但当它无法弄清楚时会给你一个列表。

```py
**sapply**(1:3, function(x) x**2)
## [1] 1 4 9
```

猜测对于交互式工作很有用，但是在编写程序时可能不安全。当你能看到它所创建的内容时，它会猜测并产生不同类型的输出，这不是问题，但这在程序内部是不安全的。

函数 sapply 本质上做的和 sapply 一样，但是没有猜测。你必须告诉它你想要什么输出，如果它不能产生，它会给你一个错误，而不是产生你的程序可能知道或不知道该做什么的输出。

这两个函数在接口上的区别只是 vapply 需要第三个参数，该参数应该是输出类型的值。

```py
**vapply**(1:3, function(x) x**2, 1)
## [1] 1 4 9
```

## 高级功能

我们现在来看看函数的一些特殊情况。我将这一部分称为“高级功能”，但并不是因为它们真的那么高级，只是因为它们需要的功能比您已经看到的基本功能多一点。

### 特殊名称

但是首先要说一下名字。函数可以有和变量相同的名字——毕竟，当我们命名一个函数时，我们实际上只是命名一个恰好包含一个函数的变量——但是我们不能在赋值操作符的右边有所有类型的名字。例如，if 是 R 中的一个函数，但是不能将 if 写在赋值的左边。

有特殊名字的函数，也就是那些通常不能放在赋值前的名字，可以通过放在反斜杠中来引用，所以函数 if 可以像 if 一样引用。

任何函数都可以通过它在反斜杠中的名字来引用，此外，你可以在一个你通常不能使用它的名字的上下文中使用反斜杠来引用一个函数。这适用于调用函数，例如，您可以将中缀运算符用作普通函数调用:

```py
2 + 2
## [1] 4
`+`(2, 2)
## [1] 4
```

或者在为函数指定变量名时:

```py
`%or die%` <- function(test, msg) if (!test) **stop**(msg)

x <- 5
(x != 0) %or die% "x should not be zero"

x <- 0
(x != 0) %or die% "x should not be zero"
## Error in (x != 0) %or die% "x should not be zero": x should not be zero
```

### 中缀运算符

如果你觉得最后一个例子很奇怪，那可能只是因为你不知道 R 的中缀运算符。在 R 中，任何以%开头和结尾的变量都被视为中缀运算符，因此调用 x %foo% y 相当于调用`%foo%`(x，y)。几个内置的中缀运算符没有这种类型的名称，+和*是两个，但是这种命名约定使得创建自己的中缀运算符成为可能。在 dplyr 包中，通过%>% pipe 操作符可以很好地使用这一点。

### 替换功能

替换函数是假装修改变量的函数。当你给一个向量命名的时候，你看到了一个。

```py
v <- 1:4
**names**(v) <- **c**("a", "b", "c", "d")
v
## a b c d
## 1 2 3 4
```

这里发生的事情是，R 识别出你正在给一个函数调用赋值，并去寻找一个名为 names

所以我刚刚写的意思是:

```py
**names**(v) <- **c**("a", "b", "c", "d")
```

是这个的简称:

```py
v <- `names<-`(v, **c**("a", "b", "c", "d"))
```

替换函数通常用于修改一个对象的各种属性，你也可以使用它们的名字必须以

```py
`foo<-` <- function(x, value) {
  x$foo <- value
  x
}

`bar<-` <- function(x, value) {
  x$bar <- value
  x
}

x <- **list**(foo=1, bar=2)

x$foo
## [1] 1
**foo**(x) <- 3
x$foo
## [1] 3
x$bar
## [1] 2
**bar**(x) <- 3
x$bar
## [1] 3
```

请记住，这只是调用一个函数，然后将结果重新分配给一个变量的简写。它实际上并没有修改任何数据。这意味着，如果有两个变量引用同一个对象，那么只有您调用替换函数的那个变量会受到影响。替换函数返回一个副本，该副本被赋予第一个变量，而另一个变量仍然引用旧对象。

```py
y <- x
**foo**(x) <- 5
x
## $foo
## [1] 5
##
## $bar
## [1] 3
y
## $foo
## [1] 3
##
## $bar
## [1] 3
```

因为替换函数只是一个函数调用和再赋值的语法糖，你不能给一个替换函数作为它的第一个参数，一些不能赋值的表达式。

关于替换函数还有一些规则。首先，您正在分配的值的参数必须称为 value。你不能给它另一个名字。

```py
`foo<-` <- function(x, val) {
  x$foo <- val
  x
}

x <- **list**(foo=1, bar=2)
**foo**(x) <- 3
## Error in `foo<-`(`*tmp*`, value = 3): unused argument (value = 3)
```

R 重写表达式的方式假设您调用了 value 参数 value，那么就这样做。

不过，您不必调用第一个参数 x:

```py
`foo<-` <- function(y, value) {
  y$foo <- value
  y
}

x <- **list**(foo=1, bar=2)
**foo**(x) <- 3
x$foo
## [1] 3
```

如果有两个以上的参数，还应该将 value 参数作为最后一个参数。只要您修改的对象是第一个，并且 value 参数是最后一个，您就可以这样做:

```py
`modify<-` <- function(x, variable, value) {
  x[variable] <- value
  x
}

x <- **list**(foo=1, bar=2)
**modify**(x, "foo") <- 3
**modify**(x, "bar") <- 4
x$foo
## [1] 3
x$bar
## [1] 4
```

## 数据到底有多易变？

我们刚刚看到替换函数创建了一个新的副本，所以如果我们用它来修改一个对象，我们实际上并没有改变它。引用同一对象的其他变量将看到旧值，而不是更新后的值。所以我们可以合理地问:修改一个对象实际需要什么？

简单的，而且几乎总是正确的答案是，你不能修改对象*永远不能修改*。 [<sup class="calibre6">2</sup>](#Fn2) 每当你“修改”一个对象的时候，你就在创建一个新的副本，并把这个新副本赋回给你用来引用旧值的变量。

这也适用于在向量或列表中给索引赋值的情况。您将创建一个副本，虽然看起来像是在修改它，但如果您通过另一个引用查看旧对象，您会发现它并没有改变。

```py
x <- 1:4
f <- function(x) {
  x[2] <- 5
  x
}
x
## [1] 1 2 3 4
**f**(x)
## [1] 1 5 3 4
x
## [1] 1 2 3 4
```

除非你改了[函数(我劝你不要改)，否则就是所谓的原函数。这意味着它是用 C 写的，你实际上可以从 C 中修改一个对象。出于效率原因，这一点很重要。如果只有一个对向量的引用，那么赋值给它不会产生新的副本，你*会*像常量时间操作一样修改向量。如果有两个对向量的引用，那么当您第一次将其指定给向量时，会创建一个副本，然后您可以在位修改该副本。这种拥有不可变对象并且仍然有一些效率的方法被称为*写时复制*。

要编写正确的程序，请始终记住，您不是在修改对象，而是在创建副本——对您“修改”的值的其他引用仍然会看到旧值。要编写高效的程序，也要记住，对于原始函数，只要你只有一个对该对象的引用，你就可以*进行高效的更新(以恒定的时间更新，而不是与你所修改的对象的大小成比例的时间)。*

## 函数式编程

对于什么是函数式编程语言，有许多定义，并且有许多关于任何给定特性是否“纯粹”的语言战争。我不会进行这样的讨论，但我想每个人都会同意，有些功能是需要的。您应该能够将函数作为参数传递给其他函数，应该能够创建匿名函数，并且应该有闭包。

### 匿名函数

在 R 中，创建匿名函数相当容易:只是不要将函数定义赋给变量名。

不要这样做:

```py
square <- function(x) x^2
```

您只需这样做:

```py
function(x) x^2
```

在其他语言中，函数定义的语法不同于变量赋值的语法，匿名函数也有不同的语法，但是在 R 中就这么简单。

你为什么想要一个匿名函数？

有两种常见情况:

*   你想使用一个一次性函数，不需要给它一个名字

*   你想创造一个结局

当一个函数作为参数传递给另一个函数或者从一个函数返回时，通常会使用这两种情况。第一种情况是你可以和 apply 这样的函数一起使用。如果要计算矩阵各行的平方和，可以创建一个命名函数并应用它，如下所示:

```py
m <- **matrix**(1:6, nrow=3)
sum_of_squares <- function(x) **sum**(x^2)
**apply**(m, 1, sum_of_squares)
## [1] 17 29 45
```

如果这是你唯一需要这个平方和函数的时候，就没有必要给它赋一个变量；你可以直接使用函数定义方向:

```py
**apply**(m, 1, function(x) **sum**(x^2))
## [1] 17 29 45
```

当然，在这个例子中，你可以做得更好，只要利用^是矢量化的，并写下这个:

```py
**apply**(m^2, 1, sum)
## [1] 17 29 45
```

使用匿名函数来创建闭包就是你在编写一个返回函数的函数时所做的事情(接下来会详细介绍)。您*可以*将函数命名如下:

```py
f <- function(x) {
  g <- function(y) x + y
  g
}
```

但如果你只是想退货，那就没什么意义了:

```py
f <- function(x) function(y) x + y
```

### 以函数为参数的函数

您已经在所有应用示例中看到了这一点。你给出一个参数来应用一个跨维度调用的函数。一般来说，如果一个函数的一些子计算应该被参数化，那么你可以通过把一个函数作为它的一个参数来实现。

假设您想编写一个类似于(s/v)apply 的函数，但是只对满足谓词的元素应用输入函数。您可以通过将向量和两个函数作为输入来实现这样一个函数:

```py
apply_if <- function(x, p, f) {
  result <- **vector**(length=**length**(x))
  n <- 0
  for (i in **seq_along**(x)) {
    if (**p**(x[i])) {
      n <- n + 1
      result[n] <- **f**(x[i])
    }
  }
  **head**(result, n)
}
**apply_if**(1:8, function(x) x %% 2 == 0, function(x) x^2)
## [1]  4 16 36 64
```

这不是解决这个特殊问题的最优雅的方式——我们回到练习中的例子——但是它说明了函数作为参数的使用。

### 函数返回函数(和闭包)

当您在另一个函数中创建一个函数并返回它时，您就创建了闭包。因为这个内部函数可以引用周围函数中的参数和局部变量，甚至在您从它返回之后，您可以使用这样的内部函数来专门化泛型函数。它可以作为描述一系列函数的模板机制。

例如，您可以编写一个通用的幂函数，专门用于计算数字的平方或立方:

```py
power <- function(n) function(x) x^n
square <- **power**(2)
cube <- **power**(3)
x <- 1:4
**square**(x)
## [1]  1  4  9 16
**cube**(x)
## [1]  1  8 27 64
```

这是可行的，因为 power(2)和 power(3)返回的函数位于一个上下文(闭包)中，其中 n 分别为 2 和 3。我们已经修复了我们返回的那部分函数。

### 过滤、映射和减少

函数式编程中反复使用三种模式:过滤、映射和归约。在 R 中，这三者都是在不同的函数中实现的，但是您可以使用 Filter、Map 和 Reduce 函数编写所有的程序。

Filter 函数接受一个谓词和一个向量或列表，并返回满足该谓词的所有元素。

```py
is_even <- function(x) x %% 2 == 0
**Filter**(is_even, 1:8)
## [1] 2 4 6 8
**Filter**(is_even, **as.list**(1:8))
## [[1]]
## [1] 2
##
## [[2]]
## [1] 4
##
## [[3]]
## [1] 6
##
## [[4]]
## [1] 8
```

Map 函数的工作方式类似于 lapply:它将函数应用于 vector 或 list 的每个元素，并返回结果列表。如果你需要的话，使用 unlist 将它转换成一个向量。

```py
square <- function(x) x^2
**Map**(square, 1:4)
## [[1]]
## [1] 1
##
## [[2]]
## [1] 4
##
## [[3]]
## [1] 9
##
## [[4]]
## [1] 16
**unlist**(**Map**(square, 1:4))
## [1]  1  4  9 16
```

不过，您可以使用 Map 做更多的事情，因为 Map 可以应用于多个序列。如果给 Map 更多的参数，那么这些参数也会应用到函数调用中。

```py
plus <- function(x, y) x + y
**unlist**(**Map**(plus, 0:3, 3:0))
## [1] 3 3 3 3
```

到现在为止，这些结构对你来说应该很熟悉了，所以我们就不说这些了。

Reduce 函数可能看起来不太熟悉。你可以用数字的加法或乘法来描述它的功能，它在某种程度上是这种功能的推广。当你写出这样一个表达式时:

```py
a + b + c
```

或者

```py
a * b * c
```

您可以将此视为一系列函数调用:

```py
`+`(`+`(a, b), c)
```

或者

```py
`*`(`*`(a, b), c)
```

Reduce 函数概括了这一点。

```py
**Reduce**(f, **c**(a, b, c))
```

它的评估如下:

```py
**f**(**f**(a, b), c)
```

您可以通过构造一个捕捉其调用方式的函数来了解这一点:

```py
add_parenthesis <- function(a, b) **paste**("(", a, ", ", b, ")", sep = "")
**Reduce**(add_parenthesis, 1:4)
## [1] "(((1, 2), 3), 4)"
```

使用 Reduce，您可以轻松地编写自己的 sum 函数:

```py
mysum <- function(x) **Reduce**(`+`, x)
**sum**(1:4)
## [1] 10
**mysum**(1:4)
## [1] 10
```

Reduce 函数有几个额外的参数——给它一个额外的初始值，而不仅仅是第一次函数调用中最左边的元素，或者让它从右向左应用函数，而不是从左向右——但是您可以查看它的文档以获得详细信息。

## 函数操作:函数作为输入和输出

当然，函数可以将函数作为输入，将返回函数作为输出。

这允许您修改函数，并从现有函数创建新函数。

首先，考虑两个老朋友，阶乘和斐波那契数列。你已经用表格递归地计算过了。如果您可以构建一个通用的函数来缓存结果会怎么样？

这里有一个尝试:

```py
cached <- function(f) {
  **force**(f)
  table <- **list**()

  function(n) {
    key <- **as.character**(n)
    if (key %in% **names**(table)) {
      **print**(**paste**("I have already computed the value for", n))
      table[[key]]

    } else {
      **print**(**paste**("Going to compute the value for", n))
      res <- **f**(n)
      **print**(**paste**("That turned out to be", res))
      table[key] <<- res
      **print**(table)
      res
    }
  }
}
```

我添加了一些输出，以便更容易看到它下面做了什么。

它接受一个函数 f，然后给你另一个函数，它的工作方式和 f 一样，但是它会记住已经计算过的函数。首先，它通过强制记住输入函数是什么。这对于我们打算使用这个缓存函数的方式是必要的。计划是用缓存版本替换全局范围内的函数，这样外面的函数将引用缓存版本。如果在这里不强制 f，那么惰性求值意味着当你最终对 f 求值时，你引用的是缓存的版本，并将以无限递归结束。您可以尝试删除 force(f)调用，看看会发生什么。

接下来，我们创建一个表——我们使用一个列表，这通常是 R 中表的最佳选择。列表允许我们使用字符串作为索引，这样做时，你不需要存储 1 到 n 之间的所有值，就可以在表中拥有一个键为 *n* 的元素。

剩下的代码构建一个函数，该函数首先在表中查找键是否存在。如果是，那么您已经计算出了您想要的值，并且可以从表中得到它。如果键不在那里，你计算它，把它放在表中，然后返回。

您可以在阶乘函数上尝试一下:

```py
factorial <- function(n) {
  if (n == 1) {
    1
  } else {
    n * **factorial**(n - 1)
  }
}

factorial <- **cached**(factorial)
**factorial**(4)
## [1] "Going to compute the value for 4"
## [1] "Going to compute the value for 3"
## [1] "Going to compute the value for 2"
## [1] "Going to compute the value for 1"
## [1] "That turned out to be 1"
## $`1`
## [1] 1
##
## [1] "That turned out to be 2"
## $`1`
## [1] 1
##
## $`2`
## [1] 2
##
## [1] "That turned out to be 6"
## $`1`
## [1] 1
##
## $`2`
## [1] 2
##
## $`3`
## [1] 6
##
## [1] "That turned out to be 24"
## $`1`
## [1] 1
##
## $`2`
## [1] 2
##
## $`3`
## [1] 6
##
## $`4`
## [1] 24
## [1] 24
**factorial**(1)
## [1] "I have already computed the value for 1"
## [1] 1
**factorial**(2)
## [1] "I have already computed the value for 2"
## [1] 2
**factorial**(3)
## [1] "I have already computed the value for 3"
## [1] 6
**factorial**(4)
## [1] "I have already computed the value for 4"
## [1] 24
```

关于斐波那契:

```py
fibonacci <- function(n) {
  if (n == 1 || n == 2) {
    1
  } else {
    **fibonacci**(n-1) + **fibonacci**(n-2)
  }
}

fibonacci <- **cached**(fibonacci)
**fibonacci**(4)
## [1] "Going to compute the value for 4"
## [1] "Going to compute the value for 3"
## [1] "Going to compute the value for 2"
## [1] "That turned out to be 1"
## $`2`
## [1] 1
##
## [1] "Going to compute the value for 1"
## [1] "That turned out to be 1"
## $`2`
## [1] 1
##
## $`1`
## [1] 1
##
## [1] "That turned out to be 2"
## $`2`
## [1] 1
##
## $`1`
## [1] 1
##
## $`3`
## [1] 2
##
## [1] "I have already computed the value for 2"
## [1] "That turned out to be 3"
## $`2`
## [1] 1
##
## $`1`
## [1] 1
##
## $`3`
## [1] 2
##
## $`4`
## [1] 3
## [1] 3
**fibonacci**(1)
## [1] "I have already computed the value for 1"
## [1] 1
**fibonacci**(2)
## [1] "I have already computed the value for 2"
## [1] 1
**fibonacci**(3)
## [1] "I have already computed the value for 3"
## [1] 2
**fibonacci**(4)
## [1] "I have already computed the value for 4"
## [1] 3
```

### 省略参数

在看到更多函数操作的例子之前，您需要了解一个特殊的函数参数，省略号或“三点”参数。

这是一个神奇的参数，允许您编写一个函数，它可以接受任意数量的命名参数，并将它们传递给其他函数。

没有它，如果你给一个它不知道的函数提供一个参数，你会得到一个错误。

```py
f <- function(a, b) NULL
**f**(a = 1, b = 2, c = 3)
## Error in f(a = 1, b = 2, c = 3): unused argument (c = 3)
```

有了它，您可以提供任何您想要的命名参数。

```py
g <- function(a, b, ...) NULL
**g**(a = 1, b = 2, c = 3)
## NULL
```

当然，允许函数接受它不知道如何处理的参数并不是一个很好的特性。但是您可以将这些参数传递给其他函数，这些函数可能*知道如何处理它们，这就是...参数。*

您可以通过一个非常简单的函数看到这一点，这个函数只传递...列表上的参数。这就像用相同的参数直接调用 list 一样，所以这里没有什么神奇的事情发生，但是它显示了命名的参数是如何传递的。

```py
tolist <- function(...) **list**(...)

**tolist**()
## list()
**tolist**(a = 1)
## $a
## [1] 1
**tolist**(a = 1, b = 2)
## $a
## [1] 1
##
## $b
## [1] 2
```

这个参数本身有一些用途，因为它允许您编写一个调用其他函数的函数，并且您可以提供这些函数参数，而无需显式传递它们。这对一般函数(我们将在下一章讨论)和在函数操作符中修改函数特别重要。

你可以用函数操作符做的大部分事情超出了本书的范围，所以如果你有兴趣了解更多，你应该查看 Hadley Wickham 的*高级 R 编程*书中关于它们的章节(参见 http://adv-r.had.co.nz/Function-operators.html[)。](http://adv-r.had.co.nz/Function-operators.html)

这里我们将有一个快速的第二个例子，取自*高级 R 编程*，它修改了一个函数。它包装了一个函数来记录运行时间。

以下函数将函数 f 包装到一个函数中，该函数对其计时并返回时间使用情况，而不是函数的结果。它对任何函数都有效，因为它只是将我们创建的闭包中的所有参数传递给我们包装的函数(尽管错误轮廓会有所不同，因为包装函数将接受任何命名的参数，而原始函数 f 可能不允许)。

```py
time_it <- function(f) {
  **force**(f)
  function(...) {
    **system.time**(**f**(...))
  }
}
```

你可以这样试试:

```py
ti_mean <- **time_it**(mean)
**ti_mean**(**runif**(1e6))
##    user  system elapsed
##   0.025   0.002   0.026
```

## 练习

尝试以下练习，以便更好地理解本章中讨论的概念。

### 在...之间

编写一个矢量化函数，它采用一个向量 x 和两个数字 lower 和 upper，并用 NA 替换 x 中小于 lower 或大于 upper 的所有元素。

### 应用 _ 如果

考虑在本章中实现的函数 apply_if。这里我们使用了一个循环。请使用过滤器和映射来实现它。

对于我们在示例中使用的特定实例:

```py
**apply_if**(v, function(x) x %% 2 == 0, function(x) x^2)
```

我们只有矢量化的函数。使用矢量化表达式重写此函数调用。

### 力量

我们之前是这样定义通用幂函数以及正方形和立方体实例的:

```py
power <- function(n) function(x) x^n
square <- **power**(2)
cube <- **power**(3)
```

如果您改为这样定义:

```py
power <- function(x, n) x^n
```

那么你如何定义正方形和立方体呢？

### 行和列总和

使用 apply 编写 rowsum 和 colsum 函数，分别计算矩阵的行和与列和。

### 又是阶乘

写一个矢量化阶乘函数。它应该接受一个向量作为输入，并计算向量中每个元素的阶乘。

尝试创建一个能够记住已经计算过的阶乘的版本，这样就不需要重新计算阶乘了(当然，不需要使用缓存函数)。

### 功能组成

对于两个函数 *f* 和 *g* ，函数组合创建了一个新函数 *f* ∘ *g* ，使得(*f*∘*g*)(*x*)=*f*(*g*(*x*)。

R 中没有这方面的操作符，但是您可以自己创建。为了避免与外部乘积运算符%o%冲突，称它为%。%.

实现该运算符。

例如，使用这个操作符，您应该能够一劳永逸地将 Map 和 unlist 结合起来，以获得 unlist 的函数(Map(...))模式

```py
uMap <- unlist %.% Map
```

因此，这个函数的工作方式完全类似于首先调用 Map，然后取消列表:

```py
plus <- function(x, y) x + y
**unlist**(**Map**(plus, 0:3, 3:0))
## [1] 3 3 3 3
**uMap**(plus, 0:3, 3:0)
## [1] 3 3 3 3
```

有了它，您可以通过将其他函数串在一起来构建函数(这与您在 magrittr 中创建流水线的方式类似，参见[https://cran . r-project . org/web/packages/magrittr/vignettes/magrittr . html](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html))。

例如，可以这样计算均方根误差函数:

```py
error <- function(truth) function(x) x - truth
square <- function(x) x^2

rmse <- function(truth)
  sqrt %.% mean %.% square %.% **error**(truth)

mu <- 0.4
x <- **rnorm**(10, mean = 0.4)
**rmse**(mu)(x)
## [1] 0.8976526
```

像这样组合一系列函数需要从右到左阅读操作，所以我个人更喜欢 magrittr 的方法，但你可以看到相似之处。

# 脚注

[1](#Fn1_source) 所以这是一个以向量为输入，但输出单个值的函数的情况；它不是我们之前讨论过的矢量化函数。

根据你对一个对象的看法，T2 是有可能做到的。你可以通过在函数范围内给局部变量赋值来修改闭包，就像你上周看到的那样。这是因为名称空间是可以更改的对象。R 中的一个面向对象系统——RC——也允许可变对象，但是我们不会在本书中讨论 RC。一般来说，你最好认为每个对象都是不可变的，你所做的任何修改实际上都是在创建一个新的对象，因为一般来说，这就是正在发生的事情。