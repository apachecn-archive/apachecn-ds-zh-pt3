托马斯 mailund 2017 年

Thomas Mailund,《在 R 开始数据科学》, 10.1007/978-1-4842-2671-1_10

# 10.面向对象编程

Thomas Mailund <sup class="calibre6">1</sup> 的缩写形式

①丹麦奥胡斯

本章着眼于 R 风格的面向对象编程。实际上，R 有三种不同的面向对象编程系统:S3、S4 和 RC。我们只看 S3，它是最简单的，也是(我相信)应用最广泛的。

## 不可变对象和多态函数

S3 的面向对象与你在 Java 或 Python 中看到的截然不同。自然如此，因为 R 中的数据是不可变的，而在 Java 和 Python 等语言中，面向对象的底层模型是你拥有带状态的对象，你可以调用方法来改变状态。S3 没有这样的国家。你有不变的对象。就像 r 中的所有其他数据一样。

如果我们没有对象状态，那么有面向对象的意义何在？我们从 S3 系统中得到的是多态函数，在 r 中称为“泛型”函数。这些函数的功能取决于对象的类，类似于 Java 或 Python 中的方法，在类中定义的方法可以在子类中更改以优化行为。

你可以定义一个多态的函数 foo，然后定义专门的函数，比如说 foo。A 和 foo.B .然后在 A 类的对象 x 上调用 foo(x)实际上会调用 foo。A(x)和来自类 B 的对象实际上会调用 foo。B(x)。福这个名字。a 和 foo。正如您将看到的，b 在这里不是随机选择的，因为正是您如何命名函数决定了调用哪个函数。

我们没有带有状态的对象；我们只是有一个机制来使一个函数依赖于一个对象所拥有的类。这通常被称为“动态分派”或“多态方法”。这里当然，因为我们没有状态，我们可以称之为多态函数。

## 数据结构

然而，在我们开始制作实际的类和对象之前，我们应该先看看数据结构。我们在第 [1](01.html) 章和第 [8](08.html) 章讨论了 R 中的各种内置数据结构。那些内置的数据类型是 R 中数据的基本构建块，但是我们从来没有讨论过如何从它们构建更复杂的东西。

比任何面向对象系统更重要的是将相关的数据保存在一起，这样我们就可以把它作为一个整体来对待。如果我们正在处理几个以某种方式属于一起的数据，我们不希望它分散在几个不同的变量中，也许在不同的范围中，在那里我们很少有机会保持它的一致性。即使是不可变的数据，保存不同变量引用的数据也是一场噩梦。

因此，对于我们分析的数据，我们通常将其保存在数据框中。这是一个将数据放在一起的简单想法。我们正在处理的所有数据都在同一个数据框架中，我们可以使用该数据框架调用函数，并知道它们正在以一致的状态获取所有数据。至少我们可以保证数据帧的一致性；我们不能保证数据本身没有被搞乱，但是我们可以在假设数据框架以某种方式运行的情况下编写函数。

像合身的模型怎么样？如果我们用一个模型来拟合一些数据，那么这个拟合就是存储的变量捕获的拟合。我们当然希望在处理模型时将它们放在一起，因为我们不希望意外地使用适合两个不同模型的混合变量。我们可能还希望将其他数据与拟合的模型保存在一起——例如，一些关于实际拟合的信息——如果我们希望稍后在 R shell 中检查这些信息的话。或者它所适合的数据。

我们收集异构数据作为单个对象的唯一选择是列表。这就是你在 r 中的做法

### 示例:贝叶斯线性模型拟合

项目二，在本书的最后一章描述，关注贝叶斯线性模型。为了表示这一点，我们将把模型的数据包装在一个列表中。为了拟合数据，假设你有一个类似这里描述的函数(有关数学的细节，请参考第 [9](09.html) 章)。

它采用公式形式的模型规范作为其参数模型，并采用先验精度α和数据β的“精度”。然后，它计算模型拟合数据的均值和协方差矩阵。第 [9](09.html) 章解释了代码背后的数学原理。然后，它将拟合的模型与一些相关数据(用于拟合模型的公式和模型拟合中使用的数据(这里假设在变量框架中))包装在一起，并将它们放入函数返回的列表中。

```
blm <- function(model, alpha = 1, beta = 1, ...) {

*# Here goes the mathematics for computing the fit.* 
    frame <- **model.frame**(model, ...)
    phi <- **model.matrix**(frame)
    no_params <- **ncol**(phi)
    target <- **model.response**(frame)

    covar <- **solve**(**diag**(alpha, no_params) +
                   beta * **t**(phi) %*% phi)
    mean <- beta * covar %*% **t**(phi) %*% target

    **list**(formula = model,
         frame = frame,
         mean = mean,
         covar = covar)
}
```

您可以通过模拟一些数据并调用函数来查看它的运行情况:

```
*# fake some data for our linear model* 
x <- **rnorm**(10)
a <- 1 ; b <- 1.3
w0 <- 0.2 ; w1 <- 3
y <- **rnorm**(10, mean = w0 + w1 * x, sd = **sqrt**(1/b))

*# fit a model* 
model <- **blm**(y ∼ x, alpha = a, beta = b)
model
## $formula
## y ∼ x
##
## $frame
##             y           x
## 1   5.9784195  1.73343698
## 2   0.5044947 -0.45442222
## 3  -3.6050449 -1.47534377
## 4   1.7420036  0.81883381
## 5  -0.9105827  0.03838943
## 6  -3.1266983 -1.14989951
## 7   5.9018405  1.78225548
## 8   2.2878459  1.29476972
## 9   1.0121812  0.39513461
## 10 -1.7562905 -0.72161442
##
## $mean
##                  [,1]
## (Intercept) 0.2063805
## x           2.5671043
##
## $covar
##             (Intercept)           x
## (Intercept)  0.07399730 -0.01223202
## x           -0.01223202  0.05824769
```

它将模型的相关数据收集在一个列表中，因此我们总是知道我们正在处理属于一起的值。这使得对拟合模型*的进一步分析更加容易编程。*

## 班级

当我们写下:

```
model
```

如果我们在一个列表上调用 print 函数。它只是向我们显示列表中包含的所有内容。然而，print 函数是多态函数的一个例子，所以当您在对象 x 上调用 print(x)时，行为取决于对象 x 的*类*。

如果你想知道一个对象有什么类，你可以使用 class 函数:

```
**class**(model)
## [1] "list"
```

如果你想改变它，你可以使用类

```
**class**(model) <- "blm"
```

您可以为类使用任何名称；在这里，我使用了贝叶斯线性模型的 blm。

按照惯例，我们通常将类和创建该类元素的函数命名为相同的名称，因此由于我们使用 blm 函数创建这种类型的对象，惯例要求我们也调用对象的类 blm。不过这只是一个约定，你可以给这个类起任何名字。

我们总是可以用这种方式给一个对象分配一个类，但是改变一个现有对象的类被认为是不好的方式。我们将属于同一类的数据保存在一个列表中，以确保数据的一致性，但是我们希望为类提供的功能与数据一样是类的一部分，因此我们还需要确保对给定类的对象进行操作的函数总是获得与该类一致的数据。如果我们随意改变对象的类别，我们就做不到这一点。

创建对象的函数应该分配类，然后我们应该不去管对象的类。我们可以用 class

```
blm <- function(model, alpha = 1, beta = 1, ...) {

*# stuff happens here...* 

  object <- **list**(formula = model,
                 frame = frame,
                 mean = mean,
                 covar = covar)
  **class**(object) <- "blm"
  object
}
```

该类由对象的属性表示；但是，有一个函数可以为我们设置这些，叫做 structure，使用它我们可以同时创建对象和设置类，这样会好一点。

```
blm <- function(model, alpha = 1, beta = 1, ...) {

*# stuff happens here...* 

  **structure**(**list**(formula = model,
                 frame = frame,
                 mean = mean,
                 covar = covar),
            class = "blm")
}
```

现在我们给了模型对象一个类，让我们再打印一次。

```
model
## $formula
## y ∼ x
##
## $frame
##             y           x
## 1   5.9784195  1.73343698
## 2   0.5044947 -0.45442222
## 3  -3.6050449 -1.47534377
## 4   1.7420036  0.81883381
## 5  -0.9105827  0.03838943
## 6  -3.1266983 -1.14989951
## 7   5.9018405  1.78225548
## 8   2.2878459  1.29476972
## 9   1.0121812  0.39513461
## 10 -1.7562905 -0.72161442
##
## $mean
##                  [,1]
## (Intercept) 0.2063805
## x           2.5671043
##
## $covar
##             (Intercept)           x
## (Intercept)  0.07399730 -0.01223202
## x           -0.01223202  0.05824769
##
## attr(,"class")
## [1] "blm"
```

与之前唯一的不同是，它在末尾添加了关于“class”属性的信息。它仍然只是打印对象中包含的所有内容。这是因为我们还没有告诉它区别对待任何 blm 类的对象。

## 多态函数

打印函数是一个多态函数。这意味着调用它时会发生什么取决于它的第一个参数的类。当我们调用 print 时，R 将获得对象的类，假设它是 blm，就像我们的情况一样，看看它是否可以找到一个名为 print.blm 的函数，如果可以，那么它将使用您调用 print 时使用的参数来调用这个函数。如果不能，它将尝试查找函数 print.default 并调用它。

我们还没有为 blm 类定义打印函数，所以我们看到了默认打印函数的输出。

让我们尝试定义一个特定于 blm 的打印函数。

```
print.blm <- function(x, ...) {
  **print**(x$formula)
}
```

这里，我们只是告诉它打印我们用于指定模型的公式，而不是我们放入列表中的全部数据集合。

如果我们现在打印模型*，结果是这样的:*

 *```
model
## y ∼ x
```

这就是提供您自己的特定于类的打印功能是多么容易。一般来说，定义你自己的特定于类的多态函数是多么容易。您只需获取函数名并追加。类名，如果你用这个名字定义了一个函数，那么当你用这个类在一个对象上调用一个多态函数时，这个函数就会被调用。

不过，有一件事你必须小心，那就是函数的接口。我指的是函数的参数(以及它们的顺序)。每个多态函数都有一些参数。你可以通过查看函数文档来了解这一点。

```
?print
```

在定义专用函数时，可以向函数中添加更多的参数，但应该定义为至少接受与通用函数相同的参数。如果您不这样定义它，r 不会抱怨，但是当有人调用函数时，假设它基于通用接口接受哪些参数，然后遇到您的特殊函数的实现，而该函数的行为方式不同，这必然会导致问题。不要那样做。实现您的函数，使其采用与泛型函数相同的参数。这包括对参数使用相同的名称。有人可能会为泛型函数提供命名参数，只有当您使用与泛型函数相同的名称调用参数时，这种情况才会发生。这就是为什么我们使用 x 作为 print.blm 函数的输入参数。

### 定义你自己的多态函数

要定义一个多态函数的特定于类的版本，你只需要用正确的名字写一个函数。如果你想定义你自己的多态函数，还有一点要做。然后，您还需要编写泛型函数——您将实际使用对象调用的函数，它负责将函数调用分派给特定于类的函数。

使用 UseMethod 函数可以做到这一点。一般函数通常会这样做，如下所示:

```
foo <- function(x, ...) **UseMethod**("foo")
```

您用泛型函数应该接受的参数指定一个函数，然后用要分派到的函数的名称调用 UseMethod。然后，它神奇地发现要调用哪个特定于类的函数，并将参数转发到那里。

当您编写泛型函数时，定义默认函数也是一种很好的方式。

```
foo.default <- function(x, ...) **print**("default foo")
```

这样，我们就可以用所有类型的对象调用这个函数。如果你不希望这样，一个安全的默认函数将会抛出一个错误。

```
**foo**("a string")
## [1] "default foo"
**foo**(12)
## [1] "default foo"
```

当然，有了泛型函数，我们可以像以前一样定义特定于类的函数。

```
foo.blm <- function(x, ...) **print**("blm foo")
**foo**(model)
## [1] "blm foo"
```

当通用函数以…作为参数时，可以向更专门化的函数添加更多的参数。一般函数会忽略额外的参数，但是被调用的具体函数可能会做一些事情。

```
foo.blm <- function(x, upper = FALSE, ...) {
  if (upper) {
    **print**("BLM FOO")
  } else {
    **print**("blm foo")
  }
}

**foo**("a string")
## [1] "default foo"
**foo**(model)
## [1] "blm foo"
**foo**("a string", upper = TRUE)
## [1] "default foo"
**foo**(model, upper = TRUE)
## [1] "BLM FOO"
```

## 类别层次结构

多态函数是面向对象编程的一个方面，另一个方面是继承。这是一种机制，用于从更通用的类中构建更专用的类。

思考这个问题的最佳方式是专业化水平。你有一些物品的一般类别，比如家具，在这个类别中有更具体的类别，比如椅子，在这个类别中还有更具体的物品类型，比如厨房椅子。厨房的椅子也是椅子，椅子也是家具。如果你能对*所有的*家具做些什么，那么你肯定也能对椅子做些什么。比如你可以放火烧家具；你可以点燃一把椅子。然而，事实并非如此，你能对椅子做的一切也能对所有家具做。你可以向不受欢迎的客人扔椅子，但你不能向他们扔钢琴。

这种专门化的工作方式是，你可以为一般类做一些操作。这些操作可以在这些类的所有实例上完成，包括那些真正是更专门化类的对象的实例。

这些操作可能不会做完全相同的事情——就像我们可以专门化 print，一个我们可以在所有的对象上调用的操作，来为 blm 对象做一些特殊的事情——但是有一些有意义的方法来做这些操作。通常一个类被专门化的方式就是执行一个操作，这个操作可以被通用类中的所有对象执行，但只是以一种更专门化的方式。

然而，专用类可以做更多的事情，因此它们可能有更多对它们有意义的操作。那很好。只要我们能像对待更一般类的对象一样对待一个特殊类的所有对象。

这种专门化部分是接口，部分是实现。

### 作为接口的专门化

接口是我们可以在给定类的对象上调用的函数。它是一种我们如何与类的对象交互的协议。如果我们想象一些“拟合模型”的一般类别，我们可能指定对于所有模型，我们应该能够获得拟合参数，并且对于所有模型，我们应该能够对新值进行预测。在 R 中，存在这样的函数，称为 coef 和 predict，任何模型都应该实现它们。

这意味着我可以通过这些通用的模型函数编写与合适的模型交互的代码，只要我坚持使用它们提供的接口，我就可以在任何类型的模型上工作。如果在某个时候，我发现我想用决策树回归模型替换线性回归模型，我只需插入一个不同的拟合模型，并通过相同的多态函数与之通信。当我调用通用函数 coef 和 predict 时，实际调用的函数当然会不同，但接口是相同的。

r 不会为您强制这样的接口。R 中的类的类型不同于它们在 Java 中的类型，例如，在 Java 中，将某个对象声明为满足某个接口的对象是一种类型错误，如果它实际上不满足某个接口。r 不在乎。除非你调用一个不存在的函数。当然，你可能会有麻烦。但是，实现一个接口来适应您认为您的类应该匹配的类或协议的种类，这取决于您。

如果你实现了某个接口期望的函数(这些函数实际上做了一些类似于接口期望函数做的事情，而不仅仅是命名为相同的事情)，那么你就拥有了这个接口的专门化。您可以执行与实现该接口的其他类相同的操作，但是当然，您的操作只适合您的实际类。

您可以实现更多的函数，使您的类比更一般的对象类更有能力，但这也很好。其他类也可能实现这些操作，所以现在您有了不止一个具有更专门化操作的类——一个更通用并且可以进一步专门化的新类别。

你有一个类的层次结构，由它们提供的函数定义。

### 实现专业化

通过提供通用或更专门化的接口来专门化——在 R 的情况下，通过提供多态函数的实现——是面向对象编程中类层次概念的基本特征。它让你把不同种类的对象当作一个更通用的类。

然而，类层次结构的另一个方面与代码重用有关。当然，通过提供处理对象的接口，您已经得到了很多，因为您可以编写在通用接口上工作的代码，然后在实现该接口的所有对象上重用它。但是当你构建一个类的层次结构，从抽象的、一般的类到更特殊的、更具体的类时，你会得到另一种类型的重用。当你专门化一个类时，你是在获取更抽象的类的现有功能，并定义一个新的类，它实现相同的接口*，除了*有一些不同之处。

当您以这种方式细化一个类时，您不希望在其接口中实现所有多态函数的新版本。他们中的许多人会做与他们更一般的类的实现完全相同的事情。

假设你想要一个可以调用 foo 和 bar 函数的对象类。您可以将该类称为 A，并将其定义如下:

```
foo <- function(object, ...) **UseMethod**("foo")
foo.default <- function(object, ...) **stop**("foo not implemented")

bar <- function(object, ...) **UseMethod**("bar")
bar.default <- function(object, ...) **stop**("bar not implemented")

A <- function(f, b) **structure**(**list**(foo = f, bar = b), class = "A")
foo.A <- function(object, ...) **paste**("A::foo ->", object$foo)
bar.A <- function(object, ...) **paste**("A::bar ->", object$bar)

a <- **A**("qux", "qax")
**foo**(a)
## [1] "A::foo -> qux"
**bar**(a)
## [1] "A::bar -> qax"
```

为了进一步完善，您可能希望改变 bar 的工作方式，并添加另一个名为 baz 的函数:

```
baz <- function(object, ...) **UseMethod**("baz")
baz.default <- function(object, ...) **stop**("baz not implemented")

B <- function(f, b, bb) {
  a <- **A**(f, b)
  a$baz <- bb
  **class**(a) <- "B"
  a
}

bar.B <- function(object, ...) **paste**("B::bar ->", object$bar)
baz.B <- function(object, ...) **paste**("B::baz ->", object$baz)
```

我们想让 foo 函数保持原样，但是如果我们像这样定义类 B，在 B 对象上调用 foo 会给我们一个错误，因为它将调用 foo.default 函数。

```
b <- **B**("qux", "qax", "quux")
**foo**(b)
## Error in foo.default(b): foo not implemented
```

这是因为我们没有告诉 R，我们认为 B 类是 A 类的一个特化。我们编写了构造函数——我们在其中创建对象的函数，函数 B——这样所有 B 对象都包含 A 对象中的数据。我们从来没有告诉 R，我们希望 B 对象也是 A 对象。

当然，我们可以通过定义 foo 来确保在 B 对象上调用的 foo 与在 A 对象上调用的 foo 行为相同。这对于单个函数来说不会有太多的工作，但是如果有许多多态函数作用于一个对象，我们就必须为它们实现 B 版本。繁琐且容易出错的工作。

如果有一种方法可以告诉 R，B 类实际上是 a 类的扩展，那就好了。对象的 class 属性不一定是字符串。它可以是字符串的向量。如果，对于 B 对象，我们说类首先是 B，其次是 A，像这样，

```
B <- function(f, b, bb) {
  a <- **A**(f, b)
  a$baz <- bb
  **class**(a) <- **c**("B", "A")
  a
}
```

然后在 B 对象上调用 foo——其中 foo。b 未定义—将调用 foo。a 作为第二选择，在默认为 foo 之前。default:

```
b <- **B**("qux", "qax", "quux")
**foo**(b)
## [1] "A::foo -> qux"
**bar**(b)
## [1] "B::bar -> qax"
**baz**(b)
## [1] "B::baz -> quux"
```

class 属性用于多态函数的方式是，R 将按照 class 属性的顺序查找附加了类名的函数。它找到的第一个将是被调用的那个，如果没有找到专用版本，它将使用。默认版本。当我们将 B 对象的类设置为向量 c(“B”，“A”)时，我们是在说 R 应该调用。b 函数，否则调用。一个功能。

这是一个非常灵活的系统，它允许你从不相关的类中实现多个继承，但是你这样做是有风险的。这种工作方式的语义——按照向量中的类名顺序搜索函数——如果这些向量变得太复杂，将运行的实际代码可能很难计算出来。

另一个简单的警告是:如果你给一个对象一个类的列表，你应该包括所有的类。如果你定义了一个新的类，C，作为 B 的特化，我们不能说它是 C 类的一个对象(“C”，“B”)，如果我们也希望它的行为像一个 A 对象。

```
C <- function(f, b, bb) {
  b <- **B**(f, b, bb)
  **class**(b) <- **c**("C", "B")
  b
}

c <- **C**("foo", "bar", "baz")
**foo**(c)
## Error in foo.default(c): foo not implemented
```

当我们在这里调用 foo(c)时，R 将依次尝试函数:foo。c，foo。唯一被定义的是最后一个，如果被调用，它会抛出一个错误。

所以我们在这里定义的是一个可以像 B 一样行为的对象，但是只在 B 和 A 的行为不同的情况下！我们的意图是 B 是 A 的一种特殊类型，所以每一个是 B 对象的对象我们也应该能够作为 A 对象对待。对于 C 对象来说这是行不通的。

我们在这里没有真正的类层次结构，不像在 Python、C++或 Java 这样的语言中那样。我们只有一个调用多态函数的机制，这里的语义只是通过在类属性向量中添加类名来寻找多态函数。你的意图很可能是你有一个类层次结构，A 是最一般的类，B 是最特殊的类，C 是最特殊的类，但这不是你告诉 r 的，因为你不能。您告诉 R 它应该如何寻找动态函数，并且通过代码，您告诉它寻找。首先是 c 函数，然后是。函数，你没有告诉它更多，所以下一步它将寻找。默认功能。不是。a 职能。它不知道这是你想让它看的地方。

但是，如果将它添加到 class 属性中，它将会工作:

```
C <- function(f, b, bb) {
  b <- **B**(f, b, bb)
  **class**(b) <- **c**("C", "B", "A")
  b
}

c <- **C**("foo", "bar", "baz")
**foo**(c)
## [1] "A::foo -> foo"
**bar**(c)
## [1] "B::bar -> bar"
**baz**(c)
## [1] "B::baz -> baz"
```

不过，从构造函数中创建的对象获取 class 属性会稍微好一点。如果在某个时候，您更改了从 B()构造函数返回的对象的 class 属性，您不希望必须更改扩展该类的所有类中的类向量。

```
C <- function(f, b, bb) {
  b <- **B**(f, b, bb)
  **class**(b) <- **c**("C", **class**(b))
  b
}
```

## 练习

尝试以下练习，以便更好地理解本章中讨论的概念。

### 形状

想象一下，我们需要为一个程序处理一些几何图形。这些可以是圆形、正方形、三角形等。我们需要知道形状的周长和面积。这些属性可以从形状的属性中计算出来，但是每个形状的计算方法是不同的。

所以对于我们的形状，我们希望(至少)有一个界面给我们两个功能:周长和面积。默认的函数，除了它是一个形状的事实之外，我们没有关于一个对象的其他信息，是没有意义的，所以应该产生一个错误(为此检查停止函数)，但是每个专门的形状应该实现这两个函数。

实现这个协议/接口和至少圆形和矩形的两个功能；当然，如果你想的话，可以有更多的形状。

### 多项式

编写一个允许你表示多项式对象的类。一个 *n* 次多项式的形式为*c*<sub class="calibre10">0</sub>+*c*<sub class="calibre10">1</sub>*x*+*c*<sub class="calibre10">2</sub>*x*<sup class="calibre6">2</sup>...+*c*<sub class="calibre10">*n*</sub>*x*<sup class="calibre6">*n*</sup>并且可以用 *n* +1 系数( *c* <sub class="calibre10">0</sub> ， *c* <sub class="calibre10">1</sub> ，…， *c* <sub class="calibre10">*n*</sub> )来表示。编写接口，这样你就可以在任意点 *x* 计算多项式，也就是用一个函数 evaluate_polynomial(poly，x)计算多项式在 x 点的值。

函数 uniroot(内置于 R 中)可以让你找到一个普通函数的根。用它来写一个函数，找到你的多项式的根。这个函数的工作原理是用数字寻找多项式为零的点。不过，对于直线和二次多项式，还是有解析解的。写出多项式的特例，这样在特例上调用求根函数就可以利用已知的解。

# 脚注

毕竟，当你是一名枪手时，与当你是一名艺术家时相比，画画的意义是非常不同的。*