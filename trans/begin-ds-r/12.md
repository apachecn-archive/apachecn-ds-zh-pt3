托马斯 mailund 2017 年

Thomas Mailund,《在 R 开始数据科学》, 10.1007/978-1-4842-2671-1_12

# 12.测试和包装检查

Thomas Mailund <sup class="calibre6">1</sup> 的缩写形式

①丹麦奥胡斯

没有测试，就很难保证你的代码能够工作。您可能在编写代码时通过用几个选择的参数调用函数来测试代码，但是要构建健壮的软件，您需要更严格地进行测试。为了防止错误随着时间的推移悄悄进入你的代码，你应该经常测试。理想情况下，你应该随时检查你所有的代码，无论你对它做了什么样的修改。

测试软件有不同的方式——软件测试本身几乎是一门科学——但是当我们想要确保我们刚刚编写的代码按预期工作时，我们所做的那种测试被称为*单元测试*。当我们想要确保代码的改变不会破坏任何东西时，我们所做的测试被称为*回归测试*。

## 单元测试

单元测试之所以被称为单元测试，是因为它测试功能单元——在 R 语言中，这实质上意味着单一功能或一些相关的功能。每当您编写新的功能单元时，您也应该为该单元编写测试代码。测试代码用于检查新代码是否真的如预期的那样工作，如果您编写的测试可以在以后自动运行，那么您同时也对单元进行了回归测试。无论何时你对你的代码做任何改变，你都可以运行你所有的自动化测试，这将检查每一个单元，并确保一切都像以前一样工作。

大多数程序员不喜欢写测试。编写新功能是令人兴奋的，但是探测新功能的错误就没那么有趣了。然而，你真的需要这些测试，并且你会很高兴你最终会接受这些测试。不要等到写完所有的函数之后再写测试。这是把最坏的留到最后，这不是激励你写测试的方法。相反，您可以在编写函数的同时编写单元测试；有些人甚至建议在编写函数之前编写它们*，这被称为*测试驱动编程*。这里的想法是，您编写测试来指定您的函数应该如何工作，并且您知道当您的函数通过您为它编写的测试时，它会按预期工作。*

我从来没有发现测试驱动编程对我自己有用。这不符合我的工作方式，因为我喜欢在实现一个函数时探索它的不同接口和用法，但有些人更喜欢这样工作。然而，我*做*，将我的测试与我的编程结合起来，我写小脚本调用我的函数，并在我试验这些函数时将它们组合在一起。我编写代码的方式使我能够轻松地进行实验，然后在以后将它们用作自动化测试。

以我们之前做的形状练习为例，你必须编写函数来计算不同形状的面积和周长。我写了一个版本，其中我指定的宽度和高度的矩形。 [<sup class="calibre6">1</sup>](#Fn1) 对两个函数的测试可能是这样的:

```py
area <- function(x) **UseMethod**("area")
circumference <- function(x) **UseMethod**("circumference")

rectangle <- function(width, height) {
    **structure**(**list**(width = width, height = height),
              class = **c**("rectangle", "shape"))
}
area.rectangle <- function(x) x$height * x$width
circumference.rectangle <- function(x) 2 * x$height + 2 * x$width
r <- **rectangle**(width = 2, height = 4)
**area**(r)
## [1] 8
**circumference**(r)
## [1] 12
```

面积是 2×4，周长是 2×2+2×4，所以这个看起来很好。但是我通过调用函数并查看打印输出来测试代码。我不想永远用这种方式测试功能——我不能用这种方式自动化我的测试，因为我必须坐下来看我的测试的输出。但它们是可以的测试。我只需要将它们自动化。

### 自动化测试

自动化测试所要做的就是检查代码中函数的结果，而不是查看它，所以类似下面的代码就是自动化测试:

```py
r <- **rectangle**(width = 2, height = 4)
if (**area**(r) != 2*4) {
    **stop**("Area not computed correctly!")
}
if (**circumference**(r) != 2*2 + 2*4) {
    **stop**("Circumference not computed correctly!")
}
```

是的，这是多了一点代码，但本质上是相同的测试，这是我以后可以自动运行的。如果它没有报错，那么测试就通过了，一切正常。

你可以这样写你自己的测试。将它们放在一个名为 tests/(这是 R 期望测试所在的位置)的目录中，然后每当您想要检查代码的状态时，即每当您对代码进行修改时，运行这些测试。

每当您对包进行一致性检查时，tests/目录中的脚本也将自动运行(我们稍后会谈到)。当您在 RStudio 右侧的 Build 选项卡中单击 Check 或在 Build 菜单中选择 Check Package 时，就会发生这种情况，但它不仅仅是运行测试，因此它不是运行测试的最有效方式。

在 r 中有一些用于形式化这种类型测试的框架。使用这个框架，很容易运行测试(没有完整的包检查),也很容易以更结构化的方式编写测试——当然代价是为每个测试编写更多的代码。

### 使用测试

testthat 框架(参见[https://github.com/hadley/testthat](https://github.com/hadley/testthat))提供了编写单元测试的函数，并确保每个测试都在一个干净的环境中运行(这样你就不会因为打字错误之类的原因将一个测试中定义的函数泄露到另一个测试中)。它需要对您的描述文件和目录结构进行一些修改，但是您可以通过运行以下命令来自动进行这些调整:

```py
devtools::**use_testthat**()
```

这将 testthat 添加到建议包中，使目录 tests/testthat 和文件 tests/testthat.R。您可以查看该文件，但它并不那么有趣。它的目的是确保包测试——运行测试/目录中的所有脚本——也将运行所有测试。

testthat tests 应该都在 tests/the that 目录和文件名以 test 开头的文件中。否则，测试无法找到它们。测试被组织在上下文和测试中，以使运行测试的输出更具可读性——如果一个测试失败了，您不仅仅想要知道某个地方的某个测试失败了，您还想要一些关于哪个测试失败了以及失败在哪里的信息，这些信息是由上下文提供的。

在测试文件的顶部，您使用 context 函数设置了一个上下文。它只是给后面的一批测试起了个名字。这个上下文在测试过程中被打印出来，这样你可以看到测试是如何进行的，如果你为每个文件保留一个上下文，你可以看到哪些文件测试失败了。

下一级测试封装在对 test_that 函数的调用中。这个函数将一个字符串作为它的第一个参数，它应该描述被测试的内容。它的第二个论点是一个将被检验的陈述。该语句通常不止一条，在这种情况下，它会用{}括号括起来。

在测试语句的开始，您可以创建一些对象或测试所需的任何东西，然后您可以进行实际的测试。这里，testthat 还提供了一整套函数，用于测试值是否相等、几乎相等，表达式是否引发工作、触发错误等等。所有这些函数都以 expect_ 开头，你可以在 testthat 文档中查看它们的文档。

计算矩形面积和周长的测试在测试中会是这样的:

```py
**context**("Testing area and circumference")

**test_that**("we compute the correct area and circumference", {
  r <- **rectangle**(width = 2, height = 4)

  **expect_equal**(**area**(r), 2*4)
  **expect_equal**(**circumference**(r), 2*2 + 2*4)
})
```

尝试将这个测试添加到上一章练习中的 shapes 包中，看看效果如何。试着修改它来触发一个错误，看看它是如何工作的。

在测试数字的相等性时，尤其是当它们是浮点数时，你应该总是有点担心。计算机并不像数学对待实数那样对待浮点数。因为浮点数必须在有限的内存中表示，所以你得到的确切数字取决于你如何计算它，即使数学上两个表达式应该是相同的。

对于我们用矩形做的测试，这不太可能是一个问题。没有太多的方法来计算我们测试的两个量，我们*希望*得到准确的数字。但是圆的数量呢？

```py
circle <- function(radius) {
    **structure**(**list**(r = radius),
              class = **c**("circle", "shape"))
}
area.circle <- function(x) pi * x$r**2
circumference.circle <- function(x) 2 * pi * x$r
**test_that**("we compute the correct area and circumference", {
  radius <- 2
  circ <- **circle**(radius = radius)

  **expect_equal**(**area**(circ), pi * radius^2)
  **expect_equal**(**circumference**(circ), 2 * radius * pi)
})
```

这里我使用了内置的 pi，但是如果实现使用了其他东西呢？这里我们肯定是在处理浮点数，我们不应该测试是否完全相等。好消息是 expect_equal 没有。它在浮点不确定性的一定容差范围内测试相等性——这可以使用函数的附加参数来修改——所以一切正常。为了检查*精确的*相等，你应该使用函数 expect _ identical，但是通常你想要的是 expect_equal。

### 编写好的测试

为您的代码编写一些测试的最简单的方法是，在开发代码时进行实验，并立即将它们转换成这样的单元测试——或者甚至将您的检查放在单元测试文件中，以此开始。通过在编写功能的同时编写测试——或者至少在编写之后立即编写测试——您就不会积累大量未测试的功能(并且很难强迫自己在以后花费数小时来编写测试)。此外，在你编写函数并把它们放入测试文件并得到正式的单元测试时，并不需要花费太多的时间来进行非正式的测试。

如果这就是你所做的一切，至少你知道当你开发你的代码时被测试的功能在将来仍然存在，或者如果它在某个点中断了，你会得到警告，因为测试将开始失败。

如果你无论如何都要写测试，你可能会更系统化一点。我们总是倾向于检查常见的情况——我们在编写函数时想到的情况——而忘记特殊情况。然而，特殊情况经常是错误隐藏的地方，所以把它们放在你的单元测试中也是一个好主意。

特殊情况是诸如空向量和列表或空列表的情况。如果你实现一个以向量作为输入的函数，确保它在向量为空时也能工作。如果它不是函数要取的有意义的值，并且如果输入为空，您想不出一个合理的值来返回，请确保函数抛出一个错误，而不是仅仅做一些它不是设计用来做的事情。

对于数字，例外情况通常是零或负数。如果你的函数可以处理这些情况，那就太好了(但是一定要测试它！);如果他们不能处理这些特殊情况，抛出一个错误。

对于形状，具有非正的尺寸没有意义，所以在我的实现中，如果我得到了这个尺寸，我会引发一个错误，对矩形的测试可能如下所示:

```py
**test_that**("Dimensions are positive", {
  **expect_error**(**rectangle**(width = -1, height =  4))
  **expect_error**(**rectangle**(width =  2, height = -1))
  **expect_error**(**rectangle**(width = -1, height = -1))

  **expect_error**(**rectangle**(width =  0, height =  4))
  **expect_error**(**rectangle**(width =  2, height =  0))
  **expect_error**(**rectangle**(width =  0, height =  0))
})
```

当你开发你的代码和相应的单元测试时，*总是*稍微考虑一下可能的特殊情况，并确保你有选择如何处理它们的测试，这是一个好主意。

### 在测试中使用随机数

另一个好的测试方法是使用随机数据。对于我们手动设置的测试，我们倾向于避免病理病例，因为我们根本想不出来。随机数据没有这个问题。因此，在测试中使用随机数据会更有效，但是当然，这使得测试不可重复，这使得调试极其困难。

当然，您可以设置随机数生成器种子。这使得测试具有确定性和可重复性，但却违背了随机测试的初衷。

我真的没有很好的解决办法，但我有时会用这个技巧:我随机选取一个种子并记住它，然后设定这个种子。因为我现在知道了随机种子是什么，所以如果测试失败，我可以再次设置它，并从那里进行调试。

您可以通过将种子放在测试的名称中来保存它。如果测试失败，您可以从错误消息中获得种子。

```py
seed <- **as.integer**(1000 * **rnorm**(1))
**test_that**(**paste**("The test works with seed", seed), {
  **set.seed**(seed)
*# test code that uses random numbers* 
})
```

### 测试随机结果

当我们处理随机数时出现的另一个问题是函数返回的期望值应该是多少。如果函数不是确定性的，而是依赖于随机数，我们就不一定有预期的输出。

如果在这种情况下，我们所能做的只是用统计学来检验结果，那么这就是我们必须做的。如果一个函数在做一些有用的事情，它可能不是完全随机的，这意味着我们可以对它做一些测试，即使测试有时会失败。

作为一个玩具的例子，我们可以考虑通过抽样来估计一组数据的平均值。这是一个愚蠢的例子，因为在这个例子中，首先计算平均值可能要快得多，但不管怎样，让我们把它当作一个有趣的例子。

如果我们采样了 *n* 个元素，均值的标准差应该是![$$ s/\sqrt{n} $$](img/A439481_1_En_12_Chapter_IEq1.gif)，其中 *s* 是样本标准差。这意味着真实平均值和样本平均值之间的差值应分布为![$$ N\left(0, s/\sqrt{n}\right) $$](img/A439481_1_En_12_Chapter_IEq2.gif)。

在下面的代码中，我通过除以![$$ s/\sqrt{n} $$](img/A439481_1_En_12_Chapter_IEq3.gif)来归一化两个均值之间的距离，这样应该会使其分布为*Z*∩*N*(0，1)。然后，我选择了一个意义的阈值，这个阈值应该是千分之一。我实际上选择了一个只有两千分之一达到的值，但是我只测试了 *Z* 的正值，所以在分布的负端有另一个两千分之一的隐含值。

```py
seed <- **as.integer**(1000 * **rnorm**(1))
**test_that**(**paste**("Sample mean is close to true, seed", seed), {
  **set.seed**(seed)

  data <- **rnorm**(10000)
  sample_size <- 100
  samples <- **sample**(data, size = sample_size, replace = TRUE)

  true_mean <- **mean**(data)
  sample_mean <- **mean**(samples)

  standard_error <- **sd**(samples) / **sqrt**(sample_size)
  Z <- (true_mean - sample_mean) / standard_error
  threshold <- **qnorm**(1 - 1/2000)

  **expect_less_than**(**abs**(Z), threshold)
})
```

这项测试预计失败的概率为千分之一，但当结果实际上是随机的时，我们无法获得绝对的确定性。如果这个测试失败了一次，我不会担心它，但是如果我看到它失败了几次，它就不太可能只是侥幸，所以我会探索到底发生了什么。

## 检查包装的一致性

您可以通过在 RStudio 右侧的“构建”选项卡中单击“检查”,或者在“构建”菜单中单击“检查包”来执行包检查，运行您的单元测试并执行更多操作。

它调用一个脚本来运行大量的一致性检查，以确保您的包处于最佳状态。它验证你的所有功能都被记录在案，你的代码遵循一定的标准，你的文件在正确的目录中(并且没有不应该在 [<sup class="calibre6">2</sup>](#Fn2) 的文件)，所有必要的元信息都被提供，等等。在 http://r-pkgs.had.co.nz/check.html[的](http://r-pkgs.had.co.nz/check.html)检查包裹时，您可以查看更长的测试列表。

你应该试着检查一下你的包裹。它会写很多输出，最后，它会通知您发现了多少错误、警告和注释。

在输出中，每一个没有声明为正常的测试都是您应该研究的内容。这可能不是一个错误，但如果检查提出任何标志，你将不会被允许把它放在 CRAN。至少没有一个很好的借口。

## 锻炼

您已经编写了两个包——形状包和多项式包——现在您的练习是为它们编写单元测试，并让它们能够通过包检查。

# 脚注

我知道矩形不一定要有平行于这两个维度的边，但是没有必要把这个例子弄得比实际情况更复杂。

如果有，你应该看看. Rbuildignore。如果你有一个文件在你想要的地方，但检查是抱怨，你可以只添加文件名到。Rbuildignore，它就会停止抱怨。如果你有自述文件。例如，Rmd 文件，它可能会抱怨，但随后您可以添加一行到。rbuildignore 说^README.林吉特$。