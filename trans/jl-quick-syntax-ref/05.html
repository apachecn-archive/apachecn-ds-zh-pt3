<html lang="en">
<head><title>Input/Output</title>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<link href="../css/springer_epub.css" rel="styleSheet" type="text/css"/>
</head>
<body epub:type="chapter">
 
<!--Begin Abstract--><h1 class="ChapterTitle" lang="en">5.输入/输出</h1>

 
<!--End Abstract--><p>本章包括对以下第三方软件包的讨论:</p>
<table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"/>
<col class="tcol2 align-left"/>
<col class="tcol3 align-left"/>
</colgroup>
<thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">包名</p>
</th>
<th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">统一资源定位器</p>
</th>
<th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">版本</p>
</th>
</tr>
</thead>
<tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>CSV.jl</code></p>
</td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><a href="https://github.com/JuliaData/CSV.jl">T2<code>https://github.com/JuliaData/CSV.jl</code></a></p>
</td>
<td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>v0.5.11</code></p>
</td>
</tr>
<tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>HTTP.jl</code></p>
</td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><a href="https://github.com/JuliaWeb/HTTP.jl">T2<code>https://github.com/JuliaWeb/HTTP.jl</code></a></p>
</td>
<td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>v0.8.4</code></p>
</td>
</tr>
<tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>XLSX.jl</code></p>
</td>
<td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><a href="https://github.com/felipenoris/XLSX.jl">T2<code>https://github.com/felipenoris/XLSX.jl</code></a></p>
</td>
<td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>v0.5.4</code></p>
</td>
</tr>
<tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><code>JSON2.jl</code></p>
</td>
<td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><a href="https://github.com/quinnj/JSON2.jl">T2<code>https://github.com/quinnj/JSON2.jl</code></a></p>
</td>
<td style="text-align: left;"><p class="SimplePara"><code>v0.3.1</code></p>
</td>
</tr>
</tbody>
</table>

<p class="Para" id="Par3">Julia 中的输入/输出是这样实现的:首先选择合适的<code>IOStream</code>对象——一个文件、用户终端或网络对象——然后在该流上应用所需的函数。总体思路是打开流，执行所需的操作，然后关闭流。</p>
<p class="Para" id="Par4">关于用户终端，Julia 通过内置的<code>stdin</code>和<code>stdout</code>(最终还有<code>stderr</code> ) IO 流提供与它的交互。这些流已经打开，是输入和输出操作的默认流。</p>
<p class="Para" id="Par5">关于 web 资源，您目前仍然需要使用第三方软件包。我们将在本章中考虑<code>HTTP.jl</code>(参见<a href="https://github.com/JuliaWeb/HTTP.jl"> <code>https://github.com/JuliaWeb/HTTP.jl</code> </a>)。</p>
<h2 class="Heading">5.1 阅读(输入)</h2>
<h3 class="Heading">从终端读取</h3>
<p>
 
</p>
<ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par7"><code>aString = readline()</code>:读取用户在终端中键入的任何内容，直到按下<img alt="../images/477168_1_En_5_Chapter/477168_1_En_5_Figa_HTML.gif" src="../images/477168_1_En_5_Chapter/477168_1_En_5_Figa_HTML.gif" style="height:1.38em"/>。</p></li>
<li><p class="Para" id="Par8"><code>anInteger = parse(Int64, readline())</code>:读取用户在终端输入的数字。</p></li>
</ul>

<p class="Para" id="Par9">请注意，您很少会希望这样。Julia 是交互式的，您可以运行部分代码，或者直接从终端或正在使用的编辑器中更改变量。</p>
<p>不过，您仍然可以创建一个 Julia 脚本(如下例所示)并运行它(在 Julia 提示符中使用<code>julia myScript.jl</code>或<code>include("myScript.jl")</code>)。这将模仿经典的“脚本”行为，即用户运行一个脚本，但不能完全控制它，只能输入脚本请求的用户输入:</p>
<pre>println("Welcome to a Julia script\n\n")      JULIA

function getUserInput(T=String,msg="")
  print("$msg ")
  if T == String
      return readline()
  else
    try
      return parse(T,readline())
    catch
     println("Sorry, I could not interpret your answer. Please try again")
     getUserInput(T,msg)
    end
  end
end

sentence = getUserInput(String,"Which sentence do you want to be repeated?");
n = getUserInput(Int64,"How many times do you want it to be repeated?");
[println(sentence) for i in 1:n]
println("Done!")

</pre>
<p class="Para" id="Par11">请注意，在这段代码中，function 使用运行时异常来确保用户的响应与您想要的类型兼容。你将在第 8 章中了解更多关于运行时异常的内容。</p>

<h3 class="Heading">从文件中读取</h3>
<p class="Para" id="Par12">在 Julia 中，文件读取(以及，您将看到，写入)与其他语言相似。您打开文件，指定模态(<code>r</code>，代表“阅读”)，将文件绑定到一个对象，对对象进行操作，并在完成后使用<code>close()</code>。</p>
<p class="Para" id="Par13">一个更好的替代方法是将文件操作封装在一个<code>do</code>块中，当块结束时自动关闭文件。</p>
<p>
 
</p>
<ul class="UnorderedListMarkBullet"><li>一次读取整个文件:<pre>open("afile.txt", "r") do f    # "r" for reading      JULIA
  filecontent = read(f,String) # Note that it can be used only once. If used a second time, without
reopening the file, read() would return an empty string
  # ... do what you want with the file content ...
end

</pre></li>
<li>Reading a file line by line: 
<pre>open("afile.txt", "r") do f      JULIA
  for ln in eachline(f)
    # ... do what you want with the line ...
  end
end

</pre>
<p class="Para" id="Par16">这种方法甚至可以用于不适合内存的非常大的文件。</p></li>
<li>逐行读取文件并跟踪行号:<pre>open("afile.txt", "r") do f      JULIA
   for (i,ln) in enumerate(eachline(f))
     println("$i $ln")
   end
end

</pre></li>
</ul>

<h4 class="Heading">为矩阵导入数据</h4>
<p class="Para" id="Par18">您可以使用<code>readdlm()</code>(在标准库包<code>DelimitedFiles</code>中)将数据从文件导入矩阵。</p>
<p>您可以使用 slice 运算符跳过行和/或列，然后转换为所需的类型:</p>
<pre>myData = convert(Array{Float64,2},readdlm("myinputfile.csv",'\t')[2:end,4:end]); # Skip the first 1
row and the first 3 columns

</pre>

<h4 class="Heading">解析逗号分隔值(CSV)文件</h4>
<p>您可以使用<code>CSV.jl</code>包的<code>read</code>功能:</p>
<pre>myData = CSV.read(file; delim=';', missingstring="NA", decimal=',')

</pre>
<p class="Para" id="Par21"><code>read</code>支持一长串(大部分是不言自明的)选项:<code>delim</code>(对于制表符分隔的文件使用<code>\t</code>)<code>quotechar</code>、<code>openquotechar</code>、<code>closequotechar</code>、<code>escapechar</code>、<code>missingstring</code>、<code>dateformat</code>、<code>append</code>、<code>writeheader</code>、<code>header</code>、<code>newline</code>、<code>quotestrings</code>、<code>decimal</code>、<code>header</code>、<code>normalizenames</code>、<code>datarow</code>、<code>skipto</code>、<code>footerskip</code>、<code>limit</code>、<code>transpose</code>、<code>comment</code>、<code>comment</code></p>
<p class="Para" id="Par22">结果是一个<em class="EmphasisTypeItalic ">数据框架</em>(一种广泛使用的数据表格格式，你将在第<a href="10.html"> 10 章</a>中广泛了解)。除非使用了选项<code>header=false</code>，否则第一行将被解释为标题。</p>
<p class="Para" id="Par23">使用大量的初始行自动识别每个字段的类型，但有时这还不够。例如，在某些数据集中，您可能有一个所有值都缺失的字段，然后突然非缺失值很晚才出现在数据集中。当您试图用一些值填充字段时，这种情况会触发一个<code>TypeError</code>，因为它会被识别为类型<code>Missing</code>。</p>
<p class="Para" id="Par24">诀窍是用<code>types</code>参数手动指定列类型(一个向量或者一个字典，比如<code>types=Dict("myFieldFoo" =&gt; Union{Missing,Int64})</code>)。</p>
<p class="Para" id="Par25">虽然您在这里使用了<code>CSV.jl</code>包，但是您可能会对另一个更新的包感兴趣，这个包叫做<code>CSVFiles.jl</code>(参见<a href="https://github.com/queryverse/CSVFiles.jl"> <code>https://github.com/queryverse/CSVFiles.jl</code> </a>)，它允许您通过 URL 直接访问文件，或者如果文件是 gzipped 的话。</p>


<h3 class="Heading">5.1.3 从 Excel 导入数据</h3>
<p>使用 XLSX 软件包，您可以:</p>
<ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par27">获取工作表名称列表:<code>XLSX.sheetnames(XLSX.readxlsx("myExcelFile.xlsx"))</code></p></li>
<li><p class="Para" id="Par28">从给定的工作表中导入所有数据:<code>m = XLSX.readxlsx("myExcelFile.xlsx")["mySheet"][:]</code></p></li>
<li><p class="Para" id="Par29">导入特定时间间隔的所有数据:<code>m = XLSX.readxlsx("myExcelFile.xlsx")["mySheet"]["B3:D6"]</code>或<code>m = XLSX.readdata("myExcelFile.xlsx", "mySheet", "B3:D6")</code></p></li>
<li><p class="Para" id="Par30">将数据导入数据帧:<code>df = DataFrame(XLSX.readtable("myExcelFile.xlsx", "mySheet")...)</code></p></li>
</ul>

<p class="Para" id="Par31">最后一种方法值得解释一下。XLSX 通常以标准矩阵格式(<code>Array{T,2}</code>)导出数据。为了便于以 DataFrame 格式导出数据，提供了另一个函数<code>XLSX.readtable()</code>，它返回一个元组，其中第一个元素是列数据的向量(即<code>Array{Array{T,1},1}</code>)，元组的第二个元素是标题名称的向量。这种格式使用 splat 构造函数将元组分成两个独立的参数，允许您匹配 DataFrames 构造函数方法之一，即<code>DataFrame(data, headers)</code>。</p>
<p class="Para" id="Par32">如果您只想将工作表的一个范围导入到一个数据帧中，您可以在<code>readtable()</code>中指定您想导入的列作为第三个位置参数(如<code>B:D</code>)和从其导入的<code>first_row</code>。然而，在这一点上，你可能最好使用一个包，比如<code>ExcelFiles.jl</code>(见<a href="https://github.com/queryverse/ExcelFiles.jl"> <code>https://github.com/queryverse/ExcelFiles.jl</code> </a>)，它允许直接导入到<code>DataFrame</code>格式。</p>

<h3 class="Heading">5.1.4 从 JSON 导入数据</h3>
<p class="Para" id="Par33">JavaScript Object Notation (JSON)是一种通用的开放标准语言无关数据格式，它使用人类可读的文本(由属性-值对组成)来序列化和传输数据对象。</p>
<p class="Para" id="Par34">这里我呈现<code>JSON2.jl</code>包(<a href="https://github.com/quinnj/JSON2.jl"> <code>https://github.com/quinnj/JSON2.jl</code> </a>)。将数据读取或导出为 JSON 格式的其他常见选项有<code>JSON.jl</code> ( <a href="https://github.com/JuliaIO/JSON.jl"> <code>https://github.com/JuliaIO/JSON.jl</code> </a>)和<code>LazyJSON.jl</code> ( <a href="https://github.com/JuliaCloud/LazyJSON.jl"> <code>https://github.com/JuliaCloud/LazyJSON.jl</code> </a>)(特别是后者仅在需要时解析 JSON 文件，而不是一次解析所有文件。).</p>
<p>假设您在 Julia 中有以下 JSON 数据作为字符串，表示诺丁汉森林的摘录:</p>
<pre>jsonString="""      JULIA
{
     "species": "Oak",
    "latitude": 53.204199,
   "longitude": -1.072787,
       "trees": [
                 {
                    "vol": 23.54,
                    "id": 1
                 },
                 {
                    "vol": 12.25,
                     "id": 2
                 }
                ]
}
"""

</pre>
<p>有两种方法可以在程序中导入这些数据。第一种方法是使用<code>JSON2.read(jsonString, T)</code>，也就是将数据作为特定类型导入(必须已经定义好):</p>
<pre>struct ForestStand      JULIA
    sp::String
    lat::Float64
    long::Float64
    trees::Array{Dict{String,Float64},1}
end
nottFor = JSON2.read(jsonString, ForestStand)

</pre>
<p class="Para" id="Par37"><code>nottFor</code>将成为一个<code>ForestStand</code>对象。注意，在结构和导入的 JSON 数据中定义的字段名称不需要匹配。重要的是字段的顺序和类型。</p>
<p>第二种方法是不为导入的对象指定任何类型，如下所示:</p>
<pre>nottFor2 = JSON2.read(jsonString)

</pre>
<p class="Para" id="Par39"><code>nottFor2</code>将是一个<code>NamedTuple</code>，它的字段可以用普通的点符号访问，例如<code>nottFor2.trees[1].vol</code>。</p>

<h3 class="Heading">5.1.5 访问网络资源(HTTP)</h3>
<p class="Para" id="Par40">可以使用名为<code>HTTP.jl</code>(<a href="https://github.com/JuliaWeb/HTTP.jl"><code>https://github.com/JuliaWeb/HTTP.jl</code></a>)<sup><a epub:type="noteref" href="#Fn1" id="Fn1_source">1</a></sup>的第三方包，通过超文本传输协议(HTTP)访问 Web 资源。<code>HTTP.jl</code>包相当完整，包括服务器端。在这里，您只是看到了访问(读取)web 资源的基本方式。</p>
<p>首先，您可以使用<code>HTTP.jl</code>来提供一个流并对其进行操作，就像您处理本地文件一样:</p>
<pre>HTTP.open("GET", "https://julialang.org/") do io
# Note the SSLsupport      JULIA
    while !eof(io)
        println(String(readavailable(io)))
    end
end

</pre>
<p>或者，您可以对<code>get</code>方法使用更简洁的语法:</p>
<pre>res = HTTP.get("https://julialang.org/")      JULIA
println(String(res.body))

</pre>
<p class="Para" id="Par43">如果您需要做的只是从 web 资源中读取，那么第二种方法可能更简单。第一种方法的优点是，您可以同时打开其他流，并将一个流的内容重定向到另一个流。例如，您可以将流从远程视频重定向到本地播放器。</p>
<p>最后，您可以一起使用<code>CSV.jl</code>和<code>HTTP.jl</code>来访问和解析远程 CSV 文件:</p>
<pre>using HTTP, CSV      JULIA
resp = HTTP.request("GET", "https://cohesiondata.ec.europa.eu/resource/2q3n-nr7n.csv")
df = CSV.read(IOBuffer(String(resp.body)))

</pre>


<h2 class="Heading">5.2 书写(输出)</h2>
<h3 class="Heading">向终端写入</h3>
<p>要写入终端，可以使用<code>write(IO,T)</code>函数或<code>print(IO,T)</code>，使用内置的<code>stdout</code>(默认为<code>print</code>)或<code>stderr</code>流。</p>
<ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par46"><code>write(stdout, "Hello World");</code>:将<code>"Hello World"</code>字符串打印到终端。注意结尾的分号<code>;</code>。如果没有它，<code>write</code>方法也会输出字符串的大小。</p></li>
<li><p class="Para ParaOneEmphasisChild" id="Par47"><code>print("Hello World") ;</code></p></li>
<li><p class="Para" id="Par48"><code>println("Hello World")</code>:调用<code>print("Hello World")</code>，加一个换行符。</p></li>
</ul>

<p class="Para ParaTypeImportant" id="Par49"><img alt="../images/477168_1_En_5_Chapter/477168_1_En_5_Figb_HTML.gif" src="../images/477168_1_En_5_Chapter/477168_1_En_5_Figb_HTML.gif" style="width:1.69em"/> <em class="EmphasisTypeItalic ">书写 vs 打印</em></p>
<p class="Para ParaTypeImportant" id="Par50">这两个函数的主要区别在于，<code>write</code>输出对象的原始字节，而<code>print</code>输出对象的文本表示。已经为所有内置类型定义了这种表示，并且为自定义类型提供了默认值(与抛出<code>MethodError</code>的<code>write()</code>相反)。该默认值可通过覆盖<code>print()</code>进行修改:</p>
<p>
 
</p>
<pre>import Base.print # Needed when we want tooverride the print function      JULIA
struct aCustomType
    x::Int64
    y::Float64
    z::String
end
foo = aCustomType(1,2,"MyObj")



print(foo) # Output: aCustomType(1, 2.0, "MyObj")
println(foo) # Output: aCustomType(1, 2.0, "MyObj") + NewLine
write(stdout,foo) # Output: MethodError
function print(io::IO, c::aCustomType)
    print("$(c.z): x: $(c.x), y: $(c.y)")
end
print(foo) # Output: MyObj: x: 1, y: 2.0
println(foo) # Output: MyObj: x: 1, y: 2.0 + NewLine (no need to override also `println()``)

</pre>

<h3 class="Heading">写入文件</h3>
<p>写入文件类似于读取文件，但是在<code>open()</code>函数调用中使用了模态<code>w</code>(覆盖文件)或<code>a</code>(附加到现有数据)而不是<code>r</code>。当然，您还必须在 IO 对象上使用一个输出函数，如<code>write</code>或<code>print</code>:</p>
<pre>open("afile.txt", "w") do f # "w" for writing      JULIA
  write(f, "First line\n") # \n for newline
  println(f, "Second line") # Newline automatically added by println
end

</pre>
<p class="Para" id="Par53">如果您喜欢使用模式 open &gt; work on file &gt; close，而不是使用<code>do</code>块，请注意，只有当 IOStream 关闭或达到某个缓冲区限制时，操作才会刷新磁盘上的文件。</p>

<h3 class="Heading">5.2.3 导出到 CSV</h3>
<p class="Para" id="Par54">导出到 CSV 文件无疑比读取 CSV 文件简单，因为您不需要考虑无数可能的 CSV 选项，并且可以控制文件的格式。</p>
<p>您可以简单地循环遍历数据的行/列，并手动记下数据和分隔符。或者，您可以使用<code>CSV.write()</code>函数，它会为您完成这项工作:</p>
<pre>CSV.write("myOutputFile.csv", myData, delim=';', decimal='.', missingstring="NA")

</pre>
<p>当要导出的数据是一个数据帧时，这是现成的，但是对于一个标准矩阵(<code>Array{T,2}</code>)，您需要首先使用<code>Tables</code>包中的函数<code>Tables.table(Matrix)</code>将其转换成一个所谓的<code>MatrixTable</code>(参见<a href="https://github.com/JuliaData/Tables.jl"> <code>https://github.com/JuliaData/Tables.jl</code> </a>):</p>
<pre>CSV.write("myOutputFile.csv", Tables.table(myMatrix), delim=';', decimal='.', missingstring="NA", header=["field1","field2","field3"])

</pre>
<p class="Para" id="Par57"><code>write</code>支持以下选项:<code>delim</code>、<code>quotechar</code>、<code>openquotechar</code>、<code>closequotechar</code>、<code>escapechar</code>、<code>missingstring</code>、<code>dateformat</code>、<code>append</code>、<code>writeheader</code>、<code>header</code>、<code>newline</code>、<code>quotestrings</code>、<code>decimal</code>。</p>

<h3 class="Heading">将数据导出到 Excel</h3>
<p>写入 Excel 遵循在<code>do</code>块中打开文件并对其进行操作的常见模式。</p>
<pre>XLSX.openxlsx("myExcelFile.xlsx", mode="w") do xf# w to write (or overwrite) the file      JULIA
    sheet1 = xf[1] # One sheet is created by default
    XLSX.rename!(sheet1, "new sheet 1")
    sheet2 = XLSX.addsheet!(xf, "new sheet 2") # We can add further sheets if needed
    sheet1["A1"] = "Hello world!"
    sheet2["B2"] = [ 1 2 3 ; 4 5 6 ; 7 8 9 ] # Top-right cell to anchor the matrix
end

</pre>
<p>这段代码创建一个新文件(如果同名文件已经存在，它将被覆盖)。为了在不重写数据的情况下将数据“附加”到现有文件中，请使用<code>mode="rw"</code>:</p>
<pre>XLSX.openxlsx("myExcelFile.xlsx", mode="rw") do xf# rw to append to an existing file instead      JULIA
    sheet1 = xf[1] # One sheet is created by default
    sheet2 = xf[2]
    sheet3 = XLSX.addsheet!(xf, "new sheet 3") # We can add further sheets if needed
    sheet1["A2"] = "Hello world again!"
    sheet3["B2"] = [ 10 20 30 ; 40 50 60 ; 70 80 90 ] # Top-right cell to anchor the matrix
end

</pre>
<p class="Para" id="Par60">单个单元格可以接受<code>Missing</code>、<code>Bool</code>、<code>Float64</code>、<code>Int64</code>、<code>Date</code>、<code>DateTime</code>、<code>Time</code>和<code>String</code>的值。</p>
<p>如本例的最后一行所示，数组(<code>Array{T,1}</code>和<code>Array{T,2}</code>)被自动广播到各个单元格。对于其他数据结构，如数据帧，这是不正确的。正如 XLSX 提供了一个特定的函数来帮助导入数据帧一样，它也提供了一个函数来帮助导出数据帧。这个函数是<code>writetable</code>，其中要导出的数据由一个元组<code>(Array{Array{T,1},1}, Array{String})</code>给出，即数据列和字段名称。这种格式可以很容易地从数据帧中获得:</p>
<pre>XLSX.writetable("myNewExcelFile.xlsx", sheet1=( [ [1, 2, 3], [4,5,6], [7,8,9]], ["f1","f2","f3"] ), sheet2= (collect(DataFrames.eachcol(myDf)), DataFrames.names(myDf) ))

</pre>
<p class="Para" id="Par62">请注意，可以一次写入多个工作表，但是目标文件必须是新的(否则将会出现错误)。</p>

<h3 class="Heading">5.2.5 将数据导出到 JSON</h3>
<p class="Para" id="Par63">再次使用<code>JSON2.jl</code>包(<a href="https://github.com/quinnj/JSON2.jl"> <code>https://github.com/quinnj/JSON2.jl</code> </a>)并重用“从 JSON 导入数据”一节中定义的<code>nottFor</code>对象，只需使用<code>jsonString = JSON2.write(nottFor)</code>就可以将任何对象导出到 JSON。</p>
<p class="Para" id="Par64">返回的字符串是一个有效的 JSON 字符串，但是它被写成一行，并且用引号括起来。</p>
<p class="Para" id="Par65">要显示它的人类可读版本，可以使用由同一个包:<code>@pretty jsonString</code>提供的<code>@pretty</code>宏。</p>


<h2 class="Heading">5.3 其他专业 IO</h2>
<p>所有主要的数据存储格式都至少有一个 Julia 包允许你与它们交互。以下是部分列表(首先列出我的建议):</p>
<ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par67">XML: <code>EzXML.jl</code>(见<a href="https://github.com/bicycle1885/EzXML.jl"> <code>https://github.com/bicycle1885/EzXML.jl</code> </a>)和<code>LightXML.jl</code>(见<a href="https://github.com/JuliaIO/LightXML.jl"> <code>https://github.com/JuliaIO/LightXML.jl</code> </a>)</p></li>
<li><p class="Para" id="Par68">HTML(网页抓取):<code>Gumbo.jl</code>(见<a href="https://github.com/JuliaWeb/Gumbo.jl"> <code>https://github.com/JuliaWeb/Gumbo.jl</code> </a>)和<code>Cascadia.jl</code>(见<a href="https://github.com/Algocircle/Cascadia.jl"> <code>https://github.com/Algocircle/Cascadia.jl</code> </a>)</p></li>
<li><p class="Para" id="Par69">OpenDocument 电子表格格式(ODS): <code>OdsIO.jl</code>(参见<a href="https://github.com/sylvaticus/OdsIO.jl"> <code>https://github.com/sylvaticus/OdsIO.jl</code> </a>)</p></li>
<li><p class="Para" id="Par70">HDF5: <code>HDF5.jl</code>(参见<a href="https://github.com/JuliaIO/HDF5.jl"> <code>https://github.com/JuliaIO/HDF5.jl</code> </a>)</p></li>
</ul>


<aside class="FootnoteSection" epub:type="footnotes">Footnotes
<a href="#Fn1_source">1</a><p class="Para" id="Par8117">Julia 社区正在考虑将 HTTP.jl 迁移到 Julia 标准库。</p>

 

</aside>

</body>
</html>