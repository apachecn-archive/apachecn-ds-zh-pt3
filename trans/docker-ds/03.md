© Joshua Cook 2017 Joshua CookDocker for Data Science[https://doi.org/10.1007/978-1-4842-3012-1_3](03.html)

# 3.交互式编程

Joshua Cook<sup class="calibre5">1 </sup> (1)Santa Monica, California, USA  

> 交互式计算是人和机器之间的对话。—贝奇格林特[<sup class="calibre6">1</sup>T3】](#Fn1)

Jupyter is a web-based interactive application . Jupyter is a presentation environment. Jupyter is a new paradigm in programming. Jupyter is a way to save complex terminal sessions. All of this is to say that Jupyter is many things and, in this author’s humble opinion, one of the most exciting innovations in computing in recent years. Jupyter is fundamentally changing the way we write code. To be sure, Jupyter doesn’t replace vim, Sublime Text, or PyCharm. Jupyter replaces if __name__ == "__main__":.

## Jupyter 作为持久交互计算

We might see Jupyter as one part of a larger trend in the way we all engage with technology. We all actively interact with our computers every day. We pass a query to a search engine or to an online mapping tool and expect an immediate response. We change data in the cells and columns of a spreadsheet program and expect connected cells and columns to update instantaneously. We ask a voice interface in our connected home to dim the lights or play the latest pop song and expect immediate results. This is what we expect of our computers, and in this expectation it is easy to lose sight of the fact that this is fundamentally different from classical computer science.

### 如何不进行交互式编程

In order to illustrate the difference, it is useful to have a look at the C programming language . C is a descendent of Fortran and an ancestor of Python, all three of which live on today in practical everyday use. Many computational engineers do their work using Python and its computational libraries numpy and scipy, blissfully unaware of the fact that their core language is actually a high-level wrapper to C and their numerical libraries are actually high-level wrappers to the Fortran libraries BLAS and LAPACK. Never mind that they are totally unaware of what a development workflow looked like using C and BLAS. Until the somewhat recent advent of numpy, the computational engineer was forced to use a very different workflow. C is a compiled language. A functioning program, even one performing a simple mathematical calculation, requires considerable steps to bring it to life. Source code files must be written. This source code often includes references to header files existing elsewhere on the system. The code must be compiled into a binary including references to these header files and linked to any underlying compiled libraries used by the binary. Finally, the binary is executed, returning the results of the computation. We will briefly demonstrate how this process works on a trivial calculation using the [GNU Scientific Library](https://www.gnu.org/software/gsl/) (GSL). The GSL is a software library written in C used for computational mathematics. The GSL sits on top of a lower-level implementation of [BLAS](http://www.netlib.org/blas/) providing a layer of abstraction for ease in the development process.

### 建立一个最小的计算项目

As you are going to have more than one type of file to keep track of, it would behoove you to have a well-defined project directory. You first define a folder to hold your work, ch_3_minimal_comp, and three subdirectories, bin, docker, and src, to your compiled binaries, Dockerfile, and source code, respectively. Upon completing this, on a Unix-like system, you might use the command tree to display your project hierarchy. If you do not have tree installed, you can do so using brew, apt, yum, or another package manager (see Listing [3-1](#Par11)), depending upon your system. $ # change apt to brew, yum, or the appropriate package manager for your system $ apt install tree Listing 3-1.Install the Tree Next, in Listing [3-2](#Par13), you make the directories necessary to begin your project. This is followed by Listing [3-3](#Par14), in which you use the tree tool to display the project repository you have created. $ mkdir ch_3_minimal_comp ch_3_minimal_comp/bin ch_3_minimal_comp/src ch_3_minimal_comp/docker Listing 3-2.Make the Project Directories $ tree . └── ch_3_minimal_comp     ├── bin     ├── docker     └── src Listing 3-3.Display the Current State of Your Minimal Computational Project

### 编写贝塞尔函数求值的源代码

Next, you create a new file, bessel.c, to be stored in the src directory, containing your source code (see Listing [3-4](#Par16)). Note that it includes two include statements, references to external code files containing extended functionality you will use in this program, stdio.h and gsl/gsl_sf_bessel.h. You will need to explicitly tell your compiler how to handle these files using an include statement and a linking statement. // src/bessel.c #include <stdio.h> #include <gsl/gsl_sf_bessel.h> int main(void) {   double x = 5.0;   double y = gsl_sf_bessel_J0(x);   printf("J0(%g) = %.18e\n", x, y);   return 0; } Listing 3-4.Evaluation of the Zero-Order Bessel Function of the First Kind at x=5

### 使用 Docker 执行计算

The completion of this calculation will require two separate processes. You will need to compile your source code into a binary and then execute this binary. As before, you will let Docker manage these processes. You will do so using a docker image defined by the Dockerfile shown in Listing [3-5](#Par19). Note This image is built as an addition to the gcc image available on Docker Hub at [https://hub.docker.com/_/gcc/](https://hub.docker.com/_/gcc/) . FROM gcc LABEL maintainer=@joshuacook RUN apt-get update && \       apt-get install -y \       gsl-bin \       libgsl0-dbg \       libgsl0-dev \       libgsl0ldbl Listing 3-5.GSL Dockerfile You save this file as Dockerfile in your docker directory. After doing this, you again use the tree command to display the state of your project (Listing [3-6](#Par21)). $ cd ch_3_minimal_comp $ tree . ├── bin ├── docker  │   └── Dockerfile └── src     └── bessel.c Listing 3-6.Display the Current State of Your Minimal Computational Project You build the image for use with the docker build command. In your shell, you should currently be in the ch_3_minimal_comp directory. This is critical because your docker build command will make relative reference to a Dockerfile containing the definition of the image you wish to build. Here, you give the image a name via the -t flag, gsl. You specify that the build process should look for a Dockerfile within the relatively referenced directory docker. Listing [3-7](#Par23) shows the complete command executed. $ docker build -t gsl docker Sending build context to Docker daemon 2.048 kB Step 1/3 : FROM gcc latest: Pulling from library/gcc 693502eb7dfb: Already exists ... Status: Downloaded newer image for gcc:latest  ---> 408d218617ca Step 2/3 : MAINTAINER @joshuacook  ---> Running in 43a89bcd4fae  ---> 97faa5ea6f1e Removing intermediate container 43a89bcd4fae Step 3/3 : RUN apt-get update &&      apt-get install -y      gsl-bin      libgsl0-dbg      libgsl0-dev      libgsl0ldbl  ---> Running in 988614cb6d56 ... ---> 568814736d4b Removing intermediate container 988614cb6d56 Successfully built 568814736d4b Listing 3-7.Build the gsl Docker Image When the build completes, this image will be available for use globally. You can verify this via the docker images command (see Listing [3-8](#Par25)). $ docker images REPOSITORY      TAG         IMAGE ID          CREATED           SIZE gsl             latest      b3f3b5f49e4a      24 hours ago      1.52 GB ... Listing 3-8.Display Local Docker Images

### 编译你的源代码

Next, you compile your source code. To compile, you will use the following docker run outlined in Listing [3-9](#Par27). $ docker run \   -v 'pwd':/home \   gsl \   gcc \   -I /usr/include/ \   -L /usr/lib/ -lgsl -lgslcblas \   /home/src/bessel.c   -o /home/bin/bessel Listing 3-9.Compile the Bessel Function Binary This command instructs the Docker engine to

*   运行一个容器。
*   将当前工作目录(“pwd”)附加到容器中的位置/主目录。
*   使用 gsl 图像作为基础。

Note You make use of bash’s inline execution functionality via two backticks. Executing pwd prints your working directory (your current location). Running this in backticks substitutes your working directory in place. Thus, -v 'pwd':/home attaches your working directory to the directory /home in your docker container. Users interacting with the Docker engine using PowerShell, that is, Docker for Windows users, will need to use the alternative ${pwd} (e.g.  -v ${pwd}:/home). References to file locations are made relative to where they will be mounted within the container. The container will

*   运行单个进程，Gnu C 编译器，gcc。
*   包括对 gsl 头文件位置的引用(-I /usr/include/)。
*   链接 gsl 库(-L /usr/lib/ -lgsl -lgslcblas)。
*   使用/home/src/bessel.c 作为源代码。
*   将二进制输出(-o)到/home/bin/Bessel。

The process should complete very quickly. When the Docker engine attached your directory as a volume, a two-way connection was created. Because of this, the compiled binary is now present in your host machine’s file system. In Listing [3-10](#Par41), you once more display the state of your project using the tree tool. $ tree . ├── bin   │   └── bessel ├── docker   │   └── Dockerfile └── src     └── bessel.c Listing 3-10.Display the Current State of Your Minimal Computational Project

### 执行编译的二进制文件

Finally, you execute your compiled binary to retrieve the value of your calculation. Again, you must ask the Docker engine to manage this process for you, if for no other reason than that the binary was compiled to run on a gsl container. It is worth emphasizing this last point. You could be working through these exercises on literally any operating system and hardware configuration. You are working with Docker to abstract your work away from your specific configuration. This means, however, that your binary has not been compiled to run on your local hardware/software configuration. It has been compiled to run on a gsl Docker container defined by the gsl Docker image. In this case, it is compiled to run on debian:jesse. In Listing [3-11](#Par45), you execute your compiled binary using Docker. $ docker run -v 'pwd':/home gsl_image /home/bin/bessel J0(5) = -1.775967713143382642e-01 Listing 3-11.Execute the Bessel Function Binary But what if you wish to know the value at x=6 or x=7? In this case, you would need to go through the entire process once more: edit code, compile code, execute code. While there are significant advantages to writing code to run using the GSL, rapid iteration during the development cycle is not one of them and interaction is an impossibility. This entire process has been a demonstration of how not to code interactively.

## 如何交互式编程

Jump 30 years forward. Put that compiler down! Thanks to the work of pioneers like Travis Oliphant and Fernando Perez, on numpy and iPython, we can perform this trivial calculation in the way that it was meant to be performed: trivially. numpy (I say “num”-“pie” to my elders and “num”-“pee” to my peers) is short for numerical Python and provides us with a high-level wrapper to a lower-level implementation of BLAS. IPython is short for interactive Python and is a highly-evolved Python REPL (read-eval-print loop ) with a set of tools for interacting with any and all Python libraries. Note The reader should be careful not to confuse IPython, the command line REPL, and IPython Notebook, the legacy notebook server that has evolved into Jupyter.

### 使用 Docker 启动 IPython

Let’s perform this trivial calculation. In Listing [3-12](#Par50), you activate ipython using the jupyter/scipy-notebook Docker image. $ docker run -it jupyter/scipy-notebook ipython Python 3.5.2 |Continuum Analytics, Inc.| (default, Jul  2 2016, 17:53:06) Type "copyright", "credits" or "license" for more information. IPython 5.1.0 -- An enhanced Interactive Python. ?         -> Introduction and overview of IPython's features. %quickref -> Quick reference. help      -> Python's own help system. object?   -> Details about 'object', use 'object??' for extra details. Listing 3-12.Launch ipython Using the jupyter/scipy-notebook Image In Listing [3-13](#Par52), you perform the same calculation you performed earlier, although your process is not so elaborate. You first import the libraries necessary to evaluate a Bessel function in numpy, much as you imported the header files stdio.h and gsl/gsl_sf_bessel.h in your bessel.c file. Here, you import the special module from the scipy library. The special module contains a function called jv that is used to evaluate a “Bessel function of the first kind of real order and complex argument.” You pass the arguments (0,5), signifying that you wish to evaluate the zero-order function at 5. In [1]: import scipy.special as spc In [2]: spc.jv(0, 5) Out[2]: -0.17759677131433838 Listing 3-13.Evaluation of the Zero-Order Bessel Function of the First Kind at x=5 Performing these computations in an interactive REPL, your IPython environment, it is trivial to run the function twice more. This is interactive programming! In Listing [3-14](#Par54), you run the functions with the arguments (0,6) and (0,7). In [3]: spc.jv(0, 6) Out[3]: 0.15064525725099703 In [4]: spc.jv(0, 7) Out[4]: 0.30007927051955563 Listing 3-14.Evaluation of the Zero-Order Bessel Function of the First Kind at x=6 and x=7 Having perfomed all of the computations you set out to perform, you press Ctrl+D twice to exit. In doing so, you terminate the ipython process (being managed by your Docker daemon) and the container shuts down.

### 坚持

With that your process has died and your container has shut down. For your intents and purposes your work is lost forever. There is real power to interaction but not if we have to repeat everything we have done every time we step away and return. We could write a short Python module that performs these calculations and then use Python (via Docker) to execute the module. In Listing [3-15](#Par57), you write a short file named bessel.py that performs the same three computations you just performed interactively. import scipy.special as spc print(spc.jv(0, 5)) print(spc.jv(0, 6)) print(spc.jv(0, 7)) Listing 3-15.Three Bessel Function Calculations In Listing [3-16](#Par59), you once more display the state of your project using the tree tool. $ tree . ├── bin   │   └── bessel ├── docker   │   └── Dockerfile └── src     ├── bessel.c     └── bessel.py Listing 3-16.Display the Current State of Your Minimal Computational Project In Listing [3-17](#Par62), you execute your file, bessel.py. Note In order to run this, you must mount the directory containing your files as a volume to the location where the jupyter/scipy-notebook will look for files, in this case /home/jovyan. $ docker run -v 'pwd'/src:/home/jovyan/work jupyter/scipy-notebook python bessel.py -0.177596771314 0.150645257251 0.30007927052 Listing 3-17.Execute bessel.py Using Docker But now you are back to not programming interactively.

### jupyter 笔记型电脑

Jupyter Notebooks are the evolution of IPython. Jupyter allows users to combine live code, markdown- and latex-rich text, images, plots, and more in a single document. As the successor to the IPython notebook, Jupyter was renamed as the platform began to support other software kernels. Because it began with support for Julia, Python, and R, it was renamed as JuPyteR, though now the platform supports Scala, Haskell, and Ruby, amongst many others. A list of all kernels supported can be found at [https://github.com/jupyter/jupyter/wiki/Jupyter-kernels](https://github.com/jupyter/jupyter/wiki/Jupyter-kernels) . Henceforth, you will use Jupyter as your main interface for interactive programming.

#### 固执己见的码头工人

Jupyter provides [opinionated stacks](https://hub.docker.com/r/jupyter) for use in a variety of contexts: the [All Spark stack](https://hub.docker.com/r/jupyter/all-spark-notebook/), the [minimal stack](https://hub.docker.com/r/jupyter/minimal-notebook/), etc. We have already been using the [scipy stack](https://hub.docker.com/r/jupyter/scipy-notebook/). Let’s take a look at the [demo stack](https://hub.docker.com/r/jupyter/demo/). The demo stack can be tried immediately by visiting [https://try.jupyter.org](https://try.jupyter.org) and is a fully-functioning jupyter system with multiple kernels (Bash, Haskell, Julia, Python 2 and 3, R, Ruby, and Scala) preinstalled.

#### Jupyter 笔记本电脑服务器的安全性

One core best practice defined by the Jupyter Docker images maintained by the Jupyter Team is the generation of a security token at container runtime. As part of the run process, a new Jupyter container will generate and write to logs a token that must be passed as a query parameter or entered into the password field in order to interact with the system. This is only necessary the first time that Jupyter is loaded in the browser. The significance of this is that a Jupyter Noteook Server is safe from intruders should we wish to host it on the open web (as described in Chapter [1](01.html)). Listing [3-18](#Par68) demonstrates this by running the jupyter/scipy-notebook image in a new container on port 8888. $ docker run -p 8888:8888 jupyter/scipy-notebook ...  [I 18:53:31.565 NotebookApp] The Jupyter Notebook is running at: http://[all ip addresses on your system]:8888/?token=44dab68c1bc7b1662041853573f37cfa03f13d029d397816 [I 18:53:31.565 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). [C 18:53:31.566 NotebookApp]     Copy/paste this URL into your browser when you connect for the first time,     to login with a token:     http://localhost:8888/?token=44dab68c1bc7b1662041853573f37cfa03f13d029d397816 Listing 3-18.Run the jupyter/scipy-notebook Image The logs have displayed the token and generated an URL that can be copied and pasted into a browser. You can access the Jupyter Notebook Server by visiting either localhost (Listing [3-19](#Par70)) or the IP identified when you ran docker-machine followed by port 8888 (Listing [3-20](#Par70)). http://localhost:8888/?token=44dab68c1bc7b1662041853573f37cfa03f13d029d397816 Listing 3-19.Visiting Jupyter on localhost port 8888 with Provided Token http://192.168.99.100:8888/?token=44dab68c1bc7b1662041853573f37cfa03f13d029d397816 Listing 3-20.Visiting Jupyter on an IP at port 8888 with Provided Token Note The URL generated in the logs will always list the base URL as http://localhost:8888 even if the server is being run on a different IP and using a different port. You must modify the URL to reflect the proper IP and port in order to access your systems.

#### Jupyter Demo Stack

Let’s bring the Jupyter Demo Stack online in your local environment. If you are running Docker for Linux, Docker for Mac, or Docker for Windows, you will be able to access any exposed Docker containers by visiting http://localhost in a browser at the appropriate port. If you have been running the Docker daemon on a virtual machine (i.e. if you are running Docker Toolbox on Mac or Windows), you will need to get the IP of the virtual host and access your machine there instead. Typically, your Docker virtual machine will be named default. You can find this IP by using the docker-machine ip (see Listing [3-21](#Par74)). Just to reiterate, this is not necessary when using Docker for Linux, Docker for Mac, or Docker for Windows. Table [3-1](#Tab1) summarizes how you will access your system.Table 3-1.Accessing Your Docker System

<colgroup class="calibre18"><col class="calibre19"> <col class="calibre19"> <col class="calibre19"> <col class="calibre19"></colgroup> 
| 旧历法 | 码头系统 | 壳 | 访问 Jupyter，地址 |
| Linux 操作系统 | Linux 坞站 | 尝试 | 本地主机:8888 |
| MacOS >= 10.10.3 (Yosemite) | Mac 坞站 | 尝试 | 本地主机:8888 |
| MacOS >= 10.8(山地狮子) | Docker 工具箱 | 码头快速启动终端 | #DOCKERIP:8888 |
| Windows 10 专业版、企业版或教育版 | Windows | 命令行脚本语言 | 本地主机:8888 |
| Windows 7、8、8.1 或 10 家庭版 | Windows 工具箱 | 码头快速启动终端 | #DOCKERIP:8888 |

$ docker-machine ip default 192.168.99.100 Listing 3-21.Get the IP of Your Host Machine This signifies that the Docker host virtual machine is available at 192.168.99.100\. Your machine may be available at a different IP address. Note This command only needs to be run by host systems using Docker Toolbox. Systems running Docker for Linux, Docker for Mac, or Docker for Windows will be able to access their Jupyter Notebook server in browser using localhost.

#### 启动 jupyter/演示图像

To launch an image, you will first pull it from Docker Hub (see Listing [3-22](#Par79)). You could have done this implicitly via the run command but running it explicitly gives greater insight into what you are doing. $ docker pull jupyter/demo Using default tag: latest latest: Pulling from jupyter/demo ... Digest: sha256:d3dd87e52ca1edbfc8b65ad68bfa91f15eb0660d218c64fd5cdb039c1fa10818 Status: Downloaded newer image for jupyter/demo:latest Listing 3-22.Pull the Jupyter Demo from Docker Hub Having pulled the image, you run the image using the docker run command (see Listing [3-23](#Par81)). $ docker run -p 8888:8888 jupyter/demo [I 02:54:37.454 NotebookApp] Writing notebook server cookie secret to /home/jovyan/.local/share/jupyter/runtime/notebook_cookie_secret [W 02:54:37.537 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended. [I 02:54:37.580 NotebookApp] Serving notebooks from local directory: /home/jovyan/work [I 02:54:37.580 NotebookApp] 0 active kernels [I 02:54:37.580 NotebookApp] The Jupyter Notebook is running at: http://[all ip addresses on your system]:8888/ [I 02:54:37.580 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). Listing 3-23.Run the Jupyter Demo The vast majority of the output in Listing [3-23](#Par81) is output generated by the Jupyter application and written to the standard logger. As you are running the container in foreground mode , the output is written to your terminal. You may recall that earlier you attached your working directory to the directory /home/jovyan. You can see in the output here that this is the directory from which Jupyter is serving files: [I 02:54:37.580 NotebookApp] Serving notebooks from local directory: /home/jovyan/work Note Some legacy Jupyter images serve notebooks from the local directory, /home/jovyan/work. More recent Jupyter images serve notebooks from the local directory, /home/jovyan/. This will have some impact on your work in terms of the folder used to mount a local directory to a directory within the Jupyter container. If you always use -v 'pwd':/home/jovyan, then there should be no issues with accessing files or file persistence. It is worth emphasizing that local directory in this context refers to the local directory within the running Docker container.

#### jupiter 文件系统

Visiting the application in your browser, you first see the main Jupyter File System (Figure [3-1](#Fig1)).![A439726_1_En_3_Fig1_HTML.jpg](img/A439726_1_En_3_Fig1_HTML.jpg) Figure 3-1.The Jupyter file system You can launch a Jupyter file by clicking any of the files in the file system or launch a new file via the “New” menu in the upper right corner. Open the “Welcome to Python” file by clicking it. After a brief warning about using the file on the free hosting on Rackspace (which you can ignore because you are hosting it yourself), you see the barest of instructions on executing code in a Jupyter file in the first markdown cell (Listing [3-24](img/#Par89), Figure [3-2](#Fig2)).![A439726_1_En_3_Fig2_HTML.jpg](img/A439726_1_En_3_Fig2_HTML.jpg) Figure 3-2.Minimal instructions To run the code below: Click on the cell to select it. Press SHIFT+ENTER on your keyboard ... Listing 3-24.Run Some Python Code ! The next cell contains a block of Python (Listing [3-25](img/#Par91)), which you can execute by pressing Shift+Enter as instructed. The code generates a time series plot of random data (Figure [3-3](#Fig3)). Figure [3-4](#Fig4) shows the entire code and result in a Jupyter Notebook.![A439726_1_En_3_Fig3_HTML.jpg](img/A439726_1_En_3_Fig3_HTML.jpg) Figure 3-3. Random time-series data ![A439726_1_En_3_Fig4_HTML.jpg](img/A439726_1_En_3_Fig4_HTML.jpg) Figure 3-4.Try a Jupyter Python demo In [1]: %matplotlib notebook     import pandas as pd     import numpy as np     import matplotlib     from matplotlib import pyplot as plt     import seaborn as sns     ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))     ts = ts.cumsum()     df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index,     columns=['A', 'B', 'C', 'D'])     df = df.cumsum()     df.plot(); plt.legend(loc='best') Out[1]: <matplotlib.legend.Legend at 0x7f73cc716b38> Listing 3-25.Introduction to Python Close the Jupyter file by selecting File ➤ Close and Halt. This will terminate the kernel, an IPython process connected to your in-browser notebook, and close the browser window. You can shut down the Jupyter application by pressing Ctrl+C twice. This will terminate the jupyter notebook process being managed by Docker and thus shut the container down. ^C[I 03:10:32.463 NotebookApp] Interrupted... [I 03:10:32.464 NotebookApp] Shutting down kernels

### 端口连接

Let’s take a brief look at ports. You will also launch your container in detached mode via the -d flag (Listing [3-26](#Par96)). $ docker run -d -p 5000:8888 jupyter/demo 2040f677ad7ffa4666d0d9826e00175a15315ae2b2422314924f6022d6b65622 Listing 3-26.Run the jupyter/demo Image in Detached Mode In Listing [3-15](#Par57), you run the jupyter/demo image in detached mode, exposing port 8888 to port 5000\. You can access the machine by visiting localhost:5000 or 192.168.99.100:5000\. Because you ran the container in detached mode, the command returns the <container_id> of your container. As you are running the container in detached mode, the Jupyter logger’s output is not written to your terminal. You can access the output via the logs command. In order to obtain the randomly generated access token, you will need to do just this. In Listing [3-27](#Par99), you use the docker ps command to obtain the name of your container in order to access its logs. $ docker ps CONTAINER ID  IMAGE         COMMAND      PORTS                   NAMES 2040f677ad7f  jupyter/demo  "tini ..."   0.0.0.0:5000-\>8888/tcp furious_archimedes Listing 3-27.Display the Containers Currently Running Note that in addition to assigning the container a <container_id>, the Docker daemon also assigned a name, furious_archimedes. Names are randomly assigned, typically an adjective and the surname of a famous scientist. You can use this name to access the generated logs for your container (Listing [3-28](#Par101)). You will need to access the logs in order to obtain your access token. $ docker logs furious_archimedes [I 15:38:05.402 NotebookApp] Writing notebook server cookie secret to /home/jovyan/.local/share/jupyter/runtime/notebook_cookie_secret [W 15:38:05.455 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended. [I 15:38:05.471 NotebookApp] Serving notebooks from local directory: /home/jovyan/work [I 15:38:05.471 NotebookApp] 0 active kernels [I 15:38:05.471 NotebookApp] The Jupyter Notebook is running at: http://[all ip addresses on your system]:8888/?token=a7ae5855be48acdb99d12f06f03354cc0bede5a941f10d22 [I 15:38:05.472 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). [C 15:38:05.472 NotebookApp]     Copy/paste this URL into your browser when you connect for the first time, to login with a token:     http://localhost:8888/?token=a7ae5855be48acdb99d12f06f03354cc0bede5a941f10d22 ... Listing 3-28.Display Logs for a Container Running in Detached Mode

#### 端口映射

You can look at the port mappings for your container with the docker port command (Listing [3-29](#Par103)). This signifies that port 8888 on your container is mapped via the TCP protocol to port 5000 on the host machine (0.0.0.0). If you are running Docker on a virtual machine (i.e. if you are using Docker Toolbox), then access to this port will be at localhost with respect to the container. This is to say that it will have an IP on your system. You identified this IP earlier via docker-machine ip default where default was the name you assigned to your virtual machine. From the persepective of the Docker daemon you are accessing the container’s 8888 port via localhost:5000, but if you are running a virtual machine you are accessing it at 192.168.99.100:5000 (Figure [3-5](#Fig5)).![A439726_1_En_3_Fig5_HTML.jpg](img/A439726_1_En_3_Fig5_HTML.jpg) Figure 3-5.Accessing Jupyter via localhost $ docker port furious_archimedes 8888/tcp -\> 0.0.0.0:5000 Listing 3-29.Examine the Port of a Running Container

### Docker 中的数据持久性

Let’s consider persistence in Docker. To do this, you will do a quick exercise in Jupyter. The content is fairly basic and is used here solely to demonstrate persistence. Visit the Jupyter application in your browser. Once there, create a new Python file and run a basic calculation on that file. Listing [3-30](#Par105) is a simple snippet of code for generating a plot for a basic quadratic curve (Figure [3-6](#Fig6)). Figure [3-7](#Fig7) shows the entire code and result in a Jupyter Notebook.![A439726_1_En_3_Fig6_HTML.jpg](img/A439726_1_En_3_Fig6_HTML.jpg) Figure 3-6.A basic quadratic curve ![A439726_1_En_3_Fig7_HTML.jpg](img/A439726_1_En_3_Fig7_HTML.jpg) Figure 3-7.Generating a basic quadratic curve in a notebook In [1]: %matplotlib notebook         import numpy as np         import matplotlib.pyplot as plt In [2]: x = np.arange(1,10,1)         f = lambda x: x**2         y = f(x) In [3]: plt.plot(x,y) Out[3]: <matplotlib.lines.Line2D at 0x7f73cc269978> Listing 3-30.Plot a Basic Quadratic Rename the file as Basic Quadratic, save your changes, then choose “Close and Halt” from the file menu. Returning to the Jupyter file system, you should see the file you just created (Figure [3-8](img/#Fig8)).![A439726_1_En_3_Fig8_HTML.jpg](img/A439726_1_En_3_Fig8_HTML.jpg) Figure 3-8.Your file in the Jupyter file system Next, shut down your running instance and confirm that it is no longer running by using docker stop and docker ps (Listing [3-31](img/#Par108)). $ docker stop furious_archimedes furious_archimedes $ docker ps CONTAINER ID     IMAGE     COMMAND     CREATED     STATUS     PORTS     NAMES Listing 3-31.Shut Down a Running Container Now, in Listing [3-32](#Par110), you start a new Jupyter image. You will need to access the token once more. Here, you view the logs using the returned container id rather than the container’s name. $ docker run -d -p 5000:8888 jupyter/demo 5999d158488d410ac5fbf3a646e4a962d307e968d3cd2f53e60e0a0c7bbe262c $ docker logs 5999d158488d410ac5fbf3a646e4a962d307e968d3cd2f53e60e0a0c7bbe262c Listing 3-32.Run the jupyter/demo Image in Detached Mode Visit the Jupyter application in your browser. The file you just created is gone. Data has not persisted from instance to instance. This is a problem.

### 附加一个卷

This problem can be solved via a run argument. You can attach a volume via a run argument with the flag -v. Note that if you are running Docker on a virtual machine, Mac or Windows, you are only able to mount volumes from /Users (OS X) or C:\Users (Windows), and volumes may need to be made explicitly available to the docker daemon. You pass the -v flag a single argument that consists of <local_dir>:<container_id>. The Jupyter Demo stack is serving files from /home/jovyan. You will serve files in ∼/src to /home/jovyan/src. Note that you must use the absolute path (i.e. /Users/joshuacook/src). In Listing [3-33](#Par115), you run in detached mode and attach a volume. $ docker run \   -v /Users/joshuacook/src:/home/jovyan/src \     -d -p 5000:8888 \     jupyter/demo 273ff71c6755670e21accd197461dd4256fbeb129393d137733f36bcb5432a55 Listing 3-33.Run an Image and Attach a Volume Repeat the above experiment and create a new file called Basic Quadratic. You should notice three things.

*   ∨/src 中的所有文件应该可以立即用于 Jupyter 应用程序。
*   在容器化的 Jupyter 应用程序上写入 src 目录的任何文件都应该写入您机器上的{/ src。
*   因此，这些文件应该从一次启动持续到另一次启动。

It is worth repeating this here: if you wish to persist the work that you have done while running Jupyter via Docker, the best practice is to use the -v flag at runtime to mount a local directory to your container.

## 摘要

In this chapter you did quite a bit. You explored to some extent the nature of non-interactive and interactive programming using Docker. You explored the running of various Jupyter Docker images on your system for the purposes of interactive programming. You detailed the Jupyter Team-defined best practice in notebook security and how to access your Jupyter Notebook Server in a browser. Finally, you briefly explored how port mappings and file persistence can affect your work when using Docker to run Jupyter. I hope that, after this chapter, you are comfortable running Jupyter on your system using Docker, especially in terms of

1.  1.识别您的安全令牌
2.  2.识别您的 IP 和端口
3.  3.在容器的生命周期之外持久化您所做的工作

You will revisit Jupyter in Chapter [7](07.html), when you explore in some depth the publicly available Docker images written by the Jupyter team for the purposes of running and extending Jupyter via Docker. Footnotes [1](#Fn1_source) [https://beki70.wordpress.com/2011/01/27/what-is-interactive-computing/](https://beki70.wordpress.com/2011/01/27/what-is-interactive-computing/)