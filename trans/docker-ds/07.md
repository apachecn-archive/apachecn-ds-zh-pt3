© Joshua Cook 2017 Joshua CookDocker for Data Science[https://doi.org/10.1007/978-1-4842-3012-1_7](07.html)

# 7.固执己见的朱庇特·斯塔克斯

Joshua Cook<sup class="calibre5">1 </sup> (1)Santa Monica, California, USA  

> Jupyter 笔记本基于一套交互式计算的开放标准。—项目 Jupyter [<sup class="calibre6">1</sup>](#Fn1)

Project Jupyter developed out of an academic environment and out of the project came not simply a groundbreaking application, but also a well-defined set of protocols for the interactive computing paradigm. With regard to the notebook, these protocols include the notebook document format, an interactive computing protocol, and the kernel. These and the other protocols defining the Jupyter ecosystem are maintained by an openly-governed steering council.[<sup class="calibre6">2</sup>](#Fn2) Beyond the protocols defining the interactive computing via Jupyter and maintaining the numerous projects that comprise the ecosystem, Project Jupyter also maintains a GitHub repository containing numerous well-defined Jupyter Docker images: the Opinionated Jupyter Stacks .[<sup class="calibre6">3</sup>](#Fn3) It is a trivial endeavor to launch a Jupyter Notebook server within a Docker container. In Listing [7-1](#Par9), you do this using the -P (publish all) flag , which publishes all exposed ports to random ports on the host. $ docker run -d -P jupyter/scipy-notebook 72da8ca9ac9d4c694477350c500e9d793769788a26148a144e6c29448b5b4840 Listing 7-1.Launch a Jupyter scipy-notebook Server To use this container, you will need to know to which port on your host system port 8888 in the container has been published (Listing [7-2](#Par12)) and will need to obtain the notebook server’s security token (Listing [7-3](#Par14)). In Listing [7-2](#Par12), you use the docker port command to obtain the port mappings for your container using the first four characters, 72da, of the container id returned when you started the container, 72da8ca9ac9d4.... Note A Docker container can be referenced by as few characters are required to establish a unique container reference. The container, 72da8ca9ac9d4c694477350c500e9d793769788a26148a144e6c29448b5b4840, could be referenced by 7, if no other container ids begin with 7. $ docker port 72da 8888/tcp -> 0.0.0.0:32769 Listing 7-2.Obtain a Port Mapping for the Container In Listing [7-3](#Par14), you use the docker exec command to send a command to your Jupyter Notebook server within the docker container where it is being run. You again use the first four characters of the container id to reference the container and then send the container the command jupyter notebook list. This has the effect of opening a shell to the container, running this command in the shell, displaying the result, and closing the shell. $ docker exec 72da jupyter notebook list Currently running servers: http://localhost:8888/?token=61d6ead40b05daea402d9843ad7932bc937da41841575765 :: /home/jovyan Listing 7-3.Obtain a Security Token for Running Jupyter Notebook Server Bear in mind that the URL provided here refers to the URL where the notebook server can be reached within the Docker container. The actual location would be to use the IP of your docker machine (localhost or the IP of your AWS instance or the virtual machine on which you are running Docker) and the port you obtained in the previous command. Listing [7-4](#Par16) shows this URL if using Docker for Linux, Docker for Mac, or Docker for Windows. Listing [7-5](#Par17) shows the most likely URL if using Docker Toolbox. (Refer to Listing [1-10](01.html#Par83) in Chapter [1](01.html) to review accessing your Jupyter system on AWS.) http://localhost:32769/?token=61d6ead40b05daea402d9843ad7932bc937da41841575765 Listing 7-4.The Current Jupyter URL If Using Docker for Linux/Mac/Windows http://192.168.99.100:32769/?token=61d6ead40b05daea402d9843ad7932bc937da41841575765 Listing 7-5.The Likely Current Jupyter URL If Using Docker for Toolbox

## 高级概述

The Project Jupyter Docker stacks provide eight notebook images beginning with a base-notebook image upon which all subsequent images depend:

1.  1.基本笔记本
2.  2.小型笔记本电脑
3.  3\. scipy 笔记型电脑
4.  4.笔记本电脑
5.  5 . tensorflow 笔记型电脑
6.  6.数据科学-笔记本
7.  7.py spark-笔记本
8.  8.火种源笔记本

Each image has an eponymous folder in the GitHub [jupyter/docker-stacks](https://github.com/jupyter/docker-stacks) project, as well as an equivalent repository hosted under the [jupyter](http://hub.docker.com/u/jupyter/) user namespace on Docker Hub. Figure [7-1](#Fig1) shows the dependencies of these images.![A439726_1_En_7_Fig1_HTML.jpg](img/A439726_1_En_7_Fig1_HTML.jpg) Figure 7-1.Jupyter Docker stack dependency graph Note The base-notebook uses Debian “jesse”[<sup class="calibre6">4</sup>](img/#Fn4) and thus provides the container operating system for every notebook image.

### jupyter/base 笔记型电脑

The jupyter/base-notebook image defines a minimal Jupyter Notebook server. It is solely provisioned with Miniconda for Python 3 and does not come provisioned with Python 2 nor any scientific computing packages (from numpy on up). It does define the essential patterns that will be used to define Jupyter images through the entire stack: the use of the init binary tini, the addition of the unprivileged user jovyan,[<sup class="calibre6">5</sup>](#Fn5) and the inclusion of various startup scripts that will be used to run the server. You will rarely use the base-notebook image in practice, but will take the development patterns written here as best practices. Any changes you might make to an image downstream will need to be made considering these practices. You have done so already when you mounted a volume of local files to your server being run in a container in Chapter [2](02.html). You mounted these files from your working directory to the container directory /home/jovyan using the flag -v `pwd`:/home/jovyan, as in Listing [7-6](#Par33). $ docker run -d -v `pwd`:/home/jovyan -P jupyter/scipy-notebook Listing 7-6.Attach a Host Directory to a Container The use of the /home/jovyan directory as root notebook directory is defined in the Dockerfile defining the base-notebook image (Listing [7-7](#Par35)). ... ENV NB_USER jovyan ... WORKDIR /home/$NB_USER/work ... Listing 7-7. base-notebook Dockerfile

### 笔记本电脑安全性

It is not uncommon to run a notebook server as a publicly accessible server over the open web. Furthermore, a notebook server is capable of running arbitrary code. As such, it is a best practice[<sup class="calibre6">6</sup>](#Fn6) to restrict access to a notebook server. The Opinionated Jupyter Stacks define a series of security best practices, largely defined in the Dockerfile for the base-notebook image. By default, a notebook server running in a container requires a randomly generated security token to be passed as a query parameter when accessed through the browser. You saw earlier how this token can be obtained by sending the jupyter notebook list command to a running container via docker exec (Listing [7-3](#Par14)). The base-notebook image defines the start-notebook.sh script used as the default command passed to tini at runtime. This script can be used to define an alternative authentication method, although this is not recommended. In an installation in which you can guarantee security (or in which you are comfortable being somewhat less restrictive, such as a temporary AWS instance), you may wish to grant sudo access to the jovyan user. This can be done by passing the environment variable GRANT_SUDO=yes. Additionally, the container must be run by the root user. Listing [7-8](#Par40) shows a complete command for running a notebook server and granting password-less sudo to the jovyan user. $ docker run -d -e GRANT_SUDO=yes --user root jupyter/scipy-notebook a811689f2e09737e2c9686849320a424889b2ac9eeb57e0f3df2940edc600628 Listing 7-8.Run a Notebook Server and Grant Password-less sudo to the jovyan User Granting sudo access to the jovyan user is useful while working in an exploratory capacity. You may wish to quickly install Linux binaries that are not part of your image without going through a full image build cycle. With sudo access granted, this is possible. If you connect to the running container via docker exec, you can see that tini has been launched by the root user (Listing [7-9](#Par43)). The GRANT_SUDO flag has the effect of launching the jupyter notebook process, owned by jovyan, via su jupyter notebook. $ docker exec -it a811 ps aux USER    PID  %CPU  %MEM VSZ    RSS    TTY  STAT  START  TIME  COMMAND root    1    1.0   0.0  4224   668    ?    Ss    23:41  0:00  tini -- start-notebook.sh root    6    0.4   0.1  46360  3084   ?    S     23:41  0:00  su jovyan -c env ... jovyan  9    33.2  2.4  183488 50612  ?    Ss    23:41  0:01  /opt/conda/bin/python ... root    13   0.0   0.1  19100  2556   ?    Rs    23:41  0:00  ps aux Listing 7-9.Connect to a Running Container as root and View the Running Processes A notebook server running without this flag (Listing [7-10](#Par45)) will appear as in Listing [7-11](#Par46). Note that tini has been launched by jovyan and that no su command has been run to grant sudo to jovyan. $ docker run -d jupyter/base-notebook e900cbb66babb23f8b7764506482e32e300b8ad351e4ea15a0260266ca517738 Listing 7-10.Run a Notebook Server $ docker exec e900 ps aux USER     PID  %CPU  %MEM   VSZ    RSS   TTY STAT  START  TIME  COMMAND jovyan   1    0.0   0.0    4224   656   ?   Ss    23:35  0:00  tini -- start-notebook.sh jovyan   5    1.1   2.4    183404 50576 ?   S     23:35  0:01  /opt/conda/bin/python ... jovyan   2    0.0   0.1    19100  2436  ?   Rs    23:37  0:00  ps aux Listing 7-11.Connect to a Running Container as jovyan and View the Running Processes

### 默认环境

The base-notebook Dockerfile installs miniconda3 and the latest stable version of Python 3\. It also defines the default conda environment, root, which will be used throughout to manage your Python 3 installation. You can see the miniconda version and the name of your Python 3 environment by running an interactive bash shell to a base-notebook container (Listing [7-12](#Par49)). Note ipython, python, pip, easy_install, and conda are all available in this environment and reference the conda/python versions installed in the base-notebook Dockerfile. $ docker run -it --rm jupyter/base-notebook bash jovyan@c9fb2312c5b8:∼$ conda info -a Current conda install:                platform : linux-64           conda version : 4.2.12        conda is private : False       conda-env version : 4.2.12     conda-build version : not installed          python version : 3.5.2.final.0 ... # conda environments: # root                  *  /opt/conda Listing 7-12.Identify the Python 3 conda Environment. It is worth noting that you could have run the same command in an already running container, as in Listing [7-13](#Par51). Listing [7-13](#Par51) has the effect of running the command via a shell (as opposed to a bash shell) and will close the shell when the command has completed execution. Here, wizardly_hawking refers to the randomly generated name for a running container. $ docker exec wizardly_hawking conda info -a Current conda install: ... Listing 7-13.Alternatively Identify the Python 3 conda Environment Here you can see that you are running Python 3.5.2 and have a single Python environment root. You can verify that the root environment is running 3.5.2 by sourcing the root environment and checking the Python version (Listing [7-14](#Par53)). The source activate command has the effect of configuring the global python to use the python binary available at /opt/conda/bin/python. jovyan@ c9fb2312c5b8:∼$ source activate root (root) jovyan@ c9fb2312c5b8:∼$ python --version Python 3.5.2 :: Continuum Analytics, Inc. (root) jovyan@ c9fb2312c5b8:∼$ which python /opt/conda/bin/python Listing 7-14.Check the Python Version for root Environment

### 管理 Python 版本

With the release of IPython 6 and the drop of support for Python 2, in this author’s opinion there is no need to explicitly work with environments within a Docker image. It is perfectly reasonable to have one Docker image dedicated to running the latest stable version of Python, another image dedicated to running a legacy version of Python for an application that is useful but not worth updating, and still another image dedicated to running the latest alpha build of Python on all the same system. This is, in fact, a perfect use case for Docker. The dependencies of each implementation are completely isolated from each other when running in their own containers. For the time being, however, as the community continues to make the measured migration from Python 2 to Python 3, we will need to continue to explicitly manage environments running within our containers, for the primary purpose of maintaining simultaneous py2 and py3 environments. To do this, we will use conda’s native capacity for managing environments.[<sup class="calibre6">7</sup>](#Fn7) It is worth noting, before digging into the details of environment implementation, that switching environments in a running notebook or while creating a new notebook is a trivial task. We are investigating environments for the purposes of understanding the best way to add new libraries that are not installed by default. Figure [7-2](#Fig2) shows how new notebooks using different Python kernels can be created. Figure [7-3](#Fig3) shows how the kernel can be switched for a running notebook.![A439726_1_En_7_Fig2_HTML.jpg](img/A439726_1_En_7_Fig2_HTML.jpg) Figure 7-2.Select a kernel when creating a new notebook ![A439726_1_En_7_Fig3_HTML.jpg](img/A439726_1_En_7_Fig3_HTML.jpg) Figure 7-3.Change the kernel in a running notebook

#### 使用 dockerfile 文件天真地扩展木星图像

For the majority of the work you will do, you will take an image from the Jupyter Docker stacks and add libraries specific to your work as needed using the build process described in Chapter [4](04.html). Suppose, for example, that you wish to develop a semantic analysis project on Twitter data using the Python machine learning library scikit-learn and storing the data in a MongoDB database. scikit-learn is included by default with the jupyter/scipy-notebook image, but the python mongo interface library, pymongo, is not. A naive approach to building this image might use the Dockerfile described in Listing [7-15](#Par58). FROM jupyter/scipy-notebook RUN pip install pymongo Listing 7-15. Dockerfile Extending the jupyter/scipy-notebook for Semantic Analysis You could then build the image using the docker build command (Listing [7-16](#Par60)) and run a container defined by this image using docker run (Listing [7-17](#Par61)). $ docker build -t semantic_analysis. Listing 7-16.Build the semantic_analysis Image $ docker run -d -P semantic_analysis 67cf8215ed6ad75c3709455bcdfffb72fb92df2abae3627962ba63677e06c45a $ docker port 67cf 8888/tcp -> 0.0.0.0:32776 $ docker exec 67cf jupyter notebook list Currently running servers: http://localhost:8888/?token=d57ccd98004c383215c03ce25a7df85ec7796e04f8ca4723 :: /home/jovyan Listing 7-17.Run the semantic_analysis Container You can now access your semantic_analysis container using the URL of http://localhost:32776/?token=d57ccd98004c383215c03ce25a7df85ec7796e04f8ca4723.

### 利用 conda 环境扩展木星图像

The original tool for managing Python environments is the [virtualenv tool](https://virtualenv.pypa.io/en/stable/), still widely used today. Both virtualenv and the conda environments allow the user to create isolated Python environments on the same system, similar to the [Bundler](http://bundler.io/) tool for Ruby programming. The Jupyter Docker stacks use conda environments to manage environments and you will leverage the existing environments to install packages for a Python 2 kernel independent of the installation of packages for a Python 3 kernel and vice versa. You can manually switch back and forth between the two using the source activate command. This is done automatically at kernel launch by the notebook server, where necessary. In Listing [7-18](#Par66), you examine the conda environments on the jupyter/scipy-notebook image. Note base-notebook and minimal-notebook only have Python 3, but scipy-notebook and all child images have both Python 2 and Python 3. $ docker run -it --rm jupyter/scipy-notebook bash jovyan@83a2aec2da92:∼$ which python /opt/conda/bin/python jovyan@83a2aec2da92:∼$ python --version Python 3.5.2 :: Continuum Analytics, Inc. jovyan@83a2aec2da92:∼$ source activate root (root) jovyan@83a2aec2da92:∼$ python --version Python 3.5.2 :: Continuum Analytics, Inc. (root) jovyan@83a2aec2da92:∼$ source activate python2 (python2) jovyan@83a2aec2da92:∼$ python --version Python 2.7.12 Listing 7-18.Display Location and Version of python Binaries for Default, root, and python2 Environments A proper extension of a base jupyter image would do so for each of the conda environments available on the image, as seen in Listing [7-19](#Par68). Here, you are installing the pymongo library for both conda environments. FROM jupyter/scipy-notebook USER root # python 3 environment is named root RUN conda install --name root \     pymongo # python 2 environement is named python2 RUN conda install --name python2\     pymongo USER jovyan Listing 7-19.A Proper Extension of the jupyter/scipy-notebook Image Note You switch to the user root to install the libraries and switch back to user jovyan upon completion. This is considered a best practice and ensures that you do not run the notebook server with too much system privilege. Once more you build the image using the docker build command (Listing [7-20](#Par71)) and run a container defined by this image using docker run (Listing [7-21](#Par72)). It is not necessary to give the image a new name. You simply overwrite the previous semantic_analysis image. $ docker build -t semantic_analysis . Listing 7-20.Build the semantic_analysis Image $ docker run -d -P semantic_analysis ca525dbeb79b8e38a52db192b7388136e61e4a1534817f76ba5eefd8ffc0246e $ docker port ca52 8888/tcp -> 0.0.0.0:32777 $ docker exec ca52 jupyter notebook list Currently running servers: http://localhost:8888/?token=d57ccd98004c383215c03ce25a7df85ec7796e04f8ca4723 :: /home/jovyan Listing 7-21.Run the semantic_analysis Container You can now access your new semantic_analysis container using the URL http://localhost:32777/?token=d57ccd98004c383215c03ce25a7df85ec7796e04f8ca4723. One final consideration in extending jupyter images is that some python libraries may only be available via pip. You may wish to install the python library [twitter](https://pypi.python.org/pypi/twitter) for interfacing with the Twitter API. Again, you should install the library for both conda environments, as you have done in Listing [7-22](#Par75). FROM jupyter/scipy-notebook USER root # python 3 environment is named root RUN conda install --yes --name root \     pymongo # python 2 environement is named python2 RUN conda install --yes--name python2\     pymongo # install libraries via pip using bash and activating respective environment RUN ["bash", "-c", "source activate root && pip install twitter"] RUN ["bash", "-c", "source activate python2 && pip install twitter "] USER jovyan Listing 7-22.A Proper Extension of the jupyter/scipy-notebook Image using pip

## 使用 joyvan 安装库

In Listing [7-22](#Par75), you make use of a variant to the Dockerfile RUN syntax. You have previously used the RUN instruction using the syntax RUN <command>. This is known as the shell form of the RUN instruction. Using the command in this form has the effect of sending the command to an image via /bin/sh or the default shell. Installing via pip will not work using this syntax. This is because in order to install into the correct conda environment, you need to activate the appropriate environment using the source command. The source command is not available to the default shell (/bin/sh). It is available to bash. In order to use bash, you must use the alternative syntax for the RUN instruction, the exec form. The exec form uses the syntax RUN ["executable", "param1", "param2"]. You use RUN ["bash", "-c", "source activate <environment> && pip install twitter "]. This has the effect of opening a bash shell to your image and

1.  1.激活适当的环境
2.  2.通过 pip 安装 twitter

## 临时容器扩展

Finally, let’s discuss a best practice in adding libraries to a running container using the jovyan user. Prior to doing so, however, I should mention the implications of making changes to a running container. In Chapter [2](02.html), you explored persistence in containers, but did so solely with regard to files you might be working on while using Jupyter. You wanted to make sure that changes to files persisted beyond the lifespan of a container. I did not, however, discuss persistence of libraries you might install, either at the system level using the apt package manager favored by the base-notebook’s operating system Debian or at the Python level using any of the included python package managers. In practice, you will face the exact same challenges. With regard to system and pythonic libraries, however, I recommend making these changes via a Dockerfile as a best practice, as described above. That said, it is also a best practice to separate the writing of python code from the maintenance of Docker images. You will, no doubt, in the course of development, come across a situation where you wish to install a library for quick use. A best practice is certainly to quickly install the needed library and continue developing. You should be aware, however, of the implications of what you are doing. As soon as you stop and remove the container in which you have made these changes, the changes will be gone. This is by design. You must also guard yourself against keeping aging containers around long after their lifecycle because you wish to keep the changes you have made to them. With this in mind, I have found the following to be a best practice for installing ephemeral packages on running containers. The ipython magix-sx command,[<sup class="calibre6">8</sup>](#Fn8) for which ! (bang) serves as a shorthand, can be used to run a command in a shell to the underlying system from a notebook. In this way, you can install libraries via conda (Listing [7-23](#Par86)), pip (Listing [7-25](#Par92)), or apt (Listing [7-27](#Par98)) in the moment, without opening a terminal to the container. Note apt requires that password-less sudo has been granted to jovyan at container runtime, as outlined above. In [1]: import pymongo         --------------------------------------------------------------------         ImportError                               Traceback (most recent call last)         <ipython-input-1-ec8fdd1cd630> in <module>()         ----> 1 import pymongo         ImportError: No module named 'pymongo' In [2]: !conda install pymongo --yes         Fetching package metadata .........         Solving package specifications: ..........         ...         Linking packages ...         [      COMPLETE      ]|######################################| 100% Listing 7-23.Install a Package via conda Using ipython Magic Shell Process Command . The environment into which the library will be installed is a function of which kernel is being run. Figure [7-4](#Fig4) shows the Python 3 kernel. Recall that this is associated with the conda root environment.![A439726_1_En_7_Fig4_HTML.jpg](img/A439726_1_En_7_Fig4_HTML.jpg) Figure 7-4.Install pymongo into the root environment using a notebook You can verify that the package has indeed been added to the correct environment by opening a shell to the container and running a conda list (Listing [7-24](img/#Par89) ). $ docker exec -it kickass_engelbart bash jovyan@67cf8215ed6a:∼$ conda list --name root | grep pymongo pymongo                   3.2.2                    py35_0    conda-forge jovyan@67cf8215ed6a:∼$ conda list --name python2 | grep pymongo jovyan@67cf8215ed6a:∼$ Listing 7-24.Verify Library Installation The library is available to the root environment but it is not available to the python2 environment. Were you to switch kernels and run the command once more, it would be available to python2\. These changes to the container will persist as long as the container is running. If you wish for these changes to persist for more than the most trivial usage, it is recommended to make these changes permanent by making them to the image itself, as outlined above. In Listing [7-25](#Par92), you install twitter into the python2 environment using pip via a notebook. See Figure [7-5](#Fig5) for the results.![A439726_1_En_7_Fig5_HTML.jpg](img/A439726_1_En_7_Fig5_HTML.jpg) Figure 7-5.Install twitter into the python2 environment using a notebook In [1]: import twitter         --------------------------------------------------------------------         ImportError                               Traceback (most recent call last)         <ipython-input-1-645f6dc1896f> in <module>()         ----> 1 import twitter         ImportError: No module named 'twitter' In [2]: !pip install twitter         Collecting twitter           Downloading twitter-1.17.1-py2.py3-none-any.whl (55kB)             100% |████████████████████████████████| 61kB 2.4MB/s ta 0:00:01         Installing collected packages: twitter         Successfully installed twitter-1.17.1 Listing 7-25.Install a Package via pip Using ipython Magic Shell Process Command Again, you can verify that the package has indeed been added to the correct environment by opening a shell to the container and running a conda list (Listing [7-26](img/#Par94) ). $ docker exec -it kickass_engelbart bash jovyan@67cf8215ed6a:∼$ conda list --name root | grep twitter jovyan@67cf8215ed6a:∼$ conda list --name python2 | grep twitter twitter                   1.17.1                    <pip> jovyan@67cf8215ed6a:∼$ Listing 7-26.Verify Library Installation .

### 保持对图像的半持久性改变

The DevOps-minded reader will no doubt be troubled by the installation of libraries in a running Jupyter container. You have thus far clung to the notion that the best practice in working with containers is that they can be shut down, removed, and restarted at any time without any loss to your workflow. Were you to reap kickass_engelbart and start your notebook in a new container, this new container would not have twitter or mongo installed. This presents only a mild inconvenience as you have a record of libraries you will need to install in the magix-sx command in your notebooks: !conda install pymongo --yes and !pip install twitter. You may wish, however, to persist these changes in a defined container. Warning This practice is not recommended as a permanent image development practice. This is recommended as a temporary measure on a project-by-project basis. You can add temporary changes (Listing [7-27](#Par98)) made to an image using the docker commit command. I recommend using a tag to name the image. Here you add the twitter-mongo tag to the base image, jupyter/scipy-notebook. $ docker commit kickass_engelbart jupyter/scipy-notebook:twitter-mongo Listing 7-27.Persist Temporary Changes to an Image Using a Tag In Listing [7-28](#Par100), you display images in your image cache. You can see that you now have two images in your local cache, jupyter/scipy-notebook:latest and jupyter/scipy-notebook:twitter-mongo. $ docker images REPOSITORY              TAG            IMAGE ID      CREATED        SIZE jupyter/scipy-notebook  twitter-mongo  dfbb7599770d  4 seconds ago  5.37GB jupyter/scipy-notebook  latest         3dc12029099d  24 hours ago   5.35GB Listing 7-28.Display Local Images You can launch your modified image as any other image using docker run (Listing [7-29](#Par102)). $ docker run -d -v `pwd`:/home/jovyan -p 8888:8888 jupyter/scipy-notebook:twitter-mongo Listing 7-29.Launch jupyter/scipy-notebook:twitter-mongo

## 摘要

In this chapter, you looked at the Docker images defined by the Jupyter team for quick launch and extension of the Jupyter Notebook server using Docker. I briefly discussed default notebook security strategies. I also presented several strategies for extending Jupyter images using the Jupyter Team’s images as base. Following this chapter, I hope you feel comfortable accessing the right Jupyter image for your work and adding to this image to meet the needs of a given project. Footnotes [1](#Fn1_source) [http://jupyter.org/](http://jupyter.org/)   [2](#Fn2_source) [http://jupyter.org/about.html](http://jupyter.org/about.html)   [3](#Fn3_source) [https://github.com/jupyter/docker-stacks](https://github.com/jupyter/docker-stacks)   [4](#Fn4_source) [www.debian.org/releases/jessie/](http://www.debian.org/releases/jessie/)   [5](#Fn5_source)Jovyan means “related to Jupiter” (Jupyter).   [6](#Fn6_source) [http://jupyter-notebook.readthedocs.io/en/latest/security.html](http://jupyter-notebook.readthedocs.io/en/latest/security.html)   [7](#Fn7_source) [https://conda.io/docs/using/envs.html](https://conda.io/docs/using/envs.html)   [8](#Fn8_source) [https://ipython.org/ipython-doc/3/interactive/magics.html#magic-sx](https://ipython.org/ipython-doc/3/interactive/magics.html#magic-sx)