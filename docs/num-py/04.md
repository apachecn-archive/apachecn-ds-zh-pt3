# 4.绘图和可视化

可视化是一种调查和交流计算研究结果的通用工具，毫不夸张地说，几乎所有计算的最终产品——无论是数字还是符号——都是某种绘图或图形。当以图形形式可视化时，从计算结果中最容易获得知识和见解。因此，可视化在所有计算研究领域的工作流程中是一个非常重要的部分。

在 Python 的科学计算环境中，有许多高质量的可视化库。最流行的通用可视化库是 Matplotlib，它主要致力于生成静态出版物质量的 2D 和 3D 图形。许多其他图书馆专注于可视化的利基领域。几个突出的例子是 Bokeh ( [`http://bokeh.pydata.org`](http://bokeh.pydata.org) )和 Plotly ( [`http://plot.ly`](http://plot.ly) )，它们都主要关注交互性和网络连接性；Seaborn([`http://stanford.edu/~mwaskom/software/seaborn`](http://stanford.edu/%257Emwaskom/software/seaborn))，这是一个基于 Matplotlib 库的高级绘图库，以统计数据分析为目标 Mayavi 库( [`http://docs.enthought.com/mayavi/mayavi`](http://docs.enthought.com/mayavi/mayavi) )用于高质量的 3D 可视化，它使用古老的 VTK 软件( [`http://www.vtk.org`](http://www.vtk.org) )用于重型科学可视化还值得注意的是，其他基于 VTK 的可视化软件，如 ParaView ( [`www.paraview.org`](http://www.paraview.org) )，可以用 Python 编写脚本，也可以从 Python 应用程序进行控制。在 3D 可视化领域，也有更多新的参与者，如 VisPy ( [`http://vispy.org`](http://vispy.org) )，这是一个基于 OpenGL 的 2D 和 3D 可视化库，具有很好的交互性和与基于浏览器的环境的连接性，如 Jupyter Notebook。

Python 科学计算环境中的可视化前景是充满活力和多样化的，它为各种可视化需求提供了充足的选项。在这一章中，我们将重点使用 Matplotlib 库探索 Python 中传统的科学可视化。对于传统的可视化，我指的是通常用于可视化科学和技术学科中的结果和数据的图和图形，例如线图、条形图、等值线图、色彩图和 3D 表面图。

### Matplotlib

Matplotlib 是一个用于出版质量的 2D 和 3D 图形的 Python 库，支持各种不同的输出格式。在撰写本文时，最新版本是 2.2.2。有关 Matplotlib 的更多信息可在该项目的网站 [`www.matplotlib.org`](http://www.matplotlib.org) 获得。该网站包含详细的文档和丰富的图库，展示了可以使用 Matplotlib 库生成的各种类型的图形，以及每个示例的代码。这个图库是可视化思想的伟大灵感来源，我强烈推荐通过浏览这个图库来探索 Matplotlib。

创建科学可视化有两种常见的方法:使用图形用户界面手动构建图形，以及使用编程方法用代码创建图形。这两种方法各有利弊。在这一章中，我们将采用编程方法，我们将探索如何使用 Matplotlib API 来创建图形并控制它们外观的各个方面。程序化方法是一种特别适用于为科学和技术应用创建图形的方法，尤其适用于创建出版物质量的图形。这样做的动机的一个重要部分是，以编程方式创建的图形可以保证跨多个图形的一致性，可以使其可再现，并且可以容易地修改和调整，而不必在图形用户界面中重复潜在的冗长和乏味的过程。

## 导入模块

与大多数 Python 库不同，Matplotlib 实际上提供了库的多个入口点，具有不同的应用程序编程接口(API)。具体来说，它提供了一个有状态 API 和一个面向对象 API，两者都是由模块`matplotlib.pyplot`提供的。我强烈建议只使用面向对象的方法，本章的剩余部分将只关注 Matplotlib 的这一部分。<sup>[1](#Fn1)T4】</sup>

要使用面向对象的 Matplotlib API，我们首先需要导入它的 Python 模块。在下文中，我们将假设 Matplotlib 是使用以下标准约定导入的:

```
In [1]: %matplotlib inline
In [2]: import matplotlib as mpl
In [3]: import matplotlib.pyplot as plt
In [4]: from mpl_toolkits.mplot3d.axes3d import Axes3D

```

第一行假设我们在 IPython 环境中工作，更具体地说是在 Jupyter 笔记本或 IPython QtConsole 中工作。IPython magic 命令`%matplotlib inline`将 Matplotlib 配置为使用“内联”后端，这导致创建的图形直接显示在 Jupyter 笔记本中，而不是显示在新窗口中。语句`import matplotlib as mpl`导入主 Matplotlib 模块，导入语句`import matplotlib.pyplot as plt`是为了方便访问子模块`matplotlib.pyplot`，它提供了我们将用来创建新图形实例的函数。

在本章中，我们也经常使用 NumPy 库，正如在第 [2](02.html) 章中一样，我们假设 NumPy 是使用

```
In [5]: import numpy as np

```

我们还使用 SymPy 库，导入为:

```
In [6]: import sympy

```

## 入门指南

在我们深入研究如何使用 Matplotlib 创建图形的细节之前，我们先从一个简单但典型的图形创建示例开始。我们还将介绍 Matplotlib 库的一些基本原理，以便理解如何使用该库生成图形。

Matplotlib 中的图形由图中的一个`Figure`实例和一个或多个`Axes`实例构成。`Figure`实例提供了一个用于绘图的画布区域，`Axes`实例提供了分配给整个图形画布固定区域的坐标系；见图 [4-1](#Fig1) 。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig1_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig1_HTML.png)

图 4-1

Matplotlib `Figure`实例和`Axes`实例的排列示意图。`Axes`实例为绘图提供了一个坐标系，`Axes`实例本身被分配给图形画布中的一个区域。图形画布有一个简单的坐标系，其中(0，0)是左下角,( 1，1)是右上角。该坐标系仅在将元素(如`Axes`)直接放置在图形画布上时使用。

一个`Figure`可以包含多个`Axes`实例，例如，在一个图形中显示多个面板，或者在另一个`Axes`实例中显示插图。一个`Axes`实例可以手动分配到图形画布的任意区域，或者，`Axes`实例可以使用 Matplotlib 提供的几个布局管理器之一自动添加到图形画布。`Axes`实例提供了一个坐标系，可用于以各种绘图样式绘制数据，包括折线图、散点图、条形图和许多其他样式。此外，`Axes`实例还决定坐标轴如何显示，例如，相对于轴标签、刻度和刻度标签等。事实上，在使用 Matplotlib 的面向对象 API 时，调整图形外观所需的大多数函数都是`Axes`类的方法。

作为 Matplotlib 入门的一个简单示例，假设我们想要绘制函数*y*(*x*)=*x*<sup>3</sup>+5*x*<sup>2</sup>+10 及其一阶和二阶导数，范围为*x*∈[5，2]。为此，我们首先为 *x* 范围创建 NumPy 数组，然后计算我们想要绘制的三个函数。当图表的数据准备好后，我们需要创建 Matplotlib `Figure`和`Axes`实例，然后使用`Axes`实例的`plot`方法绘制数据，并使用`set_xlabel`和`set_ylabel`方法设置基本的图表属性，如 x 和 y 轴标签，并使用`legend`方法生成图例。这些步骤在下面的代码中执行，得到的图形如图 [4-2](#Fig2) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig2_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig2_HTML.png)

图 4-2

用 Matplotlib 创建的简单图形示例

```
In [7]: x = np.linspace(-5, 2, 100)
   ...: y1 = x**3 + 5*x**2 + 10
   ...: y2 = 3*x**2 + 10*x
   ...: y3 = 6*x + 10
   ...:
   ...: fig, ax = plt.subplots()
   ...: ax.plot(x, y1, color="blue", label="y(x)")
   ...: ax.plot(x, y2, color="red", label="y'(x)")
   ...: ax.plot(x, y3, color="green", label="y”(x)")
   ...: ax.set_xlabel("x")
   ...: ax.set_ylabel("y")
   ...: ax.legend()

```

这里我们使用了`plt.subplots`函数来生成`Figure`和`Axes`实例。这个函数可以用来在一个新创建的`Figure`实例中创建`Axes`实例的网格，但是这里它只是作为一种在一个函数调用中创建一个`Figure`和一个`Axes`实例的方便方法。一旦`Axes`实例可用，注意所有剩下的步骤都涉及调用这个`Axes`实例的方法。为了创建实际的图形，我们使用了`ax.plot`，它将 NumPy 数组作为第一个和第二个参数，这些数组带有图形的数值数据 *x* 和 *y* ，它绘制了一条连接这些数据点的线。我们还使用可选的`color`和`label`关键字参数来指定每一行的颜色，并为图例中使用的每一行分配一个文本标签。这几行代码足以生成我们想要生成的图形，但是最起码，我们还应该在 *x* 和 *y* 轴上设置标签，如果合适的话，为我们绘制的曲线添加一个图例。使用`ax.set_xlabel`和`ax.set_ylabel`方法设置轴标签，该方法将带有相应标签的文本字符串作为参数。使用`ax.legend`方法添加图例，在这种情况下不需要任何参数，因为我们在绘制曲线时使用了`label`关键字参数。

这些是使用 Matplotlib 创建图表所需的典型步骤。虽然此图(图 [4-2](#Fig2) )完整且功能齐全，但在外观的许多方面仍有改进的空间。例如，为了满足出版或生产标准，我们可能需要更改轴标签、刻度标签和图例的字体和字体大小，并且我们可能应该将图例移动到图形中不干扰我们绘制的曲线的部分。我们甚至可能想要更改轴记号和标签的数量，并添加注释和额外的帮助行来强调图形的某些方面等等。沿着这些路线进行一些修改，该图可能会出现，例如，如图 [4-3](#Fig3) 所示，这是非常像样的。在本章的剩余部分，我们将研究如何完全控制使用 Matplotlib 生成的图形的外观。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig3_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig3_HTML.png)

图 4-3

图 [4-2](#Fig2) 的修订版

### 交互和非交互模式

Matplotlib 库设计用于许多不同的环境和平台。因此，该库不仅包含生成图形的例程，而且还支持在不同的图形环境中显示图形。为此，Matplotlib 提供了*后端*，用于生成不同格式的图形(例如，PNG、PDF、Postscript 和 SVG)以及使用适用于不同平台的各种不同的小部件工具包(例如，Qt、GTK、wxWidgets 和适用于 Mac OS X 的 Cocoa)在图形用户界面中显示图形。

可以在 Matplotlib 资源文件中选择使用哪个后端， <sup>[2](#Fn2)</sup> 或者使用函数`mpl.use`，该函数必须在导入`matplotlib`之后，导入`matplotlib.pyplot`模块之前调用。例如，要选择 Qt4Agg 后端，我们可以使用

```
import matplotlib as mpl
mpl.use('qt4agg')
import matplotlib.pyplot as plt

```

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig4_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig4_HTML.png)

图 4-4

使用 Mac OS X 上的 Qt4 后端显示图形的 Matplotlib 图形用户界面的屏幕截图。详细的外观因平台和后端而异，但基本功能是相同的。

用于显示 Matplotlib 图形的图形用户界面，如图 [4-4](#Fig4) 所示，对于与 Python 脚本文件或 IPython 控制台的交互使用非常有用，它允许交互地浏览图形，例如，通过缩放和平移。当使用交互式后端(在图形用户界面中显示图形)时，需要调用函数`plt.show`使窗口出现在屏幕上。默认情况下，`plt.show`调用将一直挂起，直到窗口关闭。为了获得更多的交互体验，我们可以通过调用`plt.ion`函数来激活*交互模式*。这指示 Matplotlib 接管 GUI 事件循环，并在图形创建后立即显示图形窗口，将控制流返回给 Python 或 IPython 解释器。为了使图形更改生效，我们需要使用函数`plt.draw`发出一个 redraw 命令。我们可以使用功能`plt.ioff`取消交互模式，并且我们可以使用功能`mpl.is_interactive`检查 Matplotlib 是处于交互模式还是非交互模式。

虽然交互式图形用户界面具有独特的优势，但在使用 Jupyter 笔记本或 Qtconsole 时，直接在笔记本中显示 Matplotlib 生成的图形通常更方便。这个行为是使用 IPython 命令`%matplotlib inline`激活的，它激活了 IPython 提供的“内联后端”。这会将 Matplotlib 配置为使用非交互式后端来生成图形图像，然后在 Jupyter Notebook 中显示为静态图像。可以使用 IPython `%config`命令对 Matplotlib 的 IPython“内联后端”进行微调。例如，我们可以使用`InlineBackend.figure_format`选项、 <sup>[3](#Fn3)</sup> 为生成的图形选择输出格式，例如，我们可以设置为“svg”来生成 SVG 图形而不是 PNG 文件:

```
In [8]: %matplotlib inline
In [9]: %config InlineBackend.figure_format='svg'

```

使用这种方法，图形用户界面的交互式方面丢失了(例如，缩放和平移)，但是将图形直接嵌入笔记本具有许多其他优点。例如，将用于生成图形的代码与生成的图形保存在同一个文档中，就不需要重新运行代码来显示图形，而且 Jupyter Notebook 本身的交互性取代了 Matplotlib 图形用户界面的某些交互性。

当使用 IPython 内联后端时，没有必要使用`plt.show`和`plt.draw`，因为 IPython 富显示系统负责触发图形的渲染和显示。在本书中，我将假设代码示例在 Jupyter 笔记本中执行，因此对函数`plt.show`的调用不在代码示例中。当使用交互式后端时，有必要在每个示例的末尾添加这个函数调用。

## 数字

正如上一节所介绍的，Matplotlib 中使用了`Figure`对象来表示一个图形。除了提供一个画布，例如，`Axes`实例可以放在上面，`Figure`对象还提供了对图形执行操作的方法，它有几个属性可以用来配置图形的属性。

可以使用函数`plt.figure`创建一个`Figure`对象，该函数采用几个可选的关键字参数来设置图形属性。特别是，它接受了`figsize`关键字参数，该参数应该分配给表单`(width, height)`上的一个元组，以英寸为单位指定图形画布的宽度和高度。通过设置`facecolor`关键字参数来指定图形画布的颜色也很有用。

一旦创建了一个`Figure`，我们可以使用`add_axes`方法创建一个新的`Axes`实例，并将其分配给图形画布上的一个区域。`add_axes`带一个强制参数:一个包含图形画布坐标系中左下角坐标和`Axes`宽度和高度的列表，格式为`(left, bottom, width, height).`<sup>[4](#Fn4)</sup>`Axes`对象的坐标和宽度和高度表示为整个画布宽度和高度的分数；见图 [4-1](#Fig1) 。例如，完全填充画布的`Axes`对象对应于`(0, 0, 1, 1)`，但是这没有为轴标签和刻度留下空间。更实际的大小可能是`(0.1, 0.1, 0.8, 0.8)`，它对应于一个居中的`Axes`实例，覆盖了画布宽度和高度的 80%。`add_axes`方法接受大量关键字参数来设置新`Axes`实例的属性。这些将在本章后面深入讨论`Axes`对象时详细描述。然而，这里值得强调的一个关键字参数是`facecolor`，用它我们可以为`Axes`对象分配一个背景颜色。与`plt.figure`的`facecolor`参数一起，这允许选择画布和由`Axes`实例覆盖的区域的颜色。

有了从`plt.figure`和`fig.add_axes`获得的`Figure`和`Axes`对象，我们就有了使用`Axes`对象的方法开始绘制数据的必要准备。有关这方面的更多详细信息，请参见本章的下一节。然而，一旦创建了所需的图形，在图形创建工作流程中，`Figure`对象中还有更多重要的方法。例如，要设置一个整体图形标题，我们可以使用`suptitle`，它接受一个带有标题的字符串作为参数。要将图形保存到文件中，我们可以使用`savefig`方法。这个方法接受一个字符串，输出文件名作为第一个参数，还有几个可选的关键字参数。默认情况下，输出文件格式将由 filename 参数的文件扩展名决定，但是我们也可以使用`format`参数显式指定格式。可用的输出格式取决于使用的 Matplotlib 后端，但通常可用的选项是 PNG、PDF、EPS 和 SVG 格式。生成图像的分辨率可以用`dpi`参数设置。DPI 代表“每英寸点数”，由于图形大小是使用`figsize`参数以英寸为单位指定的，因此将这些数字相乘可以得到以像素为单位的输出图像大小。例如，使用`figsize=(8, 6)`和`dpi=100`，生成的图像大小为 800x600 像素。`savefig`方法也接受一些类似于`plt.figure`函数的参数，比如`facecolor`参数。注意，即使`facecolor`参数与`plt.figure`一起使用，它也需要与`savefig`一起指定，以便应用于生成的图像文件。最后，还可以使用`savefig`的`transparent=True`参数使图形画布透明。下面的代码清单演示了这些技术，结果如图 [4-5](#Fig5) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig5_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig5_HTML.png)

图 4-5

用`figsize`设置图形大小，用`add_axes`添加一个新的`Axes`实例，用`facecolor`设置`Figure`和`Axes`对象的背景颜色，最后用`savefig`将图形保存到文件中

```
In [10]: fig = plt.figure(figsize=(8, 2.5), facecolor="#f1f1f1")
    ...:
    ...: # axes coordinates as fractions of the canvas width and height
    ...: left, bottom, width, height = 0.1, 0.1, 0.8, 0.8
    ...: ax = fig.add_axes((left, bottom, width, height), facecolor="#e1e1e1")
    ...:
    ...: x = np.linspace(-2, 2, 1000)
    ...: y1 = np.cos(40 * x)
    ...: y2 = np.exp(-x**2)
    ...:
    ...: ax.plot(x, y1 * y2)
    ...: ax.plot(x, y2, 'g')
    ...: ax.plot(x, -y2, 'g')
    ...: ax.set_xlabel("x")
    ...: ax.set_ylabel("y")
    ...:
    ...: fig.savefig("graph.png", dpi=100, facecolor="#f1f1f1")

```

## 轴线

上一节中介绍的`Figure`对象提供了 Matplotlib 图的主干，但是所有有趣的内容都是在`Axes`实例中或围绕着它组织的。我们已经在本章前面几次遇到了`Axes`物体。`Axes`对象是大多数 Matplotlib 库绘图活动的核心。它提供了我们可以在其中绘制数据和数学函数的坐标系统，此外，它还包含确定轴标签和轴刻度放置位置的轴对象。绘制不同类型图的函数也是这个`Axes`类的方法。在本节中，我们首先探索可以使用`Axes`方法绘制的不同类型的图，以及如何定制 *x* 和 *y* 轴的外观以及用于`Axes`对象的坐标系。

我们已经看到了如何使用`add_axes`方法将新的`Axes`实例显式地添加到图形中。这是一个灵活而强大的方法，可以将`Axes`对象放置在任意位置，它有几个重要的应用，我们将在本章后面看到。然而，对于大多数常见的用例来说，在图形画布中显式指定`Axes`实例的坐标是很繁琐的。当在一个图形中使用多个`Axes`实例面板时，尤其如此，例如，在网格布局中。Matplotlib 提供了几个不同的`Axes`布局管理器，它们按照不同的策略在图形画布中创建和放置`Axes`实例。在这一章的后面，我们将更详细地讨论如何使用这样的布局管理器。然而，为了方便接下来的例子，我们在这里简单地看一下其中一个布局管理器:`plt.subplots`函数。在本章的前面，我们已经使用这个函数在一个函数调用中方便地生成了新的`Figure`和`Axes`对象。然而，`plt.subplots`函数也能够用`Axes`实例的网格填充图形，这是使用第一个和第二个参数指定的，或者用`nrows`和`ncols`参数指定的，顾名思义，这创建了一个具有给定行数和列数的`Axes`对象的网格。例如，要在新创建的`Figure`对象中生成一个由`Axes`实例组成的网格，有三行两列，我们可以使用

```
fig, axes = plt.subplots(nrows=3, ncols=2)

```

这里，`plt.subplots`函数返回一个元组`(fig, axes)`，其中`fig`是一个`Figure`实例，`axes`是一个大小为`(nrows, ncols)`的 NumPy 数组，其中每个元素都是一个`Axes`实例，已经被适当地放置在相应的图形画布中。此时，我们还可以使用`sharex`和`sharey`参数指定列和/或行应该共享 x 和 y 轴，这些参数可以设置为`True`或`False`。

`plt.subplots`函数还带有两个特殊的关键字参数`fig_kw`和`subplot_kw`，它们是分别在创建`Figure`和`Axes`实例时使用的关键字参数字典。这允许我们使用`plt.subplots`设置并保持对`Figure`和`Axes`对象属性的完全控制，就像直接使用`plt.figure`和`make_axes`方法一样。

### 地块类型

有效的科学和技术数据可视化需要各种各样的绘图技术。Matplotlib 实现了许多类型的绘图技术作为`Axes`对象的方法。例如，在前面的例子中，我们已经使用了`plot`方法，它在`Axes`对象提供的坐标系中绘制曲线。在接下来的几节中，我们将通过在示例图中使用 Matplotlib 的一些绘图函数来更深入地探讨这些函数。图 [4-6](#Fig6) 总结了常用的 2D 绘图功能。其他类型的图形，如彩色地图和 3D 图形，将在本章后面讨论。Matplotlib 中的所有绘图函数都期望数据作为 NumPy 数组作为输入，通常是以 *x* 和 *y* 坐标作为第一个和第二个参数的数组。有关详细信息，请参见图 [4-6](#Fig6) 所示的每个方法的文档字符串，例如使用`help(plt.Axes.bar)`。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig6_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig6_HTML.png)

图 4-6

所选 2D 图形类型概览。生成每种图形的`Axes`方法的名称与相应的图形一起显示。

### 线条属性

最基本的绘图类型是简单的线图。例如，它可用于描绘单变量函数的图形，或绘制作为控制变量函数的数据。在线图中，我们经常需要配置图中线条的属性，例如，线条宽度、线条颜色和线条样式(实线、虚线、点线等)。).在 Matplotlib 中，我们用关键字参数为绘图方法设置这些属性，例如`plot`、`step`和`bar`。图 [4-6](#Fig6) 显示了其中一些图形类型。许多绘图方法都有自己特定的参数，但基本属性(如颜色和线宽)是大多数绘图方法共有的。表 [4-1](#Tab1) 总结了这些基本属性和相应的关键字参数。

表 4-1

用于 Matplotlib 绘图方法的基本线条特性及其相应的参数名称

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

争吵

 | 

示例值

 | 

描述

 |
| --- | --- | --- |
| `color` | 颜色规范可以是带有颜色名称的字符串，如“红色”、“蓝色”等。，或表格“#aabbcc”上的 RGB 颜色代码 | 颜色规格。 |
| `alpha` | 介于 0.0(完全透明)和 1.0(完全不透明)之间的浮点数。 | 透明度的数量。 |
| `linewidth, lw` | 浮点数。 | 线条的宽度。 |
| `linestyle, ls` | “-”–实心"-"–虚线":"–带点".-"–点划线 | 线条的样式，即线条是绘制为实线，还是应该绘制为虚线。 |
| `marker` | +，o，* =十字形，圆形，星形s =正方形。=小圆点1, 2, 3, 4, ...=不同角度的三角形符号。 | 每个数据点，无论它是否与相邻的数据点相连，都可以用一个标记符号来表示，如该参数所指定的。 |
| `markersize` | 浮点数。 | 标记大小。 |
| `markerfacecolor` | 颜色规格(参见上文)。 | 标记的填充颜色。 |
| `markeredgewidth` | 浮点数。 | 标记边缘的线条宽度。 |
| `markeredgecolor` | 颜色规格(见上文)。 | 标记边缘颜色。 |

为了说明这些属性和参数的用法，请考虑下面的代码，该代码使用不同的线宽、线条样式、标记符号、颜色和大小值绘制水平线。结果图如图 [4-7](#Fig7) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig7_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig7_HTML.png)

图 4-7

显示线条属性线宽、线条样式、标记类型和标记大小以及颜色设置结果的图形

```
In [11]: x = np.linspace(-5, 5, 5)
    ...: y = np.ones_like(x)
    ...:
    ...: def axes_settings(fig, ax, title, ymax):
    ...:    ax.set_xticks([])
    ...:    ax.set_yticks([])
    ...:    ax.set_ylim(0, ymax+1)
    ...:    ax.set_title(title)
    ...:
    ...: fig, axes = plt.subplots(1, 4, figsize=(16,3))
    ...:
    ...: # Line width
    ...: linewidths = [0.5, 1.0, 2.0, 4.0]
    ...: for n, linewidth in enumerate(linewidths):
    ...:    axes[0].plot(x, y + n, color="blue", linewidth=linewidth)
    ...: axes_settings(fig, axes[0], "linewidth", len(linewidths))
    ...:
    ...: # Line style

    ...: linestyles = ['-', '-.', ':']
    ...: for n, linestyle in enumerate(linestyles):
    ...:    axes[1].plot(x, y + n, color="blue", lw=2, linestyle=linestyle)
    ...: # custom dash style
    ...: line, = axes[1].plot(x, y + 3, color="blue", lw=2)
    ...: length1, gap1, length2, gap2 = 10, 7, 20, 7
    ...: line.set_dashes([length1, gap1, length2, gap2])
    ...: axes_settings(fig, axes[1], "linetypes", len(linestyles) + 1)

    ...: # marker types

    ...: markers = ['+', 'o', '*', 's', '.', '1', '2', '3', '4']
    ...: for n, marker in enumerate(markers):
    ...:    # lw = shorthand for linewidth, ls = shorthand for linestyle
    ...:    axes[2].plot(x, y + n, color="blue", lw=2, ls='*', marker=marker)
    ...: axes_settings(fig, axes[2], "markers", len(markers))
    ...:
    ...: # marker size and color
    ...: markersizecolors = [(4, "white"), (8, "red"), (12, "yellow"), (16, "lightgreen")]
    ...: for n, (markersize, markerfacecolor) in enumerate(markersizecolors):
    ...:    axes[3].plot(x, y + n, color="blue", lw=1, ls='-',
    ...:                 marker='o', markersize=markersize,
    ...:                 markerfacecolor=markerfacecolor, markeredgewidth=2)
    ...: axes_settings(fig, axes[3], "marker size/color", len(markersizecolors))

```

在实践中，使用不同的颜色、线条宽度和线条样式是使图表易于阅读的重要工具。在有大量线条的图形中，我们可以使用颜色和线条样式的组合来使每条线条唯一可识别，例如，通过图例。线宽属性最适合用来强调重要的线条。考虑以下示例，其中绘制了函数 sin( *x* )及其围绕 *x* = 0 的前几个级数展开，如图 [4-8](#Fig8) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig8_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig8_HTML.png)

图 4-8

sin(x)的图形及其最低几阶的泰勒级数近似

```
In [12]: # a symbolic variable for x, and a numerical array with specific values of x
    ...: sym_x = sympy.Symbol("x")
    ...: x = np.linspace(-2 * np.pi, 2 * np.pi, 100)
    ...:
    ...: def sin_expansion(x, n):
    ...:     """
    ...:     Evaluate the nth order Taylor. series expansion
    ...:     of sin(x) for the numerical values in the array x.
    ...:     """
    ...:     return sympy.lambdify(sym_x, sympy.sin(sym_x).series(n=n+1).removeO(), 'numpy')(x)
    ...:
    ...: fig, ax = plt.subplots()
    ...:
    ...: ax.plot(x, np.sin(x), linewidth=4, color="red", label="exact")
    ...:
    ...: colors = ["blue", "black"]
    ...: linestyles = [':', '-.', '--']
    ...: for idx, n in enumerate(range(1, 12, 2)):
    ...:     ax.plot(x, sin_expansion(x, n), color=colors[idx // 3],
    ...:             linestyle=linestyles[idx % 3], linewidth=3,
    ...:             label="order %d approx." % (n+1))
    ...:
    ...:  ax.set_ylim(-1.1, 1.1)
    ...: ax.set_xlim(-1.5*np.pi, 1.5*np.pi)
    ...:
    ...: # place a legend outsize of the Axes
    ...: ax.legend(bbox_to_anchor=(1.02, 1), loc=2, borderaxespad=0.0)
    ...: # make room for the legend to the right of the Axes
    ...: fig.subplots_adjust(right=.75)

```

### 传说

有多条线的图形通常会受益于图例，图例会在图形中的某个位置沿每种线型显示一个标签。正如我们在前面的例子中看到的，可以使用`legend`方法将图例添加到 Matplotlib 图形中的`Axes`实例。图例中仅包含已分配标签的线条(要为线条分配标签，请使用`label`参数，例如`Axes.plot`)。legend 方法接受大量可选参数。详见`help(plt.legend)`。这里我们强调几个更有用的论点。在上一节的示例中，我们使用了`loc`参数，该参数允许指定在`Axes`区域中添加图例的位置:`loc=1`用于右上角、`loc=2`用于左上角、`loc=3`用于左下角、`loc=4`用于右下角，如图 [4-9](#Fig9) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig9_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig9_HTML.png)

图 4-9

一个`Axes`实例中不同位置的图例，使用方法`legend`的`loc`参数指定

在上一节的例子中，我们还使用了`bbox_to_anchor`，在它的帮助下，可以将图例放置在图形画布中的任意位置。`bbox_to_anchor`参数以`(x, y)`的形式获取一个元组的值，其中`x`和`y`是`Axes`对象内的*画布坐标*。即点`(0, 0)`对应左下角，`(1, 1)`对应右上角。请注意，在这种情况下，`x`和`y`可以小于 0，也可以大于 1，这表示图例将放置在`Axes`区域之外，如前一节所用。

默认情况下，图例中的所有线条都以垂直排列方式显示。使用`ncols`参数，可以将图例标签分成多列，如图 [4-10](#Fig10) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig10_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig10_HTML.png)

图 4-10

图例显示在`Axes`对象外，显示为四列，而不是一列，这里使用的是`ax.legend(ncol=4, loc=3, bbox_to_anchor=(0, 1))`

### 文本格式和注释

文本标签、标题和注释是大多数图表中的重要组成部分，例如，完全控制用于呈现此类文本的字体类型和字体大小是制作出版物质量的图表的基本要求。Matplotlib 提供了几种配置字体属性的方法。默认值可以在 Matplotlib 资源文件中设置，会话范围的配置可以在`mpl.rcParams`字典中设置。该字典是 Matplotlib 资源文件的缓存，在 Python 解释器重启并再次导入 Matplotlib 之前，对该字典中参数的更改都是有效的。与如何显示文本相关的参数包括，例如，`'font.family'`和`'font.size'`。

### 小费

尝试`print(mpl.rcParams)`获取可能的配置参数及其当前值的列表。更新参数很简单，只需在字典`mpl.rcParams`中为相应的条目分配一个新值，例如`mpl.rcParams[`‘save fig . dpi’`] = 100.`参见`mpl.rc`函数，该函数可用于更新`mpl.rcParams`字典，而`mpl.rcdefaults`用于恢复默认值。

还可以根据具体情况设置文本属性，方法是将一组标准关键字参数传递给在图形中创建文本标签的函数。大多数处理文本标签的 Matplotlib 函数都以某种方式接受表 [4-2](#Tab2) 中总结的关键字参数(此列表是常见参数的不完整选择；完整参考见`help(mpl.text.Text)`。例如，这些参数可以与方法`Axes.text`一起使用，该方法在给定的坐标上创建一个新的文本标签。也可与`set_title`、`set_xlabel`、`set_ylabel`等搭配使用。有关这些方法的更多信息，请参见下一节。

在科学和技术可视化中，能够在文本标签中呈现数学符号和表达式显然很重要。Matplotlib 通过其文本标签中的 LaTeX 标记为此提供了出色的支持:Matplotlib 中的任何文本标签都可以通过将 LaTeX math 包含在$ signs 中来实现，例如，`"Regular text: $f(x)=1-x^2$"`。默认情况下，Matplotlib 使用内部 LaTeX 呈现，它支持 LaTeX 语言的子集。但是，通过设置配置参数`mpl.rcParams["text.usetex"]=True,`，也可以使用外部全功能 LaTeX 引擎(如果您的系统上有)。

在 Python 中将 LaTeX 代码嵌入字符串时，有一个常见的绊脚石:Python 使用\作为转义符，而在 LaTeX 中，它用于表示命令的开始。为了防止 Python 解释器对包含 LaTeX 表达式的字符串中的字符进行转义，可以方便地使用原始字符串，原始字符串是带有前缀和一个`r`的文字字符串表达式，例如 r `"$\int f(x) dx$" and r'$x_{\rm A}$'`。

以下示例演示了如何使用`ax.text`和`ax.annotate`向 Matplotlib 图形添加文本标签和注释，以及如何呈现包含 LaTeX 中排版的公式的文本标签。结果图如图 [4-11](#Fig11) 所示。

表 4-2

所选字体属性和相应关键字参数的摘要

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

争吵

 | 

描述

 |
| --- | --- |
| `fontsize` | 字体的大小，以磅为单位。 |
| `family or fontname` | 字体类型。 |
| `backgroundcolor` | 文本标签背景色的颜色规范。 |
| `color` | 字体颜色的颜色规范。 |
| `alpha` | 字体颜色的透明度。 |
| `rotation` | 文本标签的旋转角度。 |

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig11_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig11_HTML.png)

图 4-11

示例演示了使用`ax.text`和`ax.annotation`添加文本标签和注释以及在 Matplotlib 文本标签中包含 LaTeX 格式的等式的结果

```
In [13]: fig, ax = plt.subplots(figsize=(12, 3))
    ...:
    ...: ax.set_yticks([])
    ...: ax.set_xticks([])
    ...: ax.set_xlim(-0.5, 3.5)
    ...: ax.set_ylim(-0.05, 0.25)
    ...: ax.axhline(0)
    ...:
    ...: # text label
    ...: ax.text(0, 0.1, "Text label", fontsize=14, family="serif")
    ...:
    ...: # annotation
    ...: ax.plot(1, 0, "o")
    ...: ax.annotate("Annotation",
    ...:             fontsize=14, family="serif",
    ...:             xy=(1, 0), xycoords="data",
    ...:           xytext=(+20, +50), textcoords="offset points",
    ...:           arrowprops=dict(arrowstyle="->", connectionstyle="arc3, rad=.5"))
    ...:
    ...: # equation
    ...: ax.text(2, 0.1, r"Equation: $i\hbar\partial_t \Psi = \hat{H}\Psi$", fontsize=14, family="serif")
    ...:

```

### 轴属性

在创建了`Figure`和`Axes`对象之后，使用 Matplotlib 提供的许多绘图函数中的一些来绘制数据或函数，并且定制线条和标记的外观——图形的最后一个需要配置和微调的主要方面是轴实例。二维图形有两个轴对象:水平的 *x* 轴和垂直的 *y* 轴。每个轴都可以根据属性进行单独配置，例如轴标签、刻度和刻度标签的位置以及轴本身的位置和外观。在这一节中，我们将详细探讨如何控制图表的这些方面。

#### 坐标轴标签和标题

可以说，轴最重要的属性是轴标签，几乎在所有情况下都需要设置。我们可以使用`set_xlabel`和`set_ylabel`方法设置轴标签:它们都将标签作为第一个参数。此外，可选的`labelpad`参数以磅为单位指定从轴到标签的间距。为了避免轴标签和轴刻度标签之间的重叠，这种填充有时是必要的。`set_xlabel`和`set_ylabel`方法还接受额外的参数来设置文本属性，如`color`、`fontsize,`和`fontname`，如前一节详细讨论的。生成图 [4-12](#Fig12) 的以下代码演示了如何使用`set_xlabel`和`set_ylabel`方法以及这里讨论的关键字参数。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig12_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig12_HTML.png)

图 4-12

展示使用`set_xlabel`和`set_ylabel`设置 x 轴和 y 轴标签的结果的图表

```
In [14]: x = np.linspace(0, 50, 500)
    ...: y = np.sin(x) * np.exp(-x/10)
    ...:
    ...: fig, ax = plt.subplots(figsize=(8, 2), subplot_kw={'facecolor': "#ebf5ff"})
    ...:
    ...: ax.plot(x, y, lw=2)
    ...:
    ...: ax.set_xlabel("x", labelpad=5, fontsize=18, fontname="serif", color="blue")
    ...: ax.set_ylabel("f(x)", labelpad=15, fontsize=18, fontname="serif", color="blue")
    ...: ax.set_title("axis labels and title example", fontsize=16,
    ...:              fontname='serif', color="blue")

```

除了 x 和 y 轴上的标签，我们还可以使用`set_title`方法设置一个`Axes`对象的标题。这种方法采用的参数与`set_xlabel`和`set_ylabel`基本相同，唯一不同的是 loc 参数，它可以分配给`'left'`、`'centered'`和`'right'`，并指示标题是左对齐、居中还是右对齐。

#### 轴范围

默认情况下，Matplotlib 的 *x* 和 *y* 轴的范围自动调整为在`Axes`对象中绘制的数据。在许多情况下，这些默认范围就足够了，但在某些情况下，可能需要显式设置轴范围。在这种情况下，我们可以使用`Axes`对象的`set_xlim`和`set_ylim`方法。这两种方法都有两个参数，分别指定要在轴上显示的下限和上限。`set_xlim`和`set_ylim`的替代方法是`axis`方法，例如，该方法接受字符串参数`'tight'`，用于紧密拟合其包含的线的坐标范围，以及`'equal'`，用于沿着每个轴的一个单位长度对应于相同数量的像素的坐标范围(即，比例保持坐标系)。

也可以使用`autoscale`方法，通过将`True`和`False`作为第一个参数，将 *x* 和/或 *y* 轴的`axis`参数设置为`'x'`、`'y'`或`'both'`，有选择地打开和关闭自动缩放。以下示例显示了如何使用这些方法来控制轴范围。结果图如图 [4-13](#Fig13) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig13_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig13_HTML.png)

图 4-13

显示使用`set_xlim`、`set_ ylim`和`axis`方法设置图表中显示的轴范围的结果的图表

```
In [15]: x = np.linspace(0, 30, 500)
    ...: y = np.sin(x) * np.exp(-x/10)
    ...:
    ...:
    ...: fig, axes = plt.subplots(1, 3, figsize=(9, 3), subplot_kw={'facecolor': "#ebf5ff"})
    ...:
    ...: axes[0].plot(x, y, lw=2)
    ...: axes[0].set_xlim(-5, 35)
    ...: axes[0].set_ylim(-1, 1)
    ...: axes[0].set_title("set_xlim / set_y_lim")
    ...:
    ...: axes[1].plot(x, y, lw=2)
    ...: axes[1].axis('tight')
    ...: axes[1].set_title("axis('tight')")
    ...:
    ...: axes[2].plot(x, y, lw=2)
    ...: axes[2].axis('equal')
    ...: axes[2].set_title("axis('equal')")

```

#### 坐标轴刻度、刻度标签和网格

有待配置的轴的最终基本属性是轴刻度的位置以及相应刻度标签的位置和格式。轴刻度是图表整体外观的重要组成部分，在准备出版物和产品质量的图表时，通常需要对轴刻度进行详细控制。Matplotlib 模块`mpl.ticker`提供了一个通用的、可扩展的分笔成交点管理系统，可以完全控制分笔成交点的放置。Matplotlib 区分主要刻度和次要刻度。默认情况下，每个主要刻度都有一个相应的标签，主要刻度之间的距离可以用没有标签的次要刻度来进一步标记，尽管此功能必须显式打开。参见图 [4-14](#Fig14) 中主刻度和次刻度的图示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig14_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig14_HTML.png)

图 4-14

大调和小调的区别

当处理记号的配置时，最常见的设计目标是确定带有标签的主要记号应该沿坐标轴放置在哪里。`mpl.ticker`模块为不同的节拍布局策略提供了类。例如，`mpl.ticker.MaxNLocator`可用于设置最大数量的刻度(在未指定的位置)，`mpl.ticker.MultipleLocator`可用于设置给定基数倍数的刻度，`mpl.ticker.FixedLocator`可用于在明确指定的坐标放置刻度。要改变 ticker 策略，我们可以使用`Axes.xaxis`和`Axes.yaxis`中的`set_major_locator`和`set_minor_locator`方法。这些方法接受在`mpl.ticker`中定义的 ticker 类的实例，或者从这些类之一派生的定制类。

当显式指定记号位置时，我们也可以使用方法`set_xticks`和`set_yticks`，它们接受放置主要记号的坐标列表。在这种情况下，还可以使用`set_xticklabels`和`set_yticklabels`为每个 tick 设置定制标签，这两个选项期望字符串列表用作相应 tick 的标签。如果可能的话，最好使用通用的记号放置策略，例如`mpl.ticker.MaxNLocator`，因为如果坐标范围改变，它们会动态调整，而使用 set_xticks 和 set_yticks 的显式记号放置则需要手动更改代码。然而，当必须控制分笔成交点的准确位置时，那么`set_xticks`和`set_yticks`是方便的方法。

以下代码演示了如何使用前面段落中讨论的方法的组合来更改默认刻度位置，结果图如图 [4-15](#Fig15) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig15_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig15_HTML.png)

图 4-15

演示控制主刻度和次刻度沿 *x* 轴和 *y* 轴的放置和外观的不同方式的图表

```
In [16]: x = np.linspace(-2 * np.pi, 2 * np.pi, 500)
    ...: y = np.sin(x) * np.exp(-x**2/20)
    ...:
    ...: fig, axes = plt.subplots(1, 4, figsize=(12, 3))
    ...:
    ...: axes[0].plot(x, y, lw=2)
    ...: axes[0].set_title("default ticks")

    ...: axes[1].plot(x, y, lw=2)
    ...: axes[1].set_title("set_xticks")
    ...: axes[1].set_yticks([-1, 0, 1])
    ...: axes[1].set_xticks([-5, 0, 5])
    ...:
    ...: axes[2].plot(x, y, lw=2)
    ...: axes[2].set_title("set_major_locator")
    ...: axes[2].xaxis.set_major_locator(mpl.ticker.MaxNLocator(4))
    ...: axes[2].yaxis.set_major_locator(mpl.ticker.FixedLocator([-1, 0, 1]))
    ...: axes[2].xaxis.set_minor_locator(mpl.ticker.MaxNLocator(8))
    ...: axes[2].yaxis.set_minor_locator(mpl.ticker.MaxNLocator(8))
    ...:
    ...: axes[3].plot(x, y, lw=2)
    ...: axes[3].set_title("set_xticklabels")
    ...: axes[3].set_yticks([-1, 0, 1])
    ...: axes[3].set_xticks([-2 * np.pi, -np.pi, 0, np.pi, 2 * np.pi])
    ...: axes[3].set_xticklabels([r'$-2\pi$', r'$-\pi$', 0, r'$\pi$', r'$2\pi$'])
    ...: x_minor_ticker = mpl.ticker.FixedLocator([-3 * np.pi / 2, -np.pi / 2, 0,
    ...:                                           np.pi / 2, 3 * np.pi / 2])
    ...: axes[3].xaxis.set_minor_locator(x_minor_ticker)
    ...: axes[3].yaxis.set_minor_locator(mpl.ticker.MaxNLocator(4))

```

图表中一个常用的设计元素是网格线，在从图表中读取值时，网格线可以作为一个视觉向导。网格和网格线与轴记号密切相关，因为它们是以相同的坐标值绘制的，因此本质上是跨越图形的记号的延伸。在 Matplotlib 中，我们可以使用 axes 对象的`grid`方法打开轴网格。grid 方法使用可选的关键字参数来控制网格的外观。例如，像 Matplotlib 中的许多绘图函数一样，`grid`方法接受参数`color`、`linestyle,`和`linewidth`，用于指定网格线的属性。此外，它采用参数`which`和`axis`，可以分别赋值为`'major'`、`'minor'`或`'both'`，以及`'x'`、`'y'`或`'both'`。这些参数用于指示给定样式将应用于哪个轴上的哪些刻度。如果网格线需要几种不同的样式，可以多次调用`grid`，使用不同的`which`和`axis`值。关于如何添加网格线以及如何以不同方式设置网格线样式的示例，参见以下示例，该示例生成了如图 [4-16](#Fig16) 所示的图表。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig16_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig16_HTML.png)

图 4-16

展示使用网格线的结果的图形

```
In [17]: fig, axes = plt.subplots(1, 3, figsize=(12, 4))

    ...: x_major_ticker = mpl.ticker.MultipleLocator(4)
    ...: x_minor_ticker = mpl.ticker.MultipleLocator(1)
    ...: y_major_ticker = mpl.ticker.MultipleLocator(0.5)
    ...: y_minor_ticker = mpl.ticker.MultipleLocator(0.25)
    ...:
    ...: for ax in axes:
    ...:     ax.plot(x, y, lw=2)
    ...:     ax.xaxis.set_major_locator(x_major_ticker)
    ...:     ax.yaxis.set_major_locator(y_major_ticker)
    ...:     ax.xaxis.set_minor_locator(x_minor_ticker)
    ...:     ax.yaxis.set_minor_locator(y_minor_ticker)
    ...:
    ...: axes[0].set_title("default grid")
    ...: axes[0].grid()
    ...:
    ...: axes[1].set_title("major/minor grid")
    ...: axes[1].grid(color="blue", which="both", linestyle=':', linewidth=0.5)
    ...:
    ...: axes[2].set_title("individual x/y major/minor grid")
    ...: axes[2].grid(color="grey", which="major", axis="x", linestyle='-', linewidth=0.5)
    ...: axes[2].grid(color="grey", which="minor", axis="x", linestyle=':', linewidth=0.25)
    ...: axes[2].grid(color="grey", which="major", axis="y", linestyle='-', linewidth=0.5)

```

除了控制刻度位置，Matplotlib `mpl.ticker`模块还提供了定制刻度标签的类。例如，`mpl.ticker`模块中的`ScalarFormatter`可用于设置几个有用的属性，这些属性与显示带有科学记数法的刻度标签相关，用于显示大数值的轴标签。如果使用`set_scientific`方法激活科学记数法，我们可以控制科学记数法何时与`set_powerlimits`方法一起使用的阈值(默认情况下，小数字的刻度标签不使用科学记数法显示)，并且我们可以在创建`ScalarFormatter`实例时使用`useMathText=True`参数，以便以数学样式显示指数，而不是使用代码样式指数(例如`1e10`)。有关在刻度标签中使用科学记数法的示例，请参见以下代码。结果图如图 [4-17](#Fig17) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig17_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig17_HTML.png)

图 4-17

科学记数法中带有刻度标签的图表。左侧面板使用默认标签格式，而右侧面板使用科学记数法中的刻度标签，呈现为数学文本。

```
In [19]: fig, axes = plt.subplots(1, 2, figsize=(8, 3))
    ...:
    ...: x = np.linspace(0, 1e5, 100)
    ...: y = x ** 2
    ...:
    ...: axes[0].plot(x, y, 'b.')
    ...: axes[0].set_title("default labels", loc="right")
    ...:
    ...: axes[1].plot(x, y, 'b')
    ...: axes[1].set_title("scientific notation labels", loc="right")
    ...:
    ...: formatter = mpl.ticker.ScalarFormatter(useMathText=True)
    ...: formatter.set_scientific(True)
    ...: formatter.set_powerlimits((-1,1))
    ...: axes[1].xaxis.set_major_formatter(formatter)
    ...: axes[1].yaxis.set_major_formatter(formatter)

```

#### 对数图

在跨越几个数量级的数据可视化中，使用对数坐标系非常有用。在 Matplotlib 中，有几个绘图函数用于在这样的坐标系中绘图，例如，`loglog`、`semilogx`和`semilogy`，它们分别对 *x* 和 *y* 轴、仅对 *x* 轴和仅对 *y* 轴使用对数刻度。除了对数轴刻度，这些函数的行为类似于标准绘图方法。另一种方法是使用标准绘图方法，并使用`set_xscale`和/或`set_yscale`方法将轴刻度单独配置为对数刻度，并将`'log'`作为第一参数。这些生成对数标度图的方法在下一节中举例说明，生成的图表如图 [4-18](#Fig18) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig18_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig18_HTML.png)

图 4-18

对数比例图示例

```
In [20]: fig, axes = plt.subplots(1, 3, figsize=(12, 3))
    ...:
    ...: x = np.linspace(0, 1e3, 100)
    ...: y1, y2 = x**3, x**4
    ...:
    ...: axes[0].set_title('loglog')
    ...: axes[0].loglog(x, y1, 'b', x, y2, 'r')
    ...:
    ...: axes[1].set_title('semilogy')
    ...: axes[1].semilogy(x, y1, 'b', x, y2, 'r')
    ...:
    ...: axes[2].set_title('plot / set_xscale / set_yscale')
    ...: axes[2].plot(x, y1, 'b', x, y2, 'r')
    ...: axes[2].set_xscale('log')
    ...: axes[2].set_yscale('log')

```

#### 双轴

Matplotlib 提供的一个有趣的轴技巧是双轴特性，它允许显示两个相互重叠的独立轴。这在绘制两个不同的量时很有用，例如，在同一个图形中使用不同的单位。演示该特性的简单示例如下所示，结果图如图 [4-19](#Fig19) 所示。这里我们使用`twinx`方法(还有一个`twiny`方法)来产生第二个`Axes`实例，它有一个共享的 *x* 轴和一个新的独立的 *y* 轴，显示在图表的右侧。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig19_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig19_HTML.png)

图 4-19

双轴图形示例

```
In [21]: fig, ax1 = plt.subplots(figsize=(8, 4))
    ...:
    ...: r = np.linspace(0, 5, 100)
    ...: a = 4 * np.pi * r ** 2  # area
    ...: v = (4 * np.pi / 3) * r ** 3  # volume
    ...:
    ...: ax1.set_title("surface area and volume of a sphere", fontsize=16)
    ...: ax1.set_xlabel("radius [m]", fontsize=16)
    ...:
    ...: ax1.plot(r, a, lw=2, color="blue")
    ...: ax1.set_ylabel(r"surface area ($m^2$)", fontsize=16, color="blue")
    ...: for label in ax1.get_yticklabels():
    ...:     label.set_color("blue")
    ...:
    ...: ax2 = ax1.twinx()
    ...: ax2.plot(r, v, lw=2, color="red")
    ...: ax2.set_ylabel(r"volume ($m^3$)", fontsize=16, color="red")
    ...: for label in ax2.get_yticklabels():
    ...:    label.set_color("red")

```

#### 脊柱

在到目前为止生成的所有图形中，我们总是有一个框包围着`Axes`区域。这确实是科学和技术图表的常见样式，但在某些情况下，例如，在表示示意图时，可能需要移动这些坐标线。组成包围框的线在 Matplotlib 中称为轴棘，我们可以使用`Axes.spines`属性来更改它们的属性。例如，我们可能希望删除顶部和右侧的脊线，并移动脊线以与坐标系的原点重合。

`Axes`对象的`spines`属性是一个带有键`right`、`left`、`top`和`bottom`的字典，可用于单独访问每个脊椎。我们可以使用`set_color`方法将颜色设置为`'None'`以指示不应该显示某个特定的脊线，在这种情况下，我们还需要使用`Axes.xaxis`和`Axes.yaxis`的`set_ticks_position`方法(分别接受参数`'both'`、`'top'`或`'bottom'`和`'both'`、`'left',`或`'right'`)移除与该脊线相关联的记号。使用这些方法，我们可以将周围的框转换到 *x* 和 *y* 坐标轴，如下例所示。得到的图形如图 [4-20](#Fig20) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig20_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig20_HTML.png)

图 4-20

带有轴棘的图形示例

```
In [22]: x = np.linspace(-10, 10, 500)
    ...: y = np.sin(x) / x
    ...:
    ...: fig, ax = plt.subplots(figsize=(8, 4))
    ...:
    ...: ax.plot(x, y, linewidth=2)
    ...:
    ...: # remove top and right spines
    ...: ax.spines['right'].set_color('none')
    ...: ax.spines['top'].set_color('none')
    ...:
    ...: # remove top and right spine ticks
    ...: ax.xaxis.set_ticks_position('bottom')
    ...: ax.yaxis.set_ticks_position('left')
    ...:
    ...: # move bottom and left spine to x = 0 and y = 0
    ...: ax.spines['bottom'].set_position(('data', 0))
    ...: ax.spines['left'].set_position(('data', 0))
    ...:
    ...: ax.set_xticks([-10, -5, 5, 10])
    ...: ax.set_yticks([0.5, 1])
    ...:
    ...: # give each label a solid background of white, to not overlap with the plot line
    ...: for label in ax.get_xticklabels() + ax.get_yticklabels():
    ...:    label.set_bbox({'facecolor': 'white',
    ...:                    'edgecolor': 'white'})

```

## 高级轴布局

到目前为止，我们已经重复使用了`plt.figure`、`Figure.make_axes,`和`plt.subplots`来创建新的`Figure`和`Axes`实例，然后我们用它们来生成图形。在科学和技术可视化中，通常将不同面板中的多个图形打包在一起，例如，在网格布局中。在 Matplotlib 中，使用各种不同的布局策略，有自动创建`Axes`对象并将它们放置在图形画布上的功能。我们已经使用了`plt.subplots`函数，它能够生成 Axes 对象的统一网格。在本节中，我们将探索`plt.subplots`函数的其他特性，并介绍`subplot2grid`和`GridSpec`布局管理器，它们在如何在图形画布中分布`Axes`对象方面更加灵活。

### 昆虫

在深入了解如何使用更高级的`Axes`布局管理器的细节之前，有必要后退一步，考虑我们用来向图形画布添加`Axes`实例的第一种方法的一个重要用例:T2 方法。这种方法非常适合创建所谓的插图，即显示在另一个图形区域内的较小图形。例如，Insets 经常用于显示较大图形中特别感兴趣的放大区域，或者用于显示一些次要的相关图形。

在 Matplotlib 中，我们可以在图形画布中的任意位置放置额外的`Axes`对象，即使它们与现有的`Axes`对象重叠。为了创建一个插图，我们简单地添加一个新的`Axes`对象，带有`Figure.make_axes`和插图应该放置的坐标(图形画布)。带有插图的图形的典型示例由以下代码生成，该代码生成的图形如图 [4-21](#Fig21) 所示。在为插图创建`Axes`对象时，使用参数`facecolor='none'`可能会很有用，它表示不应该有背景色，也就是说，插图的`Axes`背景应该是透明的。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig21_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig21_HTML.png)

图 4-21

带有插图的图表示例

```
In [23]: fig = plt.figure(figsize=(8, 4))
    ...:
    ...: def f(x):
    ...:     return 1/(1 + x**2) + 0.1/(1 + ((3 - x)/0.1)**2)
    ...:
    ...: def plot_and_format_axes(ax, x, f, fontsize):
    ...:     ax.plot(x, f(x), linewidth=2)
    ...:     ax.xaxis.set_major_locator(mpl.ticker.MaxNLocator(5))
    ...:     ax.yaxis.set_major_locator(mpl.ticker.MaxNLocator(4))
    ...:     ax.set_xlabel(r"$x$", fontsize=fontsize)
    ...:     ax.set_ylabel(r"$f(x)$", fontsize=fontsize)
    ...:
    ...: # main graph
    ...: ax = fig.add_axes([0.1, 0.15, 0.8, 0.8], facecolor="#f5f5f5")
    ...: x = np.linspace(-4, 14, 1000)
    ...: plot_and_format_axes(ax, x, f, 18)
    ...:
    ...: # inset
    ...: x0, x1 = 2.5, 3.5
    ...: ax.axvline(x0, ymax=0.3, color="grey", linestyle=":")
    ...: ax.axvline(x1, ymax=0.3, color="grey", linestyle=":")
    ...:
    ...: ax_insert = fig.add_axes([0.5, 0.5, 0.38, 0.42], facecolor="none")
    ...: x = np.linspace(x0, x1, 1000)
    ...: plot_and_format_axes(ax_insert, x, f, 14)

```

### 支线剧情

我们已经广泛使用了`plt.subplots`,我们已经注意到它返回一个带有`Figure`实例的 tuple 和一个带有函数调用中请求的每一行和每一列的`Axes`对象的 NumPy 数组。在绘制支线剧情网格时，经常会出现这样的情况，或者是 x 轴*或者是 y 轴*或者是两者都在支线剧情中共享。在这种情况下，使用`sharex`和`sharey`参数到`plt.subplots`会很有用，因为这样可以防止相同的轴标签在多个`Axes`中重复。

另外值得注意的是，默认情况下，`plt.subplots`返回的带有`Axes`实例的 NumPy 数组的维度是“压缩”的:也就是说，长度为 1 的维度从数组中删除。如果请求的列数和行数都大于 1，则返回一个二维数组，但是如果列数或行数都是 1，则返回一个一维(或标量，即唯一的`Axes`对象本身)。我们可以通过将参数`squeeze=False`传递给`plt.subplots`函数来关闭 NumPy 数组维度的压缩。在这种情况下，`fig, axes = plt.subplots(nrows, ncols)`中的`axes`变量总是一个二维数组。

使用`plt.subplots_adjust`函数可以实现最后一点可配置性，该函数允许显式设置整个`Axes`网格的左、右、下和上坐标，以及网格中`Axes`实例之间的宽度(`wspace`和高度间距(`hspace`)。参见以下代码和相应的图 [4-22](#Fig22) ，了解如何使用共享的 *x* 和 *y* 轴以及调整后的`Axes`间距设置`Axes`网格的分步示例。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig22_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig22_HTML.png)

图 4-22

使用`plt.subplot`和`plt.subplot_adjust`的示例图

```
In [24]: fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True, squeeze=False)
    ...:
    ...: x1 = np.random.randn(100)
    ...: x2 = np.random.randn(100)
    ...:
    ...: axes[0, 0].set_title("Uncorrelated")
    ...: axes[0, 0].scatter(x1, x2)
    ...:
    ...: axes[0, 1].set_title("Weakly positively correlated")
    ...: axes[0, 1].scatter(x1, x1 + x2)
    ...:
    ...: axes[1, 0].set_title("Weakly negatively correlated")
    ...: axes[1, 0].scatter(x1, -x1 + x2)
    ...:
    ...: axes[1, 1].set_title("Strongly correlated")
    ...: axes[1, 1].scatter(x1, x1 + 0.15 * x2)
    ...:
    ...: axes[1, 1].set_xlabel("x")
    ...: axes[1, 0].set_xlabel("x")
    ...: axes[0, 0].set_ylabel("y")
    ...: axes[1, 0].set_ylabel("y")
    ...:
    ...: plt.subplots_adjust(left=0.1, right=0.95, bottom=0.1, top=0.95, wspace=0.1, hspace=0.2)

```

### 子图 2 网格

`plt.subplot2grid`功能是`plt.subplots`和 g `ridspec`(见下一节)之间的中介，它提供了比`plt.subplots`更灵活的`Axes`布局管理，同时也比`gridspec`简单易用。特别是，`plt.subplot2grid`能够用跨越多行和/或多列的`Axes`实例创建网格。`plt.subplot2grid`带有两个强制参数:第一个参数是`Axes`网格的形状，采用元组`(nrows, ncols)`的形式，第二个参数是元组`(row, col)`，指定网格内的起始位置。两个可选的关键字参数`colspan`和`rowspan`可以用来指示新的`Axes`实例应该跨越多少行和多少列。表 [4-3](#Tab3) 中给出了如何使用`plt.subplot2grid`功能的示例。注意，每次调用`plt.subplot2grid`函数都会产生一个新的`Axes`实例，而`plt.subplots`会在一次函数调用中创建所有的`Axes`实例，并将它们返回到一个 NumPy 数组中。

表 4-3

用`plt.subplot2grid`和相应代码创建的网格布局示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

轴网格布局

 | 

密码

 |
| --- | --- |
| ![../images/332789_2_En_4_Chapter/332789_2_En_4_Figa_HTML.gif](../images/332789_2_En_4_Chapter/332789_2_En_4_Figa_HTML.gif) | `ax0 = plt.subplot2grid((3, 3), (0, 0))``ax1 = plt.subplot2grid((3, 3), (0, 1))``ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)``ax3 = plt.subplot2grid((3, 3), (2, 0), colspan=3)``ax4 = plt.subplot2grid((3, 3), (0, 2), rowspan=2)` |

### GridSpec

我们在这里介绍的最后一个网格布局管理器是来自`mpl.gridspec`模块的`GridSpec`。这是 Matplotlib 中最通用的网格布局管理器，特别是它允许创建并非所有行和列都具有相同宽度和高度的网格，这是我们在本章前面使用的网格布局管理器不容易实现的。

一个`GridSpec`对象仅用于指定网格布局，它本身并不创建任何`Axes`对象。当创建一个`GridSpec`类的新实例时，我们必须指定网格中的行数和列数。像其他网格布局管理器一样，我们也可以使用关键字参数`left`、`bottom`、`right`和`top`来设置网格的位置，并且我们可以使用`wspace`和`hspace`来设置子情节之间的宽度和高度间距。另外，`GricSpec`允许使用`width_ratios`和`height_ratios`参数指定列和行的相对宽度和高度。这两个列表都应该具有网格中每一列和每一行的相对权重。例如，要生成一个两行两列的网格，其中第一行和第二列是第二行和第二列的两倍大，我们可以使用`mpl.gridspec.GridSpec(2, 2, width_ratios=[2, 1], height_ratios=[2, 1])`。

一旦创建了 GridSpec 实例，我们就可以使用`Figure.add_subplot`方法来创建`Axes`对象，并将它们放在图形画布上。作为`add_subplot,`的参数，我们需要传递一个`mpl.gridspec.SubplotSpec`实例，我们可以使用类似数组的索引从`GridSpec`对象生成该实例:例如，给定一个`GridSpec`实例`gs`，我们使用`gs[0, 0]`为左上角的网格元素获取一个`SubplotSpec`实例，对于覆盖第一行的`SubplotSpec`实例，我们使用`gs[:, 0]`等等。如何使用`GridSpec`和`add_subplot`创建`Axes`实例的具体示例见表 [4-4](#Tab4) 。

表 4-4

如何使用子情节网格管理器的例子`mpl.gridspec.GridSpec`

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

轴网格布局

 | 

密码

 |
| --- | --- |
| ![../images/332789_2_En_4_Chapter/332789_2_En_4_Figb_HTML.gif](../images/332789_2_En_4_Chapter/332789_2_En_4_Figb_HTML.gif) | `fig = plt.figure(figsize=(6, 4))``gs = mpl.gridspec.GridSpec(4, 4)``ax0 = fig.add_subplot(gs[0, 0])``ax1 = fig.add_subplot(gs[1, 1])``ax2 = fig.add_subplot(gs[2, 2])``ax3 = fig.add_subplot(gs[3, 3])``ax4 = fig.add_subplot(gs[0, 1:])``ax5 = fig.add_subplot(gs[1:, 0])``ax6 = fig.add_subplot(gs[1, 2:])``ax7 = fig.add_subplot(gs[2:, 1])``ax8 = fig.add_subplot(gs[2, 3])``ax9 = fig.add_subplot(gs[3, 2])` |
| ![../images/332789_2_En_4_Chapter/332789_2_En_4_Figc_HTML.gif](../images/332789_2_En_4_Chapter/332789_2_En_4_Figc_HTML.gif) | `fig = plt.figure(figsize=(4, 4))``gs = mpl.gridspec.GridSpec(2, 2, width_ratios=[4, 1], height_ratios=[1, 4], wspace=0.05, hspace=0.05)``ax0 = fig.add_subplot(gs[1, 0])``ax1 = fig.add_subplot(gs[0, 0])``ax2 = fig.add_subplot(gs[1, 1])` |

## 彩色贴图打印

到目前为止，我们只考虑了一元函数的图形，或者等效地，以 *x* - *y* 格式的二维数据。我们用于此目的的二维`Axes`对象也可用于可视化二元函数，或使用所谓的颜色图(或热图)以 *x* - *y* -z 格式显示三维数据，其中`Axes`区域中的每个像素根据坐标系中该点对应的 *z* 值进行着色。Matplotlib 为这些类型的绘图提供了函数`pcolor`和`imshow`，`contour`和`contourf`函数通过绘制等高线而不是彩色地图以相同的格式绘制数据。使用这些功能生成的图形示例如图 [4-23](#Fig23) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig23_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig23_HTML.png)

图 4-23

用`pcolor`、`imshow`、`contour`和`contourf`生成的示例图

例如，为了使用`pcolor`生成一个色彩映射图，我们首先需要以适当的格式准备数据。虽然标准二维图形期望一维坐标数组具有 *x* 和 *y* 值，但是在当前情况下，我们需要使用二维坐标数组，例如，使用 NumPy `meshgrid`函数生成的二维坐标数组。为了用两个因变量绘制一个二元函数或数据，我们首先定义一维坐标数组`x`和`y`，它们跨越所需的坐标范围或对应于数据可用的值。然后可以将`x`和`y`数组传递给`np.meshgrid`函数，该函数产生所需的二维坐标数组`X`和`Y`。如有必要，我们可以使用带有`X`和`Y`的 NumPy 数组计算来计算二元函数，以获得一个数据数组`Z`，如`In [25]`中第 1 至 3 行所做的那样(参见下一节)。

一旦准备好二维坐标和数据数组，通过将`X`、`Y,`和`Z`数组作为前三个参数进行传递，就可以使用例如`pcolor`、`contour,`或`contourf`很容易地将它们可视化。`imshow`方法的工作方式类似，但只期望数据数组`Z`作为参数，相关的坐标范围必须改为使用`extent`参数设置，该参数应设置为格式`[xmin, xmax, ymin, ymax]`上的列表。对于控制色彩映射图外观很重要的其他关键字参数有`vmin`、`vmax`、`norm,`和`cmap`:`vmin`和`vmax`可用于设置映射到色彩轴的值的范围。这同样可以通过设置`norm=mpl.colors.Normalize(vmin, vmax)`来实现。`cmap`参数指定了一个颜色映射，用于将数据值映射到图形中的颜色。该参数可以是带有预定义色彩映射表名称的字符串，也可以是色彩映射表实例。Matplotlib 中预定义的颜色图在`mpl.cm`中可用。尝试`help(mpl.cm)`或尝试在`mpl.cm`模块上的 IPython 中自动完成，以获得可用颜色映射的完整列表。 <sup>[5](#Fn5)</sup>

完整的颜色图绘制所需的最后一部分是 colorbar 元素，它为图表的查看者提供了一种读取不同颜色对应的数值的方法。在 Matplotlib 中，我们可以使用`plt.colorbar`函数将一个颜色条附加到已经绘制的颜色图中。它将图的句柄作为第一个参数，并将两个可选参数`ax`和`cax`作为第一个参数，这两个参数可用于控制颜色条在图中的出现位置。如果给定了`ax`，将从这个`Axes`对象中为新的彩条留出空间。另一方面，如果给定了`cax`，那么彩条将在这个`Axes`对象上绘制。colorbar 实例`cb`有自己的 axis 对象，设置 axis 属性的标准方法可以在`cb.ax`对象上使用，例如，我们可以使用`set_label`、`set_ticks,`和`set_ticklabels`方法，与使用 *x* 和 *y* 轴的方式相同。

以下代码显示了前面段落中概述的步骤，结果图如图 [4-24](#Fig24) 所示。函数`imshow`、`contour`和`contourf`可以以几乎相似的方式使用，尽管这些函数需要额外的参数来控制它们的特征属性。例如，`contour`和`contourf`函数额外带有一个参数`N`，它指定了要绘制的轮廓线的数量。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig24_HTML.png](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig24_HTML.png)

图 4-24

使用`pcolor`生成色彩映射图的示例

```
In [25]: x = y = np.linspace(-10, 10, 150)
    ...: X, Y = np.meshgrid(x, y)
    ...: Z = np.cos(X) * np.cos(Y) * np.exp(-(X/5)**2-(Y/5)**2)
    ...:
    ...: fig, ax = plt.subplots(figsize=(6, 5))
    ...:
    ...: norm = mpl.colors.Normalize(-abs(Z).max(), abs(Z).max())
    ...: p = ax.pcolor(X, Y, Z, norm=norm, cmap=mpl.cm.bwr)
    ...:
    ...: ax.axis('tight')
    ...: ax.set_xlabel(r"$x$", fontsize=18)
    ...: ax.set_ylabel(r"$y$", fontsize=18)
    ...: ax.xaxis.set_major_locator(mpl.ticker.MaxNLocator(4))
    ...: ax.yaxis.set_major_locator(mpl.ticker.MaxNLocator(4))
    ...:
    ...: cb = fig.colorbar(p, ax=ax)
    ...: cb.set_label(r"$z$", fontsize=18)
    ...: cb.set_ticks([-1, -.5, 0, .5, 1])

```

## 三维绘图

通过对 2D 图中的数据进行颜色编码，上一节中讨论的色彩映射图用于可视化具有两个因变量的数据。可视化相同类型数据的另一种方式是使用 3D 图形，其中引入了第三个轴 *z* ，图形以透视的方式显示在屏幕上。在 Matplotlib 中，绘制 3D 图形需要使用不同的 axes 对象，即从`mpl_toolkits.mplot3d`模块中可用的`Axes3D`对象。我们可以通过传递一个`Figure`实例作为参数:`ax = Axes3D(fig)`，使用`Axes3D`类的构造函数显式地创建一个 3D 感知轴实例。或者，我们可以使用带有`projection='3d'`参数的`add_subplot`函数:

```
ax = ax = fig.add_subplot(1, 1, 1, projection="3d")

```

或者将`plt.subplots`与`subplot_kw={'projection': '3d'}`参数一起使用:

```
fig, ax = plt.subplots(1, 1, figsize=(8, 6), subplot_kw={'projection': '3d'})

```

这样，只要我们以适当的方式指定`projection`参数，我们就可以使用我们之前用于 2D 图的所有轴布局方法。注意，使用`add_subplot`，可以在同一个图形中混合轴对象与 2D 和 3D 投影，但是当使用`plt.subplots`时，`subplot_kw`参数适用于添加到图形中的所有支线剧情。

例如，使用上一段中描述的方法之一，在图形中创建并添加 3D 感知轴实例后，可以使用`Axes3D`类方法(如`plot_surface`、`plot_wireframe`和`contour`)在 3D 透视图中将数据绘制为表面。这些函数的使用方式与上一节中使用彩色地图的方式几乎相同:这些 3D 绘图函数都将二维坐标和数据数组`X`、`Y`和`Z`作为第一参数。每个函数还需要额外的参数来调整特定的属性。例如，`plot_surface`函数使用参数`rstride`和`cstride`(行和列跨度)从输入数组中选择数据(以避免数据点过于密集)。`contour`和`contourf`函数采用可选参数`zdir`和`offset`，用于选择投影方向(允许值为“`x`、“`y`、“`z`”)和显示投影的平面。

除了用于 3D 表面绘图的方法，还有可用于 2D 轴的直线和散点图函数的简单概括，例如，`plot`、`scatter`、`bar`和`bar3d`，在 Axes3D 类中可用的版本中，这些函数为 *z* 坐标提供了一个额外的参数。像它们的 2D 亲戚一样，这些函数期望一维数据阵列，而不是用于表面绘图的二维坐标阵列。

当涉及到轴标题、标签、刻度和刻度标签时，本章前面详细描述的用于 2D 图的所有方法都可以直接推广到 3D 图。例如，有新的方法`set_zlabel`、`set_zticks`和`set_zticklabels`来操作新的 *z* 轴的属性。`Axes3D`对象还为 3D 特定动作和属性提供了新的类方法。特别是，`view_init`方法可以用来改变查看图形的角度，它将仰角和方位角(以度为单位)作为第一个和第二个参数。

下面给出了如何使用这些 3D 绘图功能的例子，生成的图形如图 [4-25](#Fig25) 所示。

![../images/332789_2_En_4_Chapter/332789_2_En_4_Fig25_HTML.jpg](../images/332789_2_En_4_Chapter/332789_2_En_4_Fig25_HTML.jpg)

图 4-25

使用`plot_surface`、`plot_wireframe`、`contour`生成的三维曲面和等高线图

```
In [26]: fig, axes = plt.subplots(1, 3, figsize=(14, 4), subplot_kw={'projection': '3d'})
    ...:
    ...: def title_and_labels(ax, title):
    ...:     ax.set_title(title)
    ...:     ax.set_xlabel("$x$", fontsize=16)
    ...:     ax.set_ylabel("$y$", fontsize=16)
    ...:     ax.set_zlabel("$z$", fontsize=16)
    ...:
    ...: x = y = np.linspace(-3, 3, 74)
    ...: X, Y = np.meshgrid(x, y)
    ...:
    ...: R = np.sqrt(X**2 + Y**2)
    ...: Z = np.sin(4 * R) / R
    ...:
    ...: norm = mpl.colors.Normalize(-abs(Z).max(), abs(Z).max())
    ...:
    ...: p = axes[0].plot_surface(X, Y, Z, rstride=1, cstride=1, linewidth=0, antialiased=False, norm=norm, cmap=mpl.cm.Blues)
    ...:                          
    ...: cb = fig.colorbar(p, ax=axes[0], shrink=0.6)
    ...: title_and_labels(axes[0], "plot_surface")
    ...:
    ...: p = axes[1].plot_wireframe(X, Y, Z, rstride=2, cstride=2, color="darkgrey")
    ...: title_and_labels(axes[1], "plot_wireframe")
    ...:
    ...: cset = axes[2].contour(X, Y, Z, zdir="z", offset=0, norm=norm, cmap=mpl.cm.Blues)
    ...: cset = axes[2].contour(X, Y, Z, zdir="y", offset=3, norm=norm, cmap=mpl.cm.Blues)
    ...: title_and_labels(axes[2], "contour")

```

## 摘要

在本章中，我们已经讲述了如何使用 Matplotlib 生成 2D 和 3D 图形的基础知识。可视化是计算科学家和工程师最重要的工具之一，既可以作为处理计算问题时的分析工具，也可以用于展示和交流计算结果。因此，可视化是计算工作流不可或缺的一部分，同样重要的是能够快速可视化和探索数据，并能够生成完美的出版物质量的图形，并对每个图形元素进行详细控制。Matplotlib 是一个很棒的通用工具，既可用于探索性可视化，也可用于生成出版物质量的图形。但是，使用 Matplotlib 可以实现的功能有一些限制，特别是在交互性和高质量 3D 图形方面。因此，对于更专业的用例，我建议也探索一下科学 Python 生态系统中可用的一些其他图形库，其中一些在本章开始时已经简要提到。

## 进一步阅读

Matplotlib 在专门针对图书馆的书籍中进行了处理，如 Tosi (2009)和 Devert (2014)，以及范围更广的几本书，如 Milovanovi (2013)和 McKinney (2013)。有关数据可视化和样式指南以及可视化良好实践的有趣讨论，请参见 Yau (2011)和 J. Steele (2010)。

## 参考

Devert，A. (2014 年)。 *matplotlib 绘制食谱。*孟买:Packt。

J.纽约州斯蒂尔(2010 年)。*美丽的可视化。*塞瓦斯托波尔:奥莱利。

McKinney，W. (2013 年)。 *Python 进行数据分析。*塞瓦斯托波尔:奥莱利。

Milovanovi，I. (2013 年)。 *Python 数据可视化食谱。*孟买:Packt。

Tosi，S. (2009 年)。面向 Python 开发者的 Matplotlib。孟买:Packt。

北丘(2011 年)。想象一下。印第安纳波利斯:威利。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

尽管有状态 API 对于小例子来说可能是方便和简单的，但是为有状态 API 编写的代码的可读性和可维护性很差，并且这种代码依赖于上下文的特性使得它很难重新安排或重用。因此，我建议完全避免使用它，只使用面向对象的 API。

  [2](#Fn2_source)

Matplotlib 资源文件`matplotlibrc`可用于设置许多 Matplotlib 参数的默认值，包括使用哪个后端。文件的位置取决于平台。详见 [`http://matplotlib.org/users/customizing.html`](http://matplotlib.org/users/customizing.html) 。

  [3](#Fn3_source)

对于 Max OS X 用户，`%config InlineBackend.figure_format=’retina’`是另一个有用的选项，它提高了在 retina 显示屏上查看 Matplotlib 图形的质量。

  [4](#Fn4_source)

将坐标和尺寸元组传递给`add_axes`的另一种方法是传递一个已经存在的轴实例。

  [5](#Fn5_source)

在 [`http://wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps`](http://wiki.scipy.org/Cookbook/Matplotlib/Show_colormaps) 可以看到所有可用的彩色地图。本页还描述了如何创建新的彩色地图。

 </aside>