# 9.常微分方程

未知量是一个函数而不是一个变量，并且包含未知函数的导数的方程称为微分方程。*普通*微分方程是一种特殊情况，其中未知函数只有一个独立变量，关于该变量的导数出现在方程中。另一方面，如果一个以上变量的导数出现在方程中，那么它被称为一个*偏微分方程，这就是第 [11 章](11.html)的主题。这里我们集中讨论常微分方程(以下简称为 ODEs ),我们将在本章中探索求解这类方程的符号方法和数值方法。常微分方程的解析闭合解通常不存在，但对于许多特殊类型的常微分方程，存在解析解，在这些情况下，我们有机会使用符号方法找到解。如果失败了，我们必须像往常一样求助于数字技术。*

常微分方程在科学和工程以及许多其他领域中普遍存在，例如，它们出现在动力系统的研究中。常微分方程的一个典型例子是描述过程的时间演变的方程，其中变化率(导数)可以与过程的其他属性相关。为了了解过程如何随时间演化，给定一些初始状态，我们必须求解或整合描述过程的 ODE。常微分方程应用的具体例子是物理学中的机械运动定律、化学和生物学中的分子反应以及生态学中的群体建模，仅举几个例子。

在这一章中，我们将探索解决常微分方程问题的符号和数值方法。对于符号方法，我们使用 SymPy 模块，对于 ODEs 的数值积分，我们使用 SciPy 中`integrate`模块的函数。

## 导入模块

在这里，我们需要 NumPy 和 Matplotlib 库用于基本的数值和绘图目的，为了求解 ode，我们需要 SymPy 库和 SciPy 的`integrate`模块。通常，我们假设这些模块以下列方式导入:

```py
In [1]: import numpy as np
In [2]: import matplotlib.pyplot as plt
In [3]: from scipy import integrate
In [4]: import sympy

```

为了很好地显示 SymPy 的输出，我们需要初始化它的打印系统:

```py
In [5]: sympy.init_printing()

```

## 常微分方程

常微分方程最简单的形式是![$$ \frac{dy(x)}{dx}=f\left(x,y(x)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq1.png)，其中 *y* ( *x* )为未知函数 *f* ( *x* ， *y* ( *x* ))为已知函数。它是一个微分方程，因为未知函数 *y* ( *x* )的导数出现在方程中。只有一阶导数出现在方程中，因此它是一阶常微分方程的一个例子。更一般的，我们可以把第 n 个*阶的颂歌以*显式*形式写成![$$ \frac{d^ny}{d{x}^n}=f\left(x,y,\frac{dy}{dx},\dots, \frac{d^{n-1}y}{d{x}^{n-1}}\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq2.png)，或者以*隐式*形式写成![$$ F\left(x,y,\frac{dy}{dx},\dots, \frac{d^ny}{d{x}^n}\right)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq3.png)，其中 *f* 和 *F* 为已知函数。*

一阶微分方程的一个例子是牛顿冷却定律![$$ \frac{dT(t)}{dt}=-k\left(T(t)-{T}_a\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq4.png)，它描述了一个物体在温度为 *T* <sub>* a *</sub> 的环境中的温度 *T* ( *t* )。这首颂歌的解法是*T*(*T*)=*T*<sub>0</sub>+(*T*<sub>0</sub>—*T*<sub>*a*</sub>)*e*—*kt*，其中*T*T37 二阶 ODE 的一个例子是牛顿第二运动定律 *F* = *ma* ，或者更明确地说![$$ F\left(x(t)\right)=m\frac{d^2x(t)}{d{t}^2} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq5.png)这个方程描述了质量为 *m* 的物体在受到位置相关力*F*(*x*(*t*)时的位置 *x* ( *t* )。要完全确定这个常微分方程的解，除了找到它的一般解，我们还必须给出物体的初始位置和速度。类似地，一个 *n* 阶微分方程的一般解具有 *n* 个自由参数，我们需要指定这些参数，例如，作为未知函数的初始条件以及其导数的*n*-1。

一首颂歌总是可以重写为一个一阶颂歌系统。具体来说，通过引入 *n* 新函数 *y* <sub>1</sub> = *y* 、![$$ {y}_2=\frac{dy}{dx} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq7.png)、…、![$$ {y}_n=\frac{d^{n-1}y}{d{x}^{n-1}} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq8.png)，可以将显式![$$ \frac{d^ny}{d{x}^n}=g\left(x,y,\frac{dy}{dx},\dots, \frac{d^{n-1}y}{d{x}^{n-1}}\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq6.png)上的 *n* thorder ODE 写成*标准型*。这给出了下面的一阶常微分方程系统

![$$ \frac{d}{dx}\left[\begin{array}{l}\kern0.5em {y}_1\\ {}\kern0.5em {y}_2\\ {}\kern1em \vdots \\ {}{y}_{n-1}\\ {}\kern0.5em {y}_n\end{array}\right]=\left[\begin{array}{l}\kern4em {y}_2\\ {}\kern4em {y}_3\\ {}\kern4.5em \vdots \\ {}\kern4em {y}_n\\ {}g\left(x,{y}_1,\dots, {y}_n\right)\end{array}\right], $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equa.png)

这也可以写成更紧凑的向量形式:![$$ \frac{d}{dx}\boldsymbol{y}(x)=f\left(x,\boldsymbol{y}(x)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq9.png)。这种规范形式对于常微分方程的数值解特别有用，求解常微分方程的数值方法通常采用函数 *f* = ( * f * <sub>1</sub> ， *f* <sub>2</sub> ，…， *f* <sub>* n *</sub> )，在当前情况下为*f*=(*y*<sub>2</sub>，例如，牛顿第二运动定律的二阶方程![$$ F(x)=m\frac{d^2x}{d{t}^2} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq10.png)，可以用![$$ \boldsymbol{y}={\left[{y}_1=x,{y}_2=\frac{dx}{dt}\right]}^T $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq11.png)写成标准形式，给出![$$ \frac{d}{dt}\left[\begin{array}{c}{y}_1\\ {}{y}_2\end{array}\right]=\left[\begin{array}{c}{y}_2\\ {}F\left({y}_1\right)/m\end{array}\right]. $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq12.png)

如果函数 *f* <sub>1</sub> ， *f* <sub>2</sub> ，…， *f* <sub>*n*</sub> 都是线性的，那么相应的常微分方程组可以写成简单的形式![$$ \frac{d\boldsymbol{y}\left(\boldsymbol{x}\right)}{dx}=A(x)\boldsymbol{y}(x)+\boldsymbol{r}(x) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq13.png)，其中 *A* ( *x* 是一个 *n* × *n* 矩阵和*在这种形式下，***r***(*x*)称为*源项*，如果***r***(*x*)= 0，否则*非齐次*，则该线性系统称为*齐次*。线性常微分方程是可以求解的重要特例，比如用 *A* ( *x* )的特征值分解。同样，对于函数 *f* ( *x* ，***y***(*x*))的某些性质和形式，可能存在已知的解决相应常微分方程问题的解和特殊方法，但对于任意的 *f* ( *x* ，***y**)则没有通用的方法**

除了函数 *f* ( *x* ，*T5】y*(*x*))的性质之外，一个常微分方程的边界条件也影响常微分方程问题的可解性，以及可用的数值方法。需要边界条件来确定出现在解中的积分常数的值。ODE 问题的边界条件主要有两种:*初值条件*和*边值条件*。对于初值问题，函数及其导数的值是在一个起点给出的，问题是从这个起点在自变量(如代表时间或位置)中向前演化函数。对于边值问题，未知函数或其导数的值在固定点给出。这些固定点通常是感兴趣区域的端点。本章我们主要关注初值问题，适用于边值问题的方法在第 [10](10.html) 章偏微分方程中讨论。

## 常微分方程的符号解

SymPy 提供了一个通用的 ODE 求解器`sympy.dsolve`，它能够找到许多基本 ODE 的解析解。`sympy.dsolve`函数试图对给定的 ODE 进行自动分类，它可能会尝试各种技术来找到它的解决方案。也可以给`dsolve`函数一些提示，引导它找到最合适的解决方法。虽然`dsolve`可以用来象征性地求解许多简单的常微分方程，正如我们将在下面看到的，但值得记住的是，大多数常微分方程无法解析求解。人们希望找到符号解的常微分方程的典型例子是一阶或二阶常微分方程，或者只有几个未知函数的一阶常微分方程的线性系统。如果常微分方程具有特殊的对称性或性质，如可分性、常系数或存在已知解析解的特殊形式，也会有很大帮助。虽然这些类型的常微分方程是例外和特殊情况，但这些常微分方程有许多重要的应用，对于这些情况，SymPy 的`dsolve`可以成为传统分析方法的非常有用的补充。在这一节中，我们将探索如何使用 SymPy 及其`dsolve`函数来解决简单但常见的 ode 问题。

为了说明用 SymPy 求解常微分方程的方法，我们从一个简单的问题开始，逐步看更复杂的情况。第一个例子是牛顿冷却定律的简单一阶微分方程，![$$ \frac{dT(t)}{dt}=-k\left(T(t)-{T}_a\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq14.png)，初始值为 *T* (0) = * T * <sub>0</sub> 。为了使用 SymPy 解决这个问题，我们首先需要为变量 *t* 、 *k* 、 *T* <sub>0</sub> 和 *T* <sub>* a *</sub> 定义符号，为了表示未知函数 *T* ( *t* ，我们可以使用一个`sympy.Function`对象:

```py
In [6]: t, k, T0, Ta = sympy.symbols("t, k, T_0, T_a")
In [7]: T = sympy.Function("T")

```

接下来，当写在表单![$$ \frac{dT(t)}{dt}+k\left(T(t)-{T}_a\right)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq15.png)上时，我们可以通过简单地为颂歌的左侧创建一个 SymPy 表达式来非常自然地定义颂歌。这里，为了表示函数 *T* ( *t* )，我们现在可以使用 Sympy `function`对象`T`。使用函数调用语法`T(t)`将符号`t`应用于它，产生一个应用的函数对象，我们可以在`T(t)`表达式上使用`sympy.diff`或`diff`方法对其进行衍生:

![$$ k\left(-{T}_a+T(t)\right)+\frac{dT(t)}{dt}=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equb.png)

```py
In [8]: ode = T(t).diff(t) + k*(T(t) - Ta)
In [9]: sympy.Eq(ode)
Out[9]:

```

这里我们使用`sympy.Eq`来显示等式，包括等号和右边的零。给定 ODE 的这个表示，我们可以直接将其传递给`sympy.dsolve`，它将尝试自动找到 ODE 的一般解。

![$$ T(t)={C}_1{e}^{- kt}+{T}_a $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equc.png)

```py
In [10]: ode_sol = sympy.dsolve(ode)
In [11]: ode_sol
Out[11]:

```

对于这个 ODE 问题，`sympy.dsolve`函数确实找到了通解，这里包括一个未知的积分常数*C*T7】1，我们必须从问题的初始条件中确定。从`sympy.dsolve`返回的值是`sympy.Eq`的一个实例，这是一个等式的符号表示。它具有属性`lhs`和`rhs`，用于访问等式对象的左侧和右侧:

```py
In [12]: ode_sol.lhs
Out[12]: T(t)
In [13]: ode_sol.rhs
Out[13]: C1e–kt + Ta

```

一旦找到了一般解，我们就需要使用初始条件来找到待定积分常数的值。这里初始条件是 *T* (0) = *T* <sub>0</sub> 。为此，我们首先创建一个描述初始条件`ics = {T(0): T0}`的字典，我们可以使用 SymPy 的`subs`方法将初始条件应用于 ODE 的求解。这导致未知积分常数*C*T10】1 的等式:

```py
In [14]: ics = {T(0): T0}
In [15]: ics
Out[15]: {T(0): T0}
In [16]: C_eq = ode_sol.subs(t, 0).subs(ics)
In [17]: C_eq
Out[17]: T0=C1 + Ta

```

在本例中，求解*C*T3】1 的方程很简单，但是为了通用性，这里我们使用`sympy.solve`来求解。结果是一个解决方案列表(在这种情况下，只有一个解决方案的列表)。我们可以将 *C* <sub>1</sub> 的解代入常微分方程问题的一般解中，得到对应于给定初始条件的特殊解:

```py
In [18]: C_sol = sympy.solve(C_eq)
In [19]: C_sol
Out[19]: [{C1:T0 – Ta}]
In [20]: ode_sol.subs(C_sol[0])
Out[20]: T(t) = Ta + (T0 – Ta)e–kt

```

通过进行这些步骤，我们已经象征性地彻底解决了 ODE 问题，得到了解*T*(*T*)=*T*<sub>*a*</sub>+(*T*<sub>0</sub>-*<sub>*a*</sub>)*e*<sup>-*kt*</sup>。这个过程涉及的步骤很简单，但是应用初始条件和求解待定积分常数可能有点繁琐，值得将这些步骤收集到一个可重用的函数中。下面的函数 apply_ics 是一个基本实现，它将这些步骤推广到任意阶的微分方程。*

```py
In [21]: def apply_ics(sol, ics, x, known_params):
   ....:     """
   ....:      Apply the initial conditions (ics), given as a dictionary on
   ....:      the form ics = {y(0): y0, y(x).diff(x).subs(x, 0): yp0, ...},
   ....:      to the solution of the ODE with independent variable x.
   ....:      The undetermined integration constants C1, C2, ... are extracted
   ....:      from the free symbols of the ODE solution, excluding symbols in
   ....:      the known_params list.
   ....:      """
   ....:      free_params = sol.free_symbols - set(known_params)
   ....:      eqs = [(sol.lhs.diff(x, n) - sol.rhs.diff(x, n)).subs(x, 0).subs(ics) for n in range(len(ics))]
   ....:      sol_params = sympy.solve(eqs, free_params)
   ....:      return sol.subs(sol_params)

```

有了这个函数，我们可以更方便地选出满足一组初始条件的一个常微分方程的一个特殊解，给定同一个常微分方程的一般解。对于我们之前的例子，我们得到

```py
In [22]: ode_sol
Out[22]: T(t) = C1e–kt + Ta
In [23]: apply_ics(ode_sol, ics, t, [k, Ta])
Out[23]: T(t) = Ta + (T0 – Ta)e–kt

```

到目前为止，我们看到的例子几乎是微不足道的，但同样的方法可以用来处理任何 ODE 问题，尽管当然不能保证会找到解决方案。作为一个稍微复杂一点的问题的例子，考虑阻尼谐振子的 ODE，它是形式为![$$ \frac{d^2x(t)}{d{t}^2}+2\gamma {\omega}_0\frac{dx(t)}{dt}+{\omega}_0^2x(t)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq16.png)的二阶 ODE，其中 *x* ( *t* )是时间*t*`,`*ω*<sub>0</sub>是无阻尼情况下的频率，而 *γ* 是阻尼比。我们首先定义所需的符号并构建 ODE，然后通过调用 sympy.dsolve 让 SymPy 找到一般的解决方案:

![$$ \frac{d^2x(t)}{d{t}^2}+2\gamma {\omega}_0\frac{dx(t)}{dt}+{\omega}_0^2x(t)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equd.png)

```py
In [24]: t, omega0, gamma= sympy.symbols("t, omega_0, gamma", positive=True)
In [25]: x = sympy.Function("x")
In [26]: ode = x(t).diff(t, 2) + 2 * gamma * omega0 * x(t).diff(t) + omega0**2 * x(t)
In [27]: sympy.Eq(ode)
Out[27]:

```

![$$ x(t)={C}_1{e}^{\omega_0t\left(-\gamma -\sqrt{\gamma^2-1}\right)}+{C}_2{e}^{\omega_0t\left(-\gamma +\sqrt{\gamma^2-1}\right)} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Eque.png)

```py
In [28]: ode_sol = sympy.dsolve(ode)
In [29]: ode_sol
Out[29]:

```

由于这是一个二阶常微分方程，一般解中有两个待定积分常数。我们需要为位置 *x* (0)和速度![$$ {\left.\frac{dx(t)}{dt}\right|}_{t=0} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq17.png)指定初始条件，以选出一个求解常微分方程的特殊解。为此，我们使用这些初始条件创建了一个字典，并使用 apply_ics 将其应用于通用 ODE 解决方案:

![$$ \left\{x(0):1,\kern0.5em {\left.\frac{dx(t)}{dt}\right|}_{t=0}:0\right\} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equf.png)

```py
In [30]: ics = {x(0): 1, x(t).diff(t).subs(t, 0): 0}
In [31]: ics
Out[31]:

```

![$$ x(t)=\left(-\frac{\gamma }{2\sqrt{\gamma^2-1}}+\frac{1}{2}\right){e}^{\omega_0t\left(-\gamma -\sqrt{\gamma^2-1}\right)}+\left(\frac{\gamma }{2\sqrt{\gamma^2-1}}+\frac{1}{2}\right){e}^{\omega_0t\left(-\gamma +\sqrt{\gamma^2-1}\right)} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equg.png)

```py
In [32]: x_t_sol = apply_ics(ode_sol, ics, t, [omega0, gamma])
In [33]: x_t_sol
Out[33]:

```

这是对于任意值的 *t* 、 *ω* 、 <sub>0</sub> 和 *γ* 的振荡器动态的解，其中我们使用初始条件 *x* (0) = 1 和![$$ {\left.\frac{dx(t)}{dt}\right|}_{t=0}=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq18.png)。然而，将对应于临界阻尼的 *γ* = 1 直接代入该表达式会导致除以零的误差，对于 *γ* 的这一特定选择，我们需要小心计算 *γ* → 1 的极限。

![$$ \frac{\omega_0t+1}{e^{\omega_0t}} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equh.png)

```py
In [34]: x_t_critical = sympy.limit(x_t_sol.rhs, gamma, 1)
In [35]: x_t_critical
Out[35]:

```

最后，我们绘制出 *ω* <sub>0</sub> = 2 *π* 以及一系列不同阻尼比值 *γ* 的解:

```py
In [36]: fig, ax = plt.subplots(figsize=(8, 4))
    ...: tt = np.linspace(0, 3, 250)
    ...: w0 = 2 * sympy.pi
    ...: for g in [0.1, 0.5, 1, 2.0, 5.0]:
    ...:     if g == 1:
    ...:         x_t = sympy.lambdify(t, x_t_critical.subs({omega0: w0}), 'numpy')
    ...:     else:
    ...:         x_t = sympy.lambdify(t, x_t_sol.rhs.subs({omega0: w0, gamma: g}), 'numpy')
    ...:     ax.plot(tt, x_t(tt).real, label=r"$\gamma = %.1f$" % g)
    ...: ax.set_xlabel(r"$t$", fontsize=18)
    ...: ax.set_ylabel(r"$x(t)$", fontsize=18)
    ...: ax.legend()

```

阻尼谐振子的 ODE 解如图 [9-1](#Fig1) 所示。对于 *γ* < 1，振子欠阻尼，我们看到振荡解。对于 *γ* > 1，振荡器过阻尼并单调衰减。这两种行为之间的交叉发生在临界阻尼比 *γ* = 1 时。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig1_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig1_HTML.png)

图 9-1

一系列阻尼比下阻尼谐振子常微分方程的解

到目前为止，我们所看到的两个常微分方程的例子都可以通过解析的方法来精确求解，但是情况远非总是如此。甚至许多一阶常微分方程也不能用初等函数精确求解。例如，考虑![$$ \frac{dy(x)}{dx}=x+y{(x)}^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq19.png)，它是一个没有任何封闭解的 ODE 的例子。如果我们尝试使用 sympy.dsolve 求解该方程，我们将获得幂级数形式的近似解:

![$$ \frac{dy(x)}{dx}=x+y{(x)}^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equi.png)

```py
In [37]: x = sympy.symbols("x")
In [38]: y = sympy.Function("y")
In [39]: f = y(x)**2 + x
In [40]: sympy.Eq(y(x).diff(x), f)
Out[40]:

```

![$$ y(x)={C}_1+{C}_1x+\frac{1}{2}\left(2{C}_1+1\right){x}^2+\frac{7{C}_1}{6}{x}^3+\frac{C_1}{12}\left({C}_1+5\right){x}^4+\frac{1}{60}\left({C}_1^2\left({C}_1+45\right)+20{C}_1+3\right){x}^5+\mathcal{O}\left({x}^6\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equj.png)

```py
In [41]: sympy.dsolve(y(x).diff(x) - f)
Out[41]:

```

对于许多其他类型的方程，SymPy 完全不能产生任何解。例如，如果我们试图求解二阶微分方程![$$ \frac{d^2y(x)}{d{x}^2}=x+y{(x)}^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq20.png)，我们会得到以下错误信息:

![$$ \frac{d^2y(x)}{d{x}^2}=x+y{(x)}^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equk.png)

```py
In [42]: sympy.Eq(y(x).diff(x, x), f)
Out[42]:

```

```py
In [43]: sympy.dsolve(y(x).diff(x, x) - f)
---------------------------------------------------------------------------
...
NotImplementedError: solve: Cannot solve -x - y(x)**2 + Derivative(y(x), x, x)

```

这种类型的结果可能意味着实际上没有对常微分方程的解析解，或者很有可能，只是 SymPy 不能处理它。

dsolve 函数接受许多可选参数，如果通过提示应该使用哪些方法来解决手头的 ODE 问题来指导求解程序，它通常会有所不同。有关可用选项的更多信息，请参见 sympy.dsolve 的 docstring。

### 方向字段

一个*方向场图*是一个简单但有用的技术，可以可视化任意一阶常微分方程的可能解。它由短线组成，显示未知函数在*x*–*y*平面网格上的斜率。因为*x*–*y*平面任意点处的 *y* ( *x* )的斜率是由 ODE 的定义给出的:![$$ \frac{dy(x)}{dx}=f\left(x,y(x)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq21.png)也就是说，我们只需要迭代感兴趣的坐标网格上的 *x* 和 *y* 值，并对 *f* ( *x* ，*方向场图有用的原因是，与方向场图中的斜线(在每一点)相切的平滑连续曲线是 ODE 的可能解。*

给定独立变量 *x* ，未知函数 *y* ( *x* )，以及右侧函数 *f* ( *x* ， *y* ( *x* )，下面的函数 plot_direction_field 生成一阶 ODE 的方向场图。它还为 *x* 和 *y* 轴(分别为 x_lim 和 y_lim)和一个可选的 Matplotlib 轴实例获取可选的范围，以便在其上绘制图形。

```py
 In [44]: def plot_direction_field(x, y_x, f_xy, x_lim=(-5, 5), y_lim=(-5, 5), ax=None):
    ...:     f_np = sympy.lambdify((x, y_x), f_xy, 'numpy')
    ...:     x_vec = np.linspace(x_lim[0], x_lim[1], 20)
    ...:     y_vec = np.linspace(y_lim[0], y_lim[1], 20)
    ...:
    ...:     if ax is None:
    ...:         _, ax = plt.subplots(figsize=(4, 4))
    ...:
    ...:     dx = x_vec[1] - x_vec[0]
    ...:     dy = y_vec[1] - y_vec[0]
    ...:
    ...:     for m, xx in enumerate(x_vec):
    ...:         for n, yy in enumerate(y_vec):
    ...:             Dy = f_np(xx, yy) * dx
    ...:             Dx = 0.8 * dx**2 / np.sqrt(dx**2 + Dy**2)
    ...:             Dy = 0.8 * Dy*dy / np.sqrt(dx**2 + Dy**2)
    ...:             ax.plot([xx - Dx/2, xx + Dx/2],
    ...:                     [yy - Dy/2, yy + Dy/2], 'b', lw=0.5)
    ...:     ax.axis('tight')
    ...:     ax.set_title(r"$%s$" %
    ...:                  (sympy.latex(sympy.Eq(y(x).diff(x), f_xy))),
    ...:                  fontsize=18)
    ...:     return ax

```

使用此功能，我们可以为表单![$$ \frac{dy(x)}{dx}=f\left(x,y(x)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq22.png)上的 ode 生成方向场图。例如，下面的代码为 *f* ( *x* ，*y*(*x*)=*y*(*x*)<sup>2</sup>+*x*， *f* ( *x* ， *y* ( *x* )生成方向场图 以及 *f* ( *x* ，*y*(*x*)=*y*(*x*)<sup>2</sup>/*x*。 结果如图 [9-2](#Fig2) 所示。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig2_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig2_HTML.png)

图 9-2

三个一阶微分方程的方向场

```py
In [45]: x = sympy.symbols("x")
In [46]: y = sympy.Function("y")
In [47]: fig, axes = plt.subplots(1, 3, figsize=(12, 4))
    ...: plot_direction_field(x, y(x), y(x)**2 + x, ax=axes[0])
    ...: plot_direction_field(x, y(x), -x / y(x), ax=axes[1])
    ...: plot_direction_field(x, y(x), y(x)**2 / x, ax=axes[2])

```

图 [9-2](#Fig2) 中图形的方向线表明了作为相应常微分方程解的曲线如何表现，因此方向场图是可视化无法解析求解的常微分方程解的有用工具。为了说明这一点，再次考虑具有初始条件 *y* (0) = 0 的 ODE ![$$ \frac{dy(x)}{dx}=x+y{(x)}^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq23.png)，我们之前看到它可以作为近似幂级数不精确地求解。像以前一样，我们通过定义符号 x 和函数 y(x)再次解决了这个问题，我们依次使用它们来构造和显示 ODE:

![$$ \frac{dy(x)}{dx}=x+y{(x)}^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equl.png)

```py
In [48]: x = sympy.symbols("x")
In [49]: y = sympy.Function("y")
In [50]: f = y(x)**2 + x
In [51]: sympy.Eq(y(x).diff(x), f)
Out[51]:

```

现在我们要找到满足初始条件的特定幂级数解，对于这个问题，我们可以直接使用 dsolve 函数 <sup>[1](#Fn1)</sup> 的 ics 关键字参数来指定初始条件:

```py
In [52]: ics = {y(0): 0}
In [53]: ode_sol = sympy.dsolve(y(x).diff(x) - f, ics=ics)
In [54]: ode_sol
Out[54]:

```

![$$ y(x)=\frac{x^2}{2}+\frac{x^5}{20}+\mathcal{O}\left({x}^6\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equm.png)

将解和常微分方程的方向场一起画出来，是了解幂级数近似的有效范围的一种快速而简单的方法。以下代码绘制了近似解和方向场(图 [9-3](#Fig3) ，左侧面板)。具有扩展的有效性范围的解决方案也可以通过在增加的值 *x* 下重复求解具有初始条件的常微分方程来获得，取自先前的幂级数解决方案(图 [9-3](#Fig3) ，右图)。

```py
In [55]: fig, axes = plt.subplots(1, 2, figsize=(8, 4))
    ...: # left panel
    ...: plot_direction_field(x, y(x), f, ax=axes[0])
    ...: x_vec = np.linspace(-3, 3, 100)
    ...: axes[0].plot(x_vec, sympy.lambdify(x, ode_sol.rhs.removeO())(x_vec), 'b', lw=2)
    ...: axes[0].set_ylim(-5, 5)
    ...:
    ...: # right panel
    ...: plot_direction_field(x, y(x), f, ax=axes[1])
    ...: x_vec = np.linspace(-1, 1, 100)
    ...: axes[1].plot(x_vec, sympy.lambdify(x, ode_sol.rhs.removeO())(x_vec), 'b', lw=2)
    ...: # iteratively resolve the ODE with updated initial conditions
    ...: ode_sol_m = ode_sol_p = ode_sol
    ...: dx = 0.125
    ...: # positive x
    ...: for x0 in np.arange(1, 2., dx):
    ...:     x_vec = np.linspace(x0, x0 + dx, 100)
    ...:     ics = {y(x0): ode_sol_p.rhs.removeO().subs(x, x0)}
    ...:     ode_sol_p = sympy.dsolve(y(x).diff(x) - f, ics=ics, n=6)
    ...:     axes[1].plot(x_vec, sympy.lambdify

(x, ode_sol_p.rhs.removeO())(x_vec), 'r', lw=2)
    ...: # negative x
    ...: for x0 in np.arange(-1, -5, -dx):
    ...:     x_vec = np.linspace(x0, x0 - dx, 100)
    ...:     ics = {y(x0): ode_sol_m.rhs.removeO().subs(x, x0)}
    ...:     ode_sol_m = sympy.dsolve(y(x).diff(x) - f, ics=ics, n=6)
    ...:     axes[1].plot(x_vec, sympy.lambdify(x, ode_sol_m.rhs.removeO())(x_vec), 'r', lw=2)

```

在图 [9-3](#Fig3) 的左图中，我们看到近似解曲线在 *x* = 0 附近与方向场线对齐良好，但对于∣ *x* ∣ ≳ 1 开始偏离，这表明近似解不再有效。右侧面板中显示的解决方案曲线在整个绘图范围内与方向场对齐得更好。蓝色(深灰色)曲线段是原始近似解，而红色(浅灰色)曲线是通过用初始条件序列求解 ODE 而获得的延续，该初始条件序列从蓝色(深灰色)曲线结束的地方开始。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig3_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig3_HTML.png)

图 9-3

*ODE![$$ \frac{dy(x)}{dx}=y{(x)}^2+x $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq24.png)的方向场图*，在 *x* = 0 附近有五阶幂级数解(左图)，在 5 到 2 之间的 x 附近有连续的幂级数展开，间距为 0.125(右图)

### 用拉普拉斯变换求解常微分方程

除了用 SymPy 的“黑盒”解算器 <sup>[2](#Fn2)</sup> `dsolve`象征性地求解微分方程，另一种方法是使用 SymPy 的象征性功能来帮助用更手动的方法求解微分方程。一种可用于解决某些常微分方程问题的技术是对常微分方程进行拉普拉斯变换，对于许多问题来说，这导致更容易求解的代数方程。代数方程的解然后可以用逆拉普拉斯变换变换回原始域，以获得原始问题的解。这种方法的关键是函数导数的拉普拉斯变换是函数本身拉普拉斯变换中的一个代数表达式:![$$ \mathcal{L}\left[{y}^{'}(t)\right]=s\mathcal{L}\left[y(t)\right]\hbox{--} y(0) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq25.png)。然而，虽然 SymPy 擅长拉普拉斯变换许多类型的初等函数，但是它不认识如何变换未知函数的导数。但是定义一个执行这个任务的函数可以很容易地修正这个缺点。

例如，考虑驱动谐振子的以下微分方程:

![$$ \frac{d^2}{d{t}^2}y(t)+2\frac{d}{dt}y(t)+10y(t)=2\sin 3t. $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equn.png)

为了使用这个颂歌，我们首先为独立变量 *t* 和函数 *y* ( *t* )创建 SymPy 符号，然后使用它们来构造颂歌的符号表达式:

![$$ 10y(t)-2\mathit{\sin}(3t)+2\frac{d}{dt}y(t)+\frac{d^2}{d{t}^2}y(t)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equo.png)

```py
In [56]: t = sympy.symbols("t", positive=True)
In [57]: y = sympy.Function("y")
In [58]: ode = y(t).diff(t, 2) + 2 * y(t).diff(t) + 10 * y(t) - 2 * sympy.sin(3*t)
In [59]: sympy.Eq(ode)
Out[59]:

```

拉普拉斯变换这个方程会产生一个代数方程。为了使用 SymPy 及其函数 sympy.laplace_transform 实现这种方法，我们首先需要创建一个符号 *s* ，用于 laplace 变换。在这一点上，我们还创建了一个符号 *Y* 以备后用。

```py
In [60]: s, Y = sympy.symbols("s, Y", real=True)

```

接下来，我们对未知函数 y(t)以及整个常微分方程进行拉普拉斯变换:

![$$ {\mathcal{L}}_t\left[y(t)\right](img/s) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equp.png)

```py
In [61]: L_y = sympy.laplace_transform(y(t), t, s)
In [62]: L_y
Out[62]:

```

![$$ 10{\mathcal{L}}_t\left[y(t)\right](img/s)+2{\mathcal{L}}_t\left[\frac{d}{dt}y(t)\right](s)+{\mathcal{L}}_t\left[\frac{d^2}{d{t}^2}y(t)\right](s)-\frac{6}{s^2+9}=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equq.png)

```py
In [63]: L_ode = sympy.laplace_transform(ode, t, s, noconds=True)
In [64]: sympy.Eq(L_ode)
Out[64]:

```

当拉普拉斯变换未知函数 *y* ( *t* )时，我们得到待定结果![$$ {\mathcal{L}}_t\left[y(t)\right](img/s) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq26.png)，这是意料之中的。然而，对 *y* ( *t* )的导数应用 sympy.laplace_transform，例如![$$ \frac{d}{dt}y(t) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq27.png)，会导致未赋值的表达式![$$ {\mathcal{L}}_t\left[\frac{d}{dt}y(t)\ \right](img/s) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq28.png)。这不是我们想要的结果，我们需要解决这个问题来得到我们想要的代数方程。未知函数的导数的拉普拉斯变换有一个众所周知的形式，它涉及函数本身的拉普拉斯变换，而不是它的导数:对于函数的第 *n* 阶导数 *y* ( *t* )，公式为

![$$ {\mathcal{L}}_t\left[\frac{d^n}{d{t}^n}y(t)\ \right](img/s)={s}^n{\mathcal{L}}_t\left[y(t)\ \right](s)-{\left.\sum_{m=0}^{n-1}{s}^{n-m-1}\frac{d^m}{d{t}^m}y(t)\right|}_{t=0}. $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equr.png)

通过迭代 L_ode 的 SymPy 表达式树，并用该公式给出的形式的表达式替换![$$ {\mathcal{L}}_t\left[\frac{d^n}{d{t}^n}y(t)\ \right](img/s) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq29.png)的出现，我们可以获得我们寻求的 ode 的代数形式。以下函数采用拉普拉斯变换的 ODE，并对 *y* ( *t* )的导数的未赋值拉普拉斯变换进行替换:

```py
In [65]: def laplace_transform_derivatives(e):
    ...:     """
    ...:     Evaluate laplace transforms of derivatives of functions
    ...:     """
    ...:     if isinstance(e, sympy.LaplaceTransform):
    ...:         if isinstance(e.args[0], sympy.Derivative):
    ...:             d, t, s = e.args
    ...:             n = len(d.args) - 1
    ...:             return ((s**n) * sympy.LaplaceTransform(d.args[0], t, s) -
    ...:                     sum([s**(n-i) * sympy.diff(d.args[0], t, i-1).subs(t, 0) for i in range(1, n+1)]))
    ...:
    ...:     if isinstance(e, (sympy.Add, sympy.Mul)):
    ...:         t = type(e)
    ...:         return t(*[laplace_transform_derivatives(arg) for arg in e.args])
    ...:
    ...:     return e

```

将该函数应用于拉普拉斯变换的 ODE 方程 L_ode，得到:

![$$ {s}^2{\mathcal{L}}_t\left[y(t)\right](img/s)+2s{\mathcal{L}}_t\left[y(t)\right](s)- sy(0)+10{\mathcal{L}}_t\left[y(t)\right](s)-2y(0)-{\left.\frac{d}{dt}y(t)\right|}_{t=0}-\frac{6}{s^2+9}=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equs.png)

```py
In [66]: L_ode_2 = laplace_transform_derivatives(L_ode)
In [67]: sympy.Eq(L_ode_2)
Out[67]:

```

为了简化符号，我们现在用表达式![$$ {\mathcal{L}}_t\left[y(t)\right](img/s) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq30.png) `for the symbol` Y `:`来代替

![$$ {s}^2Y+2 sY- sy(0)+10Y-2y(0)-{\left.\frac{d}{dt}y(t)\right|}_{t=0}-\frac{6}{s^2+9}=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equt.png)

```py
In [68]: L_ode_3 = L_ode_2.subs(L_y, Y)
In [69]: sympy.Eq(L_ode_3)
Out[69]:

```

此时，我们需要指定常微分方程问题的边界条件。这里我们使用 *y* (0) = 1 和*y*<sup>’</sup>(*t*)= 0，并且在创建包含这些边界条件的字典之后，我们使用它将这些值代入拉普拉斯变换的 ODE 方程:

![$$ \left\{y(0):1,{\left.\frac{d}{dt}y(t)\right|}_{t=0}:0\right\} $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equu.png)

```py
In [70]: ics = {y(0): 1, y(t).diff(t).subs(t, 0): 0}
In [71]: ics
Out[71]:

```

![$$ Y{s}^2+2 Ys+10Y-s-2-\frac{6}{s^2+9}=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equv.png)

```py
In [72]: L_ode_4 = L_ode_3.subs(ics)
In [73]: sympy.Eq(L_ode_4)
Out[74]:

```

`This is an algebraic equation that can be solved for` *Y* `:`

![$$ \left[\frac{s^3+2{s}^2+9s+24}{s^4+2{s}^3+19{s}^2+18s+90}\right] $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equw.png)

```py
In [75]: Y_sol = sympy.solve(L_ode_4, Y)
In [76]: Y_sol
Out[76]:

```

`The result is a list of solutions` `, which in this case contains only one element. Performing the inverse Laplace transformation on this expression gives the solution to the original problem in the time domain:`

![$$ \frac{1}{111{e}^t}\left(6\left(\sin 3t-6\cos 3t\right){e}^t+43\sin 3t+147\cos 3t\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equx.png)

```py
In [77]: y_sol = sympy.inverse_laplace_transform(Y_sol[0], s, t)
In [78]: sympy.simplify(y_sol)
Out[78]:

```

这种拉普拉斯变换一个常微分方程，求解相应的代数方程，并对结果进行逆拉普拉斯变换以获得原问题的解的技术，可以应用于解决许多重要的常微分方程问题，这些问题出现在例如电气工程和过程控制应用中。虽然这些问题可以借助拉普拉斯变换表手工解决，但使用 SymPy 有可能大大简化这一过程。

## 求解常微分方程的数值方法

虽然有些常微分方程问题可以用解析方法解决，正如我们在前面的例子中所看到的，但是无法用解析方法解决的常微分方程问题更为常见。实际上，常微分方程问题因此主要用数值方法来解决。有许多数值求解常微分方程的方法，其中大多数是为标准形式<sup>[【3】](#Fn3)</sup>![$$ \frac{d\boldsymbol{y}(x)}{dx}=f\left(x,\boldsymbol{y}(x)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq31.png)上的一阶常微分方程系统而设计的，其中 *** y *** (x)是 *x* 的未知函数的向量。SciPy 提供了解决这类问题的函数，但在我们探索如何使用这些函数之前，我们先简要回顾一下基本概念，并介绍一下用于 ODE 问题数值积分的术语。

许多常微分方程数值方法的基本思想都体现在欧拉方法中。例如，该方法可以从围绕点 *x* 的 *y* ( *x* )的泰勒级数展开中导出

![$$ y\left(x+h\right)=y(x)+\frac{dy(x)}{dx}h+\frac{1}{2}\frac{d^2y(x)}{d{x}^2}{h}^2+\dots, $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equy.png)

其中为了符号的简单，我们考虑当 *y* ( *x* )是标量函数的情况。去掉二阶或更高阶的项，得到近似方程*y*(*x*+*h*)≈*y*(*x*)+*f*(*x*，*y*(*x*)*h*，精确到步长的一阶将 *x* 变量、*x*T30】0、*x*T34】1、…、 *x* <sub>*k*</sub> 离散化，选择步长*h*<sub>*k*</sub>=*x*<sub>由此产生的迭代公式*y*<sub>*k*+1</sub>≈*y*<sub>*k*</sub>+*f*(*x*<sub>*k*</sub>， *y* <sub>*k* 之所以说它是一个*显式*形式，是因为给定了*y*<sub>*k*</sub>的值，我们可以使用公式直接计算出*y*<sub>*k*+1</sub>。 初值问题的数值解法的目标是在给定初始条件*y*(*x<sub>0</sub>)=*y*0<sub>0</sub>的情况下，计算某些点的 *y* ( *x* )因此，类似前向欧拉法的迭代公式可用于计算从*y*0*</sub>开始的*y*<sub>*k*</sub>的连续值。这种方法涉及两种类型的误差:首先，泰勒级数的截断给出了一个误差，该误差限制了该方法的*精度*。第二，在计算*y*<sub>*k*+1</sub>时，使用前一次迭代给出的*y*<sub>*k*</sub>的近似值，会产生额外的误差，该误差可能会在连续的迭代中累积，并会影响该方法的*稳定性*。</sub>

可以以类似方式导出的替代形式是由迭代公式*y*<sub>T5】k+1</sub>≈*y*<sub>*k*</sub>+*f*(*x*<sub>*k*+1</sub>， *y* <sub>给出的*向后欧拉法*这是一个*向后微分公式(BDF)* 的例子，也就是*隐式*，因为*y*<sub>*k*+1</sub>出现在方程的两边。为了计算*y*<sub>*k*+1</sub>，我们因此需要解一个代数方程(例如，使用牛顿法，参见第 [5 章](05.html))。隐式方法比显式方法实现起来更复杂，并且每次迭代需要更多的计算工作。但是，优点是隐式方法通常具有更大的稳定区域和更好的精度，这意味着可以使用更大的步长 *h* <sub>*k*</sub> 同时仍然可以获得精确和稳定的解。显式方法还是隐式方法更有效取决于正在解决的特定问题。隐式方法通常对*僵硬*问题特别有用，不严格地说，这些问题是描述具有多个不同时标的动力学的常微分方程问题(例如，包括快速和慢速振荡的动力学)。</sub>

有几种方法可以改进一阶欧拉向前和向后方法。一种策略是在 *y* ( *x* + *h* )的泰勒级数展开中保留高阶项，这样给出的高阶迭代公式可以有更好的精度，比如二阶法![$$ {y}_{k+1}\approx y\left({x}_k\right)+f\left({x}_{k+1},{y}_{k+1}\right){h}_k+\frac{1}{2}{y}_k^{\prime \prime }(x){h}_k^2 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq32.png)。但是，这种方法需要计算 *y* ( *x* )的高阶导数，如果事先不知道 *f* ( *x* ， *y* ( *x* ))，这可能是个问题。解决这个问题的方法包括使用导数的有限差分近似来近似高阶导数，或者在区间[*x*T29]T30]kT32]，*x*T35]T36]k+1 中的中间点处采样函数*f*(*x*，*y*(*x*)。这种方法的一个例子是众所周知的龙格-库塔法，这是一种单步方法，它使用了对 *f* ( *x* ， *y* ( *x* ))的附加评估。最著名的龙格-库塔法是四阶格式

![$$ {y}_{k+1}={y}_k+\frac{1}{6}\left({k}_1+2{k}_2+2{k}_3+{k}_4\right), $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equz.png)

在哪里

![$$ {k}_1=f\left({t}_k,{y}_k\right){h}_k, $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equaa.png)

![$$ {k}_2=f\left({t}_k+\frac{h_k}{2},{y}_k+\frac{k_1}{2}\right){h}_k, $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equab.png)

![$$ {k}_3=f\left({t}_k+\frac{h_k}{2},{y}_k+\frac{k_2}{2}\right){h}_k, $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equac.png)

![$$ {k}_4=f\left({t}_k+{h}_k,{y}_k+{k}_3\right){h}_k. $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equad.png)

这里， *k* <sub>1</sub> 到 *k* <sub>4</sub> 是前文给出的*y*<sub>*k*+1</sub>显式公式中使用的 ODE 函数 *f* ( *x* ， *y* ( *x* ))的四种不同求值。得到的估计值*y*<sub>*k*+1</sub>精确到四阶，误差五阶。也可以构造使用更多函数评估的高阶方案。通过组合不同阶的两种方法，也可以估计近似中的误差。一种流行的组合是 Runge-Kutta 四阶和五阶方案，这产生了具有误差估计的四阶精确方法。它被称为 RK45 或龙格-库塔-费尔伯格方法。Dormand-Prince 方法是高阶方法的另一个例子，它还使用自适应步长控制。例如，8-5-3 方法结合了三阶和五阶方案，产生了八阶方法。这个方法的实现在 SciPy 中可用，我们将在下一节中看到。

另一种方法是使用多个先前的值 *y* <sub>*k*</sub> 来计算 *y* <sub>*k* +1</sub> 。这种方法称为多步法，通常可以写成以下形式

![$$ {y}_{k+s}=\sum_{n=0}^{s-1}{a}_n{y}_{k+n}+h\sum_{n=0}^s{b}_nf\left({x}_{k+n,}{y}_{k+n}\right). $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equae.png)

用这个公式，可以计算出*y*<sub>*k*+*s*</sub>， *y* <sub>*k*</sub> 和*f*(*x*<sub>*k*</sub>， *y* <sub>*k*</sub> )系数 *a* <sub>*n*</sub> 和 *b* <sub>*n*</sub> 的选择产生不同的多步法。注意，如果*b*<sub>*s*</sub>= 0，那么该方法是显式的，如果*b*<sub>*s*</sub>≠0，则是隐式的。

例如，*b*<sub>0</sub>=*b*<sub>1</sub>=…=*b*<sub>*s*-1</sub>= 0 给出了一个*s*-步长 BDF 公式的通式，其中 *a* <sub>*n*</sub> 和 *b* <sub>*n* 这就给出了一个可以求解未知系数 *a* <sub>*n*</sub> 和 *b* <sub>*n*</sub> 的方程组。比如用*b*<sub>1</sub>=*a*<sub>0</sub>= 1 的一步 BDF 法简化为后向欧拉法，*y*<sub>*k*+1</sub>=*y*<sub>*k*</sub>+*HF*(*x* *y*<sub>*k*+2</sub>=*a*<sub>0</sub>*y*<sub>*k**a*<sub>1</sub>*y*<sub>*k*+1</sub> 求解系数时( *a* <sub>0</sub> ， *a* <sub>1</sub> ， *b* <sub>2</sub> )，变成![$ {y}_{k+2}=-\frac{1}{3}{y}_k+\frac{4}{3}{y}_{k+1}+\frac{2}{3} hf\left({x}_{k+2,}{y}_{k+2}\right) $](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq33.png)。 也可以构造高阶 BDF 方法。SciPy 提供了一个 BDF 解算器，推荐用于刚性问题，因为它具有良好的稳定性。</sub></sub>

另一类多步法是 Adams 方法，其来源于选择*a*<sub>0</sub>=*a*=<sub>1</sub>=…=*a*<sub>*s*-2</sub>= 0 和*a*<sub>s*s*-1</sub>= 1，其中剩余的未知系数再次被选择以最大化该方法的阶数。具体来说，带有*b*<sub>*s*</sub>= 0 的显式方法称为亚当斯-巴什福斯方法，带有*b*<sub>*s*</sub>≠0 的隐式方法称为亚当斯-莫尔顿方法。例如，一步法亚当斯-巴什福斯和亚当斯-莫尔顿方法分别简化为向前和向后欧拉方法，两步法分别为![$$ {y}_{k+2}={y}_{k+1}+h\left(-\frac{1}{2}f\left({x}_{k,}{y}_k\right)+\frac{3}{2}f\left({x}_{k+1,}{y}_{k+1}\right)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq34.png)和![$$ {y}_{k+1}={y}_k+\frac{1}{2}h\left(f\left({x}_{k,}{y}_k\right)+f\left({x}_{k+1,}{y}_{k+1}\right)\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq35.png)。高阶显式和隐式方法也可以用这种方式构造。SciPy 中也提供了使用这些 Adams 方法的解算器。

一般来说，显式方法比隐式方法更便于实现，并且对迭代的计算要求更低，隐式方法原则上要求在每次迭代中用对未知量的初始猜测来求解(潜在的非线性)方程 *y* <sub>*k* +1</sub> 。然而，如前所述，隐式方法通常更准确，并且具有更好的稳定性。一个保留了两种方法的一些优点的折衷方案是以如下方式结合显式和隐式方法:首先使用显式方法计算 *y* <sub>*k* +1</sub> ，然后使用这个*y*<sub>*k*+1</sub>作为求解隐式方法给出的*y*<sub>*k*+1</sub>方程的初始猜测。该方程不需要精确求解，并且由于来自显式方法的初始猜测应该是相当好的，使用例如牛顿法，少量迭代就足够了。像这样的方法，其中来自显式方法的结果被用于预测*y*<sub>*k*+1</sub>并且隐式方法被用于*校正*预测，被称为*预测-校正*方法。

最后，许多高级 ODE 求解器采用的一项重要技术是*自适应步长*或*步长控制*:ODE 的准确性和稳定性与 ODE 方法迭代公式中使用的步长 *h* <sub>*k*</sub> 密切相关，解决方案的计算成本也是如此。如果*y*<sub>*k*+1</sub>中的误差可以与*y*<sub>*k*+1</sub>本身的计算一起估算，那么就有可能自动调整步长 *h* <sub>*k*</sub> 以便解算器在可能时使用较大的经济步长，在需要时使用较小的步长。一种相关的技术是自动调整方法的顺序，以便在可能的时候使用较低顺序的方法，而在必要的时候使用较高顺序的方法，这对于一些方法是可能的。Adams 方法是可以容易地改变顺序的方法的例子。

ODE 求解器有各种各样的高质量实现，很少需要重新实现这里讨论的任何方法。事实上，这样做可能是错误的，除非是为了教育目的，或者如果一个人的主要兴趣是研究数值求解方法。出于实用目的，建议使用已经存在的许多经过高度调整和彻底测试的 ODE 套件之一，其中大多数套件都是免费的、开源的，并打包到 SciPy 之类的库中。但是，有大量的解决方案可供选择，为了能够做出明智的决定，使用哪一个解决特定问题，并了解他们的许多选项，熟悉基本思想和方法以及用于讨论它们的术语是很重要的。

## 用 SciPy 对常微分方程进行数值积分

在回顾了上一节给出的求解常微分方程的数值方法之后，我们现在准备探索 SciPy 中可用的常微分方程求解器以及如何使用它们。SciPy 的`integrate`模块提供了两个 ODE 求解器接口:`integrate.odeint`和`integrate.ode`。`odeint`函数是 ODEPACK， <sup>[4](#Fn4)</sup> 的 LSODA 解算器的接口，该解算器自动在用于非刚性问题的 Adams 预测-校正方法和用于刚性问题的 BDF 方法之间切换。相比之下，`integrate.ode`类为许多不同的解算器提供了面向对象的接口:VODE 和 ZVODE 解算器(ZVODE 是 VODE 用于复值函数的变体)、LSODA 解算器以及 dopri5 和 dop853，它们是具有自适应步长的四阶和八阶 Dormand-Prince 方法(即龙格-库塔方法的类型)。虽然`integrate.ode`提供的面向对象的接口更加灵活，但是`odeint`函数在很多情况下更简单、更方便使用。在下文中，我们从`odeint`函数开始，来看看这两个接口。

`odeint`函数带有三个强制参数:一个用于评估标准形式的 ODE 右侧的函数，一个指定未知函数初始条件的数组(或标量),以及一个包含独立变量值的数组，其中未知函数将被计算。ODE 右侧的函数采用两个强制参数和任意数量的可选参数。必需的参数是作为第一个参数的向量 *y* ( *x* )的数组(或标量)和作为第二个参数的 *x* 的值。比如再考虑标量 ODE*y*'(*x*)=*f*(*x*，*y*(*x*)=*x*+*y*(*x*)<sup>2</sup>。为了能够再次绘制该 ODE 的方向场，这一次连同使用`odeint`通过数值积分获得的特定解，我们首先定义构造 *f* ( *x* ， *y* ( *x* )的符号表达式所需的符号:

```py
In [79]: x = sympy.symbols("x")
In [80]: y = sympy.Function("y")
In [81]: f = y(x)**2 + x

```

为了能够用 SciPy 的`odeint`来解决这个颂歌，我们首先需要为 *f* ( *x* ， *y* ( *x* ))定义一个 Python 函数，该函数将 Python 标量或 NumPy 数组作为输入。从 SymPy 表达式`f`中，我们可以使用带有`'numpy'`参数 <sup>[6](#Fn6)</sup> 的`sympy.lambdify`生成这样一个函数:

```py
In [82]: f_np = sympy.lambdify((y(x), x), f)

```

接下来，我们需要定义初始值`y0`和一个带有离散值 *x* 的 NumPy 数组，用于计算函数 *y* ( *x* )。这里我们分别使用 NumPy 数组`xp`和`xm`在正负两个方向上求解从 *x* = 0 开始的 ODE。注意，要在负方向求解 ODE，我们只需要创建一个负增量的 NumPy 数组。现在我们已经设置了 ODE 函数`f_np`、初始值`y0`和数组 *x* 坐标，例如`xp`，我们可以通过调用`integrate.odeint(f_np, y0, xp)`来集成 ODE 问题:

```py
In [83]: y0 = 0
In [84]: xp = np.linspace(0, 1.9, 100)
In [85]: yp = integrate.odeint(f_np, y0, xp)
In [86]: xm = np.linspace(0, -5, 100)
In [87]: ym = integrate.odeint(f_np, y0, xm)

```

结果是两个一维的 NumPy 数组`ym`和`yp`，与对应的坐标数组`xm`和`xp`长度相同(即 100)，包含指定点的 ODE 问题的解。为了可视化解决方案，我们接下来绘制了`ym`和`yp`数组以及 ODE 的方向字段。结果如图 [9-4](#Fig4) 所示。很明显，正如预期的那样，该解在图中的每一点都与方向场中的线(切线)对齐。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig4_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig4_HTML.png)

图 9-4

*ODE y*′(*x*)=*x*+*y*(*x*)<sup>2</sup>*的方向场以及满足 y* (0) = 0 的具体解

```py
In [88]: fig, ax = plt.subplots(1, 1, figsize=(4, 4))
    ...: plot_direction_field(x, y(x), f, ax=ax)
    ...: ax.plot(xm, ym, 'b', lw=2)
    ...: ax.plot(xp, yp, 'r', lw=2)

```

在前面的例子中，我们解决了一个标量 ODE 问题。我们更经常感兴趣的是向量值常微分方程问题(常微分方程系统)。为了了解我们如何使用`odeint`解决这类问题，考虑一下捕食者和被捕食者种群的动力学 Lotka-Volterra 方程(耦合常微分方程的经典例子)。方程为*x*'(*t*)=*ax*-*bxy*和*y*'(*t*)=*cxy*-*dy*，其中 *x* ( *t* 为被捕食动物的数量，*y*(*t*例如， *a* 是被捕食动物出生的速率， *d* 是捕食者死亡的速率。 *b* 和 *c* 系数分别是捕食者消耗猎物的速率和捕食者种群以牺牲猎物种群为代价增长的速率。注意，这是一个非线性的常微分方程系统，因为有 *xy* 项。**

为了用`odeint`解决这个问题，我们首先需要以向量的形式为 ODE 的右边写一个函数。对于这种情况，我们有 *f* ( *t* ， *x* ，*y*<sup>*T*</sup>)=*ax*-*bxy*，*cxy*-*dy*<sup>*T*</sup>，我们可以通过以下方式将它们实现为 Python 函数

```py
In [89]: a, b, c, d = 0.4, 0.002, 0.001, 0.7
In [90]: def f(xy, t):
    ...:     x, y = xy
    ...:     return [a * x - b * x * y, c * x * y - d * y]

```

这里我们还定义了系数 *a* 、 *b* 、 *c* 和 *d* 的变量和值。注意，这里 ODE 函数`f`的第一个参数是一个数组，包含了 *x* ( *t* )和 *y* ( *t* )的当前值。为了方便起见，我们首先将这些变量分解成单独的变量`x`和`y`，这使得函数的其余部分更容易阅读。函数的返回值应该是一个数组或列表，包含 *x* ( *t* )和 *y* ( *t* )的导数的值。函数`f`也必须采用参数`t`，带有独立坐标的当前值。但是，本例中没有使用`t`。一旦定义了`f`函数，我们还需要定义一个带有初始值 *x* (0)和 *y* (0)的数组`xy0`，以及一个数组`t`，用于我们希望计算 ODE 解的点。这里我们用初始条件 *x* (0) = 600、 *y* (0) = 400，对应的是模拟开始时的 600 只被捕食动物和 400 只捕食者。

```py
In [91]: xy0 = [600, 400]
In [92]: t = np.linspace(0, 50, 250)
In [93]: xy_t = integrate.odeint(f, xy0, t)
In [94]: xy_t.shape
Out[94]: (250,2)

```

调用`integrate.odeint(f, xy0, t)`整合 ODE 问题，返回 shape (250，2)数组，包含`t`中 250 个值的每一个的 *x* ( *t* )和 *y* ( *t* )。以下代码在相空间中将解绘制为时间的函数。结果如图 [9-5](#Fig5) 所示。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig5_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig5_HTML.png)

图 9-5

捕食者-食饵种群的 Lotka-Volterra 方程的解，作为时间(左)和相空间(右)的函数

```py
In [95]: fig, axes = plt.subplots(1, 2, figsize=(8, 4))
    ...: axes[0].plot(t, xy_t[:,0], 'r', label="Prey")
    ...: axes[0].plot(t, xy_t[:,1], 'b', label="Predator")
    ...: axes[0].set_xlabel("Time")
    ...: axes[0].set_ylabel("Number of animals")
    ...: axes[0].legend()
    ...: axes[1].plot(xy_t[:,0], xy_t[:,1], 'k')
    ...: axes[1].set_xlabel("Number of prey")
    ...: axes[1].set_ylabel("Number of predators")

```

在前两个示例中，ODE 右侧的函数是在没有附加参数的情况下实现的。在 Lotka-Volterra 方程的例子中，函数`f`使用了全局定义的系数变量。与使用全局变量相比，以这样一种方式实现`f`函数通常更方便、更优雅，即它接受所有系数或参数的自变量。为了说明这一点，让我们考虑另一个著名的常微分方程问题:洛伦兹方程，它是以下三个耦合的非线性常微分方程的系统，*x*'(*t*)=*σ*(*y*-*x*)、*y*'(*t*)=*x*(*ρ*-T23)这些方程以其混沌解而闻名，它们敏感地依赖于参数 *σ* 、 *ρ* 和 *β* 的值。如果我们希望针对这些参数的不同值来求解这些方程，那么编写 ODE 函数以便它另外将这些变量的值作为自变量是很有用的。在下面的`f`实现中，对应命名参数的三个参数`sigma`、`rho`和`beta`被添加到强制 *y* ( *t* )和 *t* 参数之后:

```py
In [96]: def f(xyz, t, sigma, rho, beta):
    ...:     x, y, z = xyz
    ...:     return [sigma * (y - x),
    ...:             x * (rho - z) - y,
    ...:             x * y - beta * z]

```

接下来，我们用参数的特定值定义变量，用 *t* 值定义数组来计算解，以及函数 *x* ( *t* )、 *y* ( *t* )和 *z* ( *t* )的初始条件。

```py
In [97]: sigma, rho, beta = 8, 28, 8/3.0
In [98]: t = np.linspace(0, 25, 10000)
In [99]: xyz0 = [1.0, 1.0, 1.0]

```

这一次当我们调用`integrate.odeint`时，我们还需要指定`args`参数，它需要是一个列表、元组或数组，其元素数量与我们在上一节中定义的`f`函数中附加参数的数量相同。在这种情况下，有三个参数，当调用`integrate.odeint`时，我们通过`args`参数传递一个带有这些参数值的元组。下面，我们求解三组不同参数(但初始条件相同)的常微分方程。

```py
In [100]: xyz1 = integrate.odeint(f, xyz0, t, args=(sigma, rho, beta))
In [101]: xyz2 = integrate.odeint(f, xyz0, t, args=(sigma, rho, 0.6*beta))
In [102]: xyz3 = integrate.odeint(f, xyz0, t, args=(2*sigma, rho, 0.6*beta))

```

解决方案存储在 NumPy 数组`xyz1`、`xyz2`和`xyz3`中。在这种情况下，这些数组具有形状`(10000, 3)`，因为`t`数组有 10000 个元素，并且在 ODE 问题中有三个未知函数。这三个解在下面的代码中绘制成 3D 图形，结果如图 [9-6](#Fig6) 所示。随着系统参数的微小变化，最终的解决方案可能会有很大不同。

```py
In [103]: from mpl_toolkits.mplot3d.axes3d import Axes3D
In [104]: fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 4),
     ...:                                     subplot_kw={'projection':'3d'})
     ...: for ax, xyz, c in [(ax1, xyz1, 'r'), (ax2, xyz2, 'b'), (ax3, xyz3, 'g')]:
     ...:     ax.plot(xyz[:,0], xyz[:,1], xyz[:,2], c, alpha=0.5)
     ...:     ax.set_xlabel('$x$', fontsize=16)
     ...:     ax.set_ylabel('$y$', fontsize=16)
     ...:     ax.set_zlabel('$z$', fontsize=16)
     ...:     ax.set_xticks([-15, 0, 15])
     ...:     ax.set_yticks([-20, 0, 20])
     ...:     ax.set_zticks([0, 20, 40])

```

到目前为止，我们看到的三个例子都使用了`odeint`解算器。该函数采用大量可用于微调求解器的可选参数，包括允许的最大步数(`hmax`)以及亚当斯(`mxordn`)和 BDF ( `mxords`)方法的最大阶数等选项。更多信息参见`odeint`的文档字符串。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig6_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig6_HTML.png)

图 9-6

Lorenz ODE 的动力学，对于三组不同的参数

SciPy 中对`odeint`的替代是由`integrate.ode`类提供的面向对象的接口。像使用`odeint`函数一样，要使用`integrate.ode`类，我们首先需要为 ODE 定义右边的函数，并定义初始状态数组和我们想要计算解的独立变量的值数组。然而，一个微小但重要的区别是，与`odeint`一起使用的 *f* ( *x* ， *y* ( *x* ))的函数必须具有函数签名`f(y, x, ...)`，而与`integrate.ode`一起使用的对应函数必须具有函数签名`f(x, y, ...)`(即`x`和`y`的顺序相反)。

`integrate.ode`类可以与一组不同的解算器一起工作，它对每个解算器都有特定的选项。`integrate.ode`的 docstring 描述了可用的解算器及其选项。为了说明如何使用`integrate.ode`接口，我们首先来看下面几组耦合二阶常微分方程:

![$$ {\mathrm{m}}_1{\mathrm{x}}_1^{\prime \prime}\left(\mathrm{t}\right)+{\upgamma}_1\ {\mathrm{x}}_1^{\prime}\left(\mathrm{t}\right)+{\mathrm{k}}_1{\mathrm{x}}_1-{\mathrm{k}}_2\ \left({\mathrm{x}}_2-{\mathrm{x}}_1\right)=0, $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equaf.png)

![$$ {\mathrm{m}}_2{\mathrm{x}}_2^{\prime \prime}\left(\mathrm{t}\right)+{\upgamma}_2{\mathrm{x}}_2^{\prime}\left(\mathrm{t}\right)+{\mathrm{k}}_2\ \left({\mathrm{x}}_2-{\mathrm{x}}_1\right)=0\. $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equag.png)

这些方程描述了两个耦合弹簧的动力学，其中 x <sub>1</sub> (t)和 x <sub>2</sub> (t)是质量为 m <sub>1</sub> 和 m <sub>2</sub> 的两个物体从它们的平衡位置的位移。x <sub>1</sub> 处的物体通过弹簧常数为 k <sub>1</sub> 的弹簧连接到固定壁上，并通过弹簧常数为 k <sub>2</sub> 的弹簧连接到 x <sub>2</sub> 处的物体上。两个物体分别受到由γ <sub>1</sub> 和γ <sub>2</sub> 表征的阻尼力。为了用 SciPy 解决这类问题，我们首先必须以标准形式编写它，我们可以通过引入 y<sub>0</sub>(t)= x<sub>1</sub>(t)![$$ {\mathrm{y}}_1\left(\mathrm{t}\right)={\mathrm{x}}_1^{\prime}\left(\mathrm{t}\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq36.png)，y <sub> 2 </sub> (t) = x <sub> 2 </sub> (t)和![$$ {\mathrm{y}}_3\left(\mathrm{t}\right)={\mathrm{x}}_2^{\prime}\left(\mathrm{t}\right) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq37.png)来完成，这导致四个耦合的一阶方程:

![$$ \frac{\mathrm{d}}{\mathrm{d}\mathrm{t}}\left[\begin{array}{c}{\mathrm{y}}_0\left(\mathrm{t}\right)\\ {}{\mathrm{y}}_1\left(\mathrm{t}\right)\\ {}{\mathrm{y}}_2\left(\mathrm{t}\right)\\ {}{\mathrm{y}}_3\left(\mathrm{t}\right)\end{array}\right]=\mathrm{f}\left(\mathrm{t},\mathbf{y}\left(\mathrm{t}\right)\right)=\left[\begin{array}{c}{\mathrm{y}}_1\left(\mathrm{t}\right)\\ {}\left(-{\upgamma}_1{\mathrm{y}}_1\left(\mathrm{t}\right)-{\mathrm{k}}_1{\mathrm{y}}_0\left(\mathrm{t}\right)-{\mathrm{k}}_2{\mathrm{y}}_0\left(\mathrm{t}\right)+{\mathrm{k}}_2{\mathrm{y}}_2\left(\mathrm{t}\right)\right)/{\mathrm{m}}_1\\ {}{\mathrm{y}}_3\left(\mathrm{t}\right)\\ {}\left(-{\upgamma}_2{\mathrm{y}}_3\left(\mathrm{t}\right)-{\mathrm{k}}_2{\mathrm{y}}_2\left(\mathrm{t}\right)+{\mathrm{k}}_2{\mathrm{y}}_0\left(\mathrm{t}\right)\right)/{\mathrm{m}}_2\end{array}\right] $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equah.png)

第一个任务是编写一个 Python 函数，实现函数 f(t， **y** (t))，该函数也将问题参数作为附加参数。在下面的实现中，我们将所有参数组合成一个元组，作为单个参数传递给函数，并在函数体的第一行解包:

```py
In [105]: def f(t, y, args):
     ...:     m1, k1, g1, m2, k2, g2 = args
     ...:     return [y[1], - k1/m1 * y[0] + k2/m1 * (y[2] - y[0]) - g1/m1 * y[1],
     ...:             y[3], - k2/m2 * (y[2] - y[0]) - g2/m2 * y[3]]

```

函数`f`的返回值是一个长度为 4 的列表，其元素是 ODE 函数*y*T7】0(*t*)*到 y* <sub>3</sub> ( *t* )的导数。接下来，我们为参数创建具有特定值的变量，并将它们打包成一个元组`args`，该元组可以传递给函数`f`。像以前一样，我们还需要为初始条件`y0`和 *t* 值创建数组，以便计算 ODE，`t`的解。

```py
In [106]: m1, k1, g1 = 1.0, 10.0, 0.5
In [107]: m2, k2, g2 = 2.0, 40.0, 0.25
In [108]: args = (m1, k1, g1, m2, k2, g2)
In [109]: y0 = [1.0, 0, 0.5, 0]
In [110]: t = np.linspace(0, 20, 1000)

```

使用`integrate.odeint`和`integrate.ode`的主要区别就从这一点开始。我们现在不需要调用`odeint`函数，而是需要创建一个`integrate.ode`类的实例，将 ODE 函数`f`作为参数传递:

```py
In [111]: r = integrate.ode(f)

```

这里，我们将结果解算器实例存储在变量`r`中。在开始使用它之前，我们需要配置它的一些属性。至少，我们需要使用`set_initial_value`方法设置初始状态，如果函数`f`接受额外的参数，我们需要使用`set_f_params`方法配置这些参数。我们还可以使用`set_integrator`方法选择规划求解，该方法接受以下规划求解名称作为第一个参数:`vode`、`zvode`、`lsoda`、`dopri5`和`dop853`。每个求解器都有额外的可选参数。详见`integrate.ode`的文档字符串。这里我们使用 LSODA 解算器，并为函数`f`设置初始状态和参数:

```py
In [112]: r.set_integrator('lsoda');
In [113]: r.set_initial_value(y0, t[0]);
In [114]: r.set_f_params(args);

```

一旦创建并配置了求解器，我们就可以通过调用`r.integrate`方法开始一步一步地求解 ODE，并且可以使用`r.successful`方法查询集成的状态(只要集成进行得很好，它就会返回`True`)。我们需要跟踪集成到哪个点，并且我们需要自己存储结果:

```py
In [115]: dt = t[1] - t[0]
     ...: y = np.zeros((len(t), len(y0)))
     ...: idx = 0
     ...: while r.successful() and r.t < t[-1]:
     ...:     y[idx, :] = r.y
     ...:     r.integrate(r.t + dt)
     ...:     idx += 1

```

可以说，这不如简单地调用`odeint`方便，但是它提供了额外的灵活性，有时这正是所需要的。在这个例子中，我们在数组`y`中为`t`中的每个对应元素存储了解决方案，这类似于`odeint`将返回的结果。以下代码绘制了解决方案，结果如图 [9-7](#Fig7) 所示。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig7_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig7_HTML.png)

图 9-7

两个耦合阻尼振子常微分方程的解

```py
In [116]: fig = plt.figure(figsize=(10, 4))
     ...: ax1 = plt.subplot2grid((2, 5), (0, 0), colspan=3)
     ...: ax2 = plt.subplot2grid((2, 5), (1, 0), colspan=3)
     ...: ax3 = plt.subplot2grid((2, 5), (0, 3), colspan=2, rowspan=2)
     ...: # x_1 vs time plot
     ...: ax1.plot(t, y[:, 0], 'r')
     ...: ax1.set_ylabel('$x_1$', fontsize=18)
     ...: ax1.set_yticks([-1, -.5, 0, .5, 1])
     ...: # x2 vs time plot
     ...: ax2.plot(t, y[:, 2], 'b')
     ...: ax2.set_xlabel('$t$', fontsize=18)
     ...: ax2.set_ylabel('$x_2$', fontsize=18)
     ...: ax2.set_yticks([-1, -.5, 0, .5, 1])
     ...: # x1 and x2 phase space plot
     ...: ax3.plot(y[:, 0], y[:, 2], 'k')
     ...: ax3.set_xlabel('$x_1$', fontsize=18)
     ...: ax3.set_ylabel('$x_2$', fontsize=18)
     ...: ax3.set_xticks([-1, -.5, 0, .5, 1])
     ...: ax3.set_yticks([-1, -.5, 0, .5, 1])
     ...: fig.tight_layout()

```

除了为 ODE 函数 *f* ( *t* ， *y* ( *t* ))提供 Python 函数，还可以为给定的 *t* 和 *y* ( *t* )计算雅可比矩阵。例如，求解器可以使用雅可比矩阵来更有效地求解隐式方法中出现的方程组。要使用雅可比函数`jac`，就像下面为当前问题定义的函数，我们需要在创建时将它和`f`函数一起传递给`integrate.ode`类。如果雅可比函数`jac`带有额外的参数，那么在产生的`integrate.ode`实例中，这些参数也必须使用`set_jac_params`方法进行配置:

```py
In [117]: def jac(t, y, args):
     ...:     m1, k1, g1, m2, k2, g2 = args
     ...:     return [[0, 1, 0, 0],
     ...:             [- k1/m2 - k2/m1, - g1/m1 * y[1], k2/m1, 0],
     ...:             [0, 0, 1, 0],
     ...:             [k2/m2, 0, - k2/m2, - g2/m2]]
In [118]: r = integrate.ode(f, jac)
In [119]: r.set_jac_params(args);

```

使用 SymPy 的`lambdify`可以方便地生成用于 *f* ( *t* ， *y* ( *t* ))及其雅可比矩阵的 Python 函数，前提是首先可以将 ODE 问题定义为一个 SymPy 表达式。这种符号-数值混合方法是解决常微分方程问题的有效方法。为了说明这种方法，考虑双摆的两个耦合的二阶非线性常微分方程的相当复杂的系统。第一摆和第二摆的角偏转运动方程*θ*<sub>1</sub>(*t*)和*θ*<sub>2</sub>(*t*)分别为 <sup>[7](#Fn7)</sup>

![$$ \left({m}_1+{m}_2\right)\ {l}_1{\theta}_1^{\prime \prime }(t)+{m}_2{l}_2{\theta}_2^{\prime \prime }(t)\cos \left({\theta}_1-{\theta}_2\right)+{m}_2{l}_2{\left({\theta}_2^{\prime }(t)\right)}^2\sin \left({\theta}_1-{\theta}_2\right)+g\left({m}_1+{m}_2\right)\sin {\theta}_1=0, $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equai.png)

![$$ {m}_2{l}_2{\theta}_2^{\prime \prime }(t)+{m}_2{l}_1{\theta}_1^{\prime \prime}\cos \left({\theta}_1-{\theta}_2\right)-{m}_2{l}_1{\left({\theta}_1^{\prime }(t)\right)}^2\sin \left({\theta}_1-{\theta}_2\right)+{m}_2g\sin {\theta}_2=0\. $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equaj.png)

第一摆附着在固定支架上，第二摆附着在第一摆上。这里 *m* <sub>1</sub> 和 *m* <sub>2</sub> 分别是质量和 *l* <sub>1</sub> 和 *l* <sub>2</sub> 分别是第一和第二摆的长度。我们首先为问题中的变量和函数定义 SymPy 符号，然后构造 ode 表达式:

![$$ g\left({m}_1+{m}_2\right)\sin {\theta}_1(t)+{l}_1\left({m}_1+{m}_2\right)\frac{d^2}{d{t}^2}{\theta}_1(t)+{l}_2{m}_2\sin \left({\theta}_1(t)-{\theta}_2(t)\right){\left(\frac{d}{dt}{\theta}_2(t)\right)}^2+{l}_2{m}_2\frac{d^2}{d{t}^2}{\theta}_2(t)\cos \left({\theta}_1(t)-{\theta}_2(t)\right)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equak.png)

```py
In [120]: t, g, m1, l1, m2, l2 = sympy.symbols("t, g, m_1, l_1, m_2, l_2")
In [121]: theta1, theta2 = sympy.symbols("theta_1, theta_2", cls=sympy.Function)
In [122]: ode1 = sympy.Eq((m1+m2)*l1 * theta1(t).diff(t,t) +
     ...:                 m2*l2 * theta2(t).diff(t,t) * sympy.cos(theta1(t)-theta2(t)) +
     ...:                 m2*l2 * theta2(t).diff(t)**2 * sympy.sin(theta1(t)-theta2(t)) +
     ...:                 g*(m1+m2) * sympy.sin(theta1(t)))
     ...: ode1
Out[122]:

```

![$$ g{m}_2\sin {\theta}_2(t)-{l}_1{m}_2\sin \left({\theta}_1(t)-{\theta}_2(t)\right){\left(\frac{d}{dt}{\theta}_1(t)\right)}^2+{l}_1{m}_2\cos \left({\theta}_1(t)-{\theta}_2(t)\right)\frac{d^2}{d{t}^2}{\theta}_1(t)+{l}_2{m}_2\frac{d^2}{d{t}^2}{\theta}_2(t)=0 $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_Equal.png)

```py
In [123]: ode2 = sympy.Eq(m2*l2 * theta2(t).diff(t,t) +
     ...:                 m2*l1 * theta1(t).diff(t,t) * sympy.cos(theta1(t)-theta2(t)) -
     ...:                 m2*l1 * theta1(t).diff(t)**2 * sympy.sin(theta1(t) - theta2(t)) +
     ...:                 m2*g * sympy.sin(theta2(t)))
     ...: ode2
Out[123]:

```

现在`ode1`和`ode2`是两个二阶常微分方程的 SymPy 表达式。试图用`sympy.dsolve`解这些方程是没有结果的，为了继续，我们需要使用一种数值方法。然而，这些方程的形式并不适合用 SciPy 中的常微分方程求解器进行数值求解。我们首先要把两个二阶常微分方程组写成标准形式的四个一阶常微分方程组。重写标准形式的方程并不困难，但是手工做起来会很乏味。幸运的是，我们可以利用 SymPy 的符号功能来自动完成这项任务。为此我们需要引入新的函数*y*<sub>1</sub>(*t*)=*θ*<sub>1</sub>(*t*)和![$$ {y}_2(t)={\theta}_1^{\prime }(t) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq38.png)和*y*<sub>3</sub>(*t【T22)=*θ*<sub>2</sub>(*t*)和*通过为变量 change 创建字典，并使用 SymPy 函数`subs`使用该字典执行替换，我们可以很容易地获得![$$ {y}_2^{\prime }(t) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq40.png)和![$$ {y}_4^{\prime }(t) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq41.png)的等式:

```py
In [124]: y1, y2, y3, y4 = sympy.symbols("y_1, y_2, y_3, y_4", cls=sympy.Function)
In [125]: varchange = {theta1(t).diff(t, t): y2(t).diff(t),
     ...:              theta1(t): y1(t),
     ...:              theta2(t).diff(t, t): y4(t).diff(t),
     ...:              theta2(t): y3(t)}
In [126]: ode1_vc = ode1.subs(varchange)
In [127]: ode2_vc = ode2.subs(varchange)

```

我们还需要为![$$ {y}_1^{\prime }(t) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq42.png)和![$$ {y}_3^{\prime }(t) $$](img/332789_2_En_9_Chapter/332789_2_En_9_Chapter_TeX_IEq43.png)引入另外两个 ode:

```py
In [128]: ode3 = y1(t).diff(t) - y2(t)
In [129]: ode4 = y3(t).diff(t) - y4(t)

```

此时，我们有四个耦合的一阶常微分方程，分别用于函数*y*T3】1 到*y*T7】4。只剩下求解这些函数的导数来获得标准形式的常微分方程。我们可以使用`sympy.solve`来做到这一点:

```py
In [130]: y = sympy.Matrix([y1(t), y2(t), y3(t), y4(t)])
In [131]: vcsol = sympy.solve((ode1_vc, ode2_vc, ode3, ode4), y.diff(t), dict=True)
In [132]: f = y.diff(t).subs(vcsol[0])

```

现在`f`是 ODE 函数 *f* ( *t* ， *y* ( *t* ))的 SymPy 表达式。我们可以使用`sympy.Eq(y.diff(t), f)`显示 ode，但是结果相当长，为了节省空间，我们没有在这里显示输出。这里构造`f`的主要目的是将它转换成一个 NumPy-aware 函数，可以与`integrate.odeint`或`integrate.ode`一起使用。ode 现在在一个表单上，我们可以使用`sympy.lambdify`创建这样一个函数。此外，由于到目前为止我们已经有了问题的符号表示，因此也很容易计算雅可比矩阵并为其创建一个 NumPy-aware 函数。当使用`sympy.lambdify`为`odeint`和`ode`创建函数时，我们必须小心地将`t`和`y`以正确的顺序放入传递给`sympy.lambdify`的元组中。这里我们将使用`integrate.ode`，因此我们需要一个带有签名`f(t, y, *args)`的函数，因此我们将元组`(t, y)`作为第一个参数传递给`sympy.lambdify`，并且我们用一个`lambda`函数包装结果函数，以便能够接收 SymPy 表达式中没有使用的附加参数`args`。

```py
In [133]: params = {m1: 5.0, l1: 2.0, m2: 1.0, l2: 1.0, g: 10.0}
In [134]: _f_np = sympy.lambdify((t, y), f.subs(params), 'numpy')
In [135]: f_np = lambda _t, _y, *args: _f_np(_t, _y)
In [136]: jac = sympy.Matrix([[fj.diff(yi) for yi in y] for fj in f])
In [137]: _jac_np = sympy.lambdify((t, y), jac.subs(params), 'numpy')
In [138]: jac_np = lambda _t, _y, *args: _jac_np(_t, _y)

```

在这里，我们在调用`sympy.lambdify`之前也替换了系统参数的特定值。第一个钟摆是第二个钟摆的两倍长，五倍重。有了函数`f_np`和`jac_np`，我们现在可以用和前面例子一样的方式用`integrate.ode`求解 ODE 了。这里我们取初始状态为 *θ* <sub>1</sub> (0) = 2 和 *θ* <sub>2</sub> (0) = 0，导数为零到零，我们用 1000 步求解时间间隔[0，20]:

```py
In [139]: y0 = [2.0, 0, 0, 0]
In [140]: tt = np.linspace(0, 20, 1000)
In [141]: r = integrate.ode(f_np, jac_np).set_initial_value(y0, tt[0])
In [142]: dt = tt[1] - tt[0]
     ...: yy = np.zeros((len(tt), len(y0)))
     ...: idx = 0
     ...: while r.successful() and r.t < tt[-1]:
     ...:     yy[idx, :] = r.y
     ...:     r.integrate(r.t + dt)
     ...:     idx += 1

```

ODEs 的解现在存储在数组`yy`中，数组的形状为`(1000, 4)`。当可视化这个解时，更直观的是绘制摆锤在*x*–*y*平面中的位置，而不是它们的角度偏转。角度变量 *θ* <sub>1</sub> 与 *θ* <sub>2</sub> 与 *x* 与 *y* 坐标之间的转换为*x*<sub>1</sub>=*l*<sub>1</sub>sin*θ*<sub>1</sub>*y* <sub>*x*<sub>2</sub>=*x*<sub>1</sub>+*l*<sub>2</sub>sin*θ*<sub>2</sub>和*y*<sub>2</sub>=*y*<sub>1</sub>+*l*</sub>

```py
In [143]: theta1_np, theta2_np = yy[:, 0], yy[:, 2]
In [144]: x1 = params[l1] * np.sin(theta1_np)
     ...: y1 = -params[l1] * np.cos(theta1_np)
     ...: x2 = x1 + params[l2] * np.sin(theta2_np)
     ...: y2 = y1 - params[l2] * np.cos(theta2_np)

```

最后，我们在*x*–*y*平面上绘制双摆的动力学，作为时间的函数。结果如图 [9-8](#Fig8) 所示。正如所料，摆 1 被限制在圆周上移动(因为它有固定的锚点)，而摆 2 有更复杂的轨迹。

![img/332789_2_En_9_Chapter/332789_2_En_9_Fig8_HTML.png](img/332789_2_En_9_Chapter/332789_2_En_9_Fig8_HTML.png)

图 9-8

双摆的动力学

```py
In [145]: fig = plt.figure(figsize=(10, 4))
     ...: ax1 = plt.subplot2grid((2, 5), (0, 0), colspan=3)
     ...: ax2 = plt.subplot2grid((2, 5), (1, 0), colspan=3)
     ...: ax3 = plt.subplot2grid((2, 5), (0, 3), colspan=2, rowspan=2)
     ...:
     ...: ax1.plot(tt, x1, 'r')
     ...: ax1.plot(tt, y1, 'b')
     ...: ax1.set_ylabel('$x_1, y_1$', fontsize=18)
     ...: ax1.set_yticks([-3, 0, 3])
     ...:
     ...: ax2.plot(tt, x2, 'r')
     ...: ax2.plot(tt, y2, 'b')
     ...: ax2.set_xlabel('$t$', fontsize=18)
     ...: ax2.set_ylabel('$x_2, y_2$', fontsize=18)
     ...: ax2.set_yticks([-3, 0, 3])
     ...:
     ...: ax3.plot(x1, y1, 'r')
     ...: ax3.plot(x2, y2, 'b', lw=0.5)
     ...: ax3.set_xlabel('$x$', fontsize=18)
     ...: ax3.set_ylabel('$y$', fontsize=18)
     ...: ax3.set_xticks([-3, 0, 3])
     ...: ax3.set_yticks([-3, 0, 3])

```

## 摘要

在本章中，我们探索了使用 Python 的科学计算包求解常微分方程(ODEs)的各种方法和工具。常微分方程出现在科学和工程的许多领域——特别是在动态系统的建模和描述中——因此，掌握解决常微分方程问题的技术是计算科学家技能的重要组成部分。在这一章中，我们首先看了用 SymPy 象征性地求解常微分方程，或者用`sympy.dsolve`函数，或者用拉普拉斯变换方法。符号方法通常是一个很好的起点，借助 SymPy 的符号功能，许多基本的 ODE 问题都可以解析地解决。然而，对于大多数实际问题，没有解析解，符号方法注定要失败。我们剩下的选择是依靠数字技术。常微分方程的数值积分是数学中的一个广阔领域，存在许多解决常微分方程问题的可靠方法。在本章中，我们简要回顾了积分常微分方程的方法，旨在介绍在 SciPy 提供的解算器中使用的亚当斯和 BDF 多步法背后的概念和思想。最后，我们看了如何通过解决几个示例问题来使用通过 SciPy `integrate`模块获得的`odeint`和`ode`求解器。尽管大多数 ODE 问题最终都需要数值积分，但使用符号-数值混合方法会有很大的优势，这种方法使用了 SymPy 和 SciPy 的特征。本章的最后一个例子专门用来演示这种方法。

## 进一步阅读

Heath (2002)给出了许多数值求解常微分方程问题方法的简单介绍。有关带代码示例的常微分方程的回顾，请参见*数值方法*中的第 [11](11.html) 章(W.H. Press 2007)。关于常微分方程数值方法的更详细的调查，例如，见(Kendall Atkinson (2009))。SciPy 中使用的 ODE 解算器的主要实现是 VODE 和 LSODA 解算器。这些方法的原始源代码可分别从 netlib 的 [`www.netlib.org/ode/vode.f`](http://www.netlib.org/ode/vode.f) 和 [`www.netlib.org/odepack`](http://www.netlib.org/odepack) 获得。除了这些解算器，还有一套著名的解算器，叫做 sundials，由劳伦斯利弗莫尔国家实验室提供，可在 [`http://computation.llnl.gov/casc/sundials/main.html`](http://computation.llnl.gov/casc/sundials/main.html) 获得。这个套件还包括微分代数方程(DAE)的解算器。`scikit.odes`库为日晷解算器提供了一个 Python 接口，可以从 [`http://github.com/bmcage/odes`](http://github.com/bmcage/odes) 获得。`odespy`库也为许多不同的 ODE 解算器提供了一个统一的接口。有关`odespy`的更多信息，请参见该项目的网站 [`http://hplgit.github.io/odespy/doc/web/index.html`](http://hplgit.github.io/odespy/doc/web/index.html) 。

## 参考

科学计算。2 号。纽约:麦格劳希尔公司，2002 年。

肯德尔阿特金森，韩为民，。*常微分方程的数值解法。*新泽西:威利，2009 年。

W.H. Press，S.A. Teukolsky，W.T. Vetterling，B.P. Flannery。*数字食谱。*3 号。纽约:剑桥大学出版社，2007。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

在 SymPy 的当前版本中，`ics`关键字参数只能被`dsolve`中的幂级数解算器识别。其他类型常微分方程的解算器忽略了`ics`参数，因此不需要我们在本章前面定义和使用的`apply_ics`函数。

  [2](#Fn2_source)

或者“白盒”解算器，因为 SymPy 是开源的，并且`dsolve`的内部工作方式很容易检查。

  [3](#Fn3_source)

回想一下，任何一个常微分方程问题都可以写成这个标准形式的一阶常微分方程组。

  [4](#Fn4_source)

更多关于 ODEPACK 的信息请访问 [`http://computation.llnl.gov/casc/odepack`](http://computation.llnl.gov/casc/odepack) 。

  [5](#Fn5_source)

VODE 和 ZVODE 解算器可在 netlib: [`http://www.netlib.org/ode`](http://www.netlib.org/ode) 获得。

  [6](#Fn6_source)

在这种特殊的情况下，对于标量 ODE，我们也可以使用`’math’`参数，它使用标准`math`库中的函数生成一个标量函数，但更常见的是，我们需要数组感知函数，这是通过使用`’numpy’`参数到`sympy.lambdify`来获得的。

  [7](#Fn7_source)

详见 [`http://scienceworld.wolfram.com/physics/DoublePendulum.html`](http://scienceworld.wolfram.com/physics/DoublePendulum.html) 。

 </aside>*