# 2.向量、矩阵和多维数组

向量、矩阵和高维数组是数值计算的基本工具。当必须对一组输入值重复计算时，将数据表示为数组并将计算表示为数组操作是自然且有利的。以这种方式公式化的计算被称为矢量化。 <sup>[1](#Fn1)</sup> 矢量化计算通过对数组数据应用批处理操作，消除了对数组元素进行多次显式循环的需要。结果是简洁且更易维护的代码，并且它使得能够将(例如，元素方面的)数组操作的实现委托给更高效的低级库。因此，矢量化计算比顺序的逐个元素计算要快得多。这在 Python 这样的解释型语言中尤其重要，在这种语言中，逐个元素地循环数组会带来很大的性能开销。

在 Python 的科学计算环境中，NumPy 库提供了处理数组的高效数据结构。NumPy 的核心是用 C 实现的，它提供了操作和处理数组的有效函数。乍一看，NumPy 数组与 Python 的列表数据结构有些相似。但是一个重要的区别是，Python 列表是对象的通用容器，而 NumPy 数组是同构的，是固定大小的类型化数组。同构意味着数组中的所有元素都具有相同的数据类型。固定大小意味着数组不能调整大小(不创建新数组)。出于这些和其他原因，对 NumPy 数组的操作和函数比使用 Python 列表的操作和函数更有效。除了数组的数据结构之外，NumPy 还提供了作用于这些数据结构的大量基本操作符和函数，以及具有更高级算法(如线性代数和快速傅立叶变换)的子模块。

在这一章中，我们首先看一下数组的基本 NumPy 数据结构和创建这种 NumPy 数组的各种方法。接下来，我们看看操纵数组和用数组进行计算的操作。NumPy 提供的多维数据数组是几乎所有 Python 数值库的基础。因此，花时间熟悉 NumPy 并理解 NumPy 的工作原理是非常重要的。

### NumPy

NumPy 库提供了用于表示各种数组的数据结构，以及用于操作这些数组的方法和函数。NumPy 为 Python 的几乎所有科学或技术库提供了数字后端。因此，它是科学 Python 生态系统中非常重要的一部分。在撰写本文时，NumPy 的最新版本是 1.14.2。更多关于 NumPy 的信息请访问 [`www.numpy.org`](http://www.numpy.org) 。

## 导入模块

为了使用 NumPy 库，我们需要在程序中导入它。按照惯例，`numPy`模块以别名`np`导入，就像这样:

```py
In [1]: import numpy as np

```

之后，我们可以使用`np`名称空间访问`numpy`模块中的函数和类。在本书中，我们假设 NumPy 模块是以这种方式导入的。

## NumPy 数组对象

NumPy 库的核心是用于表示同构数据的多维数组的数据结构。同构是指数组中的所有元素都具有相同的数据类型。<sup>[2](#Fn2)</sup>NumPy 中多维数组的主要数据结构是`ndarray`类。除了存储在数组中的数据之外，该数据结构还包含关于数组的重要元数据，例如数组的形状、大小、数据类型和其他属性。参见表 [2-1](#Tab1) 了解这些属性的更详细描述。带有描述的完整属性列表在`ndarray` docstring 中可用，可以通过调用 Python 解释器中的`help(np.ndarray)`或 IPython 控制台中的`np.ndarray?`来访问。

表 2-1

`ndarray`类的基本属性

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

属性

 | 

描述

 |
| --- | --- |
| `Shape` | 包含数组的每个维度(轴)的元素数量(即长度)的元组。 |
| `Size` | 数组中元素的总数。 |
| `Ndim` | 维度(轴)的数量。 |
| `nbytes` | 用于存储数据的字节数。 |
| `dtype` | 数组中元素的数据类型。 |

以下示例演示了如何为类`ndarray`的实例`data`访问这些属性:

```py
In [2]: data = np.array([[1, 2], [3, 4], [5, 6]])
In [3]: type(data)
Out[3]: <class 'numpy.ndarray'>
In [4]: data
Out[4]: array([[1, 2],
               [3, 4],
               [5, 6]])
In [5]: data.ndim
Out[5]: 2
In [6]: data.shape
Out[6]: (3, 2)
In [7]: data.size
Out[7]: 6
In [8]: data.dtype
Out[8]: dtype('int64')
In [9]: data.nbytes
Out[9]: 48

```

这里的`ndarray`实例`data`是使用函数`np.array`从嵌套的 Python 列表中创建的。本章稍后将介绍更多从数据和各种规则中创建`ndarray`实例的方法。在前面的示例中，数据是一个形状为 3 × 2 的二维数组(`data.ndim`)，如`data.shape`所示，总共包含六个类型为`int64` ( `data.dtype`)的元素(`data.size`)，总大小为 48 个字节(`data.nbytes`)。

### 数据类型

在上一节中，我们遇到了`ndarray`对象的`dtype`属性。这个属性描述了数组中每个元素的数据类型(记住，因为 NumPy 数组是同构的，所以所有元素都有相同的数据类型)。NumPy 支持的基本数值数据类型如表 [2-2](#Tab2) 所示。还支持非数字数据类型，如字符串、对象和用户定义的复合类型。

表 2-2

NumPy 中可用的基本数字数据类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

类型

 | 

变体

 | 

描述

 |
| --- | --- | --- |
| `int` | `int8, int16, int32, int64` | 整数 |
| `uint` | `uint8, uint16, uint32, uint64` | 无符号(非负)整数 |
| `bool` | `Bool` | 布尔型(真或假) |
| `float` | `float16, float32, float64, float128` | 浮点数 |
| `complex` | `complex64, complex128, complex256` | 复数浮点数 |

对于数字工作，最重要的数据类型是`int`(整数)、`float`(浮点数)和`complex`(复数浮点数)。每种数据类型都有不同的大小，比如`int32`代表 32 位整数，`int64`代表 64 位整数，等等。这提供了比标准 Python 类型更细粒度的数据类型控制，标准 Python 类型只提供一种整数类型和一种浮点类型。通常不需要显式选择要使用的数据类型的位大小，但通常需要显式选择是使用整数数组、浮点数数组还是复数值数组。

以下示例演示了如何使用`dtype`属性生成整型、浮点型和复数值元素的数组:

```py
In [10]: np.array([1, 2, 3], dtype=np.int)
Out[10]: array([1, 2, 3])
In [11]: np.array([1, 2, 3], dtype=np.float)
Out[11]: array([ 1.,  2.,  3.])
In [12]: np.array([1, 2, 3], dtype=np.complex)
Out[12]: array([ 1.+0.j,  2.+0.j,  3.+0.j])

```

一旦 NumPy 数组被创建，它的`dtype`就不能被改变，除非用类型转换数组值创建一个新的副本。对数组进行类型转换很简单，可以使用`np.array`函数:

```py
In [13]: data = np.array([1, 2, 3], dtype=np.float)
In [14]: data
Out[14]: array([ 1.,  2.,  3.])
In [15]: data.dtype
Out[15]: dtype('float64')
In [16]: data = np.array(data, dtype=np.int)
In [17]: data.dtype
Out[17]: dtype('int64')
In [18]: data
Out[18]: array([1, 2, 3])

```

或者通过使用`ndarray`类的`astype`方法:

```py
In [19]: data = np.array([1, 2, 3], dtype=np.float)
In [20]: data
Out[20]: array([ 1.,  2.,  3.])
In [21]: data.astype(np.int)
Out[21]: array([1, 2, 3])

```

当使用 NumPy 数组进行计算时，如果操作需要，数据类型可能会从一种类型提升到另一种类型。例如，将浮点值和复数值数组相加，得到的数组是一个复数值数组:

```py
In [22]: d1 = np.array([1, 2, 3], dtype=float)
In [23]: d2 = np.array([1, 2, 3], dtype=complex)
In [24]: d1 + d2
Out[24]: array([ 2.+0.j,  4.+0.j,  6.+0.j])
In [25]: (d1 + d2).dtype
Out[25]: dtype('complex128')

```

在某些情况下，根据应用程序及其需求，创建数据类型适当设置为`int`或`complex`的数组是很重要的。默认类型是`float`。考虑下面的例子:

```py
In [26]: np.sqrt(np.array([-1, 0, 1]))
Out[26]: RuntimeWarning: invalid value encountered in sqrt
         array([ nan,   0.,   1.])
In [27]: np.sqrt(np.array([-1, 0, 1], dtype=complex))
Out[27]: array([ 0.+1.j,  0.+0.j,  1.+0.j])

```

这里，使用`np.sqrt`函数计算数组中每个元素的平方根，根据数组的数据类型给出不同的结果。只有当数组的数据类型为`complex`时，`–1`的平方根才产生虚数单位(在 Python 中表示为`1j`)。

#### 实部和虚部

不管`dtype`属性的值是多少，所有 NumPy 数组实例都有属性`real`和`imag`，分别用于提取数组的实部和虚部:

```py
In [28]: data = np.array([1, 2, 3], dtype=complex)
In [29]: data
Out[29]: array([ 1.+0.j,  2.+0.j,  3.+0.j])
In [30]: data.real
Out[30]: array([ 1.,  2.,  3.])
In [31]: data.imag
Out[31]: array([ 0.,  0.,  0.])

```

函数`np.real`和`np.imag`也提供了相同的功能，它们也可以应用于其他类似数组的对象，比如 Python 列表。注意 Python 本身支持复数，并且`imag`和`real`属性也可用于 Python 标量。

### 内存中数组数据的顺序

多维数组作为连续数据存储在内存中。可以自由选择如何在这个内存段中排列数组元素。考虑包含行和列的二维数组的情况:将该数组存储为连续的值序列的一种可能方法是一个接一个地存储行，另一种同样有效的方法是一个接一个地存储列。前者称为行主格式，后者称为列主格式。使用行为主还是列为主是一个约定问题，例如，在 C 编程语言中使用行为主的格式，而 Fortran 使用列为主的格式。当数组被创建或改变形状时，可以使用关键字参数`order= 'C'`将 NumPy 数组指定为以行为主的格式存储，并使用关键字参数`order= 'F'`以列为主的格式存储。默认格式是主要行。当 NumPy 数组用于用 C 和 Fortran 编写的软件接口时，NumPy 数组的`'C'`或`'F'`排序特别重要，这在使用 Python 进行数值计算时经常需要。

行优先和列优先排序是将用于寻址元素的索引映射到数组内存段中该元素的偏移量的策略的特例。一般来说，NumPy 数组属性`ndarray.strides`定义了映射是如何完成的。`strides`属性是一个长度与数组的轴(维度)数相同的元组。在计算给定索引表达式的内存偏移量(以字节为单位)时，`strides`中的每个值都是对应轴的索引所乘以的因子。

例如，考虑一个形状为`(2, 3)`的 C-order 数组`A`，它对应于一个二维数组，在第一个和第二个维度上分别有两个和三个元素。如果数据类型是`int32`，那么每个元素使用 4 个字节，因此数组的总内存缓冲区使用 2 × 3 × 4 = 24 个字节。因此这个数组的`strides`属性是(4 × 3，4 × 1) = (12，4)，因为`A[n, m]`中的`m`每增加一个，内存偏移量就增加一项，即 4 个字节。同样地，`n`的每一个增量都会增加三个项目或 12 个字节的内存偏移量(因为数组的第二维长度为 3)。另一方面，如果相同的数组以`'F'`的顺序存储，`strides`将改为`(4, 8)`。使用跨距来描述数组索引到数组内存偏移量的映射是很聪明的，因为它可以用来描述不同的映射策略，并且数组上的许多常见操作，例如转置，可以通过简单地改变`strides`属性来实现，这可以消除在内存中移动数据的需要。只需要更改`strides`属性的操作会导致新的`ndarray`对象引用与原始数组相同的数据。这样的数组称为视图。为了提高效率，在对数组应用操作时，NumPy 努力创建视图而不是副本。这通常是一件好事，但是需要注意的是，一些数组操作会产生视图而不是新的独立数组，因为修改它们的数据也会修改原始数组的数据。在本章的后面，我们将看到这种行为的几个例子。

## 创建数组

在上一节中，我们看了 NumPy 表示数组的基本数据结构，即`ndarray`类，我们还看了这个类的基本属性。在这一节中，我们关注 NumPy 库中可用于创建`ndarray`实例的函数。

数组可以通过多种方式生成，这取决于它们的属性和它们的应用。例如，正如我们在上一节中看到的，初始化`ndarray`实例的一种方法是在 Python 列表上使用`np.array`函数，例如，它可以被显式定义。但是，这种方法显然仅限于小数组。在许多情况下，有必要生成具有遵循某种给定规则的元素的数组，例如填充常数值、递增整数、均匀间隔数、随机数等。在其他情况下，我们可能需要从存储在文件中的数据创建数组。需求是多种多样的，NumPy 库提供了一套全面的函数来生成各种类型的数组。在本节中，我们将更详细地了解其中的许多功能。要获得完整的列表，请参阅 NumPy 参考手册或通过键入`help(np)`或使用自动补全功能`np.<TAB>`获得的文档字符串。表 [2-3](#Tab3) 总结了常用的数组生成函数。

表 2-3

用于生成数组的 NumPy 函数概述

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

函数名

 | 

数组类型

 |
| --- | --- |
| `np.array` | 创建一个数组，其元素由一个类似数组的对象给出，例如，可以是一个(嵌套)Python 列表、一个元组、一个可迭代序列或另一个`ndarray`实例。 |
| `np.zeros` | 用指定的维度和数据类型创建一个用零填充的数组。 |
| `np.ones` | 创建一个具有指定维度和数据类型的数组，并用 1 填充。 |
| `np.diag` | 创建一个对角线数组，沿对角线指定值，其他地方为零。 |
| `np.arange` | 创建一个数组，其值在指定的起始值、结束值和增量值之间均匀分布。 |
| `np.linspace` | 使用指定数量的元素创建一个数组，该数组的值在指定的开始值和结束值之间均匀分布。 |
| `np.logspace` | 创建一个数组，数组中的值在给定的起始值和结束值之间以对数间隔排列。 |
| `np.meshgrid` | 从一维坐标向量生成坐标矩阵(和更高维的坐标数组)。 |
| `np.fromfunction` | 创建一个数组并用给定函数指定的值填充该数组，该函数针对给定数组大小的每个索引组合进行计算。 |
| `np.fromfile` | 用二进制(或文本)文件中的数据创建一个数组。NumPy 还提供了一个相应的函数`np.tofile`，通过这个函数可以将 NumPy 数组存储到磁盘中，并在以后使用`np.fromfile`读回。 |
| `np.genfromtxt,np.loadtxt` | 根据从文本文件(例如，逗号分隔值(CSV)文件)中读取的数据创建数组。函数`np.genfromtxt`也支持带有缺失值的数据文件。 |
| `np.random.rand` | 用均匀分布在 0 和 1 之间的随机数生成数组。其他类型的分布也可在`np.random`模块中获得。 |

### 从列表和其他类似数组的对象创建的数组

使用`np.array`函数，可以从显式 Python 列表、可迭代表达式和其他类似数组的对象(比如其他`ndarray`实例)中构造 NumPy 数组。例如，要从 Python 列表创建一维数组，我们只需将 Python 列表作为参数传递给`np.array`函数:

```py
In [32]: np.array([1, 2, 3, 4])
Out[32]: array([ 1,  2,  3, 4])
In [33]: data.ndim
Out[33]: 1
In [34]: data.shape
Out[34]: (4,)

```

要创建一个与前一个示例中的数据相同的二维数组，我们可以使用嵌套的 Python 列表:

```py
In [35]: np.array([[1, 2], [3, 4]])
Out[35]: array([[1,  2],
              [3, 4]])
In [36]: data.ndim
Out[36]: 2
In [37]: data.shape
Out[37]: (2, 2)

```

### 用常数值填充的数组

函数`np.zeros`和`np.ones`分别创建和返回填充了 0 和 1 的数组。它们接受一个整数或元组作为第一个参数，这个整数或元组描述了数组中每个维度上的元素数量。例如，要创建一个用 0 填充的 2 × 3 数组和一个用 1 填充的长度为 4 的数组，我们可以使用

```py
In [38]: np.zeros((2, 3))
Out[38]: array([[ 0.,  0.,  0.],
                [ 0.,  0.,  0.]])
In [39]: np.ones(4)
Out[39]: array([ 1.,  1.,  1., 1.])

```

像其他生成数组的函数一样，`np.zeros`和`np.ones`函数也接受一个可选的关键字参数，该参数指定数组中元素的数据类型。默认情况下，数据类型是`float64`，可以通过显式指定`dtype`参数将其更改为所需的类型。

```py
In [40]: data = np.ones(4)
In [41]: data.dtype
Out[41]: dtype('float64')
In [42]: data = np.ones(4, dtype=np.int64)
In [43]: data.dtype
Out[43]: dtype('int64')

```

通过首先创建一个用 1 填充的数组，然后将该数组乘以所需的填充值，可以生成用任意常数值填充的数组。然而，NumPy 也提供了一个函数`np.full`,它一步就完成了这个任务。下面两种构造具有 10 个元素的数组的方法，在这个例子中被初始化为数值 5.4，产生相同的结果，但是使用`np.full`稍微更有效，因为它避免了乘法。

```py
In [44]: x1 = 5.4 * np.ones(10)
In [45]: x2 = np.full(10, 5.4)

```

已经创建的数组也可以使用`np.fill`函数填充常量值，该函数将数组和值作为参数，并将数组中的所有元素设置为给定值。因此，以下两种创建数组的方法会产生相同的结果:

```py
In [46]: x1 = np.empty(5)
In [47]: x1.fill(3.0)
In [48]: x1
Out[48]: array([ 3.,  3.,  3.,  3.,  3.])
In [49]: x2 = np.full(5, 3.0)
In [50]: x2
Out[50]: array([ 3.,  3.,  3.,  3.,  3.])

```

在最后一个例子中，我们还使用了`np.empty`函数，它生成了一个具有给定大小的未初始化值的数组。只有当所有元素的初始化可以通过其他方式保证时，才应该使用此函数，例如通过数组元素的显式循环或其他显式赋值。本章稍后将更详细地介绍该功能。

### 用增量序列填充的数组

在数值计算中，要求数组在起始值和结束值之间具有均匀间隔的值是很常见的。NumPy 提供了两个类似的函数来创建这样的数组:`np.arange`和`np.linspace`。这两个函数都有三个参数，其中前两个参数是起始值和结束值。`np.arange`的第三个参数是增量，而对于`np.linspace`来说，它是数组中的总点数。

例如，要生成值在 1 到 10 之间、增量为 1 的数组，我们可以使用以下任一方法:

```py
In [51]: np.arange(0.0, 10, 1)
Out[51]: array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])
In [52]: np.linspace(0, 10, 11)
Out[52]: array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.,  10.])

```

然而，注意`np.arange`不包括结束值(10)，而默认情况下`np.linspace`包括(尽管这种行为可以使用可选的`endpoint`关键字参数来改变)。使用`np.arange`还是`np.linspace`主要是个人喜好的问题，但一般推荐在增量为非整数时使用`np.linspace`。

### 用对数序列填充的数组

函数`np.logspace`与`np.linspace`类似，但是数组中元素之间的增量是对数分布的，前两个参数(起始值和结束值)是可选的`base`关键字参数的幂(默认为 10)。例如，要生成 1 到 100 之间的对数分布值的数组，我们可以使用

```py
In [53]: np.logspace(0, 2, 5)  # 5 data points between 10**0=1 to 10**2=100
Out[53]: array([ 1\. , 3.16227766, 10\. , 31.6227766 , 100.])

```

### 网格阵列

使用函数`np.meshgrid`可以生成多维坐标网格。给定两个一维坐标数组(即包含一组沿给定维度的坐标的数组)，我们可以使用`np.meshgrid`函数生成二维坐标数组。下面的例子说明了这一点:

```py
In [54]: x = np.array([-1, 0, 1])
In [55]: y = np.array([-2, 0, 2])
In [56]: X, Y = np.meshgrid(x, y)
In [57]: X
Out[57]: array([[-1,  0,  1],
                [-1,  0,  1],
                [-1,  0,  1]])
In [58]: Y
Out[58]: array([[-2, -2, -2],
                [ 0,  0,  0],
                [ 2,  2,  2]])

```

二维坐标数组的一个常见用例，如本例中的`X`和`Y`，是对两个变量 *x* 和 *y* 的函数求值。这可用于绘制两个变量的函数，如色彩图和等高线图。例如，为了计算上一节中来自`x`和`y`数组的值的所有组合的表达式(*x*+*y*)<sup>2</sup>，我们可以使用二维坐标数组`X`和`Y`:

```py
In [59]: Z = (X + Y) ** 2
In [60]: Z
Out[60]: array([[9, 4, 1],
                [1, 0, 1],
                [1, 4, 9]])

```

还可以通过将更多的数组作为参数传递给`np.meshgrid`函数来生成更高维的坐标数组。或者，函数`np.mgrid`和`np.ogrid`也可以用来生成坐标数组，使用稍微不同的基于索引和切片对象的语法。有关详细信息，请参阅它们的 docstrings 或 NumPy 文档。

### 创建未初始化的数组

要创建一个特定大小和数据类型的数组，但不需要将数组中的元素初始化为任何特定的值，我们可以使用函数`np.empty`。例如，使用这个函数而不是`np.zeros`(它创建一个用零值元素初始化的数组)的优点是，我们可以避免初始化步骤。如果所有元素都保证在代码的后面被初始化，这可以节省一点时间，特别是在处理大型数组时。为了说明`np.empty`函数的用法，考虑下面的例子:

```py
In [61]: np.empty(3, dtype=np.float)
Out[61]: array([  1.28822975e-231,   1.28822975e-231,   2.13677905e-314])

```

这里我们生成了一个新的数组，包含三个 float 类型的元素。不能保证这些元素有任何特定的值，实际值会随时变化。因此，在使用数组之前显式分配所有值非常重要；否则很可能会出现不可预测的错误。通常情况下，`np.zeros`函数是`np.empty`更安全的替代方法，如果性能增益不是必需的，那么最好使用`np.zeros,`来最小化由于`np.empty`返回的数组中未初始化的值而导致的微妙且难以重现的错误的可能性。

### 使用其他数组的属性创建数组

通常需要创建与另一个数组共享属性(如形状和数据类型)的新数组。NumPy 为此提供了一系列函数:`np.ones_like`、`np.zeros_like`、`np.full_like`和`np.empty_like`。一个典型的用例是一个函数，它将未指定类型和大小的数组作为参数，并需要相同大小和类型的工作数组。例如，以下函数中给出了这种情况的样板示例:

```py
def f(x):
    y = np.ones_like(x)
    # compute with x and y
    return y

```

在这个函数体的第一行，使用`np.ones_like`创建了一个新的数组`y`，这个数组的大小和数据类型与`x`相同，并且填充了 1。

### 创建矩阵阵列

矩阵或二维数组是数值计算的一个重要例子。NumPy 提供了生成常用矩阵的函数。具体来说，函数`np.identity`生成一个对角线上为 1，其他地方为 0 的方阵:

```py
In [62]: np.identity(4)
Out[62]: array([[ 1.,  0.,  0.,  0.],
                [ 0.,  1.,  0.,  0.],
                [ 0.,  0.,  1.,  0.],
                [ 0.,  0.,  0.,  1.]])

```

类似的函数`numpy.eye`生成对角线上有 1 的矩阵(可选偏移)。下面的示例说明了这一点，该示例生成的矩阵中，非零对角线分别位于对角线的上方和下方:

```py
In [63]: np.eye(3, k=1)
Out[63]: array([[ 0.,  1.,  0.],
                [ 0.,  0.,  1.],
                [ 0.,  0.,  0.]])

In [64]: np.eye(3, k=-1)
Out[64]: array([[ 0.,  0.,  0.],
                [ 1.,  0.,  0.],
                [ 0.,  1.,  0.]])

```

要在对角线上构建一个具有任意一维数组的矩阵，我们可以使用`np.diag`函数(它也使用可选的关键字参数`k`来指定从对角线的偏移量)，如下所示:

```py
In [65]: np.diag(np.arange(0, 20, 5))
Out[65]: array([[0,  0,  0,  0],
                [0,  5,  0,  0],
                [0,  0, 10,  0],
                [0,  0,  0, 15]])

```

这里我们给了函数`np.arange`第三个参数，它指定了函数返回的数组中元素枚举的步长。因此，得到的数组包含值[0，5，10，15]，这些值通过`np.diag`函数插入到二维矩阵的对角线上。

## 索引和切片

NumPy 数组的元素和子数组使用标准的方括号符号来访问，该符号也用于 Python 列表。在方括号中，各种不同的索引格式用于不同类型的元素选择。通常，括号中的表达式是一个元组，其中元组中的每一项都是从数组的每个轴(维度)中选择哪些元素的规范。

### 一维数组

沿着单个轴，整数用于选择单个元素，所谓的切片用于选择元素的范围和序列。正整数用于从数组的开头对元素进行索引(索引从 0 开始)，负整数用于从数组的结尾对元素进行索引，其中最后一个元素用–1 进行索引，倒数第二个元素用–2 进行索引，依此类推。

切片是使用:符号指定的，该符号也用于 Python 列表。在这种表示法中，可以使用类似 m:n 的表达式来选择一系列元素，该表达式选择以 *m* 开始并以*n*1 结束的元素(注意不包括第 *n* 个元素)。片 m:n 也可以更明确地写成 m : n : 1，其中数字 1 指定应该选择在 *m* 和 *n* 之间的每个元素。要选择在 *m* 和 *n* 之间的每隔一个元素，使用 m : n : 2，要选择每隔 *p* 个元素，使用 m : n : p，依此类推。如果 *p* 为负，则元素以从 *m* 到 *n* +1 的逆序返回(这意味着 *m* 在这种情况下必须大于 *n* )。NumPy 数组的索引和切片操作总结见表 [2-4](#Tab4) 。

表 2-4

数组索引和切片表达式的示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

表示

 | 

描述

 |
| --- | --- |
| `a[m]` | 选择索引为 *m* 的元素，其中 *m* 为整数(从 0 开始计数)。 |
| `a[-m]` | 从列表末尾选择第 *n* 个元素，其中 *n* 为整数。列表中的最后一个元素的地址为–1，倒数第二个元素的地址为–2，依此类推。 |
| `a[m:n]` | 选择索引从 *m* 开始到*n*1 结束的元素( *m* 和 *n* 为整数)。 |
| `a[:] or a[0:-1]` | 选择给定轴中的所有元素。 |
| `a[:n]` | 从索引 0 开始选择元素，一直到索引*n*1(整数)。 |
| `a[m:] or a[m:-1]` | 选择元素，从索引 *m* (整数)开始，一直到数组中的最后一个元素。 |
| `a[m:n:p]` | 选择索引为 *m* 到 *n* (不含)的元素，增量为 *p* 。 |
| `a[::-1]` | 以相反的顺序选择所有元素。 |

以下示例演示 NumPy 数组的索引和切片操作。首先，考虑一个具有单轴(维度)的数组，该数组包含一个 0 到 10 之间的整数序列:

```py
In [66]: a = np.arange(0, 11)
In [67]: a
Out[67]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])

```

请注意，最终值 11 不包含在数组中。要从此数组中选择特定元素，例如第一个、最后一个和第五个元素，我们可以使用整数索引:

```py
In [68]: a[0]  # the first element
Out[68]: 0
In [69]: a[-1] # the last element
Out[69]: 10
In [70]: a[4]  # the fifth element, at index 4
Out[70]: 4

```

要选择一系列元素，比如从第二个到倒数第二个元素，分别选择每个元素和每隔一个元素，我们可以使用索引片:

```py
In [71]: a[1:-1]
Out[71]: array([1, 2, 3, 4, 5, 6, 7, 8, 9])
In [72]: a[1:-1:2]
Out[72]: array([1, 3, 5, 7, 9])

```

为了从一个数组中选择前五个和后五个元素，我们可以使用切片:5 和–5:，因为如果在 m:n 中省略了`m`或`n`，那么缺省值分别是数组的开头和结尾。

```py
In [73]: a[:5]
Out[73]: array([0, 1, 2, 3, 4])
In [74]: a[-5:]
Out[74]: array([6, 7, 8, 9, 10])

```

要反转数组并仅选择每第二个值，我们可以使用 slice `::-2`，如下例所示:

```py
In [75]: a[::-2]
Out[75]: array([10,  8,  6,  4,  2,  0]) 

```

### 多维数组

对于多维数组，可以在每个轴(维度)上应用类似于上一节中介绍的元素选择。结果是一个简化的数组，其中每个元素都匹配给定的选择规则。作为一个具体的例子，考虑下面的二维数组:

```py
In [76]: f = lambda m, n: n + 10 * m
In [77]: A = np.fromfunction(f, (6, 6), dtype=int)
In [78]: A
Out[78]: array([[ 0,  1,  2,  3,  4,  5],
                [10, 11, 12, 13, 14, 15],
                [20, 21, 22, 23, 24, 25],
                [30, 31, 32, 33, 34, 35],
                [40, 41, 42, 43, 44, 45],
                [50, 51, 52, 53, 54, 55]])

```

我们可以使用切片和整数索引的组合从这个二维数组中提取列和行:

```py
In [79]: A[:, 1]  # the second column
Out[79]: array([ 1, 11, 21, 31, 41, 51])
In [80]: A[1, :]  # the second row
Out[80]: array([10, 11, 12, 13, 14, 15])

```

通过在每个阵列轴上应用切片，我们可以提取子阵列(在这个二维示例中是子矩阵):

```py
In [81]: A[:3, :3]  # upper half diagonal block matrix
Out[81]: array([[ 0,  1,  2],
                [10, 11, 12],
                [20, 21, 22]])
In [82]: A[3:, :3]  # lower left off-diagonal block matrix
Out[82]: array([[30, 31, 32],
                [40, 41, 42],
                [50, 51, 52]])

```

元素间距不为 1 时，可以提取由不连续元素组成的子矩阵:

```py
In [83]: A[::2, ::2]  # every second element starting from 0, 0
Out[83]: array([[ 0,  2,  4],
                [20, 22, 24],
                [40, 42, 44]])
In [84]: A[1::2, 1::3]  # every second and third element starting from 1, 1
Out[84]: array([[11, 14],
                [31, 34],
                [51, 54]])

```

这种从多维数组中提取数据子集的能力是许多数据处理应用程序的一个简单但非常强大的功能。

### 视图

使用切片操作从数组中提取的子数组是同一底层数组数据的可选*视图*。也就是说，它们是引用内存中与原始数组相同的数据的数组，但是具有不同的`strides`配置。当视图中的元素被赋予新值时，原始数组的值也随之更新。举个例子，

```py
In [85]: B = A[1:5, 1:5]
In [86]: B
Out[86]: array([[11, 12, 13, 14],
                [21, 22, 23, 24],
                [31, 32, 33, 34],
                [41, 42, 43, 44]])
In [87]: B[:, :] = 0
In [88]: A
Out[88]: array([[ 0,  1,  2,  3,  4,  5],
                [10,  0,  0,  0,  0, 15],
                [20,  0,  0,  0,  0, 25],
                [30,  0,  0,  0,  0, 35],
                [40,  0,  0,  0,  0, 45],
                [50, 51, 52, 53, 54, 55]])

```

在这里，给数组`B`中的元素赋值，数组`B`是从数组`A`中创建的，也会修改`A`中的值(因为两个数组引用内存中相同的数据)。提取子阵列产生视图而不是新的独立阵列的事实消除了复制数据的需要并提高了性能。当需要副本而不是视图时，可以通过使用`ndarray`实例的`copy`方法显式地复制视图。

```py
In [89]: C = B[1:3, 1:3].copy()
In [90]: C
Out[90]: array([[0, 0],
                [0, 0]])
In [91]: C[:, :] = 1  # this does not affect B since C is a copy of the view B[1:3, 1:3]
In [92]: C
Out[92]: array([[1, 1],
                [1, 1]])
In [93]: B
Out[93]: array([[0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]])

```

除了`ndarray`类的`copy`属性之外，还可以使用函数`np.copy`或者等价地，使用带有关键字参数`copy=True`的`np.array`函数来复制数组。

### 花式索引和布尔值索引

在前一节中，我们研究了用整数和片索引 NumPy 数组，以提取单个元素或元素范围。NumPy 提供了另一种方便的索引数组的方法，称为花式索引。使用花式索引，一个数组可以用另一个 NumPy 数组、Python 列表或整数序列进行索引，它们的值选择索引数组中的元素。为了阐明这个概念，考虑下面的例子:我们首先创建一个具有 11 个浮点数的 NumPy 数组，然后用另一个 NumPy 数组(和 Python 列表)索引该数组，从原始数组中提取元素号 0、2 和 4:

```py
In [94]: A = np.linspace(0, 1, 11)
Out[94]: array([ 0\. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1\. ])
In [95]: A[np.array([0, 2, 4])]
Out[95]: array([ 0\. ,  0.2,  0.4])
In [96]: A[[0, 2, 4]]  # The same thing can be accomplished by indexing with a Python list
Out[96]: array([ 0\. ,  0.2,  0.4])

```

这种索引方法可以沿着多维 NumPy 数组的每个轴(维度)使用。它要求用于索引的数组或列表中的元素是整数。

索引 NumPy 数组的另一种变体是使用布尔值索引数组。在这种情况下，每个元素(值为 True 或 False)指示是否从列表中选择具有相应索引的元素。也就是说，如果布尔值的索引数组中的元素 *n* 为`True`，则从索引数组中选择元素 *n* 。如果值为`False`，则不选择元素 *n* 。从数组中过滤出元素时，这种索引方法非常方便。例如，要从数组`A`(如前一节所定义)中选择值超过 0.5 的所有元素，我们可以使用以下应用于 NumPy 数组的比较运算符和使用布尔值数组的索引的组合:

```py
In [97]: A > 0.5
Out[97]: array([False, False, False, False, False, False, True, True, True, True, True], dtype=bool)
In [98]: A[A > 0.5]
Out[98]: array([ 0.6,  0.7,  0.8,  0.9,  1\. ])

```

与使用切片创建的数组不同，使用花式索引和布尔值索引返回的数组不是视图，而是新的独立数组。尽管如此，还是可以使用高级索引为选择的元素赋值:

```py
In [99]: A = np.arange(10)
In [100]: indices = [2, 4, 6]
In [101]: B = A[indices]
In [102]: B[0] = -1  # this does not affect A
In [103]: A
Out[103]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
In [104]: A[indices] = -1  # this alters A
In [105]: A
Out[105]: array([ 0,  1, -1,  3, -1,  5, -1,  7,  8,  9])

```

同样，对于布尔值索引:

```py
In [106]: A = np.arange(10)
In [107]: B = A[A > 5]
In [108]: B[0] = -1  # this does not affect A
In [109]: A
Out[109]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
In [110]: A[A > 5] = -1  # this alters A

In [111]: A
Out[111]: array([ 0,  1,  2,  3,  4,  5, -1, -1, -1, -1])

```

图 [2-1](#Fig1) 给出了索引 NumPy 数组的不同方法的直观总结。请注意，我们在此讨论的每种索引类型都可以独立应用于数组的每个维度。

![img/332789_2_En_2_Chapter/332789_2_En_2_Fig1_HTML.png](img/332789_2_En_2_Chapter/332789_2_En_2_Fig1_HTML.png)

图 2-1

NumPy 数组索引方法的可视化总结。这些图表示形状为(4，4)的 NumPy 数组，突出显示的元素是使用数组的块表示上方所示的索引表达式选择的元素。

## 调整形状和大小

当处理数组形式的数据时，重新排列数组并改变它们的解释方式通常很有用。例如，一个 *N* × *N* 的矩阵数组可以被重新排列成一个长度为 *N* <sup>2</sup> 的向量，或者一组一维数组可以被连接在一起或者彼此相邻堆叠以形成一个矩阵。NumPy 为这种类型的操作提供了丰富的函数集。这些功能的选择汇总见表 [2-5](#Tab5) 。

表 2-5

用于处理数组尺寸和形状的 NumPy 函数概要

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能/方法

 | 

描述

 |
| --- | --- |
| `np.reshape,``np.ndarray.reshape` | 重塑一个 N 维数组。元素的总数必须保持不变。 |
| `np.ndarray.flatten` | 创建一个 N 维数组的副本，并将其重新解释为一维数组(即所有维度都折叠成一个)。 |
| `np.ravel,``np.ndarray.ravel` | 创建一个 N 维数组的视图(如果可能的话，创建一个副本),在其中它被解释为一维数组。 |
| `np.squeeze` | 删除长度为 1 的轴。 |
| `np.expand_dims, np.newaxis` | 将长度为 1 的新轴(维度)添加到数组中，其中`np.newaxis`用于数组索引。 |
| `np.transpose,``np.ndarray.transpose, np.ndarray.T` | 转置数组。转置操作对应于反转(或者更一般地，置换)阵列的轴。 |
| `np.hstack` | 水平堆叠一个数组列表(沿轴 1):例如，给定一个列向量列表，追加列以形成一个矩阵。 |
| `np.vstack` | 垂直堆叠数组列表(沿 0 轴):例如，给定一个行向量列表，追加行以形成一个矩阵。 |
| `np.dstack` | 沿深度方向(沿轴 2)堆叠数组。 |
| `np.concatenate` | 通过沿给定轴依次追加数组来创建新数组。 |
| `np.resize` | 调整数组大小。以请求的大小创建原始数组的新副本。如果需要，原始数组将被重复以填充新数组。 |
| `np.append` | 向数组追加一个元素。创建数组的新副本。 |
| `np.insert` | 在给定位置插入新元素。创建数组的新副本。 |
| `np.delete` | 删除给定位置的元素。创建数组的新副本。 |

重塑数组不需要修改底层数组数据；它只是通过重新定义数组的`strides`属性来改变数据的解释方式。这种操作的一个例子是 2 × 2 数组(矩阵)，它被重新解释为 1 × 4 数组(向量)。在 NumPy 中，函数`np.reshape`或`ndarray`类方法`reshape`可以用来重新配置底层数据的解释方式。它接受一个数组和数组的新形状作为参数:

```py
In [112]: data = np.array([[1, 2], [3, 4]])
In [113]: np.reshape(data, (1, 4))
Out[113]: array([[1, 2, 3, 4]])
In [114]: data.reshape(4)
Out[114]: array([1, 2, 3, 4])

```

请求的新数组形状必须与原始大小的元素数量相匹配。然而，轴的数量(维度)不需要保持不变，如前一示例所示，其中在第一种情况下，新数组具有维度`2`和形状`(1, 4)`，而在第二种情况下，新数组具有维度`1`和形状`4,)`。这个例子还演示了调用整形操作的两种不同方式:使用函数`np.reshape`和`ndarray`方法`reshape`。注意，对数组进行整形会产生数组的视图，如果需要数组的独立副本，则必须显式地复制视图(例如，使用`np.copy`)。

`np.ravel`(及其对应的`ndarray`方法)是 reshape 的一个特例，它折叠数组的所有维度，并返回一个长度对应于原始数组中元素总数的扁平一维数组。`ndarray`方法`flatten`执行相同的功能，但是返回副本而不是视图。

```py
In [115]: data = np.array([[1, 2], [3, 4]])
In [116]: data
Out[116]: array([[1, 2],
                 [3, 4]])
In [117]: data.flatten()
Out[117]: array([ 1,  2,  3,  4])
In [118]: data.flatten().shape
Out[118]: (4,)

```

虽然`np.ravel`和`np.flatten`将一个数组的轴折叠成一维数组，但是也可以通过使用`np.reshape`或者在添加新的空轴时，在新轴的位置使用索引符号和`np.newaxis`关键字，将新轴引入一个数组。在下面的例子中，数组数据有一个轴，所以通常应该用一个只有一个元素的元组来索引。然而，如果它是用具有不止一个元素的元组索引的，并且如果元组中的额外索引具有值`np.newaxis`，则相应的新轴被添加:

```py
In [119]: data = np.arange(0, 5)
In [120]: column = data[:, np.newaxis]
In [121]: column
Out[121]: array([[0],
                 [1],
                 [2],
                 [3],
                 [4]])
In [122]: row = data[np.newaxis, :]
In [123]: row
Out[123]: array([[0, 1, 2, 3, 4]])

```

函数`np.expand_dims`也可以用来给数组增加新的维度，在前面的例子中，表达式`data[:, np.newaxis]`等价于`np.expand_dims(data, axis=1),`，`data[np.newaxis, :]`等价于`np.expand_dims(data, axis=0)`。这里的`axis`参数指定了相对于现有轴的位置，新轴将插入该位置。

到目前为止，我们已经研究了以不影响底层数据的方式重新排列数组的方法。在本章的前面，我们还看了如何使用各种索引技术提取子数组。除了整形和选择子数组之外，通常还需要将数组合并到更大的数组中，例如，当将单独计算或测量的数据序列连接到更高维的数组(如矩阵)中时。对于这个任务，NumPy 提供了函数`np.vstack`，用于将例如行垂直堆叠成矩阵，并提供了函数`np.hstack`，用于将例如列水平堆叠成矩阵。函数`np.concatenate`提供了类似的功能，但是它采用了一个关键字参数`axis`，该参数指定了数组连接的轴。

传递给`np.hstack`、`np.vstack,`和`np.concatenate`的数组的形状对于实现所需类型的数组连接很重要。例如，考虑以下情况:假设我们有一维数据数组，我们希望将它们垂直堆叠以获得一个矩阵，其中的行由一维数组组成。我们可以使用`np.vstack`来实现这一点

```py
In [124]: data = np.arange(5)
In [125]: data
Out[125]: array([0, 1, 2, 3, 4])
In [126]: np.vstack((data, data, data))
Out[126]: array([[0, 1, 2, 3, 4],
                 [0, 1, 2, 3, 4],
                 [0, 1, 2, 3, 4]])

```

相反，如果我们想要水平堆叠数组，以获得一个矩阵，其中数组是列向量，我们可以首先尝试使用`np.hstack`进行类似的操作:

```py
In [127]: data = np.arange(5)
In [128]: data
Out[128]: array([0, 1, 2, 3, 4])
In [129]: np.hstack((data, data, data))
Out[129]: array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4])

```

这实际上是水平堆叠数组，但不是以这里预期的方式。为了让`np.hstack`将输入数组视为列并相应地进行堆叠，我们需要让输入数组成为形状为`(1, 5)`的二维数组，而不是形状为`(5,)`的一维数组。如前所述，我们可以通过使用`np.newaxis`索引来插入一个新轴:

```py
In [130]: data = data[:, np.newaxis]
In [131]: np.hstack((data, data, data))
Out[131]: array([[0, 0, 0],
                 [1, 1, 1],
                 [2, 2, 2],
                 [3, 3, 3],
                 [4, 4, 4]])

```

当堆叠的数组与最终数组具有相同的维数时，以及当输入数组沿长度为 1 的轴堆叠时，水平和垂直堆叠以及使用`np.concatenate`连接数组的函数行为最为清晰。

NumPy 数组中的元素数量一旦创建就无法更改。例如，要使用函数`np.append`、`np.insert`和`np.delete`在 NumPy 数组中插入、追加和删除元素，必须创建一个新的数组并将数据复制到其中。有时，使用这些函数来增大或缩小 NumPy 数组的大小可能很诱人，但是由于创建新数组和复制数据的开销，预先分配数组的大小通常是个好主意，这样以后就不需要调整它们的大小了。

## 矢量化表达式

在数组中存储数值数据的目的是为了能够用简洁的矢量化表达式处理数据，这些表达式表示应用于数组中所有元素的批处理操作。矢量化表达式的有效使用消除了许多显式`for`循环的需要。这导致了更少的冗长代码、更好的可维护性和更高性能的代码。NumPy 实现了与最基本的数学函数和运算符相对应的函数和矢量化运算。这些函数和操作中有许多是基于元素对数组进行操作的，而二进制操作要求表达式中的所有数组都具有兼容的大小。兼容大小的含义通常是表达式中的变量代表相同大小和形状的标量或数组。更一般地说，如果数组可以通过*传播*成相同的形状和大小，那么包含两个数组的二元运算就是定义良好的。

在标量和数组之间进行运算的情况下，广播是指标量被分发，运算应用于数组中的每个元素。当表达式包含大小不等的数组时，如果可以根据 NumPy 的广播规则广播(“有效扩展”)较小的数组以匹配较大的数组，则运算仍然可以很好地定义:如果一个数组的轴逐个具有相同的长度，或者如果它们中的任何一个的长度为 1，则可以在另一个数组上广播该数组。如果两个数组的轴数不相等，则轴数较少的数组从左侧开始用长度为 1 的新轴填充，直到两个数组的维数一致。

图 [2-2](#Fig2) 给出了两个简单的例子来说明数组广播:一个 3 × 3 的矩阵分别添加到一个 1 × 3 的行向量和一个 3 × 1 的列向量，在这两种情况下，结果都是一个 3 × 3 的矩阵。然而，两个结果矩阵中的元素是不同的，因为根据 NumPy 的广播规则，行和列向量的元素被广播到较大数组的形状的方式是不同的，这取决于数组的形状。

![img/332789_2_En_2_Chapter/332789_2_En_2_Fig2_HTML.png](img/332789_2_En_2_Chapter/332789_2_En_2_Fig2_HTML.png)

图 2-2

将行和列向量广播成矩阵形状的可视化。突出显示的元素表示数组的真实元素，而浅灰色阴影元素描述较小数组元素的广播。

### 算术运算

NumPy 数组的标准算术运算执行逐元素运算。例如，考虑大小相等的数组的加法、减法、乘法和除法:

```py
In [132]: x = np.array([[1, 2], [3, 4]])
In [133]: y = np.array([[5, 6], [7, 8]])
In [134]: x + y
Out[134]: array([[ 6,  8],
                 [10, 12]])
In [135]: y - x
Out[135]: array([[4, 4],
                 [4, 4]])
In [136]: x * y
Out[136]: array([[ 5, 12],
                 [21, 32]])
In [137]: y / x
Out[137]: array([[ 5\.        ,  3\.        ],
                 [ 2.33333333,  2\.        ]])

```

在标量和数组之间的运算中，标量值应用于数组中的每个元素，正如人们所料:

```py
In [138]: x * 2
Out[138]: array([[2, 4],
                 [6, 8]])
In [139]: 2 ** x
Out[139]: array([[ 2,  4],
                 [ 8, 16]])
In [140]: y / 2
Out[140]: array([[ 2.5,  3\. ],
                 [ 3.5,  4\. ]])
In [141]: (y / 2).dtype
Out[141]: dtype('float64')

```

请注意，如果计算需要，可以提升表达式的结果数组的`dtype`，如前面的整数数组和整数标量除法示例所示，在这种情况下，结果数组的`dtype`为`np.float64`。

如果对大小或形状不兼容的数组执行算术运算，则会引发`ValueError`异常:

```py
In [142]: x = np.array([1, 2, 3, 4]).reshape(2, 2)
In [143]: z = np.array([1, 2, 3, 4])
In [144]: x / z
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-144-b88ced08eb6a> in <module>()
----> 1 x / z
ValueError: operands could not be broadcast together with shapes (2,2) (4,)

```

此处数组`x`的形状为`(2, 2)`，数组`z`的形状为`(4,)`，无法以与`(2, 2)`兼容的形式传播。另一方面，如果`z`具有形状`(2,)`、`(2, 1)`或`(1, 2)`，那么它可以通过沿着长度为 1 的轴有效地重复阵列`z`而传播到形状`(2, 2)`。让我们首先考虑一个形状为`(1, 2)`的数组`z`的例子，其中第一个轴(轴 0)的长度为 1:

```py
In [145]: z = np.array([[2, 4]])
In [146]: z.shape
Out[146]: (1, 2)

```

用数组`z`除数组`x`等同于用数组`zz`除`x`，数组`zz`是通过重复(这里使用`np.concatenate`)行向量`z`来获得与`x`具有相同维数的数组`zz`而构建的:

```py
In [147]: x / z
Out[147]: array([[ 0.5,  0.5],
                 [ 1.5,  1\. ]])
In [148]: zz = np.concatenate([z, z], axis=0)
In [149]: zz
Out[149]: array([[2, 4],
                 [2, 4]])
In [150]: x / zz
Out[150]: array([[ 0.5,  0.5],
                 [ 1.5,  1\. ]])

```

让我们考虑这样一个例子，其中数组`z`的形状为`(2, 1)`，第二个轴(轴 1)的长度为 1:

```py
In [151]: z = np.array([[2], [4]])
In [152]: z.shape
Out[152]: (2, 1)

```

在这种情况下，用`z`除`x`相当于用一个数组`zz`除`x`，该数组是通过重复列向量`z`直到得到一个与`x`维数相同的矩阵而构造的。

```py
In [153]: x / z
Out[153]: array([[ 0.5 ,  1\.  ],
                 [ 0.75,  1\.  ]])
In [154]: zz = np.concatenate([z, z], axis=1)
In [155]: zz
Out[155]: array([[2, 2],
                 [4, 4]])
In [156]: x / zz
Out[156]: array([[ 0.5 ,  1\.  ],
                 [ 0.75,  1\.  ]])

```

总之，这些例子显示了当执行操作`x / z`时，形状为`(1, 2)`和`(2, 1)`的数组是如何传播到形状为`(2, 2)`的数组`x`的。在这两种情况下，操作`x / z`的结果与首先沿其长度为 1 的轴重复较小的数组`z`以获得与`x`形状相同的新数组`zz`，然后执行大小相等的数组操作`x / zz`相同。然而，广播的实现并不显式地执行这种扩展和相应的内存复制，但是从这些方面考虑数组广播是有帮助的。

表 [2-6](#Tab6) 中给出了 NumPy 数组算术运算的运算符总结。这些运算符使用 Python 中使用的标准符号。一个或两个数组的算术运算的结果是一个新的独立数组，在内存中有它自己的数据。因此，计算复杂的算术表达式可能会触发许多内存分配和复制操作，当使用大型数组时，这可能会导致大量内存占用并对性能产生负面影响。在这种情况下，使用就地操作(见表 [2-6](#Tab6) )可以减少内存占用并提高性能。作为 inplace 运算符的一个示例，考虑下面两个具有相同效果的语句:

表 2-6

NumPy 数组上按元素进行算术运算的运算符

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

操作员

 | 

操作

 |
| --- | --- |
| +, += | 添加 |
| -, -= | 减法 |
| *, *= | 增加 |
| /, /= | 分开 |
| //, //= | 整数除法 |
| **, **= | 指数运算 |

```py
In [157]: x = x + y
In [158]: x += y

```

这两个表达式具有相同的效果，但是在第一种情况下，`x`被重新分配给一个新的数组，而在第二种情况下，数组`x`的值被就地更新。大量使用 inplace 运算符会削弱代码的可读性，因此 inplace 运算符只应在必要时使用。

### 元素功能

除了使用运算符的算术表达式之外，NumPy 还为许多初等数学函数和运算的元素求值提供了矢量化函数。表 [2-7](#Tab7) 总结了 NumPy 中的基本数学函数。 <sup>[3](#Fn3)</sup> 这些函数中的每一个都将单个数组(任意维数)作为输入，并返回一个相同形状的新数组，其中对于每个元素，该函数都已应用于输入数组中的相应元素。输出数组的数据类型不一定与输入数组的数据类型相同。

表 2-7

初等数学函数中数值函数的选择

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

NumPy 函数

 | 

描述

 |
| --- | --- |
| `np.cos, np.sin, np.tan` | 三角函数。 |
| `np.arccos, np.arcsin, np.arctan` | 反三角函数。 |
| `np.cosh, np.sinh, np.tanh` | 双曲三角函数。 |
| `np.arccosh, np.arcsinh, np.arctanh` | 反双曲三角函数。 |
| `np.sqrt` | 平方根。 |
| `np.exp` | 指数增长。 |
| `np.log, np.log2, np.log10` | 分别以 e、2 和 10 为底的对数。 |

例如，`np.sin`函数(只有一个参数)用于计算数组中所有值的正弦函数:

```py
In [159]: x = np.linspace(-1, 1, 11)
In [160]: x
Out[160]: array([-1\. , -0.8, -0.6, -0.4, -0.2,  0\. ,  0.2,  0.4,  0.6,  0.8,  1.])
In [161]: y = np.sin(np.pi * x)
In [162]: np.round(y, decimals=4)
Out[162]: array([-0., -0.5878, -0.9511, -0.9511, -0.5878, 0., 0.5878, 0.9511, 0.9511, 0.5878, 0.])

```

这里我们还使用了常数`np.pi`和函数`np.round`将`y`的值四舍五入到四位小数。像`np.sin`函数一样，许多初等数学函数接受一个输入数组并产生一个输出数组。相比之下，许多数学运算符函数(表 [2-8](#Tab8) )对两个输入数组进行运算，返回一个数组:

表 2-8

元素式数学运算的 NumPy 函数概要

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

NumPy 函数

 | 

描述

 |
| --- | --- |
| `np.add, np.subtract, np.multiply, np.divide` | 两个 NumPy 数组的加、减、乘、除。 |
| `np.power` | 将第一个输入参数提升到第二个输入参数的幂(按元素应用)。 |
| `np.remainder` | 除法的余数。 |
| `np.reciprocal` | 每个元素的倒数。 |
| `np.real, np.imag, np.conj` | 输入数组中元素的实部、虚部和复共轭。 |
| `np.sign, np.abs` | 符号和绝对值。 |
| `np.floor, np.ceil, np.rint` | 转换为整数值。 |
| `np.round` | 舍入到给定的小数位数。 |

```py
In [163]: np.add(np.sin(x) ** 2, np.cos(x) ** 2)
Out[163]: array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])
In [164]: np.sin(x) ** 2 + np.cos(x) ** 2
Out[164]: array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])

```

注意，在这个例子中，`np.add`和操作符`+`是等价的，正常使用时应该使用操作符。

有时有必要定义新的函数，在 NumPy 数组上逐个元素地操作。实现这种函数的一个好方法是用已经存在的 NumPy 操作符和表达式来表达它，但是在这不可能的情况下，`np.vectorize`函数可能是一个方便的工具。此函数采用非向量化函数，并返回向量化函数。例如，考虑以下 Heaviside 阶跃函数的实现，它适用于标量输入:

```py
In [165]: def heaviside(x):
     ...:     return 1 if x > 0 else 0
In [166]: heaviside(-1)
Out[166]: 0
In [167]: heaviside(1.5)
Out[167]: 1

```

然而，不幸的是，这个函数不适用于 NumPy 数组输入:

```py
In [168]: x = np.linspace(-5, 5, 11)
In [169]: heaviside(x)
...
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()

```

使用`np.vectorize`,标量`Heaviside`函数可以转换成矢量化函数，该函数使用 NumPy 数组作为输入:

```py
In [170]: heaviside = np.vectorize(heaviside)
In [171]: heaviside(x)
Out[171]: array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])

```

虽然由`np.vectorize`返回的函数适用于数组，但它会相对较慢，因为必须为数组中的每个元素调用原始函数。有更好的方法来实现这个特殊的函数，使用布尔值数组的算术，正如本章后面所讨论的:

```py
In [172]: def heaviside(x):
     ...:     return 1.0 * (x > 0)

```

尽管如此，`np.vectorize`通常是对标量输入编写的函数进行矢量化的一种快捷方便的方法。

除了表 [2-7](#Tab7) 中总结的用于初等数学函数的 NumPy 函数之外，NumPy 中还有许多用于数学运算的函数。表 [2-8](#Tab8) 中给出了这些功能的选择汇总。

### 聚合函数

NumPy 提供了另一组用于计算 NumPy 数组聚合的函数，这些函数将数组作为输入，默认情况下返回一个标量作为输出。例如，输入数组中值的平均值、标准偏差和方差等统计数据，以及用于计算数组中元素的和与积的函数，都是聚合函数。

表 [2-9](#Tab9) 中给出了集合函数的汇总。所有这些函数也可以作为`ndarray`类中的方法使用。例如，以下示例中的`np.mean(data)`和`data.mean()`是等效的:

表 2-9

用于计算 NumPy 数组聚合的 NumPy 函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

NumPy 函数

 | 

描述

 |
| --- | --- |
| `np.mean` | 数组中所有值的平均值。 |
| `np.std` | 标准差。 |
| `np.var` | 方差。 |
| `np.sum` | 所有元素的总和。 |
| `np.prod` | 所有元素的乘积。 |
| `np.cumsum` | 所有元素的累积和。 |
| `np.cumprod` | 所有元素的累积积。 |
| `np.min, np.max` | 数组中的最小值/最大值。 |
| `np.argmin, np.argmax` | 数组中最小/最大值的索引。 |
| `np.all` | 如果参数数组中的所有元素都不为零，则返回 True。 |
| `np.any` | 如果参数数组中的任何元素非零，则返回 True。 |

```py
In [173]: data = np.random.normal(size=(15,15))
In [174]: np.mean(data)
Out[174]: -0.032423651106794522
In [175]: data.mean()
Out[175]: -0.032423651106794522

```

默认情况下，表 [2-9](#Tab9) 中的函数在整个输入数组中聚合。使用这些函数的关键字参数`axis`和它们对应的`ndarray`方法，可以控制数组聚合中的哪个轴被执行。axis 参数可以是一个整数，它指定聚合值的轴。在许多情况下，轴参数也可以是一个整数元组，它指定要聚合的多个轴。以下示例演示了如何根据`axis`参数的值，对形状`(5, 10, 15)`的数组调用聚合函数`np.sum`来减少数组的维数:

```py
In [176]: data = np.random.normal(size=(5, 10, 15))
In [177]: data.sum(axis=0).shape
Out[177]: (10, 15)
In [178]: data.sum(axis=(0, 2)).shape
Out[178]: (10,)
In [179]: data.sum()
Out[179]: -31.983793284860798

```

图 [2-3](#Fig3) 显示了一个 3 × 3 数组的所有元素、第一个轴和第二个轴的聚合情况。在本例中，`data`数组填充了 1 到 9 之间的整数:

![img/332789_2_En_2_Chapter/332789_2_En_2_Fig3_HTML.png](img/332789_2_En_2_Chapter/332789_2_En_2_Fig3_HTML.png)

图 2-3

沿形状为 3 × 3 的二维数组的所有轴(左)、第一个轴(中)和第二个轴(右)的数组聚合函数的图示

```py
In [180]: data = np.arange(1,10).reshape(3,3)
In [181]: data
Out[181]: array([[1, 2, 3],
                 [4, 5, 6],
                 [7, 8, 9]])

```

我们分别在轴 0 和轴 1 上计算整个数组的总和:

```py
In [182]: data.sum()
Out[182]: 45
In [183]: data.sum(axis=0)
Out[183]: array([12, 15, 18])
In [184]: data.sum(axis=1)
Out[184]: array([ 6, 15, 24])

```

### 布尔数组和条件表达式

使用 NumPy 数组进行计算时，通常需要比较不同数组中的元素，并根据比较结果执行条件计算。与算术运算符一样，NumPy 数组可以与常用的比较运算符一起使用，例如，`>`、`<`、`>=`、`<=`、`==,`和`!=`，并且是在逐个元素的基础上进行比较的。广播规则也适用于比较运算符，如果两个运算符具有兼容的形状和大小，则比较的结果是一个具有布尔值的新数组(使用`dtype`作为`np.bool`)，该数组给出了每个元素的比较结果:

```py
In [185]: a = np.array([1, 2, 3, 4])
In [186]: b = np.array([4, 3, 2, 1])
In [187]: a < b
Out[187]: array([ True,  True, False, False], dtype=bool)

```

例如，为了在一个`if`语句中使用数组之间的比较结果，我们需要以某种合适的方式聚集结果数组的布尔值，以获得单个`True`或`False`值。一个常见的用例是根据手头的情况应用`np.all`或`np.any`聚合函数:

```py
In [188]: np.all(a < b)
Out[188]: False
In [189]: np.any(a < b)
Out[189]: True
In [190]: if np.all(a < b):
    ...: print("All elements in a are smaller than their corresponding element in b")
    ...: elif np.any(a < b):
    ...: print("Some elements in a are smaller than their corresponding element in b")
    ...: else:
    ...: print("All elements in b are smaller than their corresponding element in a")
Some elements in a are smaller than their corresponding element in b

```

然而，布尔值数组的优势在于，它们通常可以完全避免条件`if`语句。通过在算术表达式中使用布尔值数组，有可能以矢量化的形式编写条件计算。当布尔数组与标量数字或另一个数字数据类型的 NumPy 数组一起出现在算术表达式中时，它会被转换为数值数组，分别用值 0 和 1 代替`False`和`True`。

```py
In [191]: x = np.array([-2, -1, 0, 1, 2])
In [192]: x > 0
Out[192]: array([False, False, False,  True,  True], dtype=bool)
In [193]: 1 * (x > 0)
Out[193]: array([0, 0, 0, 1, 1])
In [194]: x * (x > 0)
Out[194]: array([0, 0, 0, 1, 2])

```

这对于条件计算是一个有用的属性，比如在定义分段函数时。例如，如果我们需要定义一个描述给定高度、宽度和位置的脉冲的函数，我们可以通过将高度(一个标量变量)乘以脉冲的空间延伸的两个布尔值数组来实现该函数:

```py
In [195]: def pulse(x, position, height, width):
    ...:     return height * (x >= position) * (x <= (position + width))
In [196]: x = np.linspace(-5, 5, 11)
In [197]: pulse(x, position=-2, height=1, width=5)
Out[197]: array([0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0])
In [198]: pulse(x, position=1, height=1, width=5)
Out[198]: array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])

```

在这个例子中，表达式`(x >= position) * (x <= (position + width))`是两个布尔值数组的乘法运算，在这个例子中，乘法运算符充当元素级 and 运算符。函数`pulse`也可以使用 NumPy 的函数进行元素级 AND 运算，`np.logical_and`:

```py
In [199]: def pulse(x, position, height, width):
    ...:     return height * np.logical_and(x >= position, x <= (position + width))

```

还有用于其他逻辑操作的函数，例如 NOT、or 和 XOR，以及用于根据给定条件`np.where`、条件列表`np.select`和索引数组`np.choose`从不同数组中选择性地选取值的函数。参见表 [2-10](#Tab10) 对这些功能的总结，下面的例子演示了其中一些功能的基本用法。在给定一个布尔值数组条件(第一个参数)的情况下，`np.where`函数从两个数组(第二个和第三个参数)中选择元素。对于条件为真的元素，选择作为第二个参数给出的数组中的相应值，如果条件为假，则选择第三个参数数组中的元素:

表 2-10

用于条件和逻辑表达式的 NumPy 函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能

 | 

描述

 |
| --- | --- |
| `np.where` | 根据条件数组的值从两个数组中选择值。 |
| `np.choose` | 根据给定索引数组的值从数组列表中选择值。 |
| `np.select` | 根据条件列表从数组列表中选择值。 |
| `np.nonzero` | 返回包含非零元素索引的数组。 |
| `np.logical_and` | 执行元素级 AND 运算。 |
| `np.logical_or, np.logical_xor` | 逐元素或/异或运算。 |
| `np.logical_not` | 元素非运算(反相)。 |

```py
In [200]: x = np.linspace(-4, 4, 9)
In [201]: np.where(x < 0, x**2, x**3)
Out[201]: array([ 16.,   9.,   4.,   1.,   0.,   1.,   8.,  27.,  64.])

```

`np.select`函数的工作方式类似，但它不是一个布尔值条件数组，而是一个布尔值条件数组列表和一个相应的值数组列表:

```py
In [202]: np.select([x < -1, x < 2, x >= 2],
     ...:           [x**2  , x**3 , x**4])
Out[202]: array([  16.,    9.,    4.,   -1.,    0.,    1.,   16.,   81.,  256.])

```

`np.choose`将带有索引的列表或数组作为第一个参数，这些索引决定了从给定数组列表中的哪个数组中选取元素:

```py
In [203]: np.choose([0, 0, 0, 1, 1, 1, 2, 2, 2],
    ...:            [x**2,  x**3,  x**4])
Out[203]: array([  16.,    9.,    4.,   -1.,    0.,    1.,   16.,   81.,  256.])

```

函数`np.nonzero`返回可用于索引数组(例如，条件所基于的数组)的索引元组。这与用`abs(x) > 2`直接索引数组的结果是一样的，但是它使用了由`np.nonzero`返回的索引而不是布尔值数组索引。

```py
In [204]: np.nonzero(abs(x) > 2)
Out[204]: (array([0, 1, 7, 8]),)
In [205]: x[np.nonzero(abs(x) > 2)]
Out[205]: array([-4., -3.,  3.,  4.])
In [206]: x[abs(x) > 2]
Out[206]: array([-4., -3.,  3.,  4.])

```

### 集合操作

Python 语言提供了一个方便的*集合*数据结构，用于管理无序的唯一对象集合。NumPy 数组类`ndarray`也可以用来描述这样的集合，NumPy 包含对存储为 NumPy 数组的集合进行操作的函数。这些功能总结在表 [2-11](#Tab11) 中。使用 NumPy 数组来描述和操作集合允许以矢量化的形式表达某些操作。例如，测试 NumPy 数组中的值是否包含在一个集合中可以使用`np.in1d`函数来完成，该函数测试数组中作为第二个参数传递的第一个参数的每个元素是否存在。要了解这是如何工作的，考虑下面的例子:首先，为了确保 NumPy 数组是一个合适的集合，我们可以使用`np.unique`函数，它返回一个具有唯一值的新数组:

表 2-11

集合运算的 NumPy 函数

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能

 | 

描述

 |
| --- | --- |
| `np.unique` | 创建具有唯一元素的新数组，其中每个值只出现一次。 |
| `np.in1d` | 测试一个数组中的元素是否存在于另一个数组中。 |
| `np.intersect1d` | 返回一个数组，其元素包含在两个给定的数组中。 |
| `np.setdiff1d` | 返回一个数组，其元素包含在两个给定数组中的一个数组中，但不包含在另一个数组中。 |
| `np.union1d` | 返回一个数组，其元素包含在两个给定数组中的一个或两个中。 |

```py
In [207]: a = np.unique([1, 2, 3, 3])
In [208]: b = np.unique([2, 3, 4, 4, 5, 6, 5])
In [209]: np.in1d(a, b)
Out[209]: array([False,  True,  True], dtype=bool)

```

这里，测试了集合`b`中`a`的每个元素的存在性，结果是一个布尔值数组。注意，我们可以使用`in`关键字来测试表示为 NumPy 数组的集合中是否存在单个元素:

```py
In [210]: 1 in a
Out[210]: True
In [211]: 1 in b
Out[211]: False

```

为了测试`a`是否是`b`的子集，我们可以使用`np.in1d`，和前面的例子一样，以及聚合函数`np.all`(或者相应的`ndarray`方法) :

```py
In [212]: np.all(np.in1d(a, b))
Out[212]: False

```

标准集合运算 union(包含在任一集合或两个集合中的元素集合)、intersection(包含在两个集合中的元素)和 difference(包含在一个集合中但不包含在另一个集合中的元素)分别由`np.union1d`、`np.intersect1d`和`np.setdiff1d`提供:

```py
In [213]: np.union1d(a, b)
Out[213]: array([1, 2, 3, 4, 5, 6])
In [214]: np.intersect1d(a, b)
Out[214]: array([2, 3])
In [215]: np.setdiff1d(a, b)
Out[215]: array([1])
In [216]: np.setdiff1d(b, a)
Out[216]: array([4, 5, 6])

```

### 数组上的操作

除了 elementwise 和 aggregation 函数之外，一些操作将数组作为一个整体来操作，并产生一个相同大小的转换后的数组。转置就是这种操作的一个例子，它将数组中各轴的顺序颠倒过来。对于二维数组的特殊情况，即矩阵，转置简单地交换行和列:

```py
In [217]: data = np.arange(9).reshape(3, 3)
In [218]: data
Out[218]: array([[0, 1, 2],
                 [3, 4, 5],
                 [6, 7, 8]])
In [219]: np.transpose(data)
Out[219]: array([[0, 3, 6],
                 [1, 4, 7],
                 [2, 5, 8]])

```

转置函数`np.transpose`也作为一个方法存在于`ndarray`中，并且作为一个特殊的方法名`ndarray.T`。对于一个任意的 N 维数组，转置操作会反转所有的轴，如下面的例子所示(注意这里使用了`shape`属性来显示数组中每个轴上的值的数量) :

```py
In [220]: data = np.random.randn(1, 2, 3, 4, 5)
In [221]: data.shape
Out[221]: (1, 2, 3, 4, 5)
In [222]: data.T.shape
Out[222]: (5, 4, 3, 2, 1)

```

`np.fliplr`(左右翻转)和`np.flipud`(上下翻转)函数执行类似于转置的操作:它们重新排列数组的元素，使行(`np.fliplr`)或列(`np.flipud`)中的元素反转，输出数组的形状与输入相同。`np.rot90`函数将数组中前两个轴的元素旋转 90 度，和转置函数一样，它可以改变数组的形状。表 [2-12](#Tab12) 总结了常见数组操作的 NumPy 函数。

表 2-12

数组运算的 NumPy 函数概要

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能

 | 

描述

 |
| --- | --- |
| `np.transpose,``np.ndarray.transpose, np.ndarray.T` | 一个数组的转置。 |
| `np.fliplr/np.flipud` | 反转每行/每列中的元素。 |
| `np.rot90` | 将元素沿前两个轴旋转 90 度。 |
| `np.sort,``np.ndarray.sort` | 沿着给定的指定轴(默认为数组的最后一个轴)对数组的元素进行排序。`np.ndarray`方法 sort 就地执行排序，修改输入数组。 |

## 矩阵和向量运算

到目前为止，我们已经讨论了一般的 N 维数组。这种数组的主要应用之一是表示向量、矩阵和张量的数学概念，在这种用例中，我们还经常需要计算向量和矩阵运算，如标量(内)积、点(矩阵)积和张量(外)积。表 [2-13](#Tab13) 总结了 NumPy 的矩阵运算功能。

表 2-13

矩阵运算的 NumPy 函数概述

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

NumPy 函数

 | 

描述

 |
| --- | --- |
| `np.dot` | 表示向量、数组或张量的两个给定数组之间的矩阵乘法(点积)。 |
| `np.inner` | 表示向量的两个数组之间的标量乘法(内积)。 |
| `np.cross` | 表示向量的两个数组的叉积。 |
| `np.tensordot` | 沿着多维数组的指定轴的点积。 |
| `np.outer` | 表示向量的两个数组之间的外积(向量的张量积)。 |
| `np.kron` | 表示矩阵的数组和高维数组之间的 Kronecker 积(矩阵的张量积)。 |
| `np.einsum` | 评估爱因斯坦的多维数组求和约定。 |

在 NumPy 中，`*`操作符用于元素乘法。因此，对于两个二维数组`A`和`B`，表达式`A * B`不计算矩阵乘积(与许多其他计算环境相反)。目前没有用于表示矩阵乘法的运算符， <sup>[4](#Fn4)</sup> ，取而代之的是用于此目的的 NumPy 函数`np.dot`。在`ndarray`类中也有相应的方法。要计算大小为 *N* × *M* 和 *M* × *P* 的两个矩阵 *A* 和 *B* 的乘积，从而得到大小为 *N* × *P* 的矩阵，我们可以使用:

```py
In [223]: A = np.arange(1, 7).reshape(2, 3)
In [224]: A
Out[224]: array([[1, 2, 3],
                 [4, 5, 6]])
In [225]: B = np.arange(1, 7).reshape(3, 2)
In [226]: B
Out[226]: array([[1, 2],
                 [3, 4],
                 [5, 6]])
In [227]: np.dot(A, B)
Out[227]: array([[22, 28],
                 [49, 64]])
In [228]: np.dot(B, A)
Out[228]: array([[ 9, 12, 15],
                 [19, 26, 33],
                 [29, 40, 51]])

```

`np.dot`函数也可用于矩阵-向量乘法(即表示矩阵的二维数组与表示向量的一维数组的乘法)。举个例子，

```py
In [229]: A = np.arange(9).reshape(3, 3)
In [230]: A
Out[230]: array([[0, 1, 2],
                 [3, 4, 5],
                 [6, 7, 8]])
In [231]: x = np.arange(3)
In [232]: x
Out[232]: array([0, 1, 2])
In [233]: np.dot(A, x)
Out[233]: array([5, 14, 23])

```

在这个例子中，`x`可以是形状为`(1, 3)`的二维数组，也可以是形状为`(3,)`的一维数组。除了函数`np.dot`，在`ndarray`中还有一个对应的方法`dot`，可以如下例使用:

```py
In [234]: A.dot(x)
Out[234]: array([5, 14, 23])

```

不幸的是，当使用`np.dot`或`np.ndarray.dot`时，重要的矩阵乘法表达式通常会变得复杂和难以阅读。例如，即使是相对简单的矩阵表达式，如用于相似性变换的矩阵表达式，*A*<sup>’</sup>=*BAB*<sup>-1</sup>，也必须用相对隐晦的嵌套表达式来表示，如

```py
In [235]: A = np.random.rand(3,3)
In [236]: B = np.random.rand(3,3)
In [237]: Ap = np.dot(B, np.dot(A, np.linalg.inv(B)))

```

或者

```py
In [238]: Ap = B.dot(A.dot(np.linalg.inv(B)))

```

为了改善这种情况，NumPy 提供了一个名为`matrix`的替代数据结构来代替`ndarray`，像`A * B`这样的表达式被实现为矩阵乘法。还提供了一些方便的特殊属性，像`matrix`。I 为逆矩阵，`matrix.H`为矩阵的复共轭转置。使用这个`matrix`类的实例，可以使用可读性更好的表达式:

```py
In [239]: A = np.matrix(A)
In [240]: B = np.matrix(B)
In [241]: Ap = B * A * B.I

```

这看起来像是一个实际的妥协，但是不幸的是使用`matrix`类确实有一些缺点，因此通常不鼓励使用它。反对使用`matrix`的主要理由是，像`A * B`这样的表达式是依赖于上下文的:也就是说，不清楚`A * B`是表示元素乘法还是矩阵乘法，因为它取决于`A`和`B`的类型，这就产生了另一个代码可读性问题。如果`A`和`B`是函数的用户提供的参数，这可能是一个特别相关的问题，在这种情况下，有必要将所有输入数组显式地转换为`matrix`实例，例如使用`np.asmatrix`或函数`np.matrix`(因为不能保证用户使用类型为`matrix`而不是`ndarray`的参数调用函数)。`np.asmatrix`函数以`np.matrix`实例的形式创建原始数组的视图。这并没有增加多少计算成本，但是在`ndarray`和`matrix`之间来回显式地转换数组确实抵消了矩阵表达式可读性提高的好处。一个相关的问题是，一些操作数组和矩阵的函数可能不考虑输入的类型，并且可能返回一个`ndarray`，即使它是用类型`matrix`的输入参数调用的。这样，一个类型为`matrix`的矩阵可能会被无意地转换成`ndarray`，这反过来会改变像`A * B`这样的表达式的行为。当使用 NumPy 的数组和矩阵函数时，这种类型的行为不太可能发生，但是当使用其他包中的函数时，这种行为也不是不可能发生。然而，尽管有各种理由不要太广泛地使用`matrix`矩阵，我个人认为对复杂的矩阵表达式使用`matrix`类实例是一个重要的用例，在这些情况下，在计算之前将数组显式地转换为矩阵，并将结果显式地转换回`ndarray`类型，这可能是一个好主意，遵循以下模式:

```py
In [242]: A = np.asmatrix(A)
In [243]: B = np.asmatrix(B)
In [244]: Ap = B * A * B.I
In [245]: Ap = np.asarray(Ap)

```

表示向量的两个数组之间的内积(标量积)可以使用`np.inner`函数来计算:

```py
In [246]: np.inner(x, x)
Out[246]: 5

```

或者，等效地，使用`np.dot`:

```py
In [247]: np.dot(x, x)
Out[247]: 5

```

主要区别在于`np.inner`期望两个输入参数具有相同的维数，而`np.dot`可以分别接受形状为 1 × *N* 和 *N* × 1 的输入向量:

```py
In [248]: y = x[:, np.newaxis]
In [249]: y
Out[249]: array([[0],
                 [1],
                 [2]])
In [250]: np.dot(y.T, y)
Out[250]: array([[5]])

```

内积将两个向量映射到一个标量，而外积执行将两个向量映射到一个矩阵的互补运算。

```py
In [251]: x = np.array([1, 2, 3])
In [252]: np.outer(x, x)
Out[252]: array([[1, 2, 3],
                 [2, 4, 6],
                 [3, 6, 9]])

```

外积也可以使用函数`np.kron`使用克罗内克积来计算，然而，与`np.outer`相反，如果输入数组分别具有形状`(M, N)`和`(P, Q)`，则产生形状`(M*P, N*Q)`的输出数组。因此，对于长度为 M 和 P 的两个一维数组的情况，得到的数组具有形状`(M*P,)`:

```py
In [253]: np.kron(x, x)
Out[253]: array([1, 2, 3, 2, 4, 6, 3, 6, 9])

```

为了获得对应于`np.outer(x, x)`的结果，输入数组`x`必须扩展为形状`(N, 1)`和`(1, N)`，分别在`np.kron`的第一个和第二个参数中:

```py
In [254]: np.kron(x[:, np.newaxis], x[np.newaxis, :])
Out[254]: array([[1, 2, 3],
                 [2, 4, 6],
                 [3, 6, 9]])

```

一般来说，虽然`np.outer`函数主要用于输入向量，但`np.kron`函数可用于计算任意维数组的张量积(但两个输入必须具有相同的轴数)。例如，要计算两个 2 × 2 矩阵的张量积，我们可以使用:

```py
In [255]: np.kron(np.ones((2,2)), np.identity(2))
Out[255]: array([[ 1.,  0.,  1.,  0.],
                 [ 0.,  1.,  0.,  1.],
                 [ 1.,  0.,  1.,  0.],
                 [ 0.,  1.,  0.,  1.]])
In [256]: np.kron(np.identity(2), np.ones((2,2)))
Out[256]: array([[ 1.,  1.,  0.,  0.],
                 [ 1.,  1.,  0.,  0.],
                 [ 0.,  0.,  1.,  1.],
                 [ 0.,  0.,  1.,  1.]])

```

使用多维数组时，通常可以使用爱因斯坦求和约定来简洁地表达常见的数组操作，在该约定中，对表达式中多次出现的每个索引都假定隐式求和。例如，两个向量 x 和 y 的标积被简洁地表示为 x <sub>n</sub> y <sub>n</sub> ，两个矩阵 A 和 B 的矩阵乘法被表示为 A <sub>mk</sub> B <sub>kn</sub> 。NumPy 提供了用于执行爱因斯坦求和的函数`np.einsum`。它的第一个参数是一个索引表达式，后面是该表达式中包含的任意数量的数组。索引表达式是带有逗号分隔索引的字符串，其中每个逗号分隔每个数组的索引。每个数组可以有任意数量的索引。例如，标量积表达式 x <sub>n</sub> y <sub>n</sub> 可以使用索引表达式`"n,n"`用`np.einsum`来计算，即使用`np.einsum("n,n", x, y)`:

```py
In [257]: x = np.array([1, 2, 3, 4])
In [258]: y = np.array([5, 6, 7, 8])
In [259]: np.einsum("n,n", x, y)
Out[259]: 70
In [260]: np.inner(x, y)
Out[260]: 70

```

类似地，矩阵乘法 A <sub>mk</sub> B <sub>kn</sub> 可以使用`np.einsum`和索引表达式`"mk,kn"`来计算:

```py
In [261]: A = np.arange(9).reshape(3, 3)
In [262]: B = A.T
In [263]: np.einsum("mk,kn", A, B)
Out[263]: array([[  5,  14,  23],
                 [ 14,  50,  86],
                 [ 23,  86, 149]])
In [264]: np.alltrue(np.einsum("mk,kn", A, B) == np.dot(A, B))
Out[264]: True

```

当处理多维数组时，爱因斯坦求和约定可能特别方便，因为定义运算的索引表达式明确了执行哪个运算以及沿着哪个轴执行。例如，使用`np.tensordot`的等效计算可能需要给出要计算点积的轴。

## 摘要

在本章中，我们简要介绍了使用 NumPy 库进行基于数组的编程，可以作为本书后面章节的参考。NumPy 是一个用于 Python 计算的核心库，它为几乎所有的 Python 计算库提供了基础。熟悉 NumPy 库及其使用模式是使用 Python 进行科学和技术计算的一项基本技能。在这里，我们首先介绍 NumPy 的 N 维数组数据结构——`ndarray`对象——然后继续讨论创建和操作数组的函数，包括索引和切片，以便从数组中提取元素。我们还讨论了使用`ndarray`对象执行计算的函数和操作符，重点是使用数组进行高效计算的矢量化表达式和操作符。在本书的其余部分，我们将看到科学计算中特定领域的高级库的例子，它们使用 NumPy 提供的数组框架。

## 进一步阅读

NumPy library 是几本书的主题，包括 NumPy T. Oliphant 的创造者编写的《NumPy 指南》，可在 [`http://web.mit.edu/dvp/Public/numpybook.pdf`](http://web.mit.edu/dvp/Public/numpybook.pdf) 在线免费获得，以及 Ivan Idris 的一系列书籍: *Numpy 初学者指南* (2015 年)、 *NumPy 食谱* (2012 年)和*学习 NumPy 阵列* (2014 年)。《McKinney 》( 2013)也详细介绍了 NumPy。

## 参考

Idris，I. *学习 NumPy 数组。*孟买:Packt，2014 年。

—.Numpy 初学者指南。3 号。孟买:Packt，2015。

——*numpy cookbook。*孟买:打包，2012 年。

麦金尼韦斯。 *Python 进行数据分析。*塞瓦斯托波尔:奥莱利，2013 年。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

许多现代处理器提供在数组上操作的指令。这些也称为向量化操作，但这里的向量化指的是基于数组的高级操作，而不管它们在处理器级别是如何实现的。

  [2](#Fn2_source)

Python 列表不一定是这种情况，因此可以是异构的。

  [3](#Fn3_source)

注意，这不是 NumPy 中可用的 elementwise 函数的完整列表。请参阅 NumPy 参考文档以获得完整的列表。

  [4](#Fn4_source)

Python 最近采用@符号来表示矩阵乘法，从 Python 3.5 开始，这个操作符现在可用了。然而，在撰写本文时，这种操作符仍然没有被广泛使用。详见[http://legacy . python . org/dev/peps/pep-0465](http://legacy.python.org/dev/peps/pep-0465)。

  [5](#Fn5_source)

使用新的中缀矩阵乘法运算符，同样的表达式可以表示为可读性更好的:`Ap = B @ A @ np.linalg.inv(B)`。

 </aside>