# 十一、偏微分方程

偏微分方程(PDEs)是多元微分方程，其中一个以上的因变量的导数出现。即方程中的导数是*偏*导数。因此，它们是普通微分方程的推广，在第 9 章[中有所涉及。从概念上讲，常微分方程和偏微分方程之间的差别并不大，但处理常微分方程和偏微分方程所需的计算技术却非常不同，求解偏微分方程通常需要更多的计算。大多数数值求解偏微分方程的技术都是基于将问题离散化为出现在偏微分方程中的每个独立变量的思想，从而将问题重铸为代数形式。这通常会导致非常大规模的线性代数问题。将偏微分方程重新转换为代数形式的两种常见技术是有限差分方法(FDMs)，其中问题中的导数用它们的有限差分公式来近似，以及有限元方法(FEMs)，其中未知函数被写成简单基函数的线性组合，可以很容易地进行微分和积分。未知函数由这种表示中基函数的一组系数来描述，通过对偏微分方程的适当改写，我们可以得到这些系数的代数方程。](09.html)

对于 FDMs 和 FEMs，得到的代数方程组通常非常大，并且在矩阵形式中，这样的方程组通常非常稀疏。因此，FDM 和有限元法都严重依赖于代数线性方程的稀疏矩阵表示，如第 [10](10.html) 章所述。大多数 PDEs 的通用框架都是基于 FEM 或其变体，因为这种方法允许在复杂的问题域上解决非常一般的问题。

与我们到目前为止讨论过的其他类型的计算问题相比，解决偏微分方程问题需要更多的资源。这可能需要大量的资源，部分原因是离散化一个空间区域所需的点数与维数成指数关系。如果一维问题需要 100 个点来描述，分辨率相近的二维问题需要 100 个 <sup>2</sup> = 10 个 <sup>4</sup> 点，三维问题需要 100 个 <sup>3</sup> = 10 个 <sup>6</sup> 点。由于离散化空间中的每个点对应于一个未知变量，很容易想象 PDE 问题会导致非常大的方程组。以编程方式定义 PDE 问题也可能很复杂。其中一个原因是，偏微分方程的可能形式远远超过了偏微分方程的可能形式。另一个原因是几何:虽然一维空间中的区间由两个点唯一定义，但二维问题中的面积和三维问题中的体积可以具有由曲线和表面包围的任意复杂的几何形状。因此，定义 PDE 的问题域及其在坐标点网格中的离散化可能需要先进的工具，并且在如何定义边界条件方面也有很大的自由度。与常微分方程问题不同的是，任何偏微分方程问题都没有标准的定义形式。

由于这些原因，Python 的 PDE 解算器只能通过专门用于 PDE 问题的库和框架获得。对于 Python，使用 FEM 方法解决 PDE 问题至少有三个重要的库:FiPy 库、SfePy 库和 FEniCS 库。所有这些库都很广泛，功能丰富，深入研究使用这些库的细节超出了本书的范围。在这里，我们只能简单介绍 PDE 问题，并调查可以从 Python 中使用的 PDE 库的突出示例，并通过几个示例说明其中一个库(FEniCS)的一些功能。希望这能给对用 Python 解决 PDE 问题感兴趣的读者一个可用选项的鸟瞰，以及在哪里寻找进一步信息的一些有用的指示。

## 导入模块

对于基本的数值和绘图用法，在本章中，我们也需要 NumPy 和 Matplotlib 库。对于 3D 绘图，我们需要从 Matplotlib 工具包库`mpl_toolkits`中显式导入`mplot3d`模块。通常，我们假设这些库是以下列方式导入的:

```py
In [1]: import numpy as np
In [2]: import matplotlib.pyplot as plt
In [3]: import matplotlib as mpl
In [4]: import mpl_toolkits.mplot3d

```

我们还使用了 SciPy 中的`linalg`和`sparse`模块，为了使用`sparse`模块的`linalg`子模块，我们还需要显式导入它:

```py
In [5]: import scipy.sparse as sp
In [6]: import scipy.sparse.linalg
In [7]: import scipy.linalg as la

```

有了这些导入，我们可以以`la`的身份访问稠密线性代数模块，而以`sp.linalg`的身份访问稀疏线性代数模块。此外，在本章的后面，我们还将使用 FEniCS FEM 框架，并且我们要求以下列方式导入其`dolfin`和`mshr`库:

```py
In [8]: import dolfin
In [9]: import mshr

```

## 偏微分方程

PDE 中的未知量是多元函数，这里表示为 *u* 。在一个 N 维问题中，函数 *u* 依赖于*N*-自变量: *u* ( *x* <sub>1</sub> ， *x* <sub>2</sub> ，…， *x* <sub>*n*</sub> )。一般的偏微分方程可以正式写成

![$$ F\left({x}_1,{x}_2,\dots, {x}_n,u,{\left\{\frac{\partial u}{\partial {x}_{i_1}}\right\}}_{1\le {i}_1\le n},{\left\{\frac{\partial^2u}{\partial {x}_{i_1}{x}_{i_2}}\right\}}_{1\le {i}_1,{i}_2\le n},\dots \right)=0,x\in \varOmega, $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equa.png)

其中![$$ {\left\{\frac{\partial u}{\partial {x}_{i_1}}\right\}}_{1\le {i}_1\le n} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq1.png)表示对自变量 *x* <sub>1</sub> ，…， *x* <sub>* n *</sub> ，![$$ {\left\{\frac{\partial^2u}{\partial {x}_{n_1}{x}_{n_2}}\right\}}_{1\le {i}_1,{i}_2\le n} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq2.png)表示所有二阶导数，以此类推。这里 *F* 是描述 PDE 形式的已知函数，ω是 PDE 问题的定义域。实践中出现的许多偏微分方程最多只包含二阶导数，我们通常处理二维或三维空间中的问题，也可能处理时间中的问题。使用偏微分方程时，通常通过使用下标符号![$$ {u}_x=\frac{\partial u}{\partial x} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq3.png)来表示独立变量 *x* 的偏导数，从而简化符号。高阶导数用多个指数表示:![$$ {u}_{xx}=\frac{\partial^2u}{\partial {x}^2} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq4.png)、![$$ {u}_{xy}=\frac{\partial^2u}{\partial x\partial y} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq5.png)等等。典型的偏微分方程的一个例子是热方程，它在二维笛卡尔坐标系中采用的形式是*u*<sub>*t*</sub>=*α*(*u*<sub>*xx*</sub>+*u*<sub>*YY*</sub>)。这里函数*u*=*u*(*t*， *x* ， *y* )描述的是 *x* ， *y* 时刻 *t* 处的温度，而 *α* 是热扩散系数。

为了完全指定 PDE 的特定解，我们需要定义它的边界条件，这些边界条件是沿着问题域ω的边界的函数或其导数的组合的已知值，以及初始值(如果问题是时间相关的)。边界通常用γ或∂ω表示，一般来说，边界的不同部分可以给出不同的边界条件。两种重要的边界条件是狄利克雷边界条件，它指定函数在边界上的值，*u*(***x***)=*h*(***x***)用于表示**∈γ<sub>*D*</sub>，以及诺依曼边界条件，它指定函数在边界上的法向导数，![$$ \frac{\partial u(x)}{\partial n}=g(x) $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq6.png)用于表示*这里的*h*(***x***)和*g*(***x***)是任意函数。***

 **## 有限差分方法

有限差分法的基本思想是在离散化空间上用它们的有限差分公式来近似出现在 PDE 中的导数。例如，将连续变量 *x* 离散成离散点{ *x* <sub>*n*</sub> }的普通导数![$$ \frac{du(x)}{dx} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq7.png)的有限差分公式可以用向前差分公式![$$ \frac{du\left({x}_n\right)}{dx}\approx \frac{u\left({x}_{n+1}\right)-u\left({x}_n\right)}{x_{n+1}-{x}_n} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq8.png)、向后差分公式![$$ \frac{du\left({x}_n\right)}{dx}\approx \frac{u\left({x}_n\right)-u\left({x}_{n-1}\right)}{x_n-{x}_{n-1}} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq9.png)或居中差分公式![$$ \frac{du\left({x}_n\right)}{dx}\approx \frac{u\left({x}_{n+1}\right)-u\left({x}_{n-1}\right)}{x_{n+1}-{x}_{n-1}} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq10.png)来近似。同样，我们也可以构造高阶导数的有限差分公式，比如二阶导数![$$ \frac{d^2u\left({x}_n\right)}{d{x}^2}\approx \frac{u\left({x}_{n+1}\right)-2u\left({x}_n\right)+u\left({x}_{n-1}\right)}{{\left({x}_n-{x}_{n-1}\right)}^2} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq11.png)。假设将连续变量 *x* 离散成离散点足够精细，这些有限差分公式可以给出导数的良好近似。用微分方程或偏微分方程的有限差分公式代替微分方程或偏微分方程中的导数，可以将微分方程重新转换为代数方程。如果原始的常微分方程或偏微分方程是线性的，那么代数方程也是线性的，可以用标准的线性代数方法求解。

为了使这种方法更具体，考虑在区间*x*∈【0，1】中的常微分方程问题*u*<sub>*xx*</sub>= 5，并且边界条件 *u* ( *x* = 0) = 1 和 *u* ( *x* = 1) = 2，这例如来自一维稳态热方程。与第 [9](09.html) 章中考虑的 ODE 初始值问题相反，这是一个边界值问题，因为 *u* 的值在 *x* = 0 和 *x* = 1 时都有规定。因此，初值问题的方法在这里不适用。相反，我们可以通过将区间[0，1]分成离散的点 *x* <sub>*n*</sub> 来处理这个问题，然后问题是在这些点上找到函数*u*(*x*<sub>*n*</sub>)=*u*<sub>*n*</sub>。将 ODE 问题写成有限差分形式给出一个方程(*u*<sub>*N*1*u*<sub>*N*</sub>+*u*<sub>*N*+1</sub>)/δ*x*<sup>2</sup>= 5 对于每一个内点*这里区间[0，1]被离散成 *N* +2 个均匀间隔的点，包括边界点，间隔δ*x*= 1/(*N*+1)。由于在两个边界点上的函数是已知的，有 *N* 个未知变量 *u* <sub>*n*</sub> 对应内点上的函数值。内点方程组可以矩阵形式写成 *Au* = *b* ，其中*u*=[*u*<sub>1</sub>，…，*u*<sub>*N*</sub><sup>*T*</sup>，![$ b={\left[-5-\frac{u_0}{\varDelta {x}^2},-5,\dots, -5,-5-\frac{u_{N+1}}{\varDelta {x}^2}\right]}^T $](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq12.png)和*</sub>

![$$ A=\frac{1}{\varDelta {x}^2}\left[\begin{array}{ccccc}-2&amp; 1&amp; 0&amp; 0&amp; \dots \\ {}1&amp; -2&amp; 1&amp; 0&amp; \dots \\ {}0&amp; 1&amp; -2&amp; 1&amp; 0\\ {}0&amp; 0&amp; 1&amp; -2&amp; \ddots \\ {}\vdots &amp; \vdots &amp; 0&amp; \ddots &amp; \ddots \end{array}\right]. $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equb.png)

这里，矩阵 *A* 描述了*u*<sub>T5】n</sub>的方程与相邻点处的值的耦合，这归因于用于近似 ODE 中的二阶导数的有限差分公式。边界值包含在 *b* 向量中，该向量还包含原始 ODE 的右侧常量(源项)。此时，我们可以直接求解未知向量 *u* 的线性方程组 *Au* = *b* ，从而得到函数 *u* ( *x* )在离散点{*x*<sub>*n*</sub>}的近似值。

在 Python 代码中，我们可以通过以下方式设置和解决这个问题:首先，我们为内部点的数量`N`，边界`u0`和`u1`处的函数值，以及相邻点之间的间距`dx`定义变量。

```py
In [10]: N = 5
In [11]: u0, u1 = 1, 2
In [12]: dx = 1.0 / (N + 1)

```

接下来，我们构建矩阵 *A* ，如前一节所述。为此，我们可以使用 NumPy 的`eye`函数，该函数创建一个二维数组，数组中的 1 位于对角线上，或者位于上对角线或下对角线上，该数组从主对角线偏移了参数`k`给出的数字。

```py
In [13]: A = (np.eye(N, k=-1) - 2 * np.eye(N) + np.eye(N, k=1)) / dx**2
In [14]: A
Out[14]: array([[-72.,  36.,   0.,   0.,   0.],
                [ 36., -72.,  36.,   0.,   0.],
                [  0.,  36., -72.,  36.,   0.],
                [  0.,   0.,  36., -72.,  36.],
                [  0.,   0.,   0.,  36., -72.]])

```

接下来，我们需要为向量 *b* 定义一个数组，它对应于微分方程中的源项–5，以及边界条件。边界条件通过第一个和最后一个方程(对于 *u* <sub>1</sub> 和 *u* <sub>*N*</sub> )的导数的有限差分表达式进入方程，但是这些项从矩阵 *A* 表示的表达式中缺失，因此必须添加到向量 *b* 中。

```py
In [15]: b = -5 * np.ones(N)
    ...: b[0] -= u0 / dx**2
    ...: b[N-1] -= u1 / dx**2

```

一旦定义了矩阵`A`和向量`b`，我们就可以使用 SciPy 的线性方程解算器来解方程组(我们也可以使用 NumPy、`np.linalg.solve`提供的解算器)。

```py
In [16]: u = la.solve(A, b)

```

这就完成了这个 ODE 问题的解决。为了可视化解决方案，这里我们首先创建一个数组`x`，它包含我们已经解决了问题的离散坐标点，包括边界点，我们还创建一个数组`U`，它将边界值和内部点组合在一个数组中。然后绘制结果，如图 [11-1](#Fig1) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig1_HTML.png](img/332789_2_En_11_Chapter/332789_2_En_11_Fig1_HTML.png)

图 11-1

文中介绍的二阶常微分方程边值问题的解法

```py
In [17]: x = np.linspace(0, 1, N+2)
In [18]: U = np.hstack([[u0], u, [u1]])
In [19]: fig, ax = plt.subplots(figsize=(8, 4))
    ...: ax.plot(x, U)
    ...: ax.plot(x[1:-1], u, 'ks')
    ...: ax.set_xlim(0, 1)
    ...: ax.set_xlabel(r"$x$", fontsize=18)
    ...: ax.set_ylabel(r"$u(x)$", fontsize=18)

```

通过沿着每个离散坐标使用有限差分公式，有限差分方法可以容易地扩展到更高维度。对于一个二维问题，我们对于未知的内部函数值有一个二维数组`u`，当使用有限差分公式时，我们对于`u`中的元素得到一个耦合方程组。为了将这些方程写成标准的矩阵向量形式，我们可以将`u`数组重新排列成一个向量，并从有限差分方程中组装出相应的矩阵`A`。

举个例子，考虑前面问题的如下二维推广:*u*<sub>*xx*</sub>+*u*<sub>*YY*</sub>= 0，边界条件 *u* ( *x* = 0) = 3，*u*(*x*= 1)=-1， *u* ( *y 这里没有源项，但是二维问题中的边界条件比我们之前解决的一维问题更复杂。在有限差分形式下，我们可以把偏微分方程写成(*u*<sub>*m*—1，*n*</sub>—2*u*<sub>*m*，*n*</sub>+*<sub>*m*+1，*n*</sub>)/δ **n*—1—2*u*<sub>*m*，*n*</sub>+*u*<sub>*m*，*n*+1</sub>/δ*y*<sup>2</sup> 如果我们把 *x* 和 *y* 区间分成 *N* 内点( *N* +2 个点包括边界点)，那么![$$ \varDelta x=\varDelta y=\frac{1}{N+1}, $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq13.png)和 *u* 就是一个 *NxN* 矩阵。为了在标准形式 *Av* = *b* 上写方程，我们可以通过将矩阵 *u* 的行或列堆叠成大小为 *N* <sup> 2 </sup> × 1 的向量来重新排列矩阵*u*。矩阵 *A* 的大小为*N*<sup>2</sup>×*N*<sup>2</sup>，如果我们需要使用 *x* 和 *y* 坐标的精细离散化，这可能会非常大。例如，使用沿 *x* 和 *y* 的 100 个点，给出一个有 10 个 <sup>4 个</sup>未知值*u*<sub>*Mn*</sub>的方程组，矩阵 A 有 100 个 <sup>4 个</sup> = 10 个 <sup>8 个</sup>元素。幸运的是，由于有限差分公式只耦合相邻的点，矩阵 *A* 变得非常稀疏，在这里我们可以从处理稀疏矩阵中受益匪浅，正如我们将在下面看到的。***

为了用 Python 和有限元方法解决这个 PDE 问题，我们首先定义内部点数的变量和沿着单位正方形四个边界的值:

```py
In [20]: N = 100
In [21]: u0_t, u0_b = 5, -5
In [22]: u0_l, u0_r = 3, -1
In [23]: dx = 1\. / (N+1)

```

我们还在 *x* 和 *y* 的离散化中计算了均匀间隔的坐标点之间的间距`dx`(假设相等)。因为有限差分公式耦合了相邻的行和列，所以在这个例子中构造矩阵`A`稍微复杂一些。不过，一个比较直接的方法是，先沿着其中一个坐标定义一维公式对应的矩阵`A_1d`(比如说 *x* 或者 *u* <sub>*m* ， *n*</sub> 中的索引 *m* )。要沿着每一行分布这个公式，我们可以取大小为 *N* × *N* 的单位矩阵与`A_1d`矩阵的张量积。结果描述了所有指数`n`沿`m`指数的所有导数。为了涵盖将方程耦合为 *u* <sub>*m* ， *n*</sub> 到 *u* <sub>*m* ， *n* +1</sub> 和*<sub>*m*，*N*-1</sub>的各项，即沿索引`n`的导数在下文中，我们执行这些步骤来使用来自`scipy.sparse`模块的`eye`和`kron`函数构建 *A* 。结果是一个稀疏矩阵`A`，它描述了我们在此考虑的二维 PDE 的有限差分方程系统:*

```py
In [24]: A_1d = (sp.eye(N, k=-1) + sp.eye(N, k=1) - 4 * sp.eye(N))/dx**2
In [25]: A = sp.kron(sp.eye(N), A_1d) + (sp.eye(N**2, k=-N) + sp.eye(N**2, k=N))/dx**2
In [26]: A
Out[26]: <10000x10000 sparse matrix of type '<type 'numpy.float64'>'
          with 49600 stored elements in Compressed Sparse Row format>

```

`A`的打印结果显示，它是一个稀疏矩阵，有 10 个 <sup>8 个</sup>元素，49600 个非零元素，这样大约 2000 个元素中只有 1 个非零， *A* 确实非常稀疏。为了从边界条件构建向量 *b* ，方便的是创建一个由零组成的 *N* × *N* 数组，并将边界条件分配给该数组的边缘元素(它们是与边界耦合的`u`中的对应元素，即与边界相邻的内部点)。一旦这个 *N* × *N* 数组被创建并赋值，我们就可以使用`reshape`方法将其重新排列成一个 *N* <sup>2</sup> × 1 向量，该向量可以在 *Av* = *b* 等式中使用:

```py
In [27]: b = np.zeros((N, N))
​    ...: b[0, :] += u0_b   # bottom
    ...: b[-1, :] += u0_t  # top
    ...: b[:, 0] += u0_l   # left
    ...: b[:, -1] += u0_r  # right
    ...: b = - b.reshape(N**2) / dx**2

```

当`A`和`b`数组被创建时，我们可以继续求解向量`v`的方程组，并使用 reshape 方法将其重新排列到 *N* × *N* 矩阵`u`中:

```py
In [28]: v = sp.linalg.spsolve(A, b)
In [29]: u = v.reshape(N, N)

```

出于绘图目的，我们还创建了一个矩阵`U`，它将`u`矩阵与边界条件相结合。与坐标矩阵`X`和`Y`一起，我们绘制一个色图和解决方案的 3D 表面视图。结果如图 [11-2](#Fig2) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig2_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig2_HTML.jpg)

图 11-2

具有文中定义的狄利克雷边界条件的二维热传导方程的解

```py
In [30]: U = np.vstack([np.ones((1, N+2)) * u0_b,
    ...:                np.hstack([np.ones((N, 1)) * u0_l, u, np.ones((N, 1)) * u0_r]),
    ...:                np.ones((1, N+2)) * u0_t])
In [31]: x = np.linspace(0, 1, N+2)
In [32]: X, Y = np.meshgrid(x, x)
​In [33]: fig = plt.figure(figsize=(12, 5.5))
    ...: cmap = mpl.cm.get_cmap('RdBu_r')
    ...:
    ...: ax = fig.add_subplot(1, 2, 1)
    ...: c = ax.pcolor(X, Y, U, vmin=-5, vmax=5, cmap=cmap)
    ...: ax.set_xlabel(r"$x_1$", fontsize=18)
    ...: ax.set_ylabel(r"$x_2$", fontsize=18)
    ...:
    ...: ax = fig.add_subplot(1, 2, 2, projection="3d")
    ...: p = ax.plot_surface(X, Y, U, vmin=-5, vmax=5, rstride=3, cstride=3,
    ...:                     linewidth=0, cmap=cmap)
    ...: ax.set_xlabel(r"$x_1$", fontsize=18)
    ...: ax.set_ylabel(r"$x_2$", fontsize=18)
    ...: cb = plt.colorbar(p, ax=ax, shrink=0.75)
    ...: cb.set_label(r"$u(x_1, x_2)$", fontsize=18)

```

如前所述，FDM 方法会产生非常稀疏的矩阵 *A* ，与使用密集的 NumPy 数组相比，使用稀疏矩阵数据结构(如`scipy.sparse,`提供的数据结构)可以显著提高性能。为了具体说明使用稀疏矩阵解决这类问题的重要性，我们可以比较使用 IPython 命令`%timeit`求解 *Av* = *b* 方程所需的时间，这是针对 *A* 是稀疏矩阵和密集矩阵的两种情况:

```py
In [34]: A_dense = A.todense()
In [35]: %timeit la.solve(A_dense, b)
1 loops, best of 3: 10.8 s per loop
In [36]: %timeit sp.linalg.spsolve(A, b)
10 loops, best of 3: 31.9 ms per loop

```

从这些结果中，我们看到，使用稀疏矩阵来解决当前问题导致了几个数量级的加速(在这种特殊情况下，我们的加速因子为 10.8/0.0319 ≈ 340)。

我们在最后两个例子中使用的有限差分法是一种功能强大且相对简单的方法，用于求解具有简单几何形状的常微分方程边值问题和偏微分方程问题。然而，它不太容易适用于更复杂的区域或非均匀坐标网格上的问题。对于这类问题，有限元法通常更加灵活和方便，尽管有限元法在概念上比有限差分法更复杂，但它们在计算上是高效的，并能很好地适应复杂的问题域和更复杂的边界条件。

## 有限元方法

有限元方法是一种将偏微分方程转化为代数方程的强大而通用的方法。该方法的基本思想是用一组有限的离散区域或*元素*来表示 PDE 所在的区域，并将未知函数近似为基函数的线性组合，其中每个元素(或一小组相邻元素)上有局部支持。在数学上，这个近似解 *u* <sub>*h*</sub> 表示函数空间 *V* (例如，连续实值函数)中的精确解 *u* 到与问题域的离散化相关的有限子空间*v*<sub>*h*</sub>⊂*v*上的投影。如果 *V* <sub>*h*</sub> 是 *V* 的一个合适子空间，那么可以预期的是 *u* <sub>*h*</sub> 可以很好的逼近 *u* 。

为了能够解决简化函数空间 *V* <sub>*h*</sub> 上的近似问题，我们可以首先将 PDE 从其原始公式(称为*强形式*)重写为其相应的变分形式(也称为*弱形式*)。为了获得弱形式，我们将 PDE 乘以任意函数 *v* 并在整个问题域上积分。函数 *v* 被称为*测试函数*，通常可以定义在不同于 *V* 和 *V* <sub>*h*</sub> 的函数空间![$$ \widehat{V} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq14.png)上。

例如，考虑我们在本章早些时候使用 FDM 求解的稳态热方程(也称为泊松方程):该方程的强形式是δ*u*(***x***)=*f*(***x***)，其中我们使用了向量运算符符号。通过将该等式与测试函数 *v* 相乘，并在域***x***∈ω上积分，我们获得弱形式:

![$$ -\underset{\varOmega }{\int}\varDelta u\ v\ \mathrm{d}x=\underset{\varOmega }{\int }\ f\ v\ \mathrm{d}x. $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equc.png)

由于精确解 *u* 满足强形式，所以对于 *v* 的任何合理选择，它也满足 PDE 的弱形式。反过来不一定成立，但是如果函数 *u* <sub>*h*</sub> (在本文中称为*试函数*)满足一大类适当选择的测试函数 *v* 的弱形式，那么它似乎是精确解 *u* 的良好近似。

为了在数值上处理这个问题，我们首先需要从无限维函数空间 *V* 和![$$ \widehat{V} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq15.png)过渡到近似有限维函数空间 *V* <sub>* h *</sub> 和![$$ {\widehat{V}}_h $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq16.png):

![$$ -\underset{\varOmega }{\int}\varDelta {u}_h{v}_h\ \mathrm{d}x=\underset{\varOmega }{\int }\ f{v}_h\ \mathrm{d}x, $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equd.png)

其中*u*<sub>*h*</sub>∈*v*<sub>*h*</sub>和![$$ {v}_h\in {\widehat{V}}_h. $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq17.png)这里的重点是 *V* <sub>* h *</sub> 和![$$ {\widehat{V}}_h $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq18.png)是有限维的，所以我们可以使用有限的一组基函数{*ϕ*<sub>*I*</sub>}和![$$ \left\{{\widehat{\phi}}_i\right\} $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq19.png)具体来说，我们可以将 *u* <sub>* h *</sub> 表示为跨越其函数空间的基函数的线性组合，*u*<sub>*h*</sub>=∑*u*<sub>*I*</sub>*ϕ*<sub>*I*</sub>将该线性组合插入到 PDE 的弱形式中，并对基函数进行积分和微分运算，而不是直接对 PDE 中的项进行积分和微分运算，产生了一组代数方程。

为了得到简单形式 *AU* = *b* 上的方程组，我们还必须写出双线性形式的偏微分方程关于 *u* <sub>*h*</sub> 和 *v* <sub>*h*</sub> 函数*a*(*u*<sub>*h*</sub>、*v*这并不总是可能的，但是对于泊松方程的当前例子，我们可以通过部分积分获得这种形式:**

![$$ -\underset{\varOmega }{\int}\varDelta {u}_h{v}_h\ \mathrm{d}x=\underset{\varOmega }{\int}\nabla {u}_h\cdotp \nabla {v}_h\ \mathrm{d}x-\underset{\varOmega }{\int}\nabla \cdotp \left(\nabla {u}_h{v}_h\right)\mathrm{d}x=\underset{\varOmega }{\int}\nabla {u}_h\cdotp \nabla {v}_h\ \mathrm{d}x-\underset{\partial \varOmega }{\int}\left(\nabla {u}_h\cdotp n\right){v}_h\ d\varGamma, $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Eque.png)

其中，在第二个等式中，我们还应用高斯定理将第二项转化为在区域ω的边界∂ω上的积分。这里 ***n*** 是边界∂ω.向外的法向量没有将强形式的偏微分方程重写为弱形式的通用方法，每个问题都必须逐个解决。然而，这里使用的技术，即分部积分和用积分恒等式重写所得积分，可以用于许多经常出现的偏微分方程。

为了达到可以用标准线性代数方法逼近的双线性形式，我们还必须处理前面弱形式方程中的边界项。为此，假设问题在∂ω的一部分上满足狄利克雷边界条件记为γ<sub>d</sub>和在∂ω的其余部分上满足诺伊曼边界条件记为γ<sub>n</sub>:{*u*=*h*，*x*∈γ<sub>*d*</sub>}和{∇*u*∙***n***并不是所有的边界条件都是狄利克雷或诺依曼型的，但是这些边界条件涵盖了许多物理上的情况。

由于我们可以自由选择测试函数 *v* <sub>*h*</sub> ，我们可以让 *v* <sub>*h*</sub> 在满足狄利克雷边界条件的边界部分上消失。在这种情况下，我们得到 PDE 问题的以下弱形式:

![$$ \underset{\varOmega }{\int}\nabla {u}_h\cdotp \kern0.5em \nabla {v}_h\ \mathrm{d}x=\underset{\varOmega }{\int }\ f{v}_h\ \mathrm{d}x+\underset{\varGamma_{\mathrm{N}}}{\int }g\ {v}_h\ d\varGamma . $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equf.png)

如果我们将函数*u*<sub>T3】kT5】替换为基函数的线性组合，并将测试函数替换为它的一个基函数，我们得到一个代数方程:</sub>

![$$ \sum {U}_j\underset{\varOmega }{\int}\nabla {\phi}_j\cdotp \kern0.5em \nabla {\widehat{\phi}}_i\ \mathrm{d}x=\underset{\varOmega }{\int }\ f{\widehat{\phi}}_i\ \mathrm{d}x+\underset{\varGamma_{\mathrm{N}}}{\int }g{\widehat{\phi}}_i\ d\varGamma . $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equg.png)

如果*V*<sub>T5】k</sub>中有 *N 个*基函数，那么就有 *N 个*未知系数 *U* <sub>*i*</sub> ，我们需要 *N 个*-独立测试函数![$$ {\widehat{\phi}}_i $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq21.png)来得到一个封闭的方程组。该方程组的形式为 *AU* = *b* 其中![$$ {A}_{ij}=\underset{\varOmega }{\int}\nabla {\phi}_j\cdotp \nabla {\widehat{\phi}}_i\ \mathrm{d}x $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq22.png)和![$$ {b}_i=\underset{\varOmega }{\int }\ f{\widehat{\phi}}_i\ \mathrm{d}x+\underset{\varGamma_{\mathrm{N}}}{\int }g{\widehat{\phi}}_i\ d\varGamma . $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq23.png)遵循此程序，我们因此将 PDE 问题转化为线性方程组，该方程组可以使用前面章节中讨论的技术轻松求解。

在实践中，可能需要非常大量的基函数来获得精确解的良好近似，因此由 FEMs 生成的线性方程组通常非常大。然而，在问题域的离散化中，每个基函数仅在一个或几个附近元素处具有支持的事实确保了矩阵 *A* 是稀疏的，这使得它易于解决相当大规模的 FEM 问题。我们还注意到，基函数*【ϕ】*<sub>*I*</sub>和![$$ {\widehat{\phi}}_i $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq24.png)的一个重要性质是，应该很容易计算问题的最终弱形式中出现的表达式的导数和积分，从而可以高效地组装矩阵 *A* 和向量 *b* 。基函数的典型例子是仅在单个元素内非零的低阶多项式函数。见图 [11-3](#Fig3) 这种类型基函数的一维图解，其中区间[0，6]使用五个内点离散化，连续函数(黑色实线)通过适当加权的三角形基函数(蓝色/深灰色实线)近似为分段线性函数(红色/浅灰色虚线)。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig3_HTML.png](img/332789_2_En_11_Chapter/332789_2_En_11_Fig3_HTML.png)

图 11-3

一维域[0，6]的局部支持的可能基函数(蓝色/深灰色线)示例

当使用 FEM 软件求解 PDE 问题时，通常需要手动将 PDE 转换为弱形式，如果可能的话，将其重写为双线性形式 *a* ( *u* ， *v* ) = *L* ( *v* )。还需要对问题域进行适当的离散化。这种离散化称为网格，它通常由整个域的三角划分(或其高阶推广)组成。对复杂的问题域进行网格化本身就是一个复杂的过程，可能需要使用专门用于网格生成的复杂软件。对于简单的几何图形，有一些工具可以编程生成网格，我们将在下一节中看到这样的例子。

一旦生成了网格并且将 PDE 问题写成了合适的弱形式，我们就可以将该问题输入到 FEM 框架中，然后 FEM 框架自动组装代数方程系统并应用合适的稀疏方程解算器来寻找解决方案。在这个过程中，我们通常可以选择使用哪种类型的基函数，以及使用哪种类型的求解器。一旦代数方程被求解，我们可以在基函数的帮助下构造 PDE 的近似解，并且我们可以，例如，可视化该解或以某种其他方式对其进行后处理。

总之，使用 FEM 求解 PDE 通常包括以下步骤:

1.  为问题域生成网格。

2.  用弱形式写偏微分方程。

3.  在有限元框架内对问题进行编程。

4.  求解得到的代数方程。

5.  后处理和/或可视化解决方案。

在下一节中，我们将回顾可用于 Python 的 FEM 框架，然后看一些例子，这些例子说明了使用 FEM 的 PDE 求解过程中的一些关键步骤。

### 有限元程序库综述

对于 Python，至少有三个重要的 FEM 包:FiPy、SfePy 和 FEniCS。这些都是功能相当全面的框架，能够解决广泛的 PDE 问题。从技术上讲，FiPy 库不是 FEM 软件，而是有限体积法(FVM)软件，但这种方法的要点与 FEM 非常相似。FiPy 框架可以从 [`http://www.ctcms.nist.gov/fipy`](http://www.ctcms.nist.gov/fipy) 获得。SfePy 库是一个 FEM 软件，它采用稍微不同的方法来定义 PDE 问题，因为它使用 Python 文件作为其 FEM 解算器的配置文件，而不是以编程方式设置 FEM 问题(尽管这种操作模式在技术上也受 SfePy 支持)。SfePy 库可从 [`http://sfepy.org`](http://sfepy.org) 获得。使用 Python 的 FEM 的第三个主要框架是 FEniCS，它是为 C++和 Python 编写的。当谈到 Python 的 FEM 软件时，FEniCS 框架是我个人最喜欢的，因为它为强大的 FEM 引擎提供了优雅的 Python 接口。像 FDM 问题一样，FEM 问题通常导致非常大规模的方程系统，需要使用稀疏矩阵技术来有效地求解。因此，FEM 框架的关键部分是有效地解决大规模线性和非线性系统，使用稀疏矩阵表示和在稀疏系统上工作的直接或迭代求解器，可能使用并行化。上一节提到的每个框架都支持这种低级计算的多个后端。例如，许多 FEM 框架可以使用 PETSc 和 Trilinos 框架。

遗憾的是，我们无法在此深入探讨如何使用这些 FEM 框架，但在下一节中，我们将着眼于使用 FEniCS 解决示例问题，从而介绍它的一些基本特性和用法。希望这些例子可以让读者了解如何在 Python 中处理 FEM 问题，并为有兴趣学习更多关于 Python 中 FEM 的读者提供一个起点。

## 用 FEniCS 求解偏微分方程

在本节中，我们将使用 FEniCS 框架解决一系列日益复杂的偏微分方程，在此过程中，我们将介绍该 FEM 软件的工作流程和一些主要功能。有关 FEniCS 框架的全面介绍，请参见项目网站上的文档和 FEniCS 官方书籍(Anders Logg，2012)。

### 断续器

FEniCS 是一个高性能的 FEM 框架，由一组用于解决 PDE 问题的库和工具组成。FEniCS 的大部分是用 C++编程的，但它也提供了一个官方的 Python 接口。由于 FEniCS 库对外部低级数值库的许多依赖性的复杂性，FEniCS 通常作为独立的环境打包和安装，尽管它也可以在一些平台上使用 conda 安装。有关 FEniCS 的更多信息，请访问该项目的网站 [`http://fenicsproject.org`](http://fenicsproject.org) 。在撰写本文时，最新版本是 2018.1.0。

FEniCS 的 Python 接口由一个名为`dolfin`的库提供。对于网格生成，我们也将使用`mshr`库。在下面的代码中，我们假设这些库是完整导入的，如本章开头所示。对于这些库中最重要的函数和类的总结，见表 [11-1](#Tab1) 和表 [11-2](#Tab2) 。

表 11-2

`mshr`和`dolfin`库中所选函数和类的概要

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

功能/类别

 | 

描述

 |
| --- | --- |
| `dolfin.Point` | 坐标点的表示。 |
| `mshr.Circle` | 圆形几何对象的表示，可用于构成 2D 域。 |
| `mshr.Ellipse` | 椭圆形状的几何对象的表示。 |
| `mshr.Rectangle` | 在 2D 由矩形定义的域的表示。 |
| `mshr.Box` | 由 3D 中的方框定义的域的表示。 |
| `mshr.Sphere` | 3D 中由球体定义的域的表示。 |
| `mshr.generate_mesh` | 从由几何对象组成的域中生成网格，例如上一节中列出的对象。 |

表 11-1

`dolfin`库中所选函数和类的概要

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

功能/类别

 | 

描述

 | 

例子

 |
| --- | --- | --- |
| `parameters` | 保存 FEniCS 框架配置参数的字典。 | `dolfin.parameters["reorder_dofs_serial"]` |
| `RectangleMesh` | 用于生成矩形 2D 网格的对象。 | `mesh = dolfin.RectangularMesh(dolfin.Point(0, 0),dolfin.Point(1, 1), 10, 10)` |
| `MeshFunction` | 定义在给定网格上的函数。 | `dolfin.MeshFunction("size_t", mesh, mesh.topology().dim()-1)` |
| `FunctionSpace` | 用于表示函数空间的对象。 | `V = dolfin.FunctionSpace(mesh, 'Lagrange', 1)` |
| `TrialFunction` | 对象，用于表示在给定函数空间中定义的试验函数。 | `u  = dolfin.TrialFunction(V)` |
| `TestFunction` | 对象，用于表示给定函数空间中定义的测试函数。 | `v = dolfin.TestFunction(V)` |
| `Function` | 对象，用于表示以 PDE 的弱形式出现的未知函数。 | `u_sol = dolfin.Function(V)` |
| `Constant` | 用于表示固定常数的对象。 | `c = dolfin.Constant(1.0)` |
| `Expression` | 用空间坐标表示数学表达式。 | `dolfin.Expression("x[0]*x[0] + x[1]*x[1]")` |
| `DirichletBC` | 用于表示 Dirichlet 类型边界条件的对象。 | `dolfin.DirichletBC(V, u0, u0_boundary)` |
| `Equation` | 用于表示公式的对象，例如，通过对其他 FEniCS 对象使用==运算符生成的对象。 | `a == L` |
| `inner` | 内积的符号表示。 | `dolfin.inner(u, v)` |
| `nabla_grad` | 梯度算子的符号表示。 | `dolfin.nabla_grad(u)` |
| `dx` | 积分体积度量的符号表示。 | `f*v*dx` |
| `ds` | 积分线度量的符号表示。 | `g_v * v * dolfin.ds(0, domain=mesh, subdomain_data=boundary_parts)` |
| `assemble` | 通过对基函数进行积分来组合代数方程。 | `A = dolfin.assemble(a)` |
| `solve` | 解一个代数方程。 | `dolfin.solve(A, u_sol.vector(), b)` |
| `plot` | 绘制一个函数或表达式。 | `dolfin.plot(u_sol)` |
| `File` | 将函数写入可以用可视化软件(如 ParaView)打开的文件。 | `dolfin.File('u_sol.pvd') << u_sol` |
| `refine` | 通过将选择的现有网格元素分割成更小的部分来优化网格。 | `mesh = dolfin.refine(mesh, cell_markers)` |
| `AutoSubDomain` | 一个域的子集的表示，由作为参数传递给它的指示函数从所有元素中选择。 | `dolfin.AutoSubDomain(v_boundary_func)` |

在我们继续使用 FEniCS 和`dolfin` Python 库之前，我们需要通过`dolfin.parameters`字典设置两个配置参数，以获得我们在以下示例中需要的行为:

```py
In [37]: dolfin.parameters["reorder_dofs_serial"] = False
In [38]: dolfin.parameters["allow_extrapolation"] = True

```

从 FEniCS 开始，我们首先重新考虑二维稳态热方程，我们已经在本章早些时候用 FDM 求解了这个方程。这里我们考虑问题*u*<sub>*xx*</sub>+*u*<sub>*YY*</sub>=*f*，其中 *f* 为源函数。首先，我们假设边界条件为 *u* ( *x* = 0，*y*)=*u*(*x*= 1， *y* ) = 0， *u* ( *x* ，*y*= 0)=*u*(*x*在后面的例子中，我们将看到如何定义狄利克雷和诺依曼边界条件。**

用有限元法求解偏微分方程的第一步是定义一个描述问题域离散化的网格。在当前例子中，问题域是单位平方 *x* ，*y*∈【0，1】。对于像这样的简单几何图形，`dolfin`库中有生成网格的函数。这里我们使用`RectangleMesh`函数，它的前两个参数是坐标点( *x* <sub>0</sub> 、 *y* <sub>0</sub> )和( *x* <sub>1</sub> 、 *y* <sub>1</sub> )，表示为`dolfin.Point`实例，其中( *x* <sub>0</sub> 、 *y* 第五个和第六个参数分别是沿 *x* 和 *y* 方向的元素数量。生成的网格对象通过其丰富的显示系统在 Jupyter 笔记本中查看(这里我们生成一个不太精细的网格以显示网格结构)，如图 [11-4](#Fig4) 所示:

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig4_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig4_HTML.jpg)

图 11-4

使用`dolfin.RectangleMesh`生成的矩形网格

```py
In [39]: N1 = N2 = 75
In [40]: mesh = dolfin.RectangleMesh(dolfin.Point(0, 0), dolfin.Point(1, 1), N1, N2)
In [41]: dolfin.RectangleMesh(dolfin.Point(0, 0), dolfin.Point(1, 1), 10, 10)  # for display

```

问题域的网格是将问题离散成可以用数值方法处理的形式的关键。下一步是使用`dolfin.FunctionSpace`类为试验和测试函数定义函数空间的表示。这个类的构造函数至少有三个参数:一个网格对象、基函数类型的名称和基函数的次数。出于我们的目的，我们将使用拉格朗日型一次基函数(线性基函数):

```py
In [42]: V = dolfin.FunctionSpace(mesh, 'Lagrange', 1)

```

一旦创建了网格和函数空间对象，我们需要为试验函数*u*<sub>T5】h</sub>和测试函数 *v* <sub>*h*</sub> 创建对象，我们可以用它们来定义感兴趣的偏微分方程的弱形式。在 FEniCS 中，我们使用`dolfin.TrialFunction`和`dolfin.TestFunction`类来实现这个目的。它们都需要一个函数空间对象作为构造函数的第一个参数:

```py
In [43]: u = dolfin.TrialFunction(V)
In [44]: v = dolfin.TestFunction(V)

```

定义函数空间`V`以及试验和测试函数`u`和`v`的表示的目的是能够在弱形式上构造一般 PDE 的表示。对于我们在这里研究的稳态热方程，弱形式在上一节中被显示为(在没有诺依曼边界条件的情况下)

![$$ \underset{\varOmega }{\int}\nabla u\cdotp \nabla v\ \mathrm{d}x=\underset{\varOmega }{\int }\ fv\ \mathrm{d}x. $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_Equh.png)

为了达到这种形式，通常需要手动重写和转换 PDE 上的直接积分，通常是通过执行部分积分。在 FEniCS 中，PDE 本身是使用以弱形式出现的被积函数定义的，包括积分测度(即 d *x* )。为此，`dolfin`库提供了许多作用于试验和测试函数对象`v`和`u`的函数，这些函数用于表示这些函数上的操作，这些操作通常以弱形式的 PDE 出现。例如，在本例中，左侧积分的被积函数是∇*u*∙∇*v*d*x*。为了表示这个表达式，我们需要一个内积的符号表示， *u* 和 *v* 的梯度，以及积分测度 d *x* 。`dolfin`库中这些函数的名称分别是`inner`、`nabla_grad`和`dx`，使用这些函数我们可以创建一个 FEniCS 框架理解并可以使用的 *a* ( *u* 、*v*)=∇*u*∙∇*v*d*x*的表示:

```py
In [45]: a = dolfin.inner(dolfin.nabla_grad(u), dolfin.nabla_grad(v)) * dolfin.dx

```

同样，对于右手边，我们需要一个代表*b*(*v*)=*Fv*d*x*。此时，我们需要指定一个显式形式的 *f* (原始 PDF 中的源项)，以便能够继续解决问题。这里我们看两类函数: *f* = 1(一个常数)和*f*=*x*<sup>2</sup>+*y*<sup>2</sup>(一个 *x* 和 *y* 的函数)。为了表示 *f* = 1，我们可以使用`dolfin.Constant`对象。它将它所代表的常量的值作为唯一的参数:

```py
In [46]: f1 = dolfin.Constant(1.0)
In [47]: L1 = f1 * v * dolfin.dx

```

如果 *f* 是 *x* 和 *y* 的函数，我们需要用`dolfin.Expression`对象来表示 *f* 。该对象的构造函数将一个字符串作为第一个参数，该参数包含一个与函数相对应的表达式。这个表达式必须用 C++语法定义，因为 FEniCS 框架自动生成并编译 C++函数，以便高效地计算表达式。在表达式中，我们可以访问一个变量`x`，它是一个特定点的坐标数组，其中 *x* 被访问为`x[0]` , *y* 被访问为`x[1]`，以此类推。例如，要写出 *f* ( *x* ，*y*)=*x*<sup>2</sup>+*y*<sup>2</sup>的表达式，我们可以使用`"x[0]*x[0] + x[1]*x[1]"`。注意，因为我们需要在这个表达式中使用 C++语法，所以我们*不能*使用 Python 语法`x[0]**2`。`Expression`类还接受指定基函数阶数的关键字参数`degree`，或者，接受描述有限元素的关键字参数`element`，例如，可以使用函数空间对象`V`的`ufl_element`方法获得。

```py
In [48]: f2 = dolfin.Expression("x[0]*x[0] + x[1]*x[1]", degree=1)
In [49]: L2 = f2 * v * dolfin.dx

```

至此，我们已经定义了在偏微分方程的弱形式中出现的项的符号表示。下一步是定义边界条件。我们从一个简单一致的狄利克雷型边界条件开始。`dolfin`库包含一个类`DirichletBC`,用于表示这种类型的边界条件。我们可以使用这个类来表示问题域边界上的任意函数，但是在第一个例子中，考虑整个边界上的简单边界条件 *u* = 0。为了表示边界上的常数值(本例中为零)，我们可以再次使用`dolfin.Constant`类。

```py
In [50]: u0 = dolfin.Constant(0)

```

除了边界条件值，我们还需要定义一个函数(这里称为`u0_boundary`)，用于在创建`DirichletBC`类的实例时选择边界的不同部分。这个函数有两个参数:一个坐标数组`x`和一个标志`on_boundary`，标志表示一个点是否在网格的物理边界上，如果点`x`属于边界，它应该返回`True`，否则返回`False`。由于该函数是针对网格中的每个顶点进行评估的，因此通过定制该函数，可以将问题域中任意部分的函数值锁定为特定的值或表达式。然而，这里我们只需要选择物理边界上的所有点，所以我们可以简单地让`u0_boundary`函数返回`on_boundary`参数。

```py
In [51]: def u0_boundary(x, on_boundary):
    ...:      return on_boundary

```

一旦我们有了边界值的表达式`u0`和从网格顶点选择边界的函数`u0_boundary`，我们就可以用函数空间对象`V`最终创建`DirichletBC`对象:

```py
In [52]: bc = dolfin.DirichletBC(V, u0, u0_boundary)

```

这就完成了偏微分方程问题的说明，我们的下一步是通过从偏微分方程的弱形式表示集合矩阵和向量，将问题转换成代数形式。我们可以使用`dolfin.assemble`函数明确地做到这一点:

```py
In [53]: A = dolfin.assemble(a)
In [54]: b = dolfin.assemble(L1)
In [55]: bc.apply(A, b)

```

这导致矩阵 *A* 和向量 *b* 定义未知函数的代数方程组。这里我们还使用了`DirichletBC`类实例`bc`的`apply`方法，它修改了`A`和`b`对象，使得边界条件在方程中得到考虑。

为了最终解决问题，我们需要创建一个存储未知解的函数对象并调用`dolfin.solve`函数，提供`A`矩阵和`b`向量，以及一个`Function`对象的底层数据数组。我们可以通过调用对象上的`vector`方法来获取`Function`实例的数据数组。

```py
In [56]: u_sol1 = dolfin.Function(V)
In [57]: dolfin.solve(A, u_sol1.vector(), b)

```

这里我们将`Function`对象命名为`u_sol1`解，调用`dolfin.solve`函数求解方程组，并将值填入`u_sol1`对象的数据数组中。这里，我们通过显式组装`A`和`b`矩阵并将结果传递给`dolfin.solve`函数来解决 PDE 问题。这些步骤也可以由`dolfin.solve`函数自动执行，方法是将一个`dolfin.Equation`对象作为函数的第一个参数，将解决方案的`Function`对象作为第二个参数，将一个边界条件(或边界条件列表)作为第三个参数。我们可以创建`Equation`对象，例如使用`a == L2`:

```py
In [58]: u_sol2 = dolfin.Function(V)
In [59]: dolfin.solve(a == L2, u_sol2, bc)

```

这比我们使用`a == L1`的等价关系来寻找`u_sol1`的方法稍微简洁一些，但是在某些情况下，当一个问题需要在多种情况下解决时，使用矩阵`A`和/或向量`b`的显式组合会很有用，因此熟悉这两种方法是值得的。

有了作为 FEniCS `Function`对象的解决方案，我们可以通过多种方式对解决方案进行后处理和可视化。绘制解决方案的一个简单方法是使用内置的`dolfin.plot`函数，该函数可用于绘制网格对象、函数对象以及其他几种类型的对象(更多信息请参见`dolfin.plot`的 docstring)。例如，为了绘制解决方案`u_sol2,`，我们简单地调用`dolfin.plot(u_sol2)`。产生的图形窗口如图 [11-5](#Fig5) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig5_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig5_HTML.jpg)

图 11-5

*图中的* *网格函数* `u_sol2` *，由* `dolfin` *库中的* `plot` *函数产生*

```py
In [60]: dolfin.plot(u_sol2)

```

使用`dolfin.plot`是快速可视化解决方案或网格的好方法，但是为了更好地控制可视化，通常需要导出数据并在专用可视化软件中绘制，例如 ParaView <sup>[1](#Fn1)</sup> 。为了将解决方案`u_sol1`和`u_sol2`保存为可以用 ParaView 打开的格式，我们可以使用`dolfin.File`对象来生成 PVD 文件(VTK 文件的集合),并使用`<<`操作符将对象附加到文件中，以类似 C++流的方式:

```py
In [61]: dolfin.File('u_sol1.pvd') << u_sol1

```

我们还可以使用以下方法将多个对象添加到 PVD 文件中:

```py
In [62]: f = dolfin.File('u_sol_and_mesh.pvd')
    ...: f << mesh
    ...: f << u_sol1
    ...: f << u_sol2

```

将 FEniCS 对象的数据导出到可以用外部可视化软件加载和可视化的文件是一种受益于强大的可视化软件的许多优点的方法，例如交互性、并行处理和对可视化的高级控制，等等。然而，在许多情况下，最好在 Jupyter 笔记本中工作，以便可视化解决方案和网格。对于相对简单的一维、二维以及某种程度上的三维问题，我们可以使用 Matplotlib 直接可视化网格和求解函数。为了能够使用 Matplotlib，我们需要获得一个 NumPy 数组，其中包含与 FEniCS 函数对象相对应的数据。有几种方法可以构造这样的数组。首先，FEniCS function 对象可以像函数一样调用，带有一个坐标值数组(列表):

```py
In [63]: u_sol1([0.21, 0.67])
Out[63]: 0.0466076997781351

```

这允许我们在问题域内的任意点评估解决方案。我们还可以使用`vector`方法获得网格顶点处类似于`u_sol1`的函数对象的值作为 FEniCS 向量，然后使用`np.array`函数将其转换为 NumPy 数组。生成的 NumPy 数组是平面的(一维)，对于二维矩形网格的情况(如当前示例)，对平面数组进行整形就足以获得二维数组，例如，可以使用 Matplotlib 中的`pcolor`、`contour`或`plot_surface`函数绘制该数组。下面我们按照这些步骤将`u_sol1`和`u_sol2`函数对象的底层数据转换成 NumPy 数组，然后使用 Matplotlib 绘制。结果如图 [11-6](#Fig6) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig6_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig6_HTML.jpg)

图 11-6

*单位正方形上* *稳态热方程* *的解，源项 f* = 1 *(左)和 f*=*x*<sup>2</sup>+*y*<sup>2</sup>*(右)，条件是函数 u* ( *x* ， *y* )

```py
In [64]: u_mat1 = np.array(u_sol1.vector()).reshape(N1+1, N2+1)
In [65]: u_mat2 = np.array(u_sol2.vector()).reshape(N1+1, N2+1)
In [66]: X, Y = np.meshgrid(np.linspace(0, 1, N1+2), np.linspace(0, 1, N2+2))
In [67]: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    ...:
    ...: c = ax1.pcolor(X, Y, u_mat1, cmap=mpl.cm.get_cmap('Reds'))
    ...: cb = plt.colorbar(c, ax=ax1)
    ...: ax1.set_xlabel(r"$x$", fontsize=18)
    ...: ax1.set_ylabel(r"$y$", fontsize=18)
    ...: cb.set_label(r"$u(x, y)$", fontsize=18)
    ...: cb.set_ticks([0.0, 0.02, 0.04, 0.06])
    ...:
    ...: c = ax2.pcolor(X, Y, u_mat2, cmap=mpl.cm.get_cmap('Reds'))
    ...: cb = plt.colorbar(c, ax=ax2)
    ...: ax1.set_xlabel(r"$x$", fontsize=18)
    ...: ax1.set_ylabel(r"$y$", fontsize=18)
    ...: cb.set_label(r"$u(x, x)$", fontsize=18)
    ...: cb.set_ticks([0.0, 0.02, 0.04])

```

生成图形 [11-6](#Fig6) 的方法简单方便，但只适用于矩形网格。对于更复杂的网格，顶点坐标不是以结构化的方式组织的，简单的平面阵列数据的整形是不够的。然而，代表问题域网格的`Mesh`对象包含每个顶点的坐标列表。加上来自一个`Function`对象的值，这些可以组合成一个可以用 Matplotlib `triplot`和`tripcolor`函数绘制的表单。要使用这些绘图函数，我们首先需要从网格的顶点坐标创建一个`Triangulation`对象:

```py
In [68]: coordinates = mesh.coordinates()
    ...: triangles = mesh.cells()
    ...: triangulation = mpl.tri.Triangulation(coordinates[:, 0], coordinates[:, 1], triangles)

```

定义了三角测量对象后，我们可以使用`triplot`和`tripcolor`直接绘制 FEniCS 函数的数组数据，如下面的代码所示。得到的图形如图 [11-7](#Fig7) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig7_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig7_HTML.jpg)

图 11-7

与图 [11-6](#Fig6) 相同，除了该图是用 Matplotlib 的三角测量函数生成的。网格画在左边，偏微分方程的解画在右边

```py
In [69]: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))
    ...: ax1.triplot(triangulation)
    ...: ax1.set_xlabel(r"$x$", fontsize=18)
    ...: ax1.set_ylabel(r"$y$", fontsize=18)
    ...: cmap = mpl.cm.get_cmap('Reds')
    ...: c = ax2.tripcolor(triangulation, np.array(u_sol2.vector()), cmap=cmap)
    ...: cb = plt.colorbar(c, ax=ax2)
    ...: ax2.set_xlabel(r"$x$", fontsize=18)
    ...: ax2.set_ylabel(r"$y$", fontsize=18)
    ...: cb.set_label(r"$u(x, y)$", fontsize=18)
    ...: cb.set_ticks([0.0, 0.02, 0.04])

```

为了了解我们如何处理更复杂的边界条件，再次考虑热方程，这次没有源项*u*<sub>*xx*</sub>+*u*<sub>*YY*</sub>= 0，但是具有以下边界条件: *u* ( *x* = 0) = 3， *u* ( *x* = 1)，【T20 这和我们在本章前面用 FDM 方法解决的问题是一样的。这里我们再次用有限元法解决这个问题。和前面的例子一样，我们首先为问题域、函数空间以及试验和测试函数对象定义一个网格:

```py
In [70]: V = dolfin.FunctionSpace(mesh, 'Lagrange', 1)
In [71]: u = dolfin.TrialFunction(V)
In [72]: v = dolfin.TestFunction(V)

```

接下来，我们定义偏微分方程的弱形式。这里我们使用一个`dolfin.Constant`对象来表示 *f* ，设置 *f* = 0:

```py
In [73]: a = dolfin.inner(dolfin.nabla_grad(u), dolfin.nabla_grad(v)) * dolfin.dx
In [74]: f = dolfin.Constant(0.0)
In [75]: L = f * v * dolfin.dx

```

现在剩下的是根据给定的规范定义边界条件。在这个例子中，我们不想要一个适用于整个边界的统一边界条件，所以我们需要使用传递给`DirichletBC`类的边界选择函数的第一个参数，来挑选出边界的不同部分。为此，我们定义了四个函数来选择顶部、底部、左侧和右侧边界:

```py
In [76]: def u0_top_boundary(x, on_boundary):
    ...:     # on boundary and y == 1 -> top boundary
    ...:     return on_boundary and abs(x[1]-1) < 1e-5
In [77]: def u0_bottom_boundary(x, on_boundary):
    ...:     # on boundary and y == 0 -> bottom boundary
    ...:     return on_boundary and abs(x[1]) < 1e-5
In [78]: def u0_left_boundary(x, on_boundary):
    ...:     # on boundary and x == 0 -> left boundary
    ...:     return on_boundary and abs(x[0]) < 1e-5
In [79]: def u0_right_boundary(x, on_boundary):
    ...:     # on boundary and x == 1 -> left boundary
    ...:     return on_boundary and abs(x[0]-1) < 1e-5

```

每个边界处未知函数的值是简单的常数，我们可以用`dolfin.Constant`的实例来表示。因此，我们可以为每个边界创建`DirichletBC`的实例，结果对象被收集在一个列表`bcs`中:

```py
In [80]: bc_t = dolfin.DirichletBC(V, dolfin.Constant(5), u0_top_boundary)
    ...: bc_b = dolfin.DirichletBC(V, dolfin.Constant(-5), u0_bottom_boundary)
    ...: bc_l = dolfin.DirichletBC(V, dolfin.Constant(3), u0_left_boundary)
    ...: bc_r = dolfin.DirichletBC(V, dolfin.Constant(-1), u0_right_boundary)
In [81]: bcs = [bc_t, bc_b, bc_r, bc_l]

```

有了这个边界条件的规范，我们可以通过调用`dolfin.solve`继续求解 PDE 问题。使用 Matplotlib 的`pcolor`函数，将转换为 NumPy 数组的结果向量用于绘制解决方案。结果如图 [11-8](#Fig8) 所示。通过与图 [11-2](#Fig2) 所示的相应 FDM 计算结果进行比较，我们可以得出结论，这两种方法确实给出了相同的结果。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig8_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig8_HTML.jpg)

图 11-8

单位正方形两侧具有不同 Dirichlet 边界条件的热传导方程的稳态解

```py
In [82]: u_sol = dolfin.Function(V)
In [83]: dolfin.solve(a == L, u_sol, bcs)
In [84]: u_mat = np.array(u_sol.vector()).reshape(N1+1, N2+1)
In [85]: x = np.linspace(0, 1, N1+2)
    ...: y = np.linspace(0, 1, N1+2)
    ...: X, Y = np.meshgrid(x, y)
In [86]: fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    ...: c = ax.pcolor(X, Y, u_mat, vmin=-5, vmax=5, cmap=mpl.cm.get_cmap('RdBu_r'))
    ...: cb = plt.colorbar(c, ax=ax)
    ...: ax.set_xlabel(r"$x_1$", fontsize=18)
    ...: ax.set_ylabel(r"$x_2$", fontsize=18)
    ...: cb.set_label(r"$u(x_1, x_2)$", fontsize=18)

```

到目前为止，我们已经用有限元法解决了我们用 FDM 解决的同类问题，但是当考虑具有更复杂几何问题的偏微分方程问题时，有限元法的真正优势首先变得明显。为了说明这一点，考虑由五个小圆贯穿的单位圆上的热量方程，其中一个小圆以原点为中心，其他四个小圆如下图所示。要为这样的几何图形生成网格，我们可以使用 FEniCS 附带的`mshr`库。提供几何图元(`Point`、`Circle`、`Rectangle`等)。)可用于代数(集合)运算，为感兴趣的问题域组成网格。这里我们首先创建一个单位圆，使用`mshr.Circle`以(0，0)为中心，并从中减去其他`Circle`对象，这些对象对应于应该被移除的网格部分。生成的网格如图 [11-9](#Fig9) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig9_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig9_HTML.jpg)

图 11-9

由`mshr`库生成的网格对象

```py
In [87]: r_outer = 1
    ...: r_inner = 0.25
    ...: r_middle = 0.1
    ...: x0, y0 = 0.4, 0.4
In [88]: domain = mshr.Circle(dolfin.Point(.0, .0), r_outer) \
    ...:     - mshr.Circle(dolfin.Point(.0, .0), r_inner) \
    ...:     - mshr.Circle(dolfin.Point( x0,  y0), r_middle) \
    ...:     - mshr.Circle(dolfin.Point( x0, -y0), r_middle) \
    ...:     - mshr.Circle(dolfin.Point(-x0,  y0), r_middle) \
    ...:     - mshr.Circle(dolfin.Point(-x0, -y0), r_middle)
In [89]: mesh = mshr.generate_mesh(domain, 10)

```

这种网格的物理解释是，几何形状是穿过材料块的五个管道的横截面，其中，例如，内部管道输送热流体，外部管道输送冷流体，用于冷却材料块(例如，被冷却管围绕的发动机气缸)。考虑到这种解释，我们将内部管道的边界条件设置为较高的值![$$ {\left.{u}_0\left(x,y\right)\right|}_{x^2+{y}^2={r}_{\mathrm{outer}}^2}=10 $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq25.png)，将周围较小的管道设置为较低的值![$$ {\left.{u}_0\left(x,y\right)\right|}_{{\left(x-{x}_0\right)}^2+{\left(y-{y}_0\right)}^2={r}_{\mathrm{inner}}^2}=0 $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq26.png)，其中(*x*T5】0，*y*T9】0)是每个较小管道的中心。我们不指定外部边界，这相当于 Neumann 边界条件的特殊情况:![$$ \frac{\partial u(x)}{\partial n}=0 $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq27.png)。和以前一样，我们定义了在边界上挑选顶点的函数。由于我们在不同的边界上有不同的边界条件，这里我们也需要使用坐标参数`x`来确定哪些顶点属于哪个边界。

```py
In [90]: def u0_inner_boundary(x, on_boundary):
    ...:     x, y = x[0], x[1]
    ...:     return on_boundary and abs(np.sqrt(x**2 + y**2) - r_inner) < 5e-2
In [91]: def u0_middle_boundary(x, on_boundary):
    ...:     x, y = x[0], x[1]
    ...:     if on_boundary:
    ...:         for _x0 in [-x0, x0]:
    ...:             for _y0 in [-y0, y0]:
    ...:                 if abs(np.sqrt((x-_x0)**2 + (y-_y0)**2) - r_middle) < 5e-2:
    ...:                     return True
    ...:     return False
In [92]: bc_inner = dolfin.DirichletBC(V, dolfin.Constant(10), u0_inner_boundary)
    ...: bc_middle = dolfin.DirichletBC(V, dolfin.Constant(0), u0_middle_boundary)
In [93]: bcs = [bc_inner, bc_middle]

```

一旦指定了网格和边界条件，我们就可以像往常一样定义函数空间、试验函数和测试函数，并构造偏微分方程问题的弱形式表示:

```py
In [94]: V = dolfin.FunctionSpace(mesh, 'Lagrange', 1)
In [95]: u = dolfin.TrialFunction(V)
In [96]: v = dolfin.TestFunction(V)
In [97]: a = dolfin.inner(dolfin.nabla_grad(u), dolfin.nabla_grad(v)) * dolfin.dx
In [98]: f = dolfin.Constant(0.0)
In [99]: L = f * v * dolfin.dx
In [100]: u_sol = dolfin.Function(V)

```

解决和可视化问题也遵循与之前相同的模式。绘制解决方案的结果如图 [11-10](#Fig10) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig10_HTML.png](img/332789_2_En_11_Chapter/332789_2_En_11_Fig10_HTML.png)

图 11-10

穿孔单位圆上热方程的解

```py
In [101]: dolfin.solve(a == L, u_sol, bcs)
In [102]: coordinates = mesh.coordinates()
     ...: triangles = mesh.cells()
     ...: triangulation = mpl.tri.Triangulation(
     ...:     coordinates[:, 0], coordinates[:, 1], triangles)
In [103]: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))
     ...: ax1.triplot(triangulation)
     ...: ax1.set_xlabel(r"$x$", fontsize=18)
     ...: ax1.set_ylabel(r"$y$", fontsize=18)
     ...: c = ax2.tripcolor(
     ...:     triangulation, np.array(u_sol.vector()), cmap=mpl.cm.get_cmap("Reds"))
     ...: cb = plt.colorbar(c, ax=ax2)
     ...: ax2.set_xlabel(r"$x$", fontsize=18)
     ...: ax2.set_ylabel(r"$y$", fontsize=18)
     ...: cb.set_label(r"$u(x, y)$", fontsize=18)
     ...: cb.set_ticks([0.0, 5, 10, 15])

```

这种几何形状的问题用 FDM 方法很难处理，但用有限元法可以相对容易地处理。一旦我们获得了一个 FEM 问题的解，即使对于复杂的问题边界，我们也可以相对容易地用除了绘图以外的其他方法对解函数进行后处理。例如，我们可能对某个边界上的函数值感兴趣。例如，在当前问题中，很自然地要查看问题域外半径上的温度，例如，查看由于四个冷却管，物体的外部温度降低了多少。为了进行这种分析，我们需要一种从`u_sol`对象中挑出边界值的方法。我们可以通过定义一个描述边界的对象(这里用的是`dolfin.AutoSubDomain`)并将其应用到一个新的`Function`对象来实现，该对象被用作从`u_sol`和`mesh.coordinates()`中选择所需元素的遮罩。在下文中，我们称这个屏蔽功能为`mask_outer`。

```py
In [104]: outer_boundary = dolfin.AutoSubDomain(
     ...:     lambda x, on_bnd: on_bnd and abs(np.sqrt(x[0]**2 + x[1]**2) - r_outer) < 5e-2)
In [105]: bc_outer = dolfin.DirichletBC(V, 1, outer_boundary)
In [106]: mask_outer = dolfin.Function(V)
In [107]: bc_outer.apply(mask_outer.vector())
In [108]: u_outer = u_sol.vector()[mask_outer.vector() == 1]
In [109]: x_outer = mesh.coordinates()[mask_outer.vector() == 1]

```

通过这些步骤，我们创建了外边界条件的屏蔽，并将其应用于`u_sol.vector()`和`mesh.coordinates()`，从而获得了外边界点的函数值和坐标。接下来，我们将边界数据绘制成( *x* 、 *y* )点和 *x* 轴之间角度的函数。结果如图 [11-11](#Fig11) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig11_HTML.png](img/332789_2_En_11_Chapter/332789_2_En_11_Fig11_HTML.png)

图 11-11

穿孔单位圆外边界的温度分布

```py
In [110]: phi = np.angle(x_outer[:, 0] + 1j * x_outer[:, 1])
In [111]: order = np.argsort(phi)
In [112]: fig, ax = plt.subplots(1, 1, figsize=(8, 4))
     ...: ax.plot(phi[order], u_outer[order], 's-', lw=2)
     ...: ax.set_ylabel(r"$u(x,y)$ at $x^2+y^2=1$", fontsize=18)
     ...: ax.set_xlabel(r"$\phi$", fontsize=18)
     ...: ax.set_xlim(-np.pi, np.pi)

```

用 FEM 计算的 PDE 的解的精度与代表问题域的网格中的元素大小密切相关:更精细的网格给出更精确的解。然而，增加网格中元素的数量也使得解决该问题需要更多的计算。因此，必须考虑网格精度和可用计算资源之间的权衡。处理这种折衷的一个重要工具是具有非均匀分布元素的网格。有了这样的网格，我们可以在未知函数的值预计会快速变化的地方使用较小的元素，在不太感兴趣的区域使用较少的元素。使用`dolfin.refine`函数，`dolfin`库提供了一种简单的方法来细化网格。它将一个网格作为第一个参数，如果没有给定其他参数，它将统一优化该网格并返回一个新的网格。然而，`dolfin.refine`函数也接受一个可选的第二个参数，描述网格的哪些部分应该被细化。这个参数应该是一个布尔值`dolfin.MeshFunction`的实例，它作为一个掩码来标记哪些元素(单元格)应该被划分。例如，考虑单位圆的网格减去象限中的部分，其中*x*T10】0 和*y*T11】0。我们可以使用`mshr.Circle`和`mshr.Rectangle`为这个几何体构建一个网格:

```py
In [113]: domain = mshr.Circle(dolfin.Point(.0, .0), 1.0) \
     ...:     - mshr.Rectangle(dolfin.Point(0.0, -1.0), dolfin.Point(1.0, 0.0))
In [114]: mesh = mshr.generate_mesh(domain, 10)

```

生成的网格如图 [11-12](#Fig12) 左侧所示。通常希望在几何图形的尖角附近使用具有更精细结构的网格。对于此示例，尝试在靠近原点的边周围细化网格是合理的。为此，我们需要创建一个`dolfin.MeshFunction`的实例；使用`set_all`方法将其所有元素初始化为`False`；遍历元素，将原点附近的元素标记为`True`；最后用网格和`MeshFunction`实例作为参数调用`dolfin.refine`函数。我们可以重复这样做，直到获得足够精细的网格。在下文中，我们迭代地调用`dolfin.refine`，标记为分裂的单元格数量减少:

```py
In [115]: refined_mesh = mesh
     ...: for r in [0.5, 0.25]:
     ...:      cell_markers = dolfin.MeshFunction("bool", refined_mesh, dim=2)
     ...:      cell_markers.set_all(False)
     ...:      for cell in dolfin.cells(refined_mesh):
     ...:          if cell.distance(dolfin.Point(.0, .0)) < r:
     ...:              # mark cells within a radius r from the origin to be split
     ...:              cell_markers[cell] = True
     ...:      refined_mesh = dolfin.refine(refined_mesh, cell_markers)

```

生成的网格`refined_mesh`是原始网格的一个版本，在原点附近具有更精细的元素划分。以下代码绘制两个网格进行比较，结果如图 [11-12](#Fig12) 所示。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig12_HTML.png](img/332789_2_En_11_Chapter/332789_2_En_11_Fig12_HTML.png)

图 11-12

四分之三单位圆的原始网格和精细网格

```py
In [116]: def mesh_triangulation(mesh):
     ...:     coordinates = mesh.coordinates()
     ...:     triangles = mesh.cells()
     ...:     triangulation = mpl.tri.Triangulation(coordinates[:, 0], coordinates[:, 1],
     ...:     return triangulation
In [117]: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))
     ...:
     ...: ax1.triplot(mesh_triangulation(mesh))
     ...: ax2.triplot(mesh_triangulation(refined_mesh))
     ...:
     ...: # hide axes and ticks
     ...: for ax in [ax1, ax2]:
     ...:     for side in ['bottom','right','top','left']:
     ...:         ax.spines[side].set_visible(False)
     ...:         ax.set_xticks([])
     ...:         ax.set_yticks([])
     ...:         ax.xaxis.set_ticks_position('none')
     ...:         ax.yaxis.set_ticks_position('none')
     ...:
     ...: ax.set_xlabel(r"$x$", fontsize=18)
     ...: ax.set_ylabel(r"$y$", fontsize=18)

```

使用`dolfin.refine`细化网格是一种实用的技术，可以改进使用几何图元表达式构建的简单网格，就像我们在本章中使用的一样。作为使用 FEniCS 的最后一个例子，我们考虑稳态热方程的另一个例子，对单位圆的四分之三使用这种精细网格，其中我们在沿着单位圆的缺失的四分之一的垂直和水平边界上施加 Neumann 边界条件:对于垂直边缘，我们假设热的流出由∇*u*∙*T4】n*= 2， *x* = 0 描述， *y*

像往常一样，我们首先为函数空间、测试函数和试验函数创建对象:

```py
In [118]: mesh = refined_mesh
In [119]: V = dolfin.FunctionSpace(mesh, 'Lagrange', 1)
In [120]: u = dolfin.TrialFunction(V)
In [121]: v = dolfin.TestFunction(V)

```

对于 Neumann 边界条件的问题，我们需要将边界条件包含在 PDE 的弱形式中。回想一下泊松方程的弱形式是![$$ \underset{\varOmega }{\int}\nabla u\cdotp \nabla v\ \mathrm{d}x=\underset{\varOmega }{\int }\ fv\ \mathrm{d}x+\underset{\varGamma_{\mathrm{N}}}{\int }g\ v\ d\varGamma $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq28.png)，因此与前面的例子相比，我们需要考虑附加项![$$ \underset{\varGamma_{\mathrm{N}}}{\int }g\ v\ d\varGamma $$](img/332789_2_En_11_Chapter/332789_2_En_11_Chapter_TeX_IEq29.png)，它是带有诺依曼边界条件的边界上的积分。为了在弱形式规范中表示这个积分的积分测度，我们可以使用`dolfin.ds`，但是为了能够区分边界的不同部分，我们首先需要标记边界部分。在 FEniCS 中这样做的一种方法是使用一个`dolfin.MeshFunction`对象，并为边界的每个不同部分分配一个唯一的整数值。为此，我们首先创建一个`dolfin.MeshFunction`实例:

```py
In [122]: boundary_parts = dolfin.MeshFunction("size_t", mesh, mesh.topology().dim()-1)

```

接下来，我们定义一个选择边界点的函数和一个从边界选择函数初始化的`dolfin.AutoSubDomain`实例。然后可以使用`AutoSubDomain`实例用一个标识整数值来标记`MeshFunction`(这里称为`boundary_parts`)中相应的单元格。下面几行代码对网格的垂直边执行这些步骤，其中 *x* = 0， *y* < 0:

```py
In [121]: def v_boundary_func(x, on_boundary):
     ...:     """ the vertical edge of the mesh, where x = 0 and y < 0 """
     ...:     x, y = x[0], x[1]
     ...:     return on_boundary and abs(x) < 1e-4 and y < 0.0
In [122]: v_boundary = dolfin.AutoSubDomain(v_boundary_func)
In [123]: v_boundary.mark(boundary_parts, 0)

```

我们对网格的水平边缘重复相同的过程，其中 *y* = 0 和 *x* > 0:

```py
In [124]: def h_boundary_func(x, on_boundary):
     ...:     """ the horizontal edge of the mesh, where y = 0 and x > 0 """
     ...:     x, y = x[0], x[1]
     ...:     return on_boundary and abs(y) < 1e-4 and x > 0.0
In [125]: h_boundary = dolfin.AutoSubDomain(h_boundary_func)
In [126]: h_boundary.mark(boundary_parts, 1)

```

我们也可以用同样的方法来定义狄利克雷边界条件。这里，我们标记由狄利克雷边界条件描述的边界部分，然后在创建`dolfin.DirichletBC`对象时使用它:

```py
In [127]: def outer_boundary_func(x, on_boundary):
     ...:     x, y = x[0], x[1]
     ...:     return on_boundary and abs(x**2 + y**2-1) < 1e-2
In [128]: outer_boundary = dolfin.AutoSubDomain(outer_boundary_func)
In [129]: outer_boundary.mark(boundary_parts, 2)
In [130]: bc = dolfin.DirichletBC(V, dolfin.Constant(0.0), boundary_parts, 2)

```

一旦划定了界限，我们就可以着手创建偏微分方程的弱形式。因为我们在这里使用分区边界，所以我们需要使用`mesh`和`boundary_parts`对象为积分度量`dolfin.dx`和`dolfin.ds`指定`domain`和`subdomain`参数。

```py
In [131]: dx = dolfin.dx(domain=mesh, subdomain_data=boundary_parts)
In [132]: a = dolfin.inner(dolfin.nabla_grad(u), dolfin.nabla_grad(v)) * dx
In [133]: f = dolfin.Constant(0.0)
In [134]: g_v = dolfin.Constant(-2.0)
In [135]: g_h = dolfin.Constant(1.0)
In [136]: L = f * v * dolfin.dx(domain=mesh, subdomain_data=boundary_parts)
In [137]: L += g_v * v * dolfin.ds(0, domain=mesh, subdomain_data=boundary_parts)
In [138]: L += g_h * v * dolfin.ds(1, domain=mesh, subdomain_data=boundary_parts)

```

在最后两个代码单元中，我们为网格中的垂直和水平边添加了新的 Neumann 边界条件。边界的这些部分分别由整数 0 和 1 表示，如前一节所定义，这些整数作为参数传递给`dolfin.ds`以选择边界不同部分的积分。

```py
In [139]: u_sol = dolfin.Function(V)
In [140]: dolfin.solve(a == L, u_sol, bc)

```

一旦定义了 PDE 的弱形式的表示，我们就可以继续使用`dolfin.solve`来解决问题，就像我们在前面的例子中所做的那样。最后，我们使用 Matplotlib 的三角测量绘图函数来绘制解决方案。结果如图 [11-13](#Fig13) 所示。从图中我们可以看到，正如预期的那样，解在原点的边附近有更多的结构。因此，在该区域中使用具有较小元素的网格是在该区域中获得足够分辨率的好方法，而不会由于使用均匀精细结构的网格而带来过多的计算成本。

![img/332789_2_En_11_Chapter/332789_2_En_11_Fig13_HTML.jpg](img/332789_2_En_11_Chapter/332789_2_En_11_Fig13_HTML.jpg)

图 11-13

具有 Neumann 和 Dirichlet 边界条件的四分之一单位圆上热方程的解

```py
In [141]: fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))
     ...: triangulation = mesh_triangulation(mesh)
     ...: ax1.triplot(triangulation)
     ...: ax1.set_xlabel(r"$x$", fontsize=18)
     ...: ax1.set_ylabel(r"$y$", fontsize=18)
     ...:
     ...: data = np.array(u_sol.vector())
     ...: norm = mpl.colors.Normalize(-abs(data).max(), abs(data).max())
     ...: c = ax2.tripcolor(triangulation, data, norm=norm, cmap=mpl.cm.get_cmap("RdBu_r"))
     ...: cb = plt.colorbar(c, ax=ax2)
     ...: ax2.set_xlabel(r"$x$", fontsize=18)
     ...: ax2.set_ylabel(r"$y$", fontsize=18)
     ...: cb.set_label(r"$u(x, y)$", fontsize=18)
     ...: cb.set_ticks([-.5, 0, .5])

```

我们在本节中探讨的例子仅仅是 FEniCS 框架可以用于解决的问题类型的几个简单演示。FEniCS 中有大量的功能，我们甚至无法在此提及。对于对解决 PDE 问题特别感兴趣的读者，我推荐学习 FEniCS 的书(Anders Logg，2012)以及其中包含的许多示例应用。特别地，用 FEM 求解 PDEs 的重要方面是我们在这里无法讨论的非平凡的 Neumann 边界条件(需要包括在 PDE 的弱形式的公式中)、向量值函数的 PDEs、更高维的 PDE 问题(例如，三维中的热方程)和依赖于时间的 PDE 问题。所有这些主题以及许多其他主题都在 FEniCS 框架中得到了很好的支持。

## 摘要

在本章中，我们简要介绍了求解偏微分方程(PDEs)的方法，以及如何在科学 Python 环境中使用这些方法。具体来说，我们介绍了解决偏微分方程问题的有限差分法(FDM)和有限元法(FEM ),并用这些方法解决了几个实例问题。FDM 的优点是它的简单性，并且对于容易应用的问题(简单的问题域，统一的离散化，等等)。)，是一个很实用的方法。对于更复杂的 PDE 问题，例如，问题域更复杂，FEM 通常更适合。然而，FEM 的数学理论更为复杂，其实现也更具技术性。虽然有许多高级的 FEM 框架可以在 Python 中使用，但在本章中，我们主要关注一个突出的例子:FEniCS 框架。FEniCS 是一个功能齐全的有限元软件，可用于广泛的偏微分方程问题。对于这里所考虑的例子，我们仅仅了解了该软件所能实现的一些皮毛。然而，希望本章所研究的例子能让你对用 FEM 解决 PDE 问题，尤其是使用 FEniCS 软件时的工作流程有一个大致的了解。

## 进一步阅读

虽然我们在本章中讨论了 FDM 和有限元法，但也有其它成功的和有用的方法来数值求解偏微分方程。例如，有限体积法(FVM)是有限元法的一种变体，常用于流体动力学计算以及其他领域。Python 库 FiPy 提供了使用该方法解决 PDE 问题的框架，并且在例如 Wesseling (2009)中给出了该方法的理论介绍。这一章给出的关于 FDM 和有限元法的理论背景信息确实非常简单，它仅仅是用来介绍这里使用的术语和符号。对于 FDM 的严肃工作，特别是有限元方法，彻底理解这些方法的基本原理是很重要的。关于 FDM 和 FEM 的很好的介绍在例如 Gockenbach (2011)、Gockenbach (2006)、Johnson (2009)和 LeVeque (2007)中给出。FEniCS 图书(Logg，2012)可从 FEniCS 项目的网站( [`http://fenicsproject.org`](http://fenicsproject.org) )免费在线获得，除了 FEniCS 软件本身的详细文档外，还包含对 FEM 方法的详细介绍。

## 参考

k . a . m . Anders Logg(2012 年)。用有限元法自动解微分方程。斯普林格。

米·戈肯巴赫(2011 年)。偏微分方程。费城:暹罗。

戈肯巴赫(2006 年)。理解和实施有限元方法。费城:暹罗。

约翰逊(2009 年)。偏微分方程的有限元数值解。剑桥:多佛。

勒维克，R. (2007)。常微分方程和偏微分方程的有限差分法:稳态和时间相关问题。费城:暹罗。

韦塞林，P. (2009 年)。计算流体动力学原理。柏林:施普林格。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

[T2`http://www.paraview.org`](http://www.paraview.org)

 </aside>****