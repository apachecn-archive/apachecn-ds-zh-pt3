# 3.NumPy 图书馆

NumPy 是一个用 Python 进行科学计算的基本包，特别是用于数据分析。事实上，这个库是大量数学和科学 Python 包的基础，其中就有熊猫库，你将在本书后面看到。这个专门用于数据分析的库是使用 NumPy 引入的概念完全开发的。事实上，标准 Python 库提供的内置工具对于数据分析中的大部分计算来说可能过于简单或不合适。

了解 NumPy 库对于能够使用所有科学 Python 包，尤其是使用和理解 pandas 库是很重要的。熊猫图书馆是以下章节的主题。

如果你已经熟悉这个库，可以直接进入下一章；否则，您可能会将本章视为复习基本概念或通过运行本章中的示例来重新熟悉基本概念的一种方式。

## 一点历史

在 Python 语言出现之初，开发人员需要执行数值计算，特别是当这种语言被科学界使用时。

第一次尝试是由 Jim Hugunin 在 1995 年开发的 Numeric，随后是一个名为 Numarray 的替代包。这两个包都是专门用于数组计算的，并且每个包都有各自的优势，这取决于它们在什么情况下使用。因此，在不同的情况下，它们会有不同的用法。这种模糊性导致了将两个包统一起来的想法。为此，Travis Oliphant 开始开发 NumPy 库。它的第一个版本(1.0 版)出现在 2006 年。

从那一刻起，NumPy 被证明是 Python 用于科学计算的扩展库，是目前应用最广泛的用于多维数组和大型数组计算的包。此外，该软件包附带了一系列函数，允许您以高效的方式对数组执行操作，并执行高级数学计算。

目前，NumPy 是开源的，并在 B SD 下授权。有许多贡献者扩大了这个图书馆的潜力。

## NumPy 装置

通常，这个模块在大多数 Python 发行版中是作为一个基本包出现的；但是，如果没有，您可以稍后安装。

在 Linux (Ubuntu 和 Debian)上，使用:

```py
sudo apt-get install python-numpy

```

在 Linux 上(Fedora)

```py
sudo yum install numpy scipy

```

在带有 Anaconda 的 Windows 上，使用:

```py
conda install numpy

```

在您的发行版上安装了 NumPy 之后，要在 Python 会话中导入 NumPy 模块，请编写以下代码:

```py
>>> import numpy as np

```

## Ndarray:图书馆的心脏

NumPy 库基于一个主对象: *ndarray* (代表 N 维数组)。这个对象是一个多维同质数组，具有预定数量的项:同质是因为其中几乎所有的项都是相同类型和相同大小的。事实上，数据类型是由另一个名为 *dtype* (数据类型)的 NumPy 对象指定的；每个 ndarray 只与一种类型的数据类型相关联。

一个数组中的维度和项目的数量是由其形状定义的，这个形状是由正整数组成的元组，指定了每个维度的大小。尺寸定义为*轴*，轴数定义为*秩*。

此外，NumPy 数组的另一个特点是它们的大小是固定的，也就是说，一旦在创建时定义了它们的大小，它就保持不变。这种行为不同于 Python 列表，Python 列表的大小可以增长或收缩。

定义一个新的 ndarray 的最简单的方法是使用`array()`函数，传递一个包含要包含在其中的元素的 Python 列表作为参数。

```py
>>> a = np.array([1, 2, 3])
>>> a
array([1, 2, 3])

```

通过将新变量传递给`type()`函数，可以很容易地检查新创建的对象是否是 ndarray。

```py
>>> type(a)
<type 'numpy.ndarray'>

```

为了知道新创建的 ndarray 的相关数据类型，您必须使用`dtype`属性。

### 注意

在不同的操作系统和 Python 发行版中，`dtype`、`shape`和其他属性的结果会有所不同。

```py
>>> a.dtype
dtype('int64')

```

刚刚创建的数组有一个轴，那么它的秩是 1，而它的形状应该是(3，1)。要从相应的数组中获取这些值，使用`ndim`属性获取轴，使用`size`属性了解数组长度，使用`shape`属性获取其形状就足够了。

```py
>>> a.ndim
1
>>> a.size
3
>>> a.shape
(3,)

```

你刚才看到的是一维数组最简单的情况。但是数组的使用可以很容易地扩展到几个维度。例如，如果定义一个二维数组 2x2:

```py
>>> b = np.array([[1.3, 2.4],[0.3, 4.1]])
>>> b.dtype
dtype('float64')
>>> b.ndim
2
>>> b.size
4
>>> b.shape
(2, 2)

```

这个数组的秩为 2，因为它有两个轴，每个轴的长度都是 2。

另一个重要的属性是`itemsize` **，**可以和 ndarray 对象一起使用。它定义了数组中每一项的字节大小，`data`是包含数组实际元素的缓冲区。第二个属性仍然没有被广泛使用，因为要访问数组中的数据，您将使用索引机制，您将在下一节中看到。

```py
>>> b.itemsize
8
>>> b.data
<read-write buffer for 0x0000000002D34DF0, si

ze 32, offset 0 at 0x0000000002D5FEA0>

```

### 创建一个数组

要创建新的数组，您可以遵循不同的路径。最常见的路径是您在上一节中看到的作为`array()`函数参数的一个列表或列表序列。

```py
>>> c = np.array([[1, 2, 3],[4, 5, 6]])
>>> c
array([[1, 2, 3],
       [4, 5, 6]])

```

除了列表之外，`array()`函数还可以接受元组和元组序列。

```py
>>> d = np.array(((1, 2, 3),(4, 5, 6)))
>>> d
array([[1, 2, 3],
       [4, 5, 6]])

```

它还可以接受元组序列和互连列表。

```py
>>> e = np.array([(1, 2, 3), [4, 5, 6], (7, 8, 9)])
>>> e
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9

]])

```

### 数据类型

到目前为止，您只看到了简单的整数和浮点数值，但是 NumPy 数组被设计为包含各种各样的数据类型(参见表 [3-1](#Tab1) )。例如，您可以使用数据类型字符串:

表 3-1

NumPy 支持的数据类型

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

数据类型

 | 

描述

 |
| --- | --- |
| `bool_` | 以字节形式存储的布尔值(真或假) |
| `int_` | 默认整数类型(同 C long 通常是`int64`或`int32` |
| `intc` | 与 C int 相同(通常为`int32`或`int64`) |
| `intp` | 用于索引的整数(同 C`size_t`；通常不是`int32`就是`int64` |
| `int8` | 字节(–128 到 127) |
| `int16` | 整数(–32768 到 32767) |
| `int32` | 整数(–2147483648 到 2147483647) |
| `int64` | 整数(–9223372036854775808 到 9223372036854775807) |
| `uint8` | 无符号整数(0 到 255) |
| `uint16` | 无符号整数(0 到 65535) |
| `uint32` | 无符号整数(0 到 4294967295) |
| `uint64` | 无符号整数(0 到 18446744073709551615) |
| `float_` | `float64`的简写 |
| `float16` | 半精度浮点:符号位、5 位指数、10 位尾数 |
| `float32` | 单精度浮点:符号位、8 位指数、23 位尾数 |
| `float64` | 双精度浮点:符号位、11 位指数、52 位尾数 |
| `complex_` | 复杂 128 的简写 |
| `complex64` | 复数，由两个 32 位浮点数表示(实部和虚部) |
| `complex128` | 复数，由两个 64 位浮点数表示(实部和虚部) |

```py
>>> g = np.array([['a', 'b'],['c', 'd']])
>>> g
array([['a', 'b'],
            ['c', 'd']],
      dtype='|<U1')
>>> g.dtype
dtype('<U1')
>>> g.dtype.name
'str32'

```

### dtype 选项

`array()`函数不接受单个参数。您已经看到每个 ndarray 对象都与一个`dtype`对象相关联，该对象唯一地定义了将占用数组中每一项的数据类型。默认情况下，`array()`函数可以根据列表或元组序列中包含的值关联最合适的类型。实际上，您可以使用`dtype`选项作为函数的参数来显式定义 dtype。

例如，如果你想定义一个具有复数值的数组，你可以使用如下的`dtype`选项:

```py
>>> f = np.array([[1, 2, 3],[4, 5, 6]], dtype=complex)
>>> f
array([[ 1.+0.j,  2.+0.j,  3.+0.j],
       [ 4.+0.j,  5.+0.j,  6.+0.j]])

```

### 数组的内在创建

NumPy 库提供了一组函数，这些函数生成具有初始内容的 ndarrays，根据函数的不同而使用不同的值创建。在整章和整本书中，你会发现这些特性非常有用。事实上，它们允许一行代码生成大量数据。

例如，`zeros()`函数创建一个完整的零数组，其维数由 shape 参数定义。例如，要创建一个二维数组 3x3，可以使用:

```py
>>> np.zeros((3, 3))
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])

```

而`ones()`函数以非常相似的方式创建一个充满 1 的数组。

```py
>>> np.ones((3, 3))
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.]])

```

默认情况下，这两个函数创建数据类型为`float64`的数组。一个特别有用的特性是`arange()`。这个函数生成 NumPy 数组，数组中的数字序列根据传递的参数响应特定的规则。例如，如果您想要生成一个介于 0 和 10 之间的值序列，那么您将只被传递给该函数一个参数，即您想要用来结束该序列的值。

```py
>>> np.arange(0, 10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

```

如果不是从零开始，而是想从另一个值开始，只需指定两个参数:第一个是起始值，第二个是最终值。

```py
>>> np.arange(4, 10)
array([4, 5, 6, 7, 8, 9])

```

还可以生成一系列值，这些值之间有精确的间隔。如果指定了`arange()`函数的第三个参数，这将表示值序列中一个值和下一个值之间的差距。

```py
>>> np.arange(0, 12, 3)
array([0, 3, 6, 9])

```

此外，这第三个参数也可以是一个浮点数。

```py
>>> np.arange(0, 6, 0.6)
array([ 0\. ,  0.6,  1.2,  1.8,  2.4,  3\. ,  3.6,  4.2,  4.8,  5.4])

```

到目前为止，您只创建了一维数组。要生成二维数组，您仍然可以继续使用`arange()`函数，但是要与`reshape()`函数结合使用。这个函数按照`shape`参数指定的方式将一个线性数组分成不同的部分。

```py
>>> np.arange(0, 12).reshape(3, 4)
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

```

另一个与`arange()`非常相似的功能是`linspace()`。这个函数仍然将序列的初始值和结束值作为它的前两个参数，但是第三个参数不是指定一个元素和下一个元素之间的距离，而是定义了我们希望间隔被拆分成的元素的数量。

```py
>>> np.linspace(0,10,5)
array([  0\. ,   2.5,   5\. ,   7.5,  10\. ])

```

最后，获得已经包含值的数组的另一种方法是用随机值填充它们。这可以通过使用`numpy.random`模块的`random()`功能来实现。该函数将生成一个数组，其中包含参数中指定的许多元素。

```py
>>> np.random.random(3)
array([ 0.78610272,  0.90630642,  0.80007102])

```

获得的数字将随着每次运行而变化。要创建多维数组，只需将数组的大小作为参数传递。

```py
>>> np.random.random((3,3))
array([[ 0.07878569,  0.7176506 ,  0.05662501],
       [ 0.82919021,  0.80349121,  0.30254079],
       [ 0.93347404,  0.65868278,  0.37379618]]) 

```

## 基本操作

到目前为止，您已经看到了如何创建一个新的 NumPy 数组以及如何在其中定义项目。现在是时候看看如何对它们应用各种操作了。

### 阿里特数学算子

对数组执行的第一个操作是算术运算符。最明显的是将一个数组与一个标量相加并相乘。

```py
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])

>>> a+4
array([4, 5, 6, 7])
>>> a*2
array([0, 2, 4, 6])

```

这些运算符也可以在两个数组之间使用。在 NumPy 中，这些操作是针对*元素的，*也就是说，操作符只应用于相应的元素之间。这些是占据相同位置的对象，因此最终结果将是一个新的数组，其中包含操作数相同位置的结果(见图 [3-1](#Fig1) )。

```py
>>> b = np.arange(4,8)
>>> b
array([4, 5, 6, 7])

```

![img/336498_2_En_3_Chapter/336498_2_En_3_Fig1_HTML.jpg](img/336498_2_En_3_Chapter/336498_2_En_3_Fig1_HTML.jpg)

图 3-1

逐元素加法

```py
>>> a + b
array([ 4,  6,  8, 10])
>>> a – b
array([–4, –4, –4, –4])
>>> a * b
array([ 0,  5, 12, 21])

```

此外，如果返回的值是 NumPy 数组，这些运算符也可用于函数。例如，您可以将数组乘以数组 **b** 的元素的正弦或平方根。

```py
>>> a * np.sin(b)
array([–0\.        , –0.95892427, –0.558831  ,  1.9709598 ])
>>> a * np.sqrt(b)
array([ 0\.        ,  2.23606798,  4.89897949,  7.93725393]) 

```

转到多维情况，即使在这里，算术运算符也继续按元素进行操作。

```py
>>> A = np.arange(0, 9).reshape(3, 3)
>>> A
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> B = np.ones((3, 3))
>>> B
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.]])
>>> A * B
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],

       [ 6.,  7.,  8.]])

```

### 矩阵乘积

对操作元素的选择是 NumPy 库的一个特殊方面。事实上，在许多其他数据分析工具中，`*`运算符在应用于两个矩阵时被理解为一个*矩阵乘积*。使用 NumPy，这种产品由`dot()`函数表示。该操作不是基于元素的。

```py
>>> np.dot(A,B)
array([[  3.,   3.,   3.],
       [ 12.,  12.,  12.],
       [ 21.,  21.,  21.]])

```

每个位置的结果是第一个矩阵的相应行的每个元素与第二个矩阵的相应列的相应元素的乘积之和。图 [3-2](#Fig2) 示出了在矩阵乘积(两个元素的运行)期间执行的过程。

![img/336498_2_En_3_Chapter/336498_2_En_3_Fig2_HTML.jpg](img/336498_2_En_3_Chapter/336498_2_En_3_Fig2_HTML.jpg)

图 3-2

计算矩阵元素作为矩阵乘积的结果

编写矩阵乘积的另一种方法是将`dot()`函数视为两个矩阵之一的对象函数。

```py
>>> A.dot(B)
array([[  3.,   3.,   3.],
       [ 12.,  12.,  12.],
       [ 21.,  21.,  21.]])

```

注意，由于矩阵乘积不是交换运算，操作数的顺序很重要。的确，A * B 不等于 B * A。

```py
>>> np.dot(B,A)
array([[  9.,  12.,  15.],
       [  9.,  12.,  15.],
       [  9.,  12.,  15.]])

```

### 递增和递减运算符

实际上，Python 中没有这样的操作符，因为没有名为`++`或`––`的操作符。要增加或减少数值，你必须使用像`+=`和`–=`这样的操作符。这些操作符与您之前看到的操作符没有什么不同，只是它们不是用结果创建一个新的数组，而是将结果重新分配给同一个数组。

```py
>>> a = np.arange(4)
>>> a
array([0, 1, 2, 3])
>>> a += 1
>>> a
array([1, 2, 3, 4])
>>> a –= 1
>>> a
array([0, 1, 2, 3])

```

因此，使用这些运算符比将值增加一个单位的简单增量运算符要广泛得多，并且它们可以应用于许多情况。例如，每当您想要更改数组中的值而不生成新的值时，您都需要它们。

```py
array([0, 1, 2, 3])
>>> a += 4
>>> a
array([4, 5, 6, 7])
>>> a *= 2
>>> a
array([ 8,

10, 12, 14])

```

### 通用函数(ufunc)

一个通用函数，gene rally 称为`ufunc`，是一个以一个元素接一个元素的方式在数组上操作的函数。这意味着它单独作用于输入数组的每个元素，在新的输出数组中生成相应的结果。最后，您获得了一个与输入大小相同的数组。

有许多数学和三角运算符合这个定义；比如用`sqrt()`算平方根，用`log()`算对数，或者用`sin()`算正弦。

```py
>>> a = np.arange(1, 5)
>>> a
array([1, 2, 3, 4])
>>> np.sqrt(a)
array([ 1\.        ,  1.41421356,  1.73205081,  2\.        ])
>>> np.log(a)
array([ 0\.        ,  0.69314718,  1.09861229,  1.38629436])
>>> np.sin(a)
array([ 0.84147098,  0.90929743,  0.14112001, –0.7568025 ])

```

许多功能已经在库 NumPy 中实现。

### 聚集功能

聚合函数对一组值(例如数组)执行运算，并产生单个结果。因此，数组中所有元素的总和是一个聚合函数。许多这类函数都是在 ndarray 类中实现的。

```py
>>> a = np.array([3.3, 4.5, 1.2, 5.7, 0.3])
>>> a.sum()
15.0
>>> a.min()
0.29999999999999999
>>> a.max()
5.7000000000000002
>>> a.mean()
3.0
>>> a.std()
2.0079840636817816

```

## 索引、切片和迭代

在前面的章节中，您看到了如何创建数组以及如何对数组执行操作。在本节中，您将看到如何操作这些对象。您将学习如何通过索引和切片来选择元素，以便获得元素中包含的值或进行赋值来更改它们的值。最后，您还将看到如何在其中进行迭代。

### 索引

数组索引总是使用方括号(`[ ]`)来索引数组的元素，以便这些元素可以被单独引用，用于各种用途，例如提取值、选择项目，甚至分配新值。

当你创建一个新的数组时，一个合适的标度指数也会自动创建(见图 [3-3](#Fig3) )。

![img/336498_2_En_3_Chapter/336498_2_En_3_Fig3_HTML.jpg](img/336498_2_En_3_Chapter/336498_2_En_3_Fig3_HTML.jpg)

图 3-3

一维数组的索引

为了访问数组中的单个元素，可以引用它的索引。

```py
>>> a = np.arange(10, 16)
>>> a
array([10, 11, 12, 13, 14, 15])
>>> a[4]
14

```

NumPy 数组也接受负索引。这些索引具有相同的从 0 到–1、–2 的递增顺序，依此类推，但实际上它们会导致最后一个元素逐渐向初始元素移动，初始元素将是索引值更负的元素。

```py
>>> a[–1]
15
>>> a[–6]
10

```

要一次选择多个项目，可以传递方括号中的索引数组。

```py
>>> a[[1, 3, 4]]
array([11, 13, 14])

```

转到二维情况，即矩阵，它们被表示为由行和列组成的矩形阵列，由两个轴定义，其中轴 0 由行表示，轴 1 由列表示。因此，这种情况下的索引由一对值表示:第一个值是行的索引，第二个值是列的索引。所以如果要访问矩阵中的值或者选择元素，还是会使用方括号，但是这次有两个值【行索引，列索引】(见图 [3-4](#Fig4) )。

![img/336498_2_En_3_Chapter/336498_2_En_3_Fig4_HTML.jpg](img/336498_2_En_3_Chapter/336498_2_En_3_Fig4_HTML.jpg)

图 3-4

索引二维数组

```py
>>> A = np.arange(10, 19).reshape((3, 3))
>>> A
array([[10, 11, 12],
       [13, 14, 15],
       [16, 17, 18]])

```

如果要删除第二行第三列的元素，必须插入对[1，2]。

```py
>>> A[1, 2]
15

```

### 限幅

Sl*ice*允许你提取数组的一部分来生成新的数组。当使用 Python 列表对数组进行切片时，得到的数组是副本，但是在 NumPy 中，数组是同一底层缓冲区的视图。

根据要提取(或查看)的数组部分，必须使用 slice 语法；也就是说，您将使用方括号内由冒号(`:`)分隔的数字序列。

如果您想要提取数组的一部分，例如从第二个元素到第六个元素，您必须插入起始元素的索引，即 1，和最后一个元素的索引，即 5，用`:`分开。

```py
>>> a = np.arange(10, 16)
>>> a
array([10, 11, 12, 13, 14, 15])
>>> a[1:5]
array([11, 12, 13, 14])

```

现在，如果您想从前面的部分提取一个项目并跳过后面特定数量的项目，然后提取下一个项目并再次跳过，您可以使用第三个数字来定义元素序列中的间隔。例如，值为 2 时，数组将以交替的方式获取元素。

```py
>>> a[1:5:2]
array([11, 13])

```

为了更好地理解 slice 语法，您还应该查看不使用显式数值的情况。如果省略第一个数字，NumPy 会隐式地将这个数字解释为 0(即数组的初始元素)。如果省略第二个数字，这将被解释为数组的最大索引；如果你省略了最后一个数字，这将被解释为 1。所有元素都将被视为没有间隔。

```py
>>> a[::2]
array([10, 12, 14])
>>> a[:5:2]
array([10, 12, 14])
>>> a[:5:]

array([10, 11, 12, 13, 14])

```

在二维数组的情况下，切片语法仍然适用，但它是为行和列单独定义的。例如，如果您只想提取第一行:

```py
>>> A = np.arange(10, 19).reshape((3, 3))
>>> A
array([[10, 11, 12],
       [13, 14, 15],
       [16, 17, 18]])
>>> A[0,:]
array([10, 11, 12])

```

正如您在第二个索引中看到的，如果您只留下冒号而没有定义数字，您将选择所有的列。相反，如果你想提取第一列的所有值，你必须反过来写。

```py
>>> A[:,0]
array([10, 13, 16])

```

相反，如果您想要提取一个更小的矩阵，您需要用定义它们的索引显式地定义所有区间。

```py
>>> A[0:2, 0:2]
array([[10, 11],
       [13, 14]])

```

如果要提取的行或列的索引不连续，可以指定一个索引数组。

```py
>>> A[[0,2], 0:2]
array([[10, 11],
       [16, 17]])

```

### 迭代数组

在 Pytho n 中，数组中各项的迭代真的非常简单；您只需要使用`for`构造。

```py
>>> for i in a:
...      print(i)
...
10
11
12
13
14
15

```

当然，即使在这里，转到二维情况，您也可以考虑用`for`构造应用两个嵌套循环的解决方案。第一个循环将扫描数组的行，第二个循环将扫描列。实际上，如果你将`for`循环应用于一个矩阵，它将总是根据第一个轴执行扫描。

```py
>>> for row in A:
...      print(row)
...
[10 11 12]
[13 14 15]
[16 17 18]

```

如果您想逐个元素地进行迭代，您可以使用下面的构造，在`A.flat`上使用`for`循环。

```py
>>> for item in A.flat:
...       print(item)
...
10
11
12
13
14
15
16
17
18

```

然而，尽管如此，NumPy 提供了一个比`for`循环更好的替代解决方案。通常，您需要应用一个迭代来对行、列或单个项目应用一个函数。如果您想启动一个聚合函数，返回为每一列或每一行计算的值，那么有一种最佳的方法让 NumPy 来管理迭代:函数`apply_along_axis()`。

这个函数有三个参数:聚合函数、应用迭代的轴和数组。如果选项`axis`等于 0，那么迭代逐列评估元素，而如果`axis`等于 1，那么迭代逐行评估元素。例如，您可以先按列再按行计算平均值。

```py
>>> np.apply_along_axis(np.mean, axis=0, arr=A)
array([ 13.,  14.,  15.])
>>> np.apply_along_axis(np.mean, axis=1, arr=A)
array([ 11.,  14.,  17.])

```

在前一个例子中，您使用了 NumPy 库中已经定义的函数，但是您可以定义自己的函数。您还使用了聚合函数。然而，没有什么禁止你使用一个`ufunc`。在这种情况下，按列和按行进行迭代会产生相同的结果。事实上，使用一个`ufunc`元素一个元素一个元素地执行一次迭代。

```py
>>> def foo(x):
...     return x/2
...
>>> np.apply_along_axis(foo, axis=1, arr=A)
array([[5.,  5.5, 6\. ],
       [6.5, 7.,  7.5],
       [8.,  8.5, 9\. ]])
>>> np.apply_along_axis(foo, axis=0, arr=A)
array([[5.,  5.5, 6.],
       [6.5, 7.,  7.5],
       [8.,  8.5, 9.]])

```

如您所见，`ufunc`函数将输入数组中每个元素的值减半，而不管迭代是按行还是按列执行的。

## 条件和布尔数组

到目前为止，您已经使用索引和切片来选择或提取数组的子集。这些方法使用数字索引。选择性提取数组中元素的另一种方法是使用条件和布尔运算符。

假设您想要选择包含 0 到 1 之间的随机数的 4x4 矩阵中小于 0.5 的所有值。

```py
>>> A = np.random.random((4, 4))
>>> A
array([[ 0.03536295,  0.0035115 ,  0.54742404,  0.68960999],
       [ 0.21264709,  0.17121982,  0.81090212,  0.43408927],
       [ 0.77116263,  0.04523647,  0.84632378,  0.54450749],
       [ 0.86964585,  0.6470581 ,  0.42582897,  0.22286282]])

```

一旦定义了一个随机数矩阵，如果应用一个运算符条件，您将收到一个布尔值数组，该数组在满足条件的位置包含真值。在本例中，这是值小于 0.5 的所有位置。

```py
>>> A < 0.5
array([[ True,  True, False, False],
       [ True,  True, False,  True],
       [False,  True, False, False],
       [False, False,  True,  True]], dtype=bool)

```

实际上，布尔数组隐含地用于选择数组的一部分。事实上，通过将前面的条件直接插入方括号中，您将提取所有小于 0.5 的元素，从而获得一个新的数组。

```py
>>> A[A < 0.5]
array([ 0.03536295,  0.0035115 ,  0.21264709,  0.17121982,  0.43408927,
        0.04523647,  0.42582897,  0.22286282])

```

## 形状操作

在创建二维数组的过程中，您已经看到了如何通过`reshape()`函数将一维数组转换成矩阵。

```py
>>> a = np.random.random(12)
>>> a
array([ 0.77841574,  0.39654203,  0.38188665,  0.26704305,  0.27519705,
        0.78115866,  0.96019214,  0.59328414,  0.52008642,  0.10862692,
        0.41894881,  0.73581471])
>>> A = a.reshape(3, 4)
>>> A
array([[ 0.77841574,  0.39654203,  0.38188665,  0.26704305],
       [ 0.27519705,  0.78115866,  0.96019214,  0.59328414],
       [ 0.52008642,  0.10862692,  0.41894881,  0.73581471]])

```

函数返回一个新的数组，因此可以创建新的对象。但是，如果您想通过修改形状来修改对象，您必须将包含新维度的元组直接分配给它的`shape`属性。

```py
>>> a.shape = (3, 4)
>>> a
array([[ 0.77841574,  0.39654203,  0.38188665,  0.26704305],
       [ 0.27519705,  0.78115866,  0.96019214,  0.59328414],
       [ 0.52008642,  0.10862692,  0.41894881,  0.73581471]])

```

如您所见，这一次是开始改变形状的数组，没有返回任何对象。相反的操作也是可能的，也就是说，你可以通过使用`ravel()`函数将二维数组转换成一维数组。

```py
>>> a = a.ravel()
array([ 0.77841574,  0.39654203,  0.38188665,  0.26704305,  0.27519705,
        0.78115866,  0.96019214,  0.59328414,  0.52008642,  0.10862692,
        0.41894881,  0.73581471])

```

或者直接作用于数组本身的`shape`属性。

```py
>>> a.shape = (12)
>>> a
array([ 0.77841574,  0.39654203,  0.38188665,  0.26704305,  0.27519705,
        0.78115866,  0.96019214,  0.59328414,  0.52008642,  0.10862692,
        0.41894881,  0.73581471])

```

另一个重要的操作是转置一个矩阵，也就是用行来反转列。NumPy 通过`transpose()`功能提供了这一特性。

```py
>>> A.transpose()
array([[ 0.77841574,  0.27519705,  0.52008642],
       [ 0.39654203,  0.78115866,  0.10862692],
       [ 0.38188665,  0.96019214,  0.41894881],
       [ 0.26704305,  0.59328414,  0.73581471]])

```

## 数组操作

通常，您需要使用已经创建的数组来创建数组。在本节中，您将看到如何通过连接或拆分已定义的数组来创建新数组。

### 连接数组

您可以合并多个数组，形成一个包含所有数组的新数组。NumPy 使用了*堆叠*的概念，在这方面提供了许多功能。例如，您可以使用`vs` `tack()`函数执行垂直堆叠，将第二个数组合并为第一个数组的新行。在这种情况下，阵列在垂直方向上增长。相比之下，`hstack()`函数执行水平堆叠；也就是说，第二个数组被添加到第一个数组的列中。

```py
>>> A = np.ones((3, 3))
>>> B = np.zeros((3, 3))
>>> np.vstack((A, B))
array([[ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 1.,  1.,  1.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
>>> np.hstack((A,B))
array([[ 1.,  1.,  1.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  0.,  0.,  0.]])

```

在多个阵列之间执行堆叠的另外两个函数是`column_stack()`和`row_stack()`。这些功能的操作与前两个功能不同。通常，这些函数与一维数组一起使用，这些一维数组堆叠成列或行，以便形成新的二维数组。

```py
>>> a = np.array([0, 1, 2])
>>> b = np.array([3, 4, 5])
>>> c = np.array([6, 7, 8])
>>> np.column_stack((a, b, c))
array([[0, 3, 6],
       [1, 4, 7],
       [2, 5, 8]])
>>> np.row_stack((a, b, c))
array([[0, 1, 2],
       [3, 4, 5],

[6, 7, 8]])

```

### 拆分数组

在上一节中，您看到了如何通过堆叠组装多个数组。现在您将看到如何将一个数组分成几个部分。在 NumPy 中，您使用拆分来实现这一点。这里也有一组函数，既可以水平地与`hsplit()` f 函数一起工作，也可以垂直地与`vsplit()`函数一起工作。

```py
>>> A = np.arange(16).reshape((4, 4))
>>> A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

```

因此，如果您想要水平拆分数组，这意味着数组的宽度被分成两部分，那么 4x4 矩阵 A 将被拆分成两个 2x4 矩阵。

```py
>>> [B,C] = np.hsplit(A, 2)
>>> B
array([[ 0,  1],
       [ 4,  5],
       [ 8,  9],
       [12, 13]])
>>> C
array([[ 2,  3],
       [ 6,  7],
       [10, 11],
       [14, 15]])

```

相反，如果您想要垂直拆分数组，这意味着数组的高度被分成两部分，那么 4x4 矩阵 A 将被拆分成两个 4x2 矩阵。

```py
>>> [B,C] = np.vsplit(A, 2)
>>> B
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
>>> C
array([[ 8,  9, 10, 11],
       [12, 13, 14, 15]])

```

一个更复杂的命令是`split()`函数，它允许你将数组分成非对称的部分。将数组作为参数传递时，还必须指定要分割的部分的索引。如果您使用选项`axis = 1`，那么索引将是列；如果选项是`axis = 0`，那么它们将是行索引。

例如，如果要将矩阵分为三部分，第一部分包括第一列，第二部分包括第二列和第三列，第三部分包括最后一列，则必须以下列方式指定三个索引。

```py
>>> [A1,A2,A3] = np.split(A,[1,3],axis=1)
>>> A1
array([[ 0],
       [ 4],
       [ 8],
       [12]])
>>> A2
array([[ 1,  2],
       [ 5,  6],
       [ 9, 10],
       [13, 14]])
>>> A3
array([[ 3],
       [ 7],
       [11],
       [15]])

```

你可以按排做同样的事情。

```py
>>> [A1,A2,A3] = np.split(A,[1,3],axis=0)
>>> A1
array([[0, 1, 2, 3]])
>>> A2
array([[ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> A3
array([[12, 13, 14, 15]])

```

该功能还包括`vsplit()`和`hsplit()`功能。

## 一般概念

本节描述了 NumPy 库的基本概念。副本和视图的区别在于它们何时返回值。本节还将介绍许多 NumPy 函数中隐含的广播机制。

### 对象的副本或视图

正如您可能已经注意到的，使用 NumPy，特别是当您操作数组时，您可以返回数组的副本或视图。NumPy 赋值不会产生数组的副本，也不会产生数组中包含的任何元素。

```py
>>> a = np.array([1, 2, 3, 4])
>>> b = a
>>> b
array([1, 2, 3, 4])
>>> a[2] = 0
>>> b
array([1, 2, 0, 4])

```

如果你将一个数组`a`分配给另一个数组`b`，你并没有复制它；数组`b`只是数组`a`的另一种叫法。事实上，通过改变第三个元素的值，你也改变了`b`的第三个值。对数组进行切片时，返回的对象是原始数组的视图。

```py
>>> c = a[0:2]
>>> c
array([1, 2])
>>> a[0] = 0
>>> c
array([0, 2])

```

如你所见，即使在切片时，你实际上也是指向同一个对象。如果你想生成一个完整的不同的数组，使用`copy()`函数。

```py
>>> a = np.array([1, 2, 3, 4])
>>> c = a.copy()
>>> c
array([1, 2, 3, 4])
>>> a[0] = 0
>>> c
array([1, 2, 3, 4])

```

在这种情况下，即使改变数组`a`中的项目，数组`c`也保持不变。

### …向量化…

*矢量* *化*，连同*广播*，是 NumPy 内部实现的基础。矢量化是指在代码开发过程中没有明确的循环。这些循环实际上不能被省略，而是在内部实现，然后被代码中的其他结构替换。矢量化的应用导致代码更加简洁易读，你可以说它在外观上会显得更加“Pythonic 化”。事实上，由于矢量化，许多操作都采用了更加数学化的表达方式。例如，NumPy 允许您将两个数组相乘，如下所示:

```py
a * b

```

或者甚至两个矩阵:

```py
A * B

```

在其他语言中，这样的操作可以用许多嵌套循环和`for`结构来表达。例如，第一个操作可以用以下方式表示:

```py
for (i = 0; i < rows; i++){
  c[i] = a[i]*b[i];
}

```

而矩阵的乘积将表示如下:

```py
for( i=0; i < rows; i++){
   for(j=0; j < columns; j++){
      c[i][j] = a[i][j]*b[i][j];
   }
}

```

您可以看到，使用 NumPy 使代码可读性更强，更加数学化。

### 广播

*Broadc* *asting* 允许一个操作符或一个函数作用于两个或多个数组，即使这些数组没有相同的形状。也就是说，不是所有的维度都可以被广播；他们必须符合一定的规则。

您看到了使用 NumPy，您可以通过一个形状对多维数组进行分类，这个形状是一个表示每个维度的元素长度的元组。

当两个数组的所有维度都兼容时，即每个维度的长度必须相等或者其中一个维度必须等于 1 时，可以对这两个数组进行广播。如果这两个条件都不满足，就会出现一个异常，指出这两个数组不兼容。

```py
>>> A = np.arange(16).reshape(4, 4)
>>> b = np.arange(4)
>>> A
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])
>>> b
array([0, 1, 2, 3])

```

在这种情况下，您将获得两个数组:

```py
4 x 4
4

```

广播有两个规则。首先，您必须为每个缺失的维度加 1。如果现在满足兼容性规则，您可以应用广播并转到第二个规则。例如:

```py
4 x 4
4 x 1

```

符合兼容性规则。然后你可以转到广播的第二条规则。这条规则解释了如何扩展最小数组的大小，使其成为最大数组的大小，以便可以应用基于元素的函数或操作符。

第二个规则假设缺失的元素(size，length 1)用扩展尺寸中包含的值的副本填充(见图 [3-5](#Fig5) )。

![img/336498_2_En_3_Chapter/336498_2_En_3_Fig5_HTML.jpg](img/336498_2_En_3_Chapter/336498_2_En_3_Fig5_HTML.jpg)

图 3-5

应用第二广播规则

既然两个数组有相同的维数，那么里面的值可以加在一起。

```py
>>> A + b
array([[ 0,  2,  4,  6],
       [ 4,  6,  8, 10],
       [ 8, 10, 12, 14],
       [12, 14, 16, 18]])

```

这是一个简单的例子，其中两个数组中的一个比另一个小。可能有更复杂的情况，其中两个阵列具有不同的形状，并且每个阵列仅在某些维度上小于另一个阵列。

```py
>>> m = np.arange(6).reshape(3, 1, 2)
>>> n = np.arange(6).reshape(3, 2, 1)
>>> m
array([[[0, 1]],

       [[2, 3]],

       [[4, 5]]])
>>> n
array([[[0],
        [1]],

       [[2],
        [3]],

       [[4],
        [5]]])

```

即使在这种情况下，通过分析两个数组的形状，您可以看到它们是兼容的，因此可以应用广播的规则。

```py
3 x 1 x 2
3 x 2 x 1

```

在这种情况下，两个阵列都经历维度的扩展(广播)。

```py
m* = [[[0,1],             n* = [[[0,0],
       [0,1]],                   [1,1]],
      [[2,3],                   [[2,2],
       [2,3]],                   [3,3]],
      [[4,5],                   [[4,4],
       [4,5]]]                   [5,5]]]

```

然后，您可以在两个数组之间应用加法运算符，对元素进行操作。

```py
>>> m + n
array([[[ 0,  1],
        [ 1,  2]],

       [[ 4,  5],
        [ 5,  6]],

       [[ 8,  9],

  [ 9, 10]]])

```

## 结构化数组

到目前为止，在前面几节的各种示例中，您看到了一维数组和二维数组。NumPy 允许您创建不仅在大小上，而且在结构上更复杂的数组，称为*结构化数组。*这种类型的数组包含`struct`或记录，而不是单个项目。

例如，您可以创建一个简单的`struct`数组作为条目。由于有了`dtype`选项，您可以指定一个逗号分隔的说明符列表来表示将构成`struct`的元素，以及数据类型和顺序。

```py
bytes                     b1
int                       i1, i2, i4, i8
unsigned ints             u1, u2, u4, u8
floats                    f2, f4, f8
complex                   c8, c16
fixed length strings      a<n>

```

例如，如果您想要指定一个由整数、长度为 6 的字符串和布尔值组成的`struct`，您将使用相应的说明符以正确的顺序在`dtype`选项中指定三种类型的数据。

### 注意

在不同的操作系统和 Python 发行版中，`dtype`的结果和其他格式属性可能会有所不同。

```py
>>> structured = np.array([(1, 'First', 0.5, 1+2j),(2, 'Second', 1.3, 2-2j), (3, 'Third', 0.8, 1+3j)],dtype=('i2, a6, f4, c8'))
>>> structured
array([(1, b'First', 0.5, 1+2.j),
       (2, b'Second', 1.3, 2.-2.j),
       (3, b'Third', 0.8, 1.+3.j)],
      dtype=[('f0', '<i2'), ('f1', 'S6'), ('f2', '<f4'), ('f3', '<c8')])

```

您还可以使用数据类型显式地指定`int8`、`uint8`、`float16`、`complex64`等等。

```py
>>> structured = np.array([(1, 'First', 0.5, 1+2j),(2, 'Second', 1.3,2-2j), (3, 'Third', 0.8, 1+3j)],dtype=('
int16, a6, float32, complex64'))
>>> structured
array([(1, b'First', 0.5, 1.+2.j),
       (2, b'Second', 1.3, 2.-2.j),
       (3, b'Third', 0.8, 1.+3.j)],
      dtype=[('f0', '<i2'), ('f1', 'S6'), ('f2', '<f4'), ('f3', '<c8')])

```

两种情况都有相同的结果。在数组内部，您会看到一个`dtype`序列，其中包含了`struct`中每一项的名称以及相应的数据类型。

编写适当的引用索引，获得相应的行，其中包含`struct`。

```py
>>> structured[1]
(2, 'bSecond', 1.3, 2.-2.j)

```

自动分配给每一项`struct`的名称可以被认为是数组的列名。将它们用作结构化索引，您可以引用相同类型或相同`column`的所有元素。

```py
>>> structured['f1']
array([b'First', b'Second', b'Third'],
      dtype='|S6')

```

正如您刚才看到的，这些名称被自动分配了一个 **f** (代表字段)和一个指示序列中位置的渐进整数。事实上，用更有意义的东西来指定名称会更有用。这是可能的，您可以在声明数组时这样做:

```py
>>> structured = np.array([(1,'First',0.5,1+2j),(2,'Second',1.3,2-2j),(3,'Third',0.8,1+3j)],dtype=[(
'id','i2'),('position','a6'),('value','f4'),('complex','c8')])
>>> structured
array([(1, b'First', 0.5, 1.+2.j),
       (2, b'Second', 1.3, 2.-2.j),
       (

3, b'Third', 0.8, 1.+3.j)],
      dtype=[('id', '<i2'), ('position', 'S6'), ('value', '<f4'), ('complex', '<c8')])

```

或者您可以稍后再做，重新定义分配给结构化数组的`dtype`属性的名称元组。

```py
>>> structured.dtype.names = ('id','order','value','complex')

```

现在，您可以为各种字段类型使用有意义的名称:

```py
>>> structured['order']
array([b'First', b'Second', b'Third'],
      dtyp

e='|S6')

```

## 在文件上读写数组数据

NumPy 的一个非常重要的方面是读取文件中包含的数据的过程，这个方面还没有讨论。这个过程非常有用，尤其是当您必须处理在数组中收集的大量数据时。这是一个非常常见的数据分析操作，因为要分析的数据集的大小几乎总是很大，因此手动管理它是不可取的，甚至是不可能的。

NumPy 提供了一组函数，允许数据分析师将他们的计算结果保存在文本或二进制文件中。类似地，NumPy 允许您读取文件中的写入数据并将其转换为数组。

### 在二进制文件中加载和保存数据

NumPy 提供了一对名为`save()`和`load()`的函数，使您能够保存并在以后检索以二进制格式存储的数据。

一旦有了要保存的数组，例如，包含数据分析处理结果的数组，您只需调用`save()`函数并指定文件名和数组名作为参数。该文件将自动被赋予`.npy`扩展名。

```py
>>> data=([[ 0.86466285,  0.76943895,  0.22678279],
       [ 0.12452825,  0.54751384,  0.06499123],
       [ 0.06216566,  0.85045125,  0.92093862],
       [ 0.58401239,  0.93455057,  0.28972379]])

>>> np.save('saved_data',data)

```

当您需要恢复存储在`.npy`文件中的数据时，您可以通过指定文件名作为参数来使用`load()`函数，这次添加了扩展名`.npy`。

```py
>>> loaded_data = np.load('saved_data.npy')
>>> loaded_data
array([[ 0.86466285,  0.76943895,  0.22678279],
       [ 0.12452825,  0.54751384,  0.06499123],
       [ 0.06216566,  0.85045125,  0.92093862],
       [ 0.58401239,  0.9

3455057,  0.28972379]])

```

### 读取带有表格数据的文件

很多时候，您想要读取或保存的数据是文本格式的(例如，TXT 或 CSV)。您可以将数据保存为这种格式，而不是二进制格式，因为如果您正在使用 NumPy 或任何其他应用程序，则可以在外部独立访问这些文件。以 CSV(逗号分隔值)格式的一组数据为例，其中数据以表格格式收集，值用逗号分隔(参见清单 [3-1](#PC95) )。

```py
id,value1,value2,value3
1,123,1.4,23
2,110,0.5,18
3,164,2.1,19

Listing 3-1ch3_data.csv

```

为了能够读取文本文件中的数据并将值插入数组，NumPy 提供了一个名为`genfromtxt()`的函数。通常，该函数有三个参数—包含数据的文件名、分隔值的字符(在本例中为逗号)以及数据是否包含列标题。

```py
>>> data = np.genfromtxt('ch3_data.csv', delimiter=',', names=True)
>>> data
array([(1.0, 123.0, 1.4, 23.0), (2.0, 110.0, 0.5, 18.0),
       (3.0, 164.0, 2.1, 19.0)],
      dtype=[('id', '<f8'), ('value1', '<f8'), ('value2', '<f8'), ('value3', '<f8')])

```

从结果中可以看出，您得到了一个结构化数组，其中列标题变成了字段名称。

这个函数隐式地执行两个循环:第一个循环一次读取一行，第二个循环分离并转换其中包含的值，插入专门创建的连续元素。该特性的一个积极方面是，如果某些数据丢失，该函数可以处理它们。

以先前的文件(见清单 [3-2](#PC97) )为例，其中删除了一些项目。另存为`data2.csv`。

```py
id,value1,value2,value3
1,123,1.4,23
2,110,,18

3,,2.1,19

Listing 3-2ch3_data2.csv

```

启动这些命令，您可以看到`genfromtxt()`函数如何用`nan`值替换文件中的空白。

```py
>>> data2 = np.genfromtxt('ch3_data2.csv', delimiter=',', names=True)
>>> data2
array([(1.0, 123.0, 1.4, 23.0), (2.0, 110.0, nan, 18.0),
       (3.0, nan, 2.1, 19.0)],
      dtype=[('id', '<f8'), ('value1', '<f8'), ('value2', '<f8'), ('value3', '<f8')])

```

在数组的底部，您可以找到文件中包含的列标题。可以将这些标题视为标签，作为按列提取值的索引:

```py
>>> data2['id']
array([ 1.,  2.,  3.])

```

相反，通过以传统方式使用数字索引，您将提取对应于行的数据。

```py
>>> data2[0]
(1.0, 123.0, 1.4, 23.0)

```

## 结论

在本章中，您了解了 NumPy 库的所有主要方面，并熟悉了一系列特性，这些特性构成了您在本书过程中将要面对的许多其他方面的基础。事实上，这些概念中的许多将取自其他更专业的科学和计算库，但它们是在这个库的基础上构建和开发的。

您看到了如何通过 ndarray 扩展 Python 的功能，使其成为适合科学计算和数据分析的语言。

因此，NumPy 知识对于任何想从事数据分析的人来说都是至关重要的。

在下一章中，我们将开始介绍一个新的库，名为 pandas，它是基于 NumPy 构建的，因此包含了本章中介绍的所有基本概念。然而，pandas 扩展了这些概念，因此它们更适用于数据分析。