# 7.用 matplotlib 实现数据可视化

在前几章讨论了负责数据处理的 Python 库之后，现在是时候让你看看一个负责可视化的库了。这个库是 matplotlib。

在数据分析中，数据可视化经常被低估，但它实际上是一个非常重要的因素，因为不正确或低效的数据表示会毁掉一个原本很好的分析。在这一章中，你将发现 matplotlib 库的各个方面，包括它是如何构造的，以及如何最大限度地发挥它的潜力。

## matplotlib 库

matplotlib 是一个专门开发二维图表(包括三维图表)的 Python 库。近年来在科学界和工程界广为流传( [`http://matplolib.org`](http://matplolib.org) )。

在使其成为数据图形化表示中最常用的工具的所有特性中，有几个非常突出:

*   使用极其简单

*   渐进开发和交互式数据可视化

*   LaTeX 中的表达式和文本

*   更好地控制图形元素

*   导出为多种格式，如 PNG、PDF、SVG 和 EPS

matplotlib 的设计目的是尽可能多地再现一个在图形视图和语法形式方面类似于 MATLAB 的环境。这种方法已被证明是成功的，因为它能够利用已上市数年的软件(MATLAB)的经验，这种软件现在已在所有专业技术科学领域广泛使用。matplotlib 不仅基于该领域大多数专家熟知的方案，而且还利用了多年来在使用中带来的可推导性和简单性的优化，这使得该库对于第一次接触数据可视化的人来说也是一个极好的选择，尤其是那些没有任何 MATLAB 或类似应用程序经验的人。

除了简单性和可演绎性，matplotlib 库还从 MATLAB 继承了*交互性*。也就是说，分析员可以插入一个又一个命令来控制数据的图形表示的逐步发展。这种模式非常适合 Python 中更具交互性的方法，如 IPython QtConsole 和 IPython Notebook(参见第 [2](02.html) 章)，从而提供了一个数据分析环境，这是 Mathematica、IDL 或 MATLAB 等其他工具所不具备的。

开发这个美丽图书馆的人的天才之处在于使用和融合了科学中现有的和正在使用的好东西。正如我们已经看到的，这不仅局限于 MATLAB 和类似的操作模式，还局限于 LaTeX 所表示的科学表达式和符号的文本格式模型。由于 LaTeX 在显示和展示科学表达式方面的巨大能力，它已经成为任何科学出版物或文档中不可替代的元素，在这些出版物或文档中，可视化地表示积分、求和以及导数等表达式的需求是强制性的。因此，matplotlib 集成了这一卓越的工具，以提高图表的代表能力。

另外，一定不要忘了，matplotlib 不是一个单独的应用，而是像 Python 这样的编程语言的库。所以它也充分利用了编程语言提供的潜力。matplotlib 看起来像一个图形库，允许您以编程方式管理组成图表的图形元素，以便可以整体控制图形显示。对图形表示进行编程的能力允许管理跨多个环境的数据表示的再现性，尤其是当您进行更改或更新数据时。

此外，因为 matplotlib 是一个 Python 库，所以它允许您充分利用任何使用这种语言实现的开发人员都可以使用的其他库的潜力。事实上，关于数据分析，matplotlib 通常与 NumPy 和 pandas 等一组其他库合作，但许多其他库可以集成，没有任何问题。

最后，通过使用该库进行编码而获得的图形表示可以以最常见的图形格式(如 PNG 和 SVG)导出，然后用于其他应用程序、文档、网页等。

## 装置

安装 matplotlib 库有许多选项。如果您选择使用像 Anaconda 或 Enthought Canopy 这样的软件包发行版，安装 matplotlib 软件包非常简单。例如，使用`conda`包管理器，您必须输入以下内容:

```py
conda install matplotlib

```

如果您想直接安装此软件包，要插入的命令因操作系统而异。

在 Debian-Ubuntu Linux 系统上，使用以下命令:

```py
sudo apt-get install python-matplotlib

```

在 Fedora-Redhat Linux 系统上，使用以下命令:

```py
sudo yum install python-matplotlib

```

在 Windows 或 MacOS 上，应该使用`pip`来安装 matplotlib。

## IPython 和 IPython QtConsole

为了熟悉 Python 世界提供的所有工具，我选择从终端和 QtConsole 使用 IPython。这是因为 IPython 允许您利用其增强终端的交互性，正如您将看到的，IPython QtConsole 还允许您直接在控制台内集成图形。

要运行 IPython 会话，只需运行以下命令:

```py
ipython

Python 3.6.3 (default, Oct  15 2017, 03:27:45) [MSC v.1900 64 bit (AMD64)]
Type "copyright", "credits" or "license" for more information.

IPython 3.6.3 -- An enhanced Interactive Python. Type '?' for help.

In [1]:

```

然而，如果您希望运行 Jupyter QtConsole，并能够在会话的行命令中显示图形，您可以使用:

```py
jupyter qtconsole

```

一个新打开的 IPython 会话窗口将立即出现在屏幕上，如图 [7-1](#Fig1) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig1_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig1_HTML.jpg)

图 7-1

IPython QtConsole

但是，如果您想继续使用标准的 Python 会话，您可以这样做。如果您不喜欢使用 IPython，并且想继续从终端使用 Python，本章中的所有例子仍然有效。

## matplotlib 架构

matplotlib 必须承担的关键任务之一是提供一组函数和工具，允许表示和操作一个*图形*(主对象)，以及组成它的所有内部对象。然而，matplotlib 不仅处理图形，还提供了所有用于事件处理的工具和动画图形的能力。因此，由于这些额外的特性，matplotlib 被证明能够基于按下键盘上的按键或鼠标移动所触发的事件来生成交互式图表。

matplotlib 的架构在逻辑上分为三层，放置在三个不同的层次上(见图 [7-2](#Fig2) )。通信是单向的，即每一层都可以与底层通信，而下层不能与上层通信。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig2_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig2_HTML.jpg)

图 7-2

matplotlib 架构的三层

这三层如下:

*   脚本

*   艺术家

*   后端

### 后端层

在 matplotlib 架构的图中，工作在最底层的层是*后端*层。这一层包含 matplotlib APIs，这是一组在底层扮演图形元素实现角色的类。

*   `FigureCanvas`是体现绘图区域概念的对象。

*   `Renderer`是绘制在`FigureCanvas`上的对象。

*   `Event`是处理用户输入(键盘和鼠标事件)的对象。

### 艺术家层

作为中间层，我们有一层叫做*艺术家*。构成图表的所有元素，如标题、轴标签、标记等。是 Artist 对象的实例。这些实例中的每一个都在一个层次结构中扮演着自己的角色(如图 [7-3](#Fig3) 所示)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig3_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig3_HTML.jpg)

图 7-3

图表中的每个元素都对应于层次结构中的一个艺术家实例

有两种艺术家类型:原始的和合成的。

*   *原始艺术家*是构成基本元素的单个对象，以形成图中的图形表示，例如线 2D，或者如矩形或圆形的几何图形，甚至是文本块。

*   *合成艺术家*是那些出现在由几个基本元素组成的图表中的图形元素，即原始艺术家。合成艺术家例如轴、记号、轴和图形(见图 [7-4](#Fig4) )。

一般来说，在这个层次工作，你将不得不经常处理更高层次的对象，如图形、轴和轴。因此，充分理解这些对象是什么以及它们在图形表示中扮演什么角色非常重要。图 [7-4](#Fig4) 显示了三个主要的美工对象(复合美工),它们通常用于在该级别执行的所有实现中。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig4_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig4_HTML.jpg)

图 7-4

艺术家层层次中的三个主要艺术家对象

*   *图*是层次中级别最高的对象。它对应于整个图形表示，通常可以包含许多轴。

*   *坐标轴*一般就是你说的曲线图或者图表。每个轴对象只属于一个图形，并且由两个艺术家轴(在三维情况下为三个)来表征。其他对象，如标题、x 标签和 y 标签，都属于这个合成艺术家。

*   *轴*考虑要在轴上表示的数值的对象，定义极限并管理刻度(轴上的标记)和刻度标签(每个刻度上表示的标签文本)。记号的位置由一个叫做*定位器*的对象调整，而格式化记号标签由一个叫做*格式化器*的对象调节。

### 脚本层(pyplot)

Artist 类及其相关函数(matplotlib API)特别适合所有开发人员，尤其是那些在 web 应用服务器上工作或开发 GUI 的人员。但是对于计算来说，特别是对于数据的分析和可视化来说，脚本层是最好的。这一层由一个名为 *pyplot* 的接口组成。

### pylab 和 pyplot

总的来说，有关于皮拉布和 T2 的讨论。但是这两个包有什么区别呢？Pylab 是随 matplotlib 一起安装的模块，而 pyplot 是 matplotlib 的内部模块。通常你会找到这种或那种方法的参考资料。

```py
from pylab import *

```

和

```py
import matplotlib.pyplot as plt
import numpy as np

```

Pylab 将 pyplot 的功能与 NumPy 的功能结合在一个名称空间中，因此您不需要单独导入 NumPy。再者，如果导入 pylab，pyplot 和 NumPy 函数可以直接调用，不需要任何对模块(命名空间)的引用，使得环境更类似于 MATLAB。

```py
plot(x,y)
array([1,2,3,4])

```

代替

```py
plt.plot()
np.array([1,2,3,4]

```

*pyplot* 包提供了编程 matplotlib 库的经典 Python 接口，有自己的命名空间，需要单独导入 NumPy 包。本书选择了这种方法；这是本章的主题；它将被用于本书的其余部分。事实上，这种选择得到了大多数 Python 开发人员的认同。

## pyplot

pyplot 模块是一个命令风格函数的集合，它允许你像 MATLAB 一样使用 matplotlib。每个 pyplot 函数都会对图形对象进行操作或进行一些更改，例如，创建图形本身、创建绘图区域、表示线条、用标签装饰绘图等。

Pyplot 也是*有状态的*，因为它跟踪当前图形及其绘图区域的状态。调用的函数作用于当前图形。

### 一个简单的交互式图表

为了熟悉 matplotlib 库，特别是 Pyplot，您将开始创建一个简单的交互式图表。使用 matplotlib，这个操作非常简单；事实上，您只需使用三行代码就可以实现它。

但是首先你需要导入`pyplot`包，并将其重命名为`plt`。

```py
In [1]: import matplotlib.pyplot as plt

```

在 Python 中，构造函数通常是不必要的；一切都已经被隐式定义了。事实上，当您导入包时，`plt`对象及其所有的图形功能已经被实例化并准备好使用。事实上，您只需使用`plot()`函数来传递要绘制的值。

因此，您可以简单地传递想要表示为整数序列的值。

```py
In [2]: plt.plot([1,2,3,4])
Out[2]: [<matplotlib.lines.Line2D at 0xa3eb438>]

```

如您所见，已经生成了一个 Line2D 对象。该对象是一条线，表示图表中包含的点的线性趋势。

现在一切都准备好了。您只需使用`show()`功能发出显示图形的命令。

```py
In [3]: plt.show()

```

结果将如图 [7-5](#Fig5) 所示。它看起来只是一个窗口，名为*绘图窗口，*带有一个工具栏和在其中显示的图形，就像 MATLAB 一样。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig5_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig5_HTML.jpg)

图 7-5

绘图窗口

## 绘图窗口

绘图窗口的特点是顶部有一个工具栏，其中有一系列按钮。

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Figa_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Figa_HTML.jpg)重置原始视图

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Figb_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Figb_HTML.jpg)转到上一个/下一个视图

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Figc_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Figc_HTML.jpg)用鼠标左键平移坐标轴，用鼠标右键缩放

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Figd_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Figd_HTML.jpg)缩放至矩形

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Fige_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fige_HTML.jpg)配置支线剧情

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Figf_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Figf_HTML.jpg)保存/导出图形

*   ![img/336498_2_En_7_Chapter/336498_2_En_7_Figg_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Figg_HTML.jpg)编辑轴、曲线和图像参数

输入 IPython 控制台的代码在 Python 控制台上对应于以下一系列命令:

```py
>>> import matplotlib.pyplot as plt
>>> plt.plot([1,2,3,4])
[<matplotlib.lines.Line2D  at 0x0000000007DABFD0>]
>>> plt.show()

```

如果您正在使用 IPython QtConsole，您可能已经注意到，在调用`plot()`函数之后，图表被直接显示，而没有显式调用`show()`函数(参见图 [7-6](#Fig6) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig6_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig6_HTML.jpg)

图 7-6

QtConsole 将图表直接显示为输出

如果您只将一个数字列表或数组传递给`plt.plot()`函数，matplotlib 会假设它是图表中的`y`值的序列，并将它们关联到值 x 的自然序列:0，1，2，3，...。

一般来说，一个绘图表示值对(x，y ),所以如果您想要正确定义一个图表，您必须定义两个数组，第一个数组包含 x 轴上的值，第二个数组包含 y 轴上的值。此外，`plot()`函数可以接受第三个参数，该参数描述了您希望如何在图表上表示该点的细节。

### 设置绘图的属性

正如你在图 [7-6](#Fig6) 中看到的，这些点用蓝线表示。事实上，如果您没有另外指定，绘图会考虑到`plt.plot()`功能的默认配置:

*   轴的大小与输入数据的范围完全匹配

*   既没有标题也没有轴标签

*   没有传说

*   将绘制一条连接这些点的蓝线

因此，你需要改变这种表示，以得到一个真实的图，其中每对值(x，y)由一个红点表示(见图 [7-7](#Fig7) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig7_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig7_HTML.jpg)

图 7-7

(x，y)值对在图中用红色圆圈表示

如果您正在使用 IPython，请关闭窗口，返回到输入新命令的活动提示。然后，您必须回调`show()`函数，以观察对绘图所做的更改。

```py
In [4]: plt.plot([1,2,3,4],[1,4,9,16],'ro')
Out[4]: [<matplotlib.lines.Line2D at 0x93e6898>]

In [5]: plt.show()

```

相反，如果您在 Jupyter QtConsole 上工作，您会看到您输入的每个新命令都有不同的绘图。

### 注意

在本书的这一点上，你已经对各种环境之间的差异有了一个非常清晰的概念。为了避免混淆，我将把 IPython QtConsole 作为唯一的开发环境。

通过定义列表 *[* `xmin, xmax, ymin, ymax` *]* 的细节，然后将其作为参数传递给`axis()`函数，可以定义 x 轴和 y 轴上的范围。

### 注意

在 IPython QtConsole 中，为了生成图表，有时需要输入更多行的命令。为了避免每次按 Enter 键(开始一个新行)时都生成一个图表并丢失先前指定的设置，您必须按 Ctrl+Enter。当您想要最终生成图表时，只需按两次 Enter 键。

您可以设置几个属性，其中之一是可以使用`title()`功能输入的标题。

```py
In [4]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot')
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
Out[4]: [<matplotlib.lines.Line2D at 0x97f1c18>]

```

在图 [7-8](#Fig8) 中，你可以看到新的设置如何使图形更具可读性。事实上，数据集的端点现在显示在图中，而不是显示在边缘。此外，图的标题现在可以在顶部看到。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig8_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig8_HTML.jpg)

图 7-8

设置属性后的绘图

### matplotlib 和 NumPy

即使是 matplot 库，尽管是一个完全图形化的库，它的基础也是 NumPy 库。事实上，到目前为止，您已经看到了如何将列表作为参数传递，既表示数据又设置轴的极值。实际上，这些列表已经在 NumPy 数组中进行了内部转换。

因此，可以直接输入 NumPy 数组作为输入数据。这个数据数组已经被 pandas 处理过，可以直接与 matplotlib 一起使用，无需进一步处理。

作为一个例子，你可以看到如何在同一个图中绘制三种不同的趋势(见图 [7-9](#Fig9) )。对于这个例子，您可以选择属于`math`模块的`sin()`函数。因此您需要导入它。要生成遵循正弦趋势的点，您将使用 NumPy 库。使用`arange()`函数在 x 轴上生成一系列点，而对于 y 轴上的值，您将使用`map()`函数对数组的所有项目应用`sin()`函数(不使用`for`循环)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig9_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig9_HTML.jpg)

图 7-9

由标记表示的相移π / 4 的三个正弦趋势

```py
In [5]: import math
In [6]: import numpy as np
In [7]: t = np.arange(0,2.5,0.1)
   ...: y1 = np.sin(math.pi*t)
   ...: y2 = np.sin(math.pi*t+math.pi/2)
   ...: y3 = np.sin(math.pi*t-math.pi/2)
In [8]: plt.plot(t,y1,'b*',t,y2,'g^',t,y3,'ys')
Out[8]:
[<matplotlib.lines.Line2D at 0xcbd2e48>,
 <matplotlib.lines.Line2D at 0xcbe10b8>,
 <matplotlib.lines.Line2D at 0xcbe15c0>]

```

### 注意

如果您没有使用带有 matplotlib 内联的 IPython QtConsole 集，或者您正在一个简单的 Python 会话上实现此代码，请在代码末尾插入`plt.show()`命令，以获得如图 [7-10](#Fig10) 所示的图表。

如图 [7-9](#Fig9) 所示，该图用三种不同的颜色和标记表示了三种不同的时间趋势。在这些情况下，当一个函数的趋势如此明显时，图也许不是最合适的表示，但最好使用线条(见图 [7-10](#Fig10) )。要用颜色以外的东西来区分这三种趋势，可以使用由点和破折号的不同组合组成的图案(-和。).

```py
In [9]: plt.plot(t,y1,'b--',t,y2,'g',t,y3,'r-.')
Out[9]:
[<matplotlib.lines.Line2D at 0xd1eb550>,
 <matplotlib.lines.Line2D at 0xd1eb780>,
 <matplotlib.lines.Line2D at 0xd1ebd68>]

```

### 注意

如果您没有使用带有 matplotlib 内联的 IPython QtConsole 集，或者您正在一个简单的 Python 会话上实现此代码，请在代码末尾插入`plt.show()`命令，以获得如图 [7-10](#Fig10) 所示的图表。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig10_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig10_HTML.jpg)

图 7-10

这个图表用彩色线条表示了三种正弦曲线模式

## 使用夸尔格

组成图表的对象有许多表征它们的属性。这些属性都是默认值，但是可以通过使用*关键字 args 来设置，*通常被称为 *kwargs* 。

这些关键字作为参数传递给函数。在 matplotlib 库的各种函数的参考文档中，你会发现它们在最后一个位置被称为 *kwargs* 。例如，您在这些示例中使用的`plot()`函数以如下方式引用。

```py
matplotlib.pyplot.plot(*args, **kwargs)

```

作为一个实际的例子，如果设置`linewidth`关键字，可以改变线条的粗细(见图 [7-11](#Fig11) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig11_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig11_HTML.jpg)

图 7-11

线条的粗细可以直接通过 plot()函数设置

```py
In [10]: plt.plot([1,2,4,2,1,0,1,2,1,4],linewidth=2.0)
Out[10]: [<matplotlib.lines.Line2D at 0xc909da0>]

```

### 使用多个图形和轴

到目前为止，您已经看到了所有 pyplot 命令如何路由到单个图形的显示。实际上，matplotlib 允许您同时管理多个图形，并且在每个图形中，它提供了查看定义为子图形的不同图形的能力。

因此，当您使用 pyplot 时，您必须始终牢记当前图形和当前轴的概念(即图形中显示的图)。

现在你会看到一个例子，两个支线剧情出现在一个图形中。`subplot()`功能除了在不同的绘图区域细分图形外，还用于将命令聚焦在特定的子图上。

传递给`subplot()`函数的参数设置细分的模式，并确定哪个是当前子情节。当前的子情节将是唯一受命令影响的图形。`subplot()`函数的参数由三个整数组成。第一个数字定义了图形被垂直分割成多少部分。第二个数字定义了图形在水平方向上被分成多少部分。第三个问题是选择哪一个是当前的子剧情，你可以在上面指挥命令。

现在你将显示两个正弦趋势(正弦和余弦)，最好的方法是将画布垂直分成两个水平子图(如图 [7-12](#Fig12) )。所以作为参数传递的数字是`211`和`212`。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig12_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig12_HTML.jpg)

图 7-12

这个图形被分成了两个水平的支线剧情

```py
In [11]: t = np.arange(0,5,0.1)
   ... : y1 = np.sin(2*np.pi*t)
   ... : y2 = np.sin(2*np.pi*t)
In [12]: plt.subplot(211)
    ...: plt.plot(t,y1,'b-.')
    ...: plt.subplot(212)
    ...: plt.plot(t,y2,'r--')
Out[12]: [<matplotlib.lines.Line2D at 0xd47f518>]

```

现在你做同样的事情，把人物分成两个垂直的支线剧情。作为参数传递给`subplot()`函数的数字是`121`和`122`(如图 [7-13](#Fig13) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig13_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig13_HTML.jpg)

图 7-13

这个人物被分成了两个垂直的次要情节

```py
In [ ]: t = np.arange(0.,1.,0.05)
   ...: y1 = np.sin(2*np.pi*t)
   ...: y2 = np.cos(2*np.pi*t)
In [ ]: plt.subplot(121)
   ...: plt.plot(t,y1,'b-.')
   ...: plt.subplot(122)
   ...: plt.plot(t,y2,'r--')
Out[94]: [<matplotlib.lines.Line2D at 0xed0c208>

]

```

## 向图表添加元素

为了使图表提供更多信息，很多时候用线条或标记来表示数据并使用两个轴来分配值的范围是不够的。事实上，有许多其他元素可以添加到图表中，以便用附加信息丰富它。

在本节中，您将看到如何将元素作为文本标签、图例等添加到图表中。

### 添加文本

您已经看到了如何使用`title()`函数向图表添加标题。另外两个文本指示您可以添加*轴标签。*这可以通过使用另外两个特定的函数来实现，称为`xlabel()`和`ylabel()`。这些函数将一个字符串作为参数，该字符串将是显示的文本。

### 注意

构成表示图表的代码的命令行的数量正在增加。您不需要每次都重写所有的命令，但是使用键盘上的箭头键，您可以调出以前传递的命令列表，并通过添加新行来编辑它们(在文本中以粗体显示)。

现在向图表添加两个轴标签。它们将描述分配给每个轴的值(如图 [7-14](#Fig14) 所示)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig14_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig14_HTML.jpg)

图 7-14

通过添加轴标签，绘图可以提供更多信息

```py
In [10]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot')
   ...: plt.xlabel('Counting')
   ...: plt.ylabel('Square values')
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
Out[10]: [<matplotlib.lines.Line2D at 0x990f3c8>]

```

多亏了关键字，你可以改变文本的特征。例如，您可以通过更改字体和增加字符大小来修改标题。您还可以修改轴标签的颜色，以突出绘图的标题(如图 [7-15](#Fig15) 所示)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig15_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig15_HTML.jpg)

图 7-15

可以通过设置关键字来修改文本

```py
In [ ]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
Out[116]: [<matplotlib.lines.Line2D at 0x11f17470>]

```

但是 matplotlib 并不局限于此:pyplot 允许您将文本添加到图表中的任何位置。该功能由一个名为`text()`的特定功能执行。

```py
text(x,y,s, fontdict=None, **kwargs)

```

前两个参数是要放置文本的位置的坐标。 **s** 是要添加的文本字符串，`fontdict`(可选)是要使用的字体。最后，你可以添加关键字。

将标签添加到图中的每个点。因为`text()`函数的前两个参数是图形的坐标，所以您必须使用在 y 轴上稍微移动的图形的四个点的坐标。

```py
In [ ]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.text(1,1.5,'First')
   ...: plt.text(2,4.5,'Second')
   ...: plt.text(3,9.5,'Third')
   ...: plt.text(4,16.5,'Fourth')
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
Out[108]: [<matplotlib.lines.Line2D at 0x10f76898>]

```

如图 [7-16](#Fig16) 所示，现在图中的每个点都有了一个标签。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig16_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig16_HTML.jpg)

图 7-16

图中的每一点都有一个信息标签

由于 matplotlib 是一个设计用于科学界的图形库，它必须能够充分利用科学语言的潜力，包括数学表达式。matplotlib 提供了集成 LaTeX 表达式的可能性，从而允许您在图表中插入数学表达式。

为此，您可以向文本中添加一个 LaTeX 表达式，将其包含在两个`$`字符之间。解释器会将它们识别为 LaTeX 表达式，并将其转换为相应的图形，可以是数学表达式、公式、数学字符，或者只是希腊字母。一般来说，您必须在包含 LaTeX 表达式的字符串前面加上一个`r`，它表示原始文本，以避免意外的转义序列。

在这里，您还可以使用关键字来进一步丰富要在情节中显示的文本。因此，作为一个例子，您可以添加描述趋势的公式，然后跟随图中的点，并将其包含在一个彩色的边界框中(参见图 [7-17](#Fig17) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig17_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig17_HTML.jpg)

图 7-17

任何数学表达式都可以在图表的上下文中看到

```py
In [ ]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.text(1,1.5,'First')
   ...: plt.text(2,4.5,'Second')
   ...: plt.text(3,9.5,'Third')
   ...: plt.text(4,16.5,'Fourth')
   ...: plt.text(1.1,12,r'$y = x^2$',fontsize=20,bbox={'facecolor':'yellow','alpha':0.2})
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')

Out[130]: [<matplotlib.lines.Line2D at 0x13920860>]

```

要全面了解 LaTeX 的潜力，请参考本书的附录 A。

### 添加网格

可以添加到绘图中的另一个元素是网格。为了更好地理解图表上每个点所占据的位置，经常需要添加它。

向图表添加网格是一个非常简单的操作:只需添加`grid()`函数，将`True`作为参数传递(见图 [7-18](#Fig18) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig18_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig18_HTML.jpg)

图 7-18

网格使读取图表上表示的数据点的值变得更加容易

```py
In [ ]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.text(1,1.5,'First')
   ...: plt.text(2,4.5,'Second')
   ...: plt.text(3,9.5,'Third')
   ...: plt.text(4,16.5,'Fourth')
   ...: plt.text(1.1,12,r'$y = x^2$',fontsize=20,bbox={'facecolor':'yellow','alpha':0.2})
   ...: plt.grid(True)
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
Out[108]: [<matplotlib.lines.Line2D at 0x10f76898>]

```

### 添加图例

另一个在任何图表中都应该出现的非常重要的部分是图例。pyplot 还为这类对象提供了一个特定的函数:`legend()`。

使用`legend()`函数向图表中添加一个图例，并添加一个字符串来指示您希望用来显示系列的单词。在本例中，将`First series`名称分配给输入数据数组(参见图 [7-19](#Fig19) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig19_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig19_HTML.jpg)

图 7-19

默认情况下，右上角会添加一个图例

```py
In [ ]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.text(2,4.5,'Second')
   ...: plt.text(3,9.5,'Third')
   ...: plt.text(4,16.5,'Fourth')
   ...: plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox={'facecolor':'yellow','alpha':0.2})
   ...: plt.grid(True)
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
   ...: plt.legend(['First series'])
Out[156]: <matplotlib.legend.Legend at 0x16377550>

```

如图 [7-19](#Fig19) 所示，图例默认添加在右上角。同样，如果你想改变这种行为，你需要添加一些夸脱。例如，图例所占据的位置是通过给`loc` kwarg 分配从 0 到 10 的数字来设置的。这些数字中的每一个都代表了图表的一个角(见表 [7-1](#Tab1) )。默认值为 1，即右上角。在下一个示例中，您将移动左上角的图例，使其不会与图中表示的点重叠。

表 7-1

loc 关键字的可能值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

位置代码

 | 

位置字符串

 |
| --- | --- |
| `0` | `best` |
| `1` | `upper-right` |
| `2` | `upper-left` |
| `3` | `lower-right` |
| `4` | `lower-left` |
| `5` | `right` |
| `6` | `center-left` |
| `7` | `center-right` |
| `8` | `lower-center` |
| `9` | `upper-center` |
| `10` | `center` |

在您开始修改代码以移动图例之前，我想添加一个小通知。通常，图例用于通过与颜色和/或标记相关联的标签向读者指示系列的定义，以在图中区分该系列。到目前为止，在示例中，您已经使用了由单个`plot()`函数表示的单个序列。现在，您必须关注一个更一般的情况，即同一个情节同时显示多个系列。图表中的每个系列将由特定的颜色和特定的标记来表征(参见图 [7-20](#Fig20) )。相反，在代码方面，每个系列将通过调用`plot()`函数来表征，并且它们被定义的顺序将对应于作为参数传递给`legend()`函数的文本标签的顺序。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig20_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig20_HTML.jpg)

图 7-20

每个多系列图表中都需要一个图例

```py
In [ ]: import matplotlib.pyplot as plt
   ...: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.text(1,1.5,'First')
   ...: plt.text(2,4.5,'Second')
   ...: plt.text(3,9.5,'Third')
   ...: plt.text(4,16.5,'Fourth')
   ...: plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox={'facecolor':'yellow','alpha':0.2})
   ...: plt.grid(True)
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
   ...: plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')
   ...: plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')
   ...: plt.legend(['First series','Second series','Third series'],loc=2)
Out[170]: <matplotlib.legend.Legend at 0x1828d7b8>

```

## 保存图表

在本节中，您将学习如何根据需要以不同的方式保存图表。如果您需要在不同的笔记本或 Python 会话中复制图表，或者在将来的项目中重用它们，保存 Python 代码是一个好的做法。另一方面，如果您需要制作报告或演示文稿，将图表保存为图像会非常有用。此外，可以将你的图表保存为 HTML 页面，当你需要在网上分享你的作品时，这将非常有用。

### 保存代码

正如您在前面几节的示例中看到的，关于单个图表表示的代码增长到了相当多的行。一旦您认为您已经达到了开发过程中的一个好点，您可以选择将所有行的代码保存在一个`.py`文件中，您可以随时调用它。

您可以使用神奇的命令`save%`，后跟您想要保存的文件的名称，再后跟包含您想要保存的代码行的输入提示的数量。如果所有的代码都只写在一个提示符下，就像你的情况一样，你必须只添加它的编号；否则如果你想保存许多提示中写的代码，例如从 10 到 20，你必须用一个`-`分开的两个数字表示这个范围，即 10-20。

在您的情况下，您将保存 Python 代码，该代码是包含在输入提示中的第一个图表的表示，编号为 171。

```py
In [171]: import matplotlib.pyplot as plt
...

```

您需要插入以下命令，将代码保存到一个新的`.py`文件中。

```py
%save my_first_chart 171

```

启动该命令后，您将在工作目录中找到`my_first_chart.py`文件(参见清单 [7-1](#PC32) )。

```py
# coding: utf-8
import matplotlib.pyplot as plt
plt.axis([0,5,0,20])
plt.title('My first plot',fontsize=20,fontname='Times New Roman')
plt.xlabel('Counting',color='gray')
plt.ylabel('Square values',color='gray')
plt.text(1,1.5,'First')
plt.text(2,4.5,'Second')
plt.text(3,9.5,'Third')
plt.text(4,16.5,'Fourth')
plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox={'facecolor':'yellow','alpha':0.2})
plt.grid(True)
plt.plot([1,2,3,4],[1,4,9,16],'ro')
plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')
plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')
plt.legend(['First series','Second series','Third series'],loc=2)

Listing 7-1my_first_chart.py

```

稍后，当您打开一个新的 IPython 会话时，您将拥有您的图表，并通过输入以下命令开始在您保存它的地方更改代码:

```py
ipython qtconsole --matplotlib inline -m my_first_chart.py

```

或者您可以使用神奇的命令`%load`在 QtConsole 的一个提示符中重新加载整个代码。

```py
%load my_first_chart.py

```

或者您可以在会话期间使用神奇的命令`%run`运行它。

```py
%run my_first_chart.py

```

### 注意

在我的系统上，这个命令只有在启动了前面的两个命令之后才起作用。

### 将您的会话转换为 HTML 文件

使用 IPython QtConsole，您可以将当前会话中的所有代码和图形转换为 HTML 页面。只需从菜单中选择*文件- >保存到 HTML/XHTML* (如图 [7-21](#Fig21) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig21_HTML.png](img/336498_2_En_7_Chapter/336498_2_En_7_Fig21_HTML.png)

图 7-21

您可以将当前会话保存为网页

您将被要求以两种不同的格式保存您的会话:HTML 和 HTML。两种格式之间的差异基于图像转换类型。如果选择 HTML 作为输出文件格式，会话中包含的图像将被转换为 PNG 格式。如果选择 XHTML 作为输出文件格式，图像将被转换为 SVG 格式。

在本例中，将您的会话保存为 HTML 文件并命名为`my_session.html`，如图 [7-22](#Fig22) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig22_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig22_HTML.jpg)

图 7-22

您可以在 HTML 和 XHTML 之间选择文件类型

此时，系统会询问您是想将图像保存在外部目录中还是内嵌目录中(参见图 [7-23](#Fig23) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig23_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig23_HTML.jpg)

图 7-23

您可以在创建外部图像文件和将 PNG 格式直接嵌入 HTML 页面之间进行选择

通过选择外部选项，图像将被收集到名为`my_session_files`的目录中。通过选择 inline，关于图像的图形信息被嵌入到 HTML 代码中。

### 将图表直接保存为图像

如果您只想将图表的图形保存为图像文件，而忽略您在会话期间编写的所有代码，这也是可行的。事实上，多亏了`savefig()`函数，您可以直接将图表保存为 PNG 格式，尽管您应该注意将该函数添加到同一系列命令的末尾(否则您将得到一个空白的 PNG 文件)。

```py
In [ ]: plt.axis([0,5,0,20])
   ...: plt.title('My first plot',fontsize=20,fontname='Times New Roman')
   ...: plt.xlabel('Counting',color='gray')
   ...: plt.ylabel('Square values',color='gray')
   ...: plt.text(1,1.5,'First')
   ...: plt.text(2,4.5,'Second')
   ...: plt.text(3,9.5,'Third')
   ...: plt.text(4,16.5,'Fourth')
   ...: plt.text(1.1,12,'$y = x^2$',fontsize=20,bbox={'facecolor':'yellow','alpha':0.2})
   ...: plt.grid(True)
   ...: plt.plot([1,2,3,4],[1,4,9,16],'ro')
   ...: plt.plot([1,2,3,4],[0.8,3.5,8,15],'g^')
   ...: plt.plot([1,2,3,4],[0.5,2.5,4,12],'b*')
   ...: plt.legend(['First series','Second series','Third series'],loc=2)
   ...: plt.savefig('my_chart.png')

```

执行前面的代码，将在您的工作目录中创建一个新文件。这个文件将被命名为`my_chart.png`，并将包含您的图表的图像。

## 处理日期值

在进行数据分析时，最常见的问题之一是处理日期-时间类型的数据。沿着轴(通常是 x 轴)显示数据可能会有问题，尤其是在管理分笔成交点时(参见图 [7-24](#Fig24) )。

例如，显示一个包含八个点的数据的线性图表，其中 x 轴上的日期值必须用以下格式表示:日-月-年。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig24_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig24_HTML.jpg)

图 7-24

如果不处理，显示日期时间值可能会有问题

```py
In [ ]: import datetime
   ...: import numpy as np
   ...: import matplotlib.pyplot as plt
   ...: events = [datetime.date(2015,1,23),datetime.date(2015,1,28),datetime.date(2015,2,3),datetime.date(2015,2,21),datetime.date(2015,3,15),datetime.date(2015,3,24),datetime.date(2015,4,8),datetime.date(2015,4,24)]
   ...: readings = [12,22,25,20,18,15,17,14]
   ...: plt.plot(events,readings)
Out[83]: [<matplotlib.lines.Line2D at 0x12666400>]

```

正如您在图 [7-24](#Fig24) 中看到的，自动管理记号，尤其是记号标签，可能是一场灾难。以这种方式表达的日期难以阅读，在一点和另一点之间没有明确的时间间隔，而且也有重叠。

因此，为了管理日期，建议用适当的对象定义一个时间刻度。首先您需要导入`matplotlib.dates`，一个专门用于这种类型数据的模块。然后，通过`MonthLocator()`和`DayLocator()`函数定义时间的刻度，在本例中，是一天和一个月的刻度。在这些情况下，格式也非常重要，为了避免重叠或不必要的引用，您必须将刻度标签限制在必要的范围内，在本例中是 year-month。这种格式可以作为参数传递给`DateFormatter()`函数。

在您定义了两个刻度(一个代表日，一个代表月)之后，您可以使用`xaxis`对象上的`set_major_locator()`和`set_minor_locator()`函数在 x 轴上设置两种不同的刻度。相反，要设置与月份相关的刻度标签的文本格式，您必须使用`set_major_formatter()`功能。

更改所有这些设置，最终得到如图 [7-25](#Fig25) 所示的图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig25_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig25_HTML.jpg)

图 7-25

现在，x 轴的刻度标签只表示月份，使图表更容易阅读

```py
In [ ]: import datetime
   ...: import numpy as np
   ...: import matplotlib.pyplot as plt
   ...: import matplotlib.dates as mdates
   ...: months = mdates.MonthLocator()
   ...: days = mdates.DayLocator()
   ...: timeFmt = mdates.DateFormatter('%Y-%m')
   ...: events = [datetime.date(2015,1,23),datetime.date(2015,1,28),datetime.date(2015,2,3),datetime.date(2015,2,21),datetime.date(2015,3,15),datetime.date(2015,3,24),datetime.date(2015,4,8),datetime.date(2015,4,24)]
readings = [12,22,25,20,18,15,17,14]
   ...: fig, ax = plt.subplots()
   ...: plt.plot(events,readings)
   ...: ax.xaxis.set_major_locator(months)
   ...: ax.xaxis.set_major_formatter(timeFmt)
   ...: ax.xaxis.set_minor_locator(days)

```

## 图表类型学

在前面几节中，您看到了许多与 matplotlib 库架构相关的示例。现在，您已经熟悉了图表中主要图形元素的用法，是时候看看一系列处理不同类型图表的示例了，从最常见的图表(如线形图、条形图和饼图)开始，到讨论一些更复杂但仍然常用的图表。

本章的这一部分非常重要，因为这个库的目的是可视化数据分析产生的结果。因此，知道如何选择合适的图表类型是一个基本的选择。请记住，出色的数据分析表现不正确会导致对实验结果的错误解释。

## 折线图

在所有的图表类型中，线形图是最简单的。折线图是由线条连接的数据点序列。每个数据点由一对值(x，y)组成，这些值将根据两个轴(x 和 y)的值的刻度显示在图表中。

举例来说，您可以开始绘制由数学函数生成的点。然后，您可以考虑一个通用的数学函数，如下所示:

*y = sin (3 * x) / x*

因此，如果您想要创建一个数据点序列，您需要创建两个 NumPy 数组。首先，创建一个数组，包含引用 x 轴的`x`值。为了定义一系列递增值，您将使用`np.arange()`函数。因为函数是正弦的，你应该参考希腊圆周率的倍数和约数( *np.pi* )。然后，使用这些值的序列，您可以直接对这些值应用`np.sin()`函数来获得`y`值(感谢 NumPy！).

完成所有这些后，您只需通过调用`plot()`函数来绘制它们。您将获得一个折线图，如图 [7-26](#Fig26) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig26_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig26_HTML.jpg)

图 7-26

用折线图表示的数学函数

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: x = np.arange(-2*np.pi,2*np.pi,0.01)
   ...: y = np.sin(3*x)/x
   ...: plt.plot(x,y)
Out[393]: [<matplotlib.lines.Line2D at 0x22404358>]

```

现在，您可以扩展想要显示一系列函数的情况，如下所示:

*y = sin (n * x) / x*

改变参数`n`。

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: x = np.arange(-2*np.pi,2*np.pi,0.01)
   ...: y = np.sin(3*x)/x
   ...: y2 = np.sin(2*x)/x
   ...: y3 = np.sin(3*x)/x
   ...: plt.plot(x,y)
   ...: plt.plot(x,y2)
   ...: plt.plot(x,y3)

```

如图 [7-27](#Fig27) 所示，不同的颜色被自动分配给每条线。所有的图都以相同的比例表示；也就是说，每个系列的数据点引用相同的 x 轴和 y 轴。这是因为对`plot()`函数的每次调用都考虑到了之前对同一函数的调用，所以图形会应用更改并保留之前命令的记忆，直到图形不再显示为止(使用 Python 的`show()`和 IPython QtConsole 的 Enter)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig27_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig27_HTML.jpg)

图 7-27

在同一个图表中用不同的颜色绘制了三个不同的系列

正如您在前面几节中看到的，不管默认设置如何，您都可以选择描边类型、颜色等。作为`plot()`函数的第三个参数，您可以指定一些对应于颜色的代码(见表 [7-2](#Tab2) )和其他对应于线条样式的代码，所有代码都包含在同一个字符串中。另一种可能是分别使用两个夸脱，`color`定义颜色，`linestyle`定义笔画(见图 [7-28](#Fig28) )。

表 7-2

颜色代码

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"></colgroup> 
| 

密码

 | 

颜色

 |
| --- | --- |
| `b` | 蓝色 |
| `g` | 绿色的 |
| `r` | 红色 |
| `c` | 蓝绿色 |
| `m` | 品红 |
| `y` | 黄色 |
| `k` | 黑色 |
| `w` | 白色 |

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig28_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig28_HTML.jpg)

图 7-28

您可以使用字符代码定义颜色和线型

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: x = np.arange(-2*np.pi,2*np.pi,0.01)
   ...: y = np.sin(3*x)/x
   ...: y2 = np.sin(2*x)/x
   ...: y3 = np.sin(3*x)/x
   ...: plt.plot(x,y,'k--',linewidth=3)
   ...: plt.plot(x,y2,'m-.')
   ...: plt.plot(x,y3,color='#87a3cc',linestyle='--')

```

您刚刚定义了 x 轴上从-2π到 2π的范围，但是默认情况下，刻度上的值以数字形式显示。因此你需要用π的倍数来代替数值。您也可以替换 y 轴上的记号。要做到这一切，您必须使用`xticks()`和`yticks()`函数，向它们传递两个值列表。第一个列表包含与要放置记号的位置相对应的值，第二个列表包含记号标签。在这种特殊情况下，为了正确显示符号π，您必须使用包含 LaTeX 格式的字符串。记得在两个`$`字符内定义它们，并添加一个`r`作为前缀。

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: x = np.arange(-2*np.pi,2*np.pi,0.01)
   ...: y = np.sin(3*x)/x
   ...: y2 = np.sin(2*x)/x
   ...: y3 = np.sin(x)/x
   ...: plt.plot(x,y,color='b')
   ...: plt.plot(x,y2,color='r')
   ...: plt.plot(x,y3,color='g')
   ...: plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],
           [r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])
   ...: plt.yticks([-1,0,1,2,3],
           [r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])
Out[423]:
([<matplotlib.axis.YTick at 0x26877ac8>,
  <matplotlib.axis.YTick at 0x271d26d8>,
  <matplotlib.axis.YTick at 0x273c7f98>,
  <matplotlib.axis.YTick at 0x273cc470>,
  <matplotlib.axis.YTick at 0x273cc9e8>],
 <a list of 5 Text yticklabel objects>)

```

最终你会得到一个干净愉悦的显示希腊字符的折线图，如图 [7-29](#Fig29) 。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig29_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig29_HTML.jpg)

图 7-29

可以通过添加 LaTeX 格式的文本来改进刻度标签

在迄今为止您看到的所有线形图中，您总是将 x 轴和 y 轴放在图形的边缘(对应于边界框的边)。显示轴的另一种方式是让两个轴通过原点(0，0)，即两个笛卡尔轴。

为此，您必须首先通过`gca()`函数捕获轴对象。然后，通过这个对象，您可以选择组成边界框的四个边中的每一个，并为每个边指定其位置:右、左、下和上。使用`set_color()`功能并指示`none`颜色，裁剪不匹配任何轴的边(右侧和底部)。然后，用`set_position()`功能移动 x 轴和 y 轴对应的边，使其通过原点(0，0)。

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: x = np.arange(-2*np.pi,2*np.pi,0.01)
   ...: y = np.sin(3*x)/x
   ...: y2 = np.sin(2*x)/x
   ...: y3 = np.sin(x)/x
   ...: plt.plot(x,y,color='b')
   ...: plt.plot(x,y2,color='r')
   ...: plt.plot(x,y3,color='g')
   ...: plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],
           [r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])
   ...: plt.yticks([-1,0,+1,+2,+3],
           [r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])
   ...: ax = plt.gca()
   ...: ax.spines['right'].set_color('none')
   ...: ax.spines['top'].set_color('none')
   ...: ax.xaxis.set_ticks_position('bottom')
   ...: ax.spines['bottom'].set_position(('data',0))
   ...: ax.yaxis.set_ticks_position('left')

   ...: ax.spines['left'].set_position(('data',0))

```

现在图表会显示在图形中间相交的两个轴，也就是笛卡尔轴的原点，如图 [7-30](#Fig30) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig30_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig30_HTML.jpg)

图 7-30

图表显示了两个笛卡尔坐标轴

通常，能够使用符号指定线的特定点，并可选地添加箭头以更好地指示该点的位置是非常有用的。例如，该符号可以是 LaTeX 表达式，例如函数 sinx/x 的极限公式，其中 x 趋于 0。

在这方面，matplotlib 提供了一个名为`annotate()`的函数，在这些情况下特别有用，即使获得一个好的结果所需的大量 kwargs 会使其设置相当复杂。第一个参数是要表示的字符串，包含 LaTeX 中的表达式；然后你可以添加各种夸脱。图表中需要注意的点由一个列表表示，该列表包含传递给`xy` kwarg 的点[x，y]的坐标。文本符号与突出显示点的距离由`xytext`箭头定义，并由曲线箭头表示，其特征在`arrowprops`箭头中定义。

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: x = np.arange(-2*np.pi,2*np.pi,0.01)
   ...: y = np.sin(3*x)/x
   ...: y2 = np.sin(2*x)/x
   ...: y3 = np.sin(x)/x
   ...: plt.plot(x,y,color='b')
   ...: plt.plot(x,y2,color='r')
   ...: plt.plot(x,y3,color='g')
   ...: plt.xticks([-2*np.pi, -np.pi, 0, np.pi, 2*np.pi],
           [r'$-2\pi$',r'$-\pi$',r'$0$',r'$+\pi$',r'$+2\pi$'])
   ...: plt.yticks([-1,0,+1,+2,+3],
           [r'$-1$',r'$0$',r'$+1$',r'$+2$',r'$+3$'])
   ...: plt.annotate(r'$\lim_{x\to 0}\frac{\sin(x)}{x}= 1$',    xy=[0,1],xycoords='data',xytext=[30,30],fontsize=16,textcoords='offset points',arrowprops=dict(arrowstyle="->",connectionstyle="arc3,rad=.2"))
   ...: ax = plt.gca()
   ...: ax.spines['right'].set_color('none')
   ...: ax.spines['top'].set_color('none')
   ...: ax.xaxis.set_ticks_position('bottom')
   ...: ax.spines['bottom'].set_position(('data',0))
   ...: ax.yaxis.set_ticks_position('left')
   ...: ax.spines['left'].set_position(('data',0))

```

运行这段代码，您将得到带有极限数学符号的图表，这就是图 [7-31](#Fig31) 中箭头所示的点。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig31_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig31_HTML.jpg)

图 7-31

可以使用 annotate()函数将数学表达式添加到图表中

### 熊猫折线图

转到更实际的案例，或者至少与数据分析更密切相关，现在是时候看看将 matplotlib 库应用于 pandas 库的数据框架是多么容易。将数据帧中的数据可视化为线性图表是一个非常简单的操作。将数据帧作为参数传递给`plot()`函数就足以获得多序列线性图表(见图 [7-32](#Fig32) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig32_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig32_HTML.jpg)

图 7-32

多系列折线图显示熊猫数据框架中的数据

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: import pandas as pd
   ...: data = {'series1':[1,3,4,3,5],
                'series2':[2,4,5,2,4],
                'series3':[3,2,3,1,3]}
   ...: df = pd.DataFrame(data)
   ...: x = np.arange(5)
   ...: plt.axis([0,5,0,7])
   ...: plt.plot(x,df)
   ...: plt.legend(data, loc=2)

```

## 直方图

一个*直方图*由竖立在 x 轴上的相邻矩形组成，分割成称为*仓*的离散间隔，其面积与该仓的出现频率成比例。这种可视化通常用于关于样本分布的统计研究。

为了表示一个直方图，pyplot 提供了一个名为`hist()`的特殊函数。这个图形功能还有一个其他制作图表的功能没有的特性。除了绘制直方图之外，`hist()`函数还返回一组值，这些值是直方图的计算结果。事实上，`hist()`函数也可以实现直方图的计算，也就是说，提供一系列样本值作为参数和要划分的区间数就足够了，它会将样本范围划分为多个区间(区间)，然后计算每个区间的出现次数。该操作的结果除了以图形形式显示外(见图 [7-33](#Fig33) )，还将以元组的形式返回。

*(n，箱，补丁)*

要理解这个操作，最好有一个实际的例子。然后您可以使用`random.randint()`函数生成从 0 到 100 的 100 个随机值的总体。

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: pop = np.random.randint(0,100,100)
   ...: pop
Out[ ]:
array([32, 14, 55, 33, 54, 85, 35, 50, 91, 54, 44, 74, 77,  6, 77, 74,  2,
       54, 14, 30, 80, 70,  6, 37, 62, 68, 88,  4, 35, 97, 50, 85, 19, 90,
       65, 86, 29, 99, 15, 48, 67, 96, 81, 34, 43, 41, 21, 79, 96, 56, 68,
       49, 43, 93, 63, 26,  4, 21, 19, 64, 16, 47, 57,  5, 12, 28,  7, 75,
        6, 33, 92, 44, 23, 11, 61, 40,  5, 91, 34, 58, 48, 75, 10, 39, 77,
       70, 84, 95, 46, 81, 27,  6, 83,  9, 79, 39, 90, 77, 94, 29])

```

现在，通过将`hist()`函数作为参数传递来创建这些样本的直方图。例如，您想将事件分成 20 个箱(如果未指定，默认值为 10 个箱)，为此您必须使用 kwarg `bin`(如图 [7-33](#Fig33) 所示)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig33_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig33_HTML.jpg)

图 7-33

直方图显示了每个箱中的出现次数

```py
In [ ]: n,bins,patches = plt.hist(pop,bins=20)

```

## 条形图

另一种非常常见的图表是条形图。它非常类似于直方图，但在这种情况下，x 轴不是用于引用数值，而是用于引用类别。用 matplotlib 实现条形图很简单，使用`bar()`函数。

```py
In [ ]: import matplotlib.pyplot as plt
   ...: index = [0,1,2,3,4]
   ...: values = [5,7,3,4,6]
   ...: plt.bar(index,values)
Out[15]: <Container object of 5 artists>

```

通过这几行代码，您将获得如图 [7-34](#Fig34) 所示的条形图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig34_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig34_HTML.jpg)

图 7-34

用 matplotlib 实现的最简单的条形图

如果你查看图 [7-34](#Fig34) ，你可以看到指数被绘制在 x 轴上，在每个条形的开始处。实际上，因为每个条形对应一个类别，所以如果通过 tick 标签指定类别会更好，tick 标签由传递给`xticks()`函数的字符串列表定义。至于这些刻度标签的位置，你必须传递一个包含对应于它们在 x 轴上的位置的值的列表，作为`xticks()`函数的第一个参数。最后你会得到一个条形图，如图 [7-35](#Fig35) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig35_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig35_HTML.jpg)

图 7-35

一个简单的条形图，x 轴上有类别

```py
In [ ]: import numpy as np
   ...: index = np.arange(5)
   ...: values1 = [5,7,3,4,6]
   ...: plt.bar(index,values1)
   ...: plt.xticks(index+0.4,['A','B','C','D','E'])

```

实际上，你可以采取许多其他步骤来进一步完善条形图。通过在`bar()`函数中添加一个特定的 kwarg 作为参数来设置每一种光洁度。例如，您可以通过`yerr` kwarg 以及包含标准偏差的列表添加条形的标准偏差值。这个 kwarg 通常与另一个名为`error_kw`的 kwarg 结合使用，后者又接受其他专门用于表示误差线的 kwarg。在这种情况下使用的两个非常特殊的 kwargs 是`eColor`，它指定误差线的颜色，和`capsize`，它定义标记误差线末端的横线的宽度。

您可以使用的另一个 kwarg 是`alpha`，它表示彩色条的透明度。Alpha 是一个范围从 0 到 1 的值。当该值为 0 时，对象完全透明，随着该值的增加逐渐变得更加显著，直到达到 1，此时颜色被完全表示。

通常，建议使用图例，因此在这种情况下，您应该使用名为`label`的图例来标识您所代表的系列。

最后你会得到一个带有误差条的条形图，如图 [7-36](#Fig36) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig36_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig36_HTML.jpg)

图 7-36

带误差线的条形图

```py
In [ ]: import numpy as np
   ...: index = np.arange(5)
   ...: values1 = [5,7,3,4,6]
   ...: std1 = [0.8,1,0.4,0.9,1.3]
   ...: plt.title('A Bar Chart')
   ...: plt.bar(index,values1,yerr=std1,error_kw={'ecolor':'0.1',
        'capsize':6},alpha=0.7,label='First')
   ...: plt.xticks(index+0.4,['A','B','C','D','E'])
   ...: plt.legend(loc=2)

```

### 水平条形图

到目前为止，您已经看到了垂直方向的条形图。也有水平方向条形图。该模式由一个名为`barh()`的特殊函数实现。对`bar()`函数有效的参数和变量在该函数中保持不变。您必须考虑的唯一变化是轴的角色颠倒了。现在，类别在 y 轴上表示，数值在 x 轴上显示(参见图 [7-37](#Fig37) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig37_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig37_HTML.jpg)

图 7-37

简单的水平条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: index = np.arange(5)
   ...: values1 = [5,7,3,4,6]
   ...: std1 = [0.8,1,0.4,0.9,1.3]
   ...: plt.title('A Horizontal Bar Chart')
   ...: plt.barh(index,values1,xerr=std1,error_kw={'ecolor':'0.1','capsize':6},alpha=0.7,label='First')
   ...: plt.yticks(index+0.4,['A','B','C','D','E'])
   ...: plt.legend(loc=5)

```

### 多序列条形图

与折线图一样，条形图通常也用于同时显示更大的数值系列。但是在这种情况下，有必要对如何构建多系列条形图做一些说明。到目前为止，您已经为 x 轴定义了一系列索引，每个索引对应一个条形。这些指数应该代表类别。然而，在这种情况下，有更多的条形必须共享同一个类别。

用来解决这个问题的一种方法是将一个索引所占用的空间(为了方便起见，其宽度为 1)分成与共享该索引并且我们想要显示的条一样多的部分。此外，建议添加空格，作为一个类别与下一个类别之间的间隔(如图 [7-38](#Fig38) 所示)。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig38_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig38_HTML.jpg)

图 7-38

显示三个系列的多系列条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: index = np.arange(5)
   ...: values1 = [5,7,3,4,6]
   ...: values2 = [6,6,4,5,7]
   ...: values3 = [5,6,5,4,6]
   ...: bw = 0.3
   ...: plt.axis([0,5,0,8])
   ...: plt.title('A Multiseries Bar Chart',fontsize=20)
   ...: plt.bar(index,values1,bw,color='b')
   ...: plt.bar(index+bw,values2,bw,color='g')
   ...: plt.bar(index+2*bw,values3,bw,color='r')
   ...: plt.xticks(index+1.5*bw,['A','B','C','D','E'])

```

关于多系列水平条形图(见图 [7-39](#Fig39) ，情况非常相似。你必须用相应的`barh()`函数替换`bar()`函数，并且记住用`yticks()`函数替换`xticks()`函数。您需要反转`axis()`功能中坐标轴覆盖的数值范围。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig39_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig39_HTML.jpg)

图 7-39

多系列水平条形图

```py
In [ ]: import matplotlib.pyplot as plt

   ...: import numpy as np
   ...: index = np.arange(5)
   ...: values1 = [5,7,3,4,6]
   ...: values2 = [6,6,4,5,7]
   ...: values3 = [5,6,5,4,6]
   ...: bw = 0.3
   ...: plt.axis([0,8,0,5])
   ...: plt.title('A Multiseries Horizontal Bar Chart',fontsize=20)
   ...: plt.barh(index,values1,bw,color='b')
   ...: plt.barh(index+bw,values2,bw,color='g')
   ...: plt.barh(index+2*bw,values3,bw,color='r')
   ...: plt.yticks(index+0.4,['A','B','C','D','E'])

```

### 带熊猫数据框架的多系列条形图

正如您在折线图中看到的，matplotlib 库还提供了以条形图形式直接表示包含数据分析结果的 dataframe 对象的能力。即使在这里，它也是快速、直接、自动地完成的。您唯一需要做的事情是使用应用于 dataframe 对象的`plot()`函数，并在一个名为`kind`的 kwarg 中指定您要表示的图表类型，在本例中是`bar`。因此，无需指定任何其他设置，您将得到如图 [7-40](#Fig40) 所示的条形图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig40_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig40_HTML.jpg)

图 7-40

数据框中的值可以直接显示为条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: import pandas as pd
   ...: data = {'series1':[1,3,4,3,5],
                'series2':[2,4,5,2,4],
                'series3':[3,2,3,1,3]}
   ...: df = pd.DataFrame(data)
   ...: df.plot(kind='bar')

```

但是，如果您想获得更多的控制，或者如果您的情况需要，您仍然可以将数据帧的一部分提取为 NumPy 数组，并按照本节前面的示例所示使用它们。也就是说，将它们分别作为参数传递给 matplotlib 函数。

此外，关于水平条形图，可以应用相同的规则，但是记住将`barh`设置为`kind` kwarg 的值。你会得到一个多序列水平条形图，如图 [7-41](#Fig41) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig41_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig41_HTML.jpg)

图 7-41

水平条形图可能是可视化数据框架值的有效替代方法

### 多序列堆积条形图

表示多系列条形图的另一种形式是堆叠形式，其中条形图一个接一个地堆叠在一起。当您想要显示所有条形相加得到的总值时，这尤其有用。

要将一个简单的多系列条形图转换成堆叠条形图，您需要将`bottom` kwarg 添加到每个`bar()`函数中。每个系列必须分配到相应的`bottom`克沃格。最后你会得到堆积条形图，如图 [7-42](#Fig42) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig42_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig42_HTML.jpg)

图 7-42

多系列堆积条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: series1 = np.array([3,4,5,3])
   ...: series2 = np.array([1,2,2,5])
   ...: series3 = np.array([2,3,3,4])
   ...: index = np.arange(4)
   ...: plt.axis([-0.5,3.5,0,15])
   ...: plt.title('A Multiseries Stacked Bar Chart')
   ...: plt.bar(index,series1,color='r')
   ...: plt.bar(index,series2,color='b',bottom=series1)
   ...: plt.bar(index,series3,color='g',bottom=(series2+series1))
   ...: plt.xticks(index+0.4,['Jan18','Feb18','Mar18','Apr18'])

```

同样，为了创建等效的水平堆积条形图，您需要用`barh()`函数替换`bar()`函数，同时小心地更改其他参数。实际上，`xticks()`函数应该被替换为`yticks()`函数，因为类别的标签现在必须在 y 轴上报告。完成所有这些更改后，您将获得如图 [7-43](#Fig43) 所示的水平堆积条形图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig43_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig43_HTML.jpg)

图 7-43

多系列水平堆积条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: index = np.arange(4)
   ...: series1 = np.array([3,4,5,3])
   ...: series2 = np.array([1,2,2,5])
   ...: series3 = np.array([2,3,3,4])
   ...: plt.axis([0,15,-0.5,3.5])
   ...: plt.title('A Multiseries Horizontal Stacked Bar Chart')
   ...: plt.barh(index,series1,color='r')
   ...: plt.barh(index,series2,color='g',left=series1)
   ...: plt.barh(index,series3,color='b',left=(series1+series2))
   ...: plt.yticks(index+0.4,['Jan18','Feb18','Mar18','Apr18'])

```

到目前为止，不同的系列是通过使用不同的颜色来区分的。区分不同系列的另一种方式是使用阴影线，它允许您用以不同方式绘制的笔画填充不同的线条。要做到这一点，你必须首先将条的颜色设置为白色，然后你必须使用`hatch` kwarg 来定义如何设置阴影。各种影线具有可在这些字符(|、/、-、\、*、-)之间区分的代码，这些字符对应于填充条的线条样式。符号复制得越多，形成影线的线条就越密集。比如`///`比`//`密，后者比`/`密(见图 [7-44](#Fig44) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig44_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig44_HTML.jpg)

图 7-44

堆叠的条可以通过它们的影线来区分

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: index = np.arange(4)
   ...: series1 = np.array([3,4,5,3])
   ...: series2 = np.array([1,2,2,5])
   ...: series3 = np.array([2,3,3,4])
   ...: plt.axis([0,15,-0.5,3.5])
   ...: plt.title('A Multiseries Horizontal Stacked Bar Chart')
   ...: plt.barh(index,series1,color='w',hatch='xx')
   ...: plt.barh(index,series2,color='w',hatch='///', left=series1)
   ...: plt.barh(index,series3,color='w',hatch='\\\\\\',left=(series1+series2))
   ...: plt.yticks(index+0.4,['Jan18','Feb18','Mar18','Apr18'])
Out[453]:
([<matplotlib.axis.YTick at 0x2a9f0748>,
  <matplotlib.axis.YTick at 0x2a9e1f98>,
  <matplotlib.axis.YTick at 0x2ac06518>,
  <matplotlib.axis.YTick at 0x2ac52128>],
 <a list of 4 Text yticklabel objects>)

```

### 带熊猫数据框架的堆积条形图

同样对于堆叠条形图，使用`plot()`函数直接表示 dataframe 对象中包含的值非常简单。你只需要添加一个参数`stacked` kwarg 设置为`True`(见图 [7-45](#Fig45) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig45_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig45_HTML.jpg)

图 7-45

数据帧的值可以直接显示为堆叠条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import pandas as pd
   ...: data = {'series1':[1,3,4,3,5],
                'series2':[2,4,5,2,4],
                'series3':[3,2,3,1,3]}
   ...: df = pd.DataFrame(data)
   ...: df.plot(kind='bar', stacked=True)
Out[5]: <matplotlib.axes._subplots.AxesSubplot at 0xcda8f98>

```

### 其他条形图表示

另一种非常有用的表示形式是用于比较的条形图，其中通过沿 y 轴的相反方向放置条形来比较两个具有相同类别的数值系列。为了做到这一点，你必须把两个数列中的一个数列的 y 值设为负数。同样在这个示例中，您将看到以不同的方式给条形的内部颜色着色的可能性。事实上，您可以通过在特定的 kwarg: `facecolor`上设置两种不同的颜色来实现这一点。

此外，在本例中，您将看到如何在每个条形的末尾添加带有标签的 y 值。这对于增加条形图的可读性很有用。你可以使用一个`for`循环来实现，其中`text()`函数将显示 y 值。您可以使用称为`ha`和`va`的两个旋钮调节标签位置，这两个旋钮分别控制水平和垂直对齐。结果将是如图 [7-46](#Fig46) 所示的图表。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig46_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig46_HTML.jpg)

图 7-46

使用这种条形图可以比较两个系列

```py
In [ ]: import matplotlib.pyplot as plt
   ...: x0 = np.arange(8)
   ...: y1 = np.array([1,3,4,6,4,3,2,1])
   ...: y2 = np.array([1,2,5,4,3,3,2,1])
   ...: plt.ylim(-7,7)
   ...: plt.bar(x0,y1,0.9,facecolor='r')
   ...: plt.bar(x0,-y2,0.9,facecolor='b')
   ...: plt.xticks(())
   ...: plt.grid(True)
   ...: for x, y in zip(x0, y1):
           plt.text(x + 0.4, y + 0.05, '%d' % y, ha="center", va= 'bottom')
   ...:
   ...: for x, y in zip(x0, y2):
           plt.text(x + 0.4, -y - 0.05, '%d' % y, ha="center", va= 'top')

```

## 饼图

将数据显示到条形图的另一种方式是饼状图，使用`pie()`函数很容易获得。

即使对于这种类型的函数，也要将包含要显示的值的列表作为主参数传递。我选择了百分比(它们的总和是 100)，但是您可以使用任何类型的值。将由`pie()`函数来固有地计算每个值所占的百分比。

同样，对于这种类型的表示，您需要利用 kwargs 来定义一些关键特性。例如，如果您想要定义颜色的顺序，它将被分配给相应的输入值顺序，您必须使用`colors` kwarg。因此，您必须分配一个字符串列表，每个字符串包含所需颜色的名称。另一个重要的特性是向饼图的每个部分添加标签。为此，您必须使用`labels` kwarg，您将向它分配一个包含要按顺序显示的标签的字符串列表。

此外，为了以完美的球形方式绘制饼图，您必须在末尾添加`axis()`函数，指定字符串`'equal'`作为参数。你将得到如图 [7-47](#Fig47) 所示的饼状图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig47_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig47_HTML.jpg)

图 7-47

一个非常简单的饼图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: labels = ['Nokia','Samsung','Apple','Lumia']
   ...: values = [10,30,45,15]
   ...: colors = ['yellow','green','red','blue']
   ...: plt.pie(values,labels=labels,colors=colors)
   ...: plt.axis('equal')

```

为了增加饼图的复杂性，您可以用从饼图中提取的切片来绘制饼图。这通常是在您想要关注特定切片时完成的。例如，在这种情况下，您可以突出显示涉及诺基亚的切片。为了做到这一点，有一种特殊的 kwarg 叫做`explode`。它只是 0 或 1 的浮点值序列，其中 1 对应于完全扩展的切片，0 对应于完全在饼图中的切片。所有中间值对应于中间提取度(见图 [7-48](#Fig48) )。

您还可以使用`title()`功能向饼图添加标题。您还可以通过添加`startangle` kwarg 来调整饼图的旋转角度，kwarg 取 0 到 360 之间的整数值，这是精确的旋转度数(0 是默认值)。

修改后的图表应如图 [7-48](#Fig48) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig48_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig48_HTML.jpg)

图 7-48

更高级的饼图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: labels = ['Nokia','Samsung','Apple','Lumia']
   ...: values = [10,30,45,15]
   ...: colors = ['yellow','green','red','blue']
   ...: explode = [0.3,0,0,0]
   ...: plt.title('A Pie Chart')
 ...:plt.pie(values,labels=labels,colors=colors,explode=explode,startangle=180)
   ...: plt.axis('equal')

```

但是，您可以在饼图中插入的其他内容并没有到此为止。例如，饼图没有带刻度的轴，因此很难想象每个扇区所代表的完美百分比。为了克服这个问题，您可以使用`autopct` kwarg，它在每个切片的中心添加一个显示相应值的文本标签。

如果你想让它看起来更吸引人，你可以把`shadow` kwarg 设置为`True`来添加阴影。最终你会得到如图 [7-49](#Fig49) 所示的饼状图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig49_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig49_HTML.jpg)

图 7-49

一个更高级的饼图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: labels = ['Nokia','Samsung','Apple','Lumia']
   ...: values = [10,30,45,15]
   ...: colors = ['yellow','green','red','blue']
   ...: explode = [0.3,0,0,0]
   ...: plt.title('A Pie Chart')
   ...: plt.pie(values,labels=labels,colors=colors,explode=explode,
        shadow=True,autopct='%1.1f%%',startangle=180)
   ...: plt.axis('equal')

```

### 带熊猫数据框的饼图

即使对于饼图，您也可以表示 dataframe 对象中包含的值。然而，在这种情况下，饼图一次只能表示一个系列，因此在本例中，您将只显示指定`df['series1']`的第一个系列的值。您必须通过`plot()`函数中的`kind` kwarg 指定您想要表示的图表类型，在本例中是`pie`。此外，因为您希望将饼图表示为完美的圆形，所以有必要添加`figsize` kwarg。最后你会得到如图 [7-50](#Fig50) 所示的饼状图。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig50_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig50_HTML.jpg)

图 7-50

熊猫数据框架中的数值可以直接绘制成饼图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import pandas as pd
   ...: data = {'series1':[1,3,4,3,5],
                'series2':[2,4,5,2,4],
                'series3':[3,2,3,1,3]}
   ...: df = pd.DataFrame(data)
   ...: df['series1'].plot(kind='pie',figsize=(6,6))
Out[14]: <matplotlib.axes._subplots.AxesSubplot at 0xe1ba710>

```

## 高级图表

除了更经典的图表，如条形图或饼图之外，您可能希望用另一种方式来表示您的结果。在互联网上和各种出版物中有许多例子，其中讨论和提出了许多可选的图形解决方案，有些非常出色和迷人。本节仅展示了一些图示；关于这个话题更详细的讨论超出了本书的目的。您可以将本节作为一个不断扩展的世界的介绍:数据可视化。

### 等高线图

科学界一种非常常见的图表类型是*等值线图*或*等值线图*。这种可视化实际上适合于通过由闭合曲线组成的等高线图来显示三维表面，这些闭合曲线示出了表面上位于同一水平面或具有相同 z 值的点。

虽然等高线图在视觉上是一个非常复杂的结构，但由于 matplotlib 库，它的实现并不困难。首先，您需要函数 *z = f (x，y)* 来生成一个三维表面。然后，一旦定义了将定义要显示的地图区域的值 x，y 的范围，您就可以计算每对(x，y)的 z 值，应用刚刚定义的函数 *f(x，y)* 以获得 z 值矩阵。最后，感谢`contour()`功能，你可以生成表面的等高线图。通常希望在等值线图的同时添加一个彩色图。也就是说，由色阶曲线界定的区域由颜色渐变填充，颜色渐变由颜色图定义。例如，如图 [7-51](#Fig51) 所示，您可以用越来越暗的蓝色阴影来表示负值，然后随着正值的增加而移动到黄色，然后是红色。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig51_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig51_HTML.jpg)

图 7-51

等值线图可以描述表面的 z 值

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: dx = 0.01; dy = 0.01
   ...: x = np.arange(-2.0,2.0,dx)
   ...: y = np.arange(-2.0,2.0,dy)
   ...: X,Y = np.meshgrid(x,y)
   ...: def f(x,y):
           return (1 - y**5 + x**5)*np.exp(-x**2-y**2)
   ...: C = plt.contour(X,Y,f(X,Y),8,colors='black')
   ...: plt.contourf(X,Y,f(X,Y),8)
   ...: plt.clabel(C, inline=1, fontsize=10)

```

标准颜色梯度(颜色图)如图 [7-51](#Fig51) 所示。实际上，你可以在大量可用的彩色地图中进行选择，只需用`cmap` kwarg 指定它们。

此外，当您必须处理这种表示时，添加色标作为图表一侧的参考几乎是必须的。这可以通过简单地在代码末尾添加`colorbar()`函数来实现。在图 [7-52](#Fig52) 中，你可以看到另一个颜色图的例子，它从黑色开始，经过红色，然后变成黄色，直到达到最高值的白色。这张彩图是`plt.cm.hot`。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig52_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig52_HTML.jpg)

图 7-52

“热”颜色贴图渐变为等高线贴图提供了一个吸引人的外观

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: dx = 0.01; dy = 0.01
   ...: x = np.arange(-2.0,2.0,dx)
   ...: y = np.arange(-2.0,2.0,dy)
   ...: X,Y = np.meshgrid(x,y)
   ...: def f(x,y):
           return (1 - y**5 + x**5)*np.exp(-x**2-y**2)
   ...: C = plt.contour(X,Y,f(X,Y),8,colors='black')
   ...: plt.contourf(X,Y,f(X,Y),8,cmap=plt.cm.hot)
   ...: plt.clabel(C, inline=1, fontsize=10)
   ...: plt.colorbar()

```

### 极坐标图

另一种流行的高级图表是*极坐标图。*这种类型的图表以一系列放射状延伸的扇形为特征；这些区域中的每一个都会占据一定的角度。因此，您可以显示两个不同的值，将它们分配给表征极线图的量值:半径 r 的延伸和扇形所占的角度θ。这些实际上是极坐标(r，θ)，这是在坐标轴上表示函数的另一种方式。从图形的角度来看，你可以把它想象成一种兼有饼图和条形图特征的图表。事实上，正如饼图所示，每个扇区的角度给出了该类别相对于总数的百分比信息。对于条形图，径向延伸是该类别的数值。

到目前为止，我们已经使用了标准的颜色集，使用单个字符作为颜色代码(例如，`r`表示红色)。事实上，你可以使用任何你想要的颜色。您必须定义一个字符串值列表，其中包含与您想要的颜色相对应的`#rrggbb`格式的 RGB 代码。

奇怪的是，要得到极坐标图，你必须使用`bar()`函数并传递包含角度 *θ* 的列表和每个扇区的径向延伸列表。结果将是一个极坐标图，如图 [7-53](#Fig53) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig53_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig53_HTML.jpg)

图 7-53

极坐标图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: N = 8
   ...: theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)
   ...: radii = np.array([4,7,5,3,1,5,6,7])
   ...: plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)
   ...: colors = np.array(['#4bb2c5', '#c5b47f', '#EAA228', '#579575', '#839557', '#958c12', '#953579', '#4b5de4'])
   ...: bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors)

```

在本例中，您已经使用格式#rrggbb 定义了颜色序列，但是您也可以将颜色序列指定为带有其实际名称的字符串(参见图 [7-54](#Fig54) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig54_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig54_HTML.jpg)

图 7-54

带有另一系列颜色的极坐标图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: N = 8
   ...: theta = np.arange(0.,2 * np.pi, 2 * np.pi / N)
   ...: radii = np.array([4,7,5,3,1,5,6,7])
   ...: plt.axes([0.025, 0.025, 0.95, 0.95], polar=True)
   ...: colors = np.array(['lightgreen', 'darkred', 'navy', 'brown', 'violet', 'plum', 'yellow', 'darkgreen'])
   ...: bars = plt.bar(theta, radii, width=(2*np.pi/N), bottom=0.0, color=colors)

```

## mplot3d 工具包

matplotlib 的所有标准安装都包含了`mplot3d`工具包，它允许您将可视化功能扩展到 3D 数据。如果图形显示在单独的窗口中，可以用鼠标旋转三维表示的轴。

在这个包中，您仍然使用 Figure 对象，只是您将定义一种新的对象，称为 Axes3D，并由这个工具包引入。因此，如果您想使用 Axes3D 对象，您需要向代码中添加一个新的导入。

```py
from mpl_toolkits.mplot3d import Axes3D

```

### 3D 曲面

在上一节中，您使用等高线图通过标高线来表示三维曲面。使用 mplot3D 包，可以直接在 3D 中绘制表面。在本例中，您将使用在等值线图中使用的相同函数 *z = f (x，y)* 。

一旦你计算了`meshgrid`，你就可以用`plot_surface()`功能查看表面。将出现一个三维的蓝色表面，如图 [7-55](#Fig55) 。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig55_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig55_HTML.jpg)

图 7-55

3D 表面可以用 mplot3d 工具包来表示

```py
In [ ]: from mpl_toolkits.mplot3d import Axes3D
   ...: import matplotlib.pyplot as plt
   ...: fig = plt.figure()
   ...: ax = Axes3D(fig)
   ...: X = np.arange(-2,2,0.1)
   ...: Y = np.arange(-2,2,0.1)
   ...: X,Y = np.meshgrid(X,Y)
   ...: def f(x,y):
   ...:    return (1 - y**5 + x**5)*np.exp(-x**2-y**2)
   ...: ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1)

```

通过改变颜色图，3D 表面最突出，例如通过设置`cmap` kwarg。您也可以使用`view_init()`功能旋转表面。实际上，这个函数调整了你观察表面的视角，改变了两个角，分别叫做`elev`和`azim`。通过它们的组合，你可以从任何角度显示表面。第一个旋钮调节表面可见的高度，而`azim`调节表面的旋转角度。

例如，您可以使用`plt.cm.hot`更改颜色贴图，并将视点移动到 elev=30 和 azim=125。结果如图 [7-56](#Fig56) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig56_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig56_HTML.jpg)

图 7-56

可以旋转 3D 表面并从更高的视点进行观察

```py
In [ ]: from mpl_toolkits.mplot3d import Axes3D
   ...: import matplotlib.pyplot as plt
   ...: fig = plt.figure()
   ...: ax = Axes3D(fig)
   ...: X = np.arange(-2,2,0.1)
   ...: Y = np.arange(-2,2,0.1)
   ...: X,Y = np.meshgrid(X,Y)
   ...: def f(x,y):
    return (1 - y**5 + x**5)*np.exp(-x**2-y**2)
   ...: ax.plot_surface(X,Y,f(X,Y), rstride=1, cstride=1, cmap=plt.cm.hot)
   ...: ax.view_init(elev=30,azim=125)

```

### 三维散点图

所有 3D 视图中使用最多的模式仍然是 3D 散点图。通过这种类型的可视化，您可以确定这些点是否遵循特定的趋势，但最重要的是，它们是否倾向于聚集。

在这种情况下，您将使用`scatter()`函数作为 2D 情况，但应用于 Axes3D 对象。通过这样做，你可以将不同的序列可视化，通过调用`scatter()`函数来表达，所有这些都在同一个 3D 表示中(见图 [7-57](#Fig57) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig57_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig57_HTML.jpg)

图 7-57

这个 3D 散点图显示了三个不同的集群

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: from mpl_toolkits.mplot3d import Axes3D
   ...: xs = np.random.randint(30,40,100)
   ...: ys = np.random.randint(20,30,100)
   ...: zs = np.random.randint(10,20,100)
   ...: xs2 = np.random.randint(50,60,100)
   ...: ys2 = np.random.randint(30,40,100)
   ...: zs2 = np.random.randint(50,70,100)
   ...: xs3 = np.random.randint(10,30,100)
   ...: ys3 = np.random.randint(40,50,100)
   ...: zs3 = np.random.randint(40,50,100)
   ...: fig = plt.figure()
   ...: ax = Axes3D(fig)
   ...: ax.scatter(xs,ys,zs)
   ...: ax.scatter(xs2,ys2,zs2,c='r',marker='^')
   ...: ax.scatter(xs3,ys3,zs3,c='g',marker='*')
   ...: ax.set_xlabel('X Label')
   ...: ax.set_ylabel('Y Label')
   ...: ax.set_zlabel('Z Label')
Out[34]: <matplotlib.text.Text at 0xe1c2438>

```

### 三维条形图

在数据分析中广泛使用的另一种类型的 3D 绘图是 3D 条形图。同样在这种情况下，您使用应用于对象 Axes3D 的`bar()`函数。如果您定义了多个系列，您可以在同一个 3D 可视化中累积对`bar()`函数的多次调用(参见图 [7-58](#Fig58) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig58_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig58_HTML.jpg)

图 7-58

三维条形图

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: from mpl_toolkits.mplot3d import Axes3D
   ...: x = np.arange(8)
   ...: y = np.random.randint(0,10,8)
   ...: y2 = y + np.random.randint(0,3,8)
   ...: y3 = y2 + np.random.randint(0,3,8)
   ...: y4 = y3 + np.random.randint(0,3,8)
   ...: y5 = y4 + np.random.randint(0,3,8)
   ...: clr = ['#4bb2c5', '#c5b47f', '#EAA228', '#579575', '#839557', '#958c12', '#953579', '#4b5de4']
   ...: fig = plt.figure()
   ...: ax = Axes3D(fig)
   ...: ax.bar(x,y,0,zdir='y',color=clr)
   ...: ax.bar(x,y2,10,zdir='y',color=clr)
   ...: ax.bar(x,y3,20,zdir='y',color=clr)
   ...: ax.bar(x,y4,30,zdir='y',color=clr)
   ...: ax.bar(x,y5,40,zdir='y',color=clr)
   ...: ax.set_xlabel('X Axis')
   ...: ax.set_ylabel('Y Axis')
   ...: ax.set_zlabel('Z Axis')
   ...: ax.view_init(elev=40)

```

## 多面板图

到目前为止，您已经有机会看到通过图表表示数据的不同方式。您看到了如何在同一个图形中通过用支线剧情分隔来查看更多图表。在本节中，您将通过分析更复杂的案例来加深对该主题的理解。

### 在其他支线剧情中显示支线剧情

现在将解释一种更高级的方法:在框架内查看他人图表的能力。因为我们讨论的是框架，即 Axes 对象，所以您需要将主轴(即通用图表)从您想要添加的框架中分离出来，该框架将是 Axes 的另一个实例。为此，您使用`figures()`函数来获取图形对象，您将在该对象上使用`add_axes()`函数定义两个不同的轴对象。见图 [7-59](#Fig59) 中该示例的结果。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig59_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig59_HTML.jpg)

图 7-59

一个子情节显示在另一个情节中

```py
In [ ]: import matplotlib.pyplot as plt
   ...: fig = plt.figure()
   ...: ax = fig.add_axes([0.1,0.1,0.8,0.8])
   ...: inner_ax = fig.add_axes([0.6,0.6,0.25,0.25])

```

为了更好的理解这种显示方式的效果，可以用真实数据填充前面的轴，如图 [7-60](#Fig60) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig60_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig60_HTML.jpg)

图 7-60

另一个情节中的次要情节的更真实的可视化

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: fig = plt.figure()
   ...: ax = fig.add_axes([0.1,0.1,0.8,0.8])
   ...: inner_ax = fig.add_axes([0.6,0.6,0.25,0.25])
   ...: x1 = np.arange(10)
   ...: y1 = np.array([1,2,7,1,5,2,4,2,3,1])
   ...: x2 = np.arange(10)
   ...: y2 = np.array([1,3,4,5,4,5,2,6,4,3])
   ...: ax.plot(x1,y1)
   ...: inner_ax.plot(x2,y2)
Out[95]: [<matplotlib.lines.Line2D at 0x14acf6d8>]

```

### 支线剧情网格

你已经看到了支线剧情的创造。使用`subplots()`功能，通过将一个情节分成几个部分来添加支线剧情是非常简单的。matplotlib 允许您使用另一个名为`GridSpec()`的函数来管理更复杂的情况。这种细分允许将绘图区域分割成子区域网格，你可以将一个或多个子区域分配给每个子情节，这样最终你可以获得不同大小和方向的子情节，如图 [7-61](#Fig61) 所示。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig61_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig61_HTML.jpg)

图 7-61

可以在子区域的网格上定义不同大小的子情节

```py
In [ ]: import matplotlib.pyplot as plt
   ...: gs = plt.GridSpec(3,3)
   ...: fig = plt.figure(figsize=(6,6))
   ...: fig.add_subplot(gs[1,:2])
   ...: fig.add_subplot(gs[0,:2])
   ...: fig.add_subplot(gs[2,0])
   ...: fig.add_subplot(gs[:2,2])
   ...: fig.add_subplot(gs[2,1:])

Out[97]: <matplotlib.axes._subplots.AxesSubplot at 0x12717438>

```

现在你已经清楚了如何通过给支线剧情分配不同的区域来管理网格，是时候看看如何使用这些支线剧情了。其实你可以用每个`add_subplot()`函数返回的 Axes 对象调用`plot()`函数来绘制相应的图(见图 [7-62](#Fig62) )。

![img/336498_2_En_7_Chapter/336498_2_En_7_Fig62_HTML.jpg](img/336498_2_En_7_Chapter/336498_2_En_7_Fig62_HTML.jpg)

图 7-62

支线剧情网格可以同时显示许多情节

```py
In [ ]: import matplotlib.pyplot as plt
   ...: import numpy as np
   ...: gs = plt.GridSpec(3,3)
   ...: fig = plt.figure(figsize=(6,6))
   ...: x1 = np.array([1,3,2,5])
   ...: y1 = np.array([4,3,7,2])
   ...: x2 = np.arange(5)
   ...: y2 = np.array([3,2,4,6,4])
   ...: s1 = fig.add_subplot(gs[1,:2])
   ...: s1.plot(x,y,'r')
   ...: s2 = fig.add_subplot(gs[0,:2])
   ...: s2.bar(x2,y2)
   ...: s3 = fig.add_subplot(gs[2,0])
   ...: s3.barh(x2,y2,color='g')
   ...: s4 = fig.add_subplot(gs[:2,2])
   ...: s4.plot(x2,y2,'k')
   ...: s5 = fig.add_subplot(gs[2,1:])
   ...: s5.plot(x1,y1,'b^',x2,y2,'yo')

```

## 结论

在本章中，您已经了解了 matplotlib 库的所有基本方面，并且通过一系列示例，您已经了解了处理数据可视化的基本工具。您已经熟悉了如何用几行代码开发不同类型的图表的各种示例。

在本章中，我们总结了提供基本工具来执行数据分析的库部分。在下一章，你将开始讨论与数据分析最密切相关的主题。