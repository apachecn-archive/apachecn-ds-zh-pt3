

# 二、分析开源软件

除非你了解开源，否则你无法掌握数据科学。在过去的二十年里，正是氧气推动了人工智能的爆炸式增长。您将很难找到今天正在使用的任何软件产品或工具不利用开源或者本身不是开源的。

在这一章中，我们将学习一个工具的开源意味着什么，以及它如何限制(或不限制)你如何使用它。然后，我们将介绍如何在您的项目中找到并开始使用不同的开源工具。最后，我们将通过评估和使用最流行的数据科学开源工具之一 scikit-learn 来运用这些技能。

我们将关注以下主题:

*   了解开源
*   了解四大 OSS 许可证
*   评估新工具或库
*   使用 Anaconda 发行版和 conda-forge 导入包
*   评估和使用 scikit-learn

# 技术要求

对于本章，您需要安装 Anaconda 发行版。这将与 conda、Navigator 和最广泛使用的数据科学工具一起提供，包括我们将在本章后面使用的所有包。

在开始之前，您需要设置一个 GitHub 帐户。头去[https://github.com/join](https://github.com/join)做那件事。

你可以在这里找到本章和本书其余部分的代码:[https://github . com/packt publishing/Building-Data-Science-Solutions-with-Anaconda/tree/main/chapter 02](https://github.com/PacktPublishing/Building-Data-Science-Solutions-with-Anaconda/tree/main/Chapter02)。

我们还将编写和编辑代码。可以选择集成开发环境 ( **IDE** )，比如 Visual Studio 代码，但是建议你使用非常流行的 Jupyter 笔记本来完成我们在本章中要做的任务。Jupyter 包含在 Anaconda 发行版中。

# 了解开源

对你已经听到或将要听到的这个术语有一个基本的看法是至关重要的。这将让你头脑中保持一幅清晰的画面，知道如何浏览当前存在的差异，并确保你能够挑选出完成工作所需的工具。在这一部分，你将了解到**开源软件**(或简称 **OSS** )是什么意思。

免费的意思是言论自由，而不是免费的啤酒，这是一个用来描述开源软件中免费的 T2 部分的短语。这个意义上的免费并不是指你可以随意使用和消费而不需要任何回报的东西；更重要的是应该有一个开放的思想交流的想法和概念。就像言论自由一样，除非你想要法律后果，否则你能说什么、不能说什么、做什么都是有限制的。随着本章的继续，这种区别会变得更加清楚。

简而言之，OSS 是可以自由使用、修改和共享的软件。这与旧的(但仍然非常活跃的)专有软件的方式形成了鲜明的对比，在这种方式下，代码由生产它的公司/实体唯一拥有。在这种情况下，代码通常不会在公司外部共享，并且会尽力限制或阻止任何使用该软件的人看到它。

最好将 OSS 视为一种理念，而不仅仅是一个法律或技术术语。核心思想是，当知识和软件可以被学习和分享，而不是被任何公司或团体扣为人质时，世界会变得更好。当看到它是如何让人工智能蓬勃发展时，很难争辩这不是事实。

开源起源

克里斯汀·彼得森现在被认为在 20 多年前提出了“开源”这个术语作为自由软件的替代品。误解是*免费*暗示它在谈论价格，但事实并非如此。相反，它意味着自由和可用源代码软件的概念。Tim O'Reilly 通过组织免费软件峰会帮助巩固了这一点，后来这个术语被更广泛地接受和采用，并变成了开源峰会。

尽管软件中可能有许多细微差别，但了解什么是操作系统*而不是*是有价值的。

OSS 并不意味着以下内容:

*   维护人员必须修补漏洞。
*   你可以用它做任何你想做的事情(许可证限制)。
*   创作者需要提供支持。
*   无论如何都要维护。
*   它将保持托管状态，因此您总是知道它在哪里。

它几乎没有任何保证。这是一个朋友把他们的车钥匙交给你，并对你说:*这是我在车库里做的一个很棒的东西。我可能会时不时过来修理一些东西，但不能保证。希望有帮助！*您可能对某些东西有疑问，您可以打开发动机罩随意更换。你不能抱怨，因为你刚刚免费得到一辆新车。

话虽如此，让我们看看开源的本质，它是一个项目的实际源代码，以及您如何开始直接使用它。

## 用 Git 和 GitHub 派生一个 OSS 库

有了这么多开放源码软件，很容易找到你想贡献的东西。很容易，分发代码最常见的方式是 VIa Git repo，如 GitHub 或 Bitbucket。 **Git** 是一个版本控制系统，它允许你维护对代码库所做的每一个变更的副本，并在你需要的时候恢复。一个**存储库**(通常简称为 *repo* )就是一个存储在某个预设的在线位置的文件集合，具有定义的结构。在 GitHub 的情况下，一个 repo 将是构成项目源代码的所有文件。如果说 OSS 是 AI 成长的氧气，那么 GitHub 和 Bitbucket 就是包容它所需要的大气。GitHub 更受欢迎，所以我们将在下一节重点讨论这一点，并查看一些常见术语。

### 工作存储库与克隆存储库

有两种主要的方式可以让你开始使用开源工具:

*   分支
*   克隆

这两种方法都创建了代码库的副本，但是主要的区别是 forking 维护了到上游 repo 的链接。上游的**只是，这个术语的意思是官方代码所在的点。维护人员做出改变并添加特性，然后它*向下游*流向你。想象一下，你的朋友在你上游的一条河流上，他们把一个新的引擎放在水中的木筏上，知道水流会把它带到你那里。**

有了克隆，您就有了上游代码的静态副本，如果您想要任何新的东西，您将不得不使用`git pull`专门请求它。这类似于在上一段的例子中，让你的朋友向下游发送新的引擎给你。

如果你想为一个你不是维护者的 OSS 项目做贡献(如果你不知道你是，那么你可能不是)，他们会要求你首先创建一个分支。这将允许您创建一个**拉请求**(或者简称为 **PR** )，如果您愿意，这将允许您的更改被提交到主存储库。

接下来，您将看到 Anaconda 命令行工具 **conda** 的这个过程的可视化。原始回购可以被分支到你自己的 GitHub 帐户的回购，从那里你可以克隆到你的实际电脑上工作。下图对此进行了说明:

![Figure 2.1 – Flow of forking and cloning a repo
](img/Figure_2.1.jpg)

图 2.1–派生和克隆回购的流程

从前面的图中，您将看到流程如下所示:

1.  从原始代码库中派生。
2.  克隆到您的本地机器。做一些改变或更新。
3.  将您的更改推回到您自己的回购中。
4.  从您的回购到原始回购创建一个 PR。

在下一节中，我们将通过一个例子快速了解分叉的实际过程。

### 如何派生存储库

分叉的过程非常简单。让我们以 Anaconda 的命令行工具 conda 为例。许多 OSS 工具都有贡献指南，conda 也不例外。完整的指南可以在 https://github.com/conda/conda/blob/master/CONTRIBUTING.md 的[找到，它详细介绍了分叉过程。现在让我们看一个快速分叉的例子:](https://github.com/conda/conda/blob/master/CONTRIBUTING.md)

1.  转到 https://github . com/conda/Conde。
2.  在屏幕的右上方，会有一个**叉**按钮。点击该按钮以创建回购的副本。(如果您是多个组织的成员，您将需要选择要加入的组织。)
3.  几分钟后，您的回购将会显示。就是这样！

在左上角，你会看到自动填充的回购名称 **<你的用户名> /conda** ，下面显示的额外信息，是从 conda/conda 分叉而来的*。现在，您将拥有自己的完整回购副本，您可以对其进行任何操作。*

拉取请求

关于拉请求，Git 的官方文档说了什么？恶作剧问题。它什么也没说。pull 请求只是存在于 GitHub 或 Bitbucket 等 repos 上的一个构造，作为在正式合并之前审查工作的一种方式。拉请求向开发人员发出信号，表明代码已经准备好合并到代码库的其余部分。

## 定义开源软件

围绕开源软件的所有讨论，你可能想知道这到底意味着什么。你可以找到各种各样的定义，但是总的来说，**开源倡议** ( **OSI** )的标准被认为是软件开源的事实标准，我们现在就来看看。

在下面的标准列表中，我提供了我自己对每个标准的总结，除非有些项目我认为已经非常清楚，不需要进一步澄清。如果你想看完整的定义，你可以在 https://opensource.org/osd[的](https://opensource.org/osd)找到:

*   **免费再分发**:许可证不能限制某人用不同来源的软件打包软件。你不能为它收费。
*   **源代码**:你必须允许并确保源代码易于访问和查看。
*   **衍生作品**:你必须允许其他人用你的软件制作其他东西，使用相同的许可。
*   作者源代码的完整性:这个可能有点棘手，所以我们将在这里多花一点时间来解释。

许可证可以要求您在分发现有代码时不要更改它，但前提是它还允许添加独立文件来修补功能。这又回到了开源的核心，即允许修改软件的方法。那么为什么要限制呢？原因是为了确保，如果需要的话，某些已知安全的安全特性可以依赖于它们在审查代码时的相同状态。这确保没有对代码直接进行不安全的修改。

你必须清楚地说，有人被允许修改原始代码，然后在他们认为合适的时候发布它。许可证可以要求从原始代码创建的任何新内容具有不同的名称或不同的版本号。这是为了避免任何混淆，它是相同的原始软件。从本质上说，你不能做很多改变，仍然称之为同一件事。

*   **不得歧视个人或群体(与 OSI 定义相同)**:许可证不得歧视任何个人或群体。
*   没有领域歧视:你不能限制任何人在他们想要的任何领域使用软件。比如体育，军事，医学，或者一个你不认同的东西的创业，等等。
*   **许可证的分发**:除了最初附在作品上的许可证之外，不应该需要任何其他许可证。
*   **许可证不得特定于某个产品**:对于来说，该程序不能成为任何软件集合(通常称为分发版)的一部分。如果它被拆分并单独使用，使用它的人应该拥有与它与原始发行版打包在一起时相同的权利。
*   **许可证不得限制其他软件**:许可证不得对与其一起发布的其他软件施加限制。这将阻止像 Anaconda 发行版这样的东西在没有将自己的意志强加于该发行版中的所有其他软件包的情况下包含有问题的许可软件。
*   **许可证必须是技术中立的**:许可证的任何部分都不能说在开发过程中必须使用任何一种技术。开源不是关于某项技术的，它是一种不应该与特定工具或技术捆绑在一起的想法。

如果任何软件符合所有这些标准，你可以肯定它是 OSS。如果你想让你的许可证被官方接受为开放源码，你也必须得到 OSI 的批准。如果你只是使用现有的许可证，那么申请批准是没有必要的。现在让我们在下一节看看 OSS 的优势。

## 开放源码软件的优势

如果我们将 OSS 软件比作一辆汽车，那么 OSS 模型除了免费获得某些东西之外的一个巨大优势是，你还可以告诉你的朋友，你可以对操控、性能等进行一些改进，然后将这些改进传递给任何人，这样任何人都可以使用它们(当然，这种类比在这里有点站不住脚，因为有了软件，每个人都可以得到自己的*汽车*。通过这种方式，在任何给定的时刻，你都成倍地增加了致力于改善现有状况的人数。

有些 OSS 工具(比如 TensorFlow)有上千个贡献者！OSS 社区是它的超级力量之一，有一大群热情的人愿意工作，让你的代码变得更好，而不要求任何回报。

这种模式的另一个优点是，你可以很容易地确保你的辛勤工作得到回报。OSS 这个词给人一种感觉，任何人都可以很容易地使用某样东西，并且知道它不能被拿走。他们也可以查看他们想要的每一点代码。开源工具也非常安全。有这么多的人可以看东西，你有许多双愿意纠正事情和提交安全补丁的眼睛。(这有局限性——参见评估 OSS 指南的*评估新工具或库*部分。)

它有很多优点，看起来免费共享是 OSS 的一个巨大组成部分。这是事实，但并不是所有的东西都是免费的。能从 OSS 上赚钱吗？是啊！如果你说，“嘿，我每天都要用这辆车去上班，我能每月付给你 100 美元来维持运转吗？”这只是一种方式。其他方式包括提供培训、支持等等。Red Hat 可能是最知名的基于 OSS 建立公司的公司。他们最出名的是他们的 Linux 发行版，他们为其提供企业支持。Anaconda 是另一家能够开辟道路的公司。

现在，你应该对什么是 OSS 有了一个基本的了解，以及拥有这个标签意味着什么。我们提到了软件的自由和好处，但是限制呢？虽然 OSS 经常被认为是你可以用它做任何你想做的事情的东西，但是在使用它的时候仍然有必须尊重的许可证。让我们来看看你最常遇到的问题。

# 了解四大 OSS 许可证

开放源码软件是有版权的，并且有一些限制，它们只是没有本世纪初普遍的知识产权法那么严格。在某个时候，你很有可能听说过诸如 MIT licenses、GPL 等术语。虽然这些听起来像是没人关心的法律术语，但出于以下原因，非常需要在高层次上熟悉这些东西:

*   如果你在你公司出售的代码库中放了一些东西，你可能不得不将这些软件开源。
*   你的个人项目可能是你宁愿保密或专有的东西。
*   将来你可能想从你的项目中赚钱。

您应该在做出决定使用某些软件包时记住这些，因为一旦您在您的软件中使用这些工具，您将来唯一可以不受这些许可证限制的选择就是完全替换您的那部分代码。在这一节中，我们将更多地讨论这些许可证对您的代码有哪些限制。

## 左版权与许可许可证

有两种主要的 OSS 许可类型:**版权所有**和**许可**。Copyleft 说，如果你对任何事情做出改变，你必须与世界分享。它的名字来源于对*版权*的半开玩笑的点头。所有衍生作品都必须拥有相同的许可，因此被视为*对等*。GPL 是最流行的版本。有了这个，如果你从你朋友的 GPL 许可的开源汽车中创建一个变形机器人，这个变形机器人也必须有 GPL 许可。

另一方面是许可的，Apache、BSD 和 MIT 都属于这一类。许可没有要求你必须在相同的许可下与世界分享你所改变的东西。在我们前面的例子中，如果您的朋友有 Apache 许可证，那么您可以在那个转换器上放一个新的许可证，这将阻止用户查看它的源代码，并且您可能可以出售它以获得不错的利润。

在开源社区中，关于哪一个是更自由的许可，存在着激烈的争论。我们将坚持事实。

虽然有大量不同的许可证(在撰写本书时有 200 多种)，但大部分开源许可证(80%以上)属于以下几种:

*   使用–25%
*   GPL 3.0–19%
*   阿帕奇 2.0–15%
*   GPL 2.0–15%
*   BSD 3–6%

让我们来看看前面列出的每一个许可证，这样下次你看到这个漂亮的新库的 *GPL* 时，你会对它的限制和允许有更好的预期:

*   麻省理工学院许可证(许可):这个排在第一位，原因很简单:很简单。在一个服务条款要求你拥有法律学位才能理解的世界里，麻省理工学院的许可证被写得非常容易处理，并且非常*轻量级*。只要你把麻省理工学院的许可证附在你的作品上，你就可以随心所欲地使用它。

*MIT 汽车类比*:车辆的所有原理图和操作都是已知可见的。如果你找到一种方法使引擎的燃油效率提高 20%,你可以把它藏起来，卖给任何你想要的人，而不会泄露你所做的任何代码更新。

*   **GNU 通用公共许可证 GPL 2.0/3.0(copy left)**:GPL 是 OSS 授权的始祖之一。它规定，如果你分发代码，那么你*必须*使人类可读的代码也是可用的。这确保了代码的现有值可以被直接更改、添加、学习和修改。此外，如果您更改代码并分发它，您还必须使它受 GPL 约束。

*GNU 车类比*:车辆的所有原理图和操作都是已知可见的。如果你找到一种方法让引擎的燃油效率提高 20%，你必须在同样的许可下让全世界都能看到你的原理图和文件。

*   Apache 2.0 许可证(许可):由 Apache Software Foundation 创建，这个许可证是自由的，有其许可权。您可以发布任何个人、内部或商业内容。如果你在事后不回头改变许可，它也可以用于专利和版权。
*   **BSD 许可证(许可)**:指因其提供的灵活性而广受欢迎的一系列许可证。它们与 Apache 许可证非常相似，但是没有关于专利等事物的明确语言。最广为人知的大概就是 3 条款版本，也就那么一个，很小的 3 条款许可。它说，如果你要在衍生作品中使用原作者的名字，你必须在软件中包含许可信息，并获得原作者的许可。

该系列中的其他许可证包括 0 条款、2 条款和 4 条款许可证。关于这些和其他的更多信息可以在他们位于[https://en.wikipedia.org/wiki/BSD_licenses](https://en.wikipedia.org/wiki/BSD_licenses)的维基页面上找到。

关于许可法的一个注释

我不得不说:这本书并不试图成为许可建议的全部，也不打算从建议和法律顾问的角度取代真正的软件律师。软件法律可能非常复杂，虽然我们试图给出准确的高级信息，但这里可能有许多细微差别，如果有任何疑问，您应该与该特定领域的专业人士交谈。

也有这样的情况，一个许可是基于一个被认可的 OSI 许可，但是没有被官方认为是开源的。

### 更改现有操作系统的许可证

正在考虑移动某物以使用新的许可证？再想想。只有新编写的代码才能受到新的、更严格的许可证的约束。这意味着已经公开的开源代码不能被编辑和修改。这是有充分理由的。你能想象如果少数非常受欢迎的 OSS 工具转换成专有模型会产生什么样的多米诺骨牌效应吗？

现在我们已经了解了一些关于许可证的知识，让我们学习如何找到一个库正在使用的许可证。

## 如何找到图书馆使用的许可证

既然你已经理解了许可对 OSS 意味着什么，你将能够实际决定你的软件包有什么许可。让我们再看一下康达的例子，看看它有什么许可证。

### 使用 conda

在 macOS 上使用终端，您可以使用下面的命令来查看您的环境中的包有哪些许可证:

```py
 <conda env file> grep '"license":' conda-meta/*.json
```

将`<conda env file>`替换为安装 conda 的正确路径。在我的系统上是这样的:

```py
/Users/computer_user/anaconda3/envs/env grep '"license":' conda-meta/*.json
```

使用终端不是唯一的方法；我们也可以在网上查看资源，找出正在使用的许可证。

### 来自 Anaconda.org

使用位于`Anaconda.org`的搜索栏找到您要找的包。当您选择它时，您会看到许可信息列为第一项。这里有一个 TensorFlow 的例子，你可以看到它使用的是 Apache 2.0。执照:[https://anaconda.org/conda-forge/tensorflow](https://anaconda.org/conda-forge/tensorflow)。

### 来自 GitHub

您可以通过搜索栏在 GitHub 上搜索包。一旦您选择它，您将被带到主回购页面。在右手边，你会看到许可证，如果它已被包括在内。通常，你会在顶层目录中看到一个**许可**文件。我们之前谈到的相同 TensorFlow 包和许可证可以在这里找到:【https://github.com/tensorflow/tensorflow[。](https://github.com/tensorflow/tensorflow)

![Figure 2.2 – View of TensorFlow license on GitHub
](img/Figure_2.2.jpg)

图 2.2–GitHub 上 TensorFlow 许可证的视图

许可可能是一个复杂的话题，也是一个潜在的法律雷区，取决于很多因素。有了这些关于主要许可的知识，您现在就有了基本的东西来确定您能做什么和不能做什么。当我们继续讨论本书中的特定工具时，我们将总是提到它们使用的许可，这样您就可以开始更好地了解它们的用途。如果你正在创业，我建议你去麻省理工学院。简单明了，你继续投入到我们所依赖的这个不可思议的生态系统中。

现在您已经了解了您将遇到的主要许可，让我们看看如何评估实际工具本身，以决定它们是否是您想要使用的。

# 评估新工具或库

唯一不变的是变化，毫无疑问，当我打这篇文章时，一个新的工具正在开发，它“修复”所有被 framework *X* 破坏的东西，但使用起来更简单。这一部分将帮助你进入一个新的世界，在这个世界里，新软件源源不断地免费提供。你将会学到在决定某样东西是否值得使用时，应该看哪些属性和因素。

在评估新工具时，您可以使用一些启发法。根据您的具体需求，可以随意调整您使用的工具:

*   该工具在 GitHub 上的星级数
*   工具的年龄
*   该工具已经更新了多长时间
*   维护者的数量
*   未解决问题/PRs 的数量
*   依赖关系的数量

我想给所有这些都加上一个大星号。这些问题有多重要的答案和哪种架构风格适合你的代码库的答案是一样的:*这取决于*。使用所有这些作为基础和指南，并在你认为合适的时候使用它们。还有一些规则密切相关，可能会抵消其他规则。例如，如果一个东西还没有上市一年，但一直有重大贡献，并且得到了一家大型科技公司的大力支持，那就没问题。

如果你在周末四处游玩，那么这些事情可能都不重要。如果这是一个关键的安全基础设施模型，那么您可能需要遵守所有这些规则的更严格的版本。这要看情况。尝试在规则上有软边。这将有助于你保持理智，并允许更多的可能性，在软件和生活中。

让我们更详细地看一下每一点。

## GitHub 星辰

*路标*:大于 20 颗 GitHub 星

虽然这看起来像是一个虚荣的衡量标准(看起来感觉不错，但没有任何实际价值)，但请考虑一下:你会用一种没人听说过的新地基技术来建造你的房子吗？

我从父亲那里学到，永远不要第一个在拍卖会上竞拍汽车。如果那里的其他人(他们以此为生)都不认为这值得，甚至是一个低报价，那么这可能是一个很好的主意，你不应该承担这个风险。这是*群众智慧*的主旨。如果没有其他人对一个项目有足够的想法，在 GitHub 上给它一颗星(这是一个低标准)，那么这不是一个好兆头。

另一方面，它可能解决了你正在做的事情所特有的一个非常具体的问题。可能就是这种情况。也可能是因为它非常新，并且使用了一种更适合一般情况的语言，这非常适合您的需要。

这也在招聘方面发挥了作用。如果你选择完全晦涩难懂的东西，你会发现很难找到了解它的人。你可以随时培训人员，但根据地区的不同，这可能仍然需要一些时间。

## 年龄

*路牌*:出至少一年，不超过 6 个月不放行。

这个列表中还有其他一些东西可以作为这个问题的代理，但是它本身仍然是有价值的。如果某样东西是全新的，那么也许要考虑它是否在战斗中得到证明，也就是实际的生产使用。如前所述，这不是凭空想象的。

你可能也不想要已经很久没有发布的东西。即使您使用 conda 之类的包管理器来解决问题，对于那些已经使用其他依赖项构建的旧程序来说，也可能会出现问题，这可能很难与代码库中的其他工具相协调。

一个例子可能是使用 Python 2。Python 2 已经寿终正寝，不再受支持(如果您正在使用 Python 2 做任何事情，请切换到 Python 3——您的生活会更轻松)。保持使用 Python 2 的东西可能是一件非常痛苦和浪费时间的事情，因为你必须处理一种语言的两个版本，这两个版本的差异足以引起很多问题。

## 自从上次更新以来有多久了

*路标*:最近 3 个月至少有 3 次作案。

当你检查一些几年没有更新的东西时，你可能需要再次猜测它是否是正确的工具。安全漏洞、其他框架问题和新特性都是你可能会遇到的问题。

可能发生的是*你*成为新的维护者，也许这是你想做的事情，但也可能是你的公司现在必须支持的事情，而不是能够专注于业务的真正价值所在。

## 维护人员数量

*路标*:过去 2 个月内至少有 5 名独立贡献者。

假设你已经开发了一个不可思议的软件，并且运行得非常好。当你正在使用的核心库只有一个所有者/维护者，而他们中了彩票，会发生什么？你认为维护者会想要处理所有伴随维护 OSS 软件而来的抱怨和问题吗？大概不会。

## 未决问题/PRs 的年龄

*路标*:钻杆排放系统的搁置时间不会超过 3-6 个月。

如果 PRs 和发行长时间无人关注，这可能表明回购没有得到应有的维护。bug、新特性和社区请求没有流动，事情会变得陈旧。很可能会有较小的或可能遗漏的 PRs 使平均值上升，但我们还是想看看这对大多数 PRs 是否一致。

值得注意的是，项目越大，它应该有更多的回旋余地。当一个项目变得非常大时，项目评审的数量很容易超过能够评审它们的人数。随着大量提交的涌入，一个项目可能会面临自身成功的危险。

## 外部依赖的数量

从某种意义上来说，这是一个额外的收获，由于试图追踪一个完整的依赖列表和评估关注程度所带来的努力和模糊性，它被有意地留在了没有路标的地方。你为什么会关心依赖关系？原因如下:

*   依赖关系会带来风险，因为包所依赖的依赖关系可能会更新，这可能会中断并导致包无法再运行。导致这种情况的原因有很多，但一个例子是您从外部库调用的方法改变了输出格式。您可以锁定您使用的版本，但这样您可能会错过重要的安全更新。
*   有些代码，开发人员没有他们自己的源代码掌握得好，因此可能无法完全理解事情是如何工作的。
*   如果依赖项的代码中存在 bug 或安全问题，您将不得不等到该代码被修复，或者自己花时间进行分叉和修补，这意味着在这方面花费了更多的工作，并且可能不是您想要花时间解决的问题的核心能力。

依赖关系在任何方面都不是坏事，但是如果你看到有大量的依赖关系，那么它会使项目更加不稳定。当你决定是否使用某样东西时，想想上面指出的缺点。看看著名的 left-pad 事件和最近的 Log4j 事件，了解依赖关系可能存在的一些更严重的问题。

查看软件包需要什么的一个简单方法是告诉 conda 命令行工具进行一次试运行安装，这将向您显示什么将被完成，而不实际安装任何东西。用下面的代码来看看 Matplotlib(一个流行的绘图工具)需要哪些依赖项:

```py
conda install matplotlib --dry-run
```

使用或不使用某物的决定可以采取不同的形式。现在让我们来讨论一下。

### 试用、评估、采用、持有

咨询公司 Thoughtworks 使用了一个很棒的框架，我觉得很有价值。这个想法是，当你在寻找使用一个新的工具或包时，你需要经历一些阶段，这些阶段需要基于你在其中使用它的系统的重要程度的更具批判性的眼光。这允许您尝试新工具，而不用担心过度分析。例如，如果有一个全新的工具或包，您可能希望在一个没有部署到生产环境中的系统上试用它，因此您不必像前面讨论的那样严格要求应用指南。这与您的整个用户群所依赖的核心安全应用程序形成了对比，在这种情况下，您应该更加犹豫是否要冒险尝试未经证实的新事物。

我建议你也为 OSS 使用这个框架。在每个阶段，你可以更加严格地评估事物:

*   试用版:在试用版中，你不必深究工具，而是对它有一个浅显的了解。这让你更乐于尝试新事物。
*   *评估*:当处于评估阶段时，你开始在一个更重要的角色中更多地使用这个工具。
*   *采用*:采用阶段是指它将被用于一个关键的生产系统，然后成为一个你支持的官方工具。该工具或包将作为工具箱中的解决方案或工具得到更广泛的使用。
*   *保持*:保持阶段是当你意识到工具没有做你需要它做的事情，或者它现在不是合适的时候。这是对工具进行分析的结果，或者是在它经历了前面的另一个阶段之后。

我们的目标是务实的，并且永远记住，最终我们要用代码解决问题，而不是创造新的问题。每个阶段都意味着一个持续的评估，并且总是有可能从一个阶段转到另一个阶段。

现在你应该知道在检查一个新的包的时候应该从几个不同的角度来看。在下一节中，我们将使用这个过程来查看一个流行的 scikit-learn 包，并通过使用 conda 将它安装到您的系统上来使用它。

# 用 Anaconda 和 conda-forge 导入包

这一节可能是整本书最有价值的部分之一，因为它是作为一名数据科学家(以及一名开发人员)日常工作的基础部分。在任何给定的项目中，甚至是一个小的概念证明,你都会使用许多包来完成你需要的东西，所以让我们看看 conda 和 conda-forge 是如何一起工作来得到你需要的东西的。

conda 包管理器和 Navigator 是很好的工具，但是没有包本身它们是没有用的。对于一个包的任何给定更新，有些东西可能会随之改变，或者引入新的依赖关系。例如，流行的机器学习框架 tensor flow(【https://github.com/tensorflow/tensorflow】)正在考虑发布 2.6.0 版本。这个版本分离出一个主要部分， *Keras* ，所以现在可能有不需要的库和需要的新库。有些软件包更新非常小，但有些需要大量的手动工作来维护和保持最新。

为什么名字很重要——一堂简短的历史课

多年来，公司都在经历变化，Anaconda(或者更确切地说，Anaconda Inc .)也不例外。您可能会在代码库或包中看到一些对 *Continuum Analytics* 的引用，这是 Anaconda 的原名。Anaconda 最受欢迎的产品是 Anaconda 个人版，通常称为 Anaconda 发行版，或者很多时候简称为 *Anaconda* 。

还有很重要的一点是 Anaconda 不是 conda。Conda 只是包管理器，是 Anaconda 发行版中包含的内容之一。Conda 是 Anaconda 创建的 OSS 工具，Anaconda 现在只是帮助维护它的团体之一。

如果您正在查看历史文档或帮助网站(如 Stack Overflow ),了解这一点可能会派上用场。也可能有 OSS 代码库和 repos 引用这一点。

拥有数以千计的开源软件包，Anaconda(该公司)需要一些帮助，这就是 conda-forge 的用武之地。conda-forge 是一个志愿者社区，维护和更新你听说过的任何软件包(但不是所有的——记住有很多)。他们专注于 macOS、Linux AMD64 和 Windows AMD64 系统，因此他们通常涵盖大多数情况。让我们导入流行的软件包 *NumPy* ，即专注于多维数组的科学计算软件包，以了解如何开始使用 conda 来处理不同的软件包。

## 更新至最新的 conda 版本

让你的工具保持锋利总是一个好主意，软件开发版本会得到最新版本的修正和改进。让我们确保您的 conda 版本是最新的:

1.  首先，在终端中用这个命令检查您的版本:

    ```py
    $ conda –version conda 4.10.1
    ```

2.  接下来，调用`update conda`命令来更新 conda 本身:

    ```py
    $ conda update conda
    ```

输出将类似于以下内容:

```py
Collecting package metadata (current_repodata.json): done
Solving environment: done
The following packages will be UPDATED:
 conda     4.10.1-py38haa95532_1 -->4.10.3-py38haa95532_0
```

在这里，你可以看到我的当前版本是`4.10.1`，在康达检查系统后，它计算出有一个新版本`4.10.3`(尾随的`py38`只是显示它在哪个版本的 Python 上)。

1.  然后询问你是否要安装新版本，如下面的代码所示。输入`y`并点击*输入* :

    ```py
    $ Proceed ([y]/n)? y
    ```

输出如下所示:

```py
Preparing transaction: done
Verifying transaction: done
Executing transaction: done
$conda --version
conda 4.10.3
```

如你所见，当我再次查看版本时，conda 已经更新为`4.10.3`。

现在，让我们使用更新的 conda 来创建一个虚拟环境，这样我们就可以将所有东西放在一个地方。

## 创建康达虚拟环境

conda 的一个关键特性是创建一个虚拟环境。它让我们可以确保我们做的任何事情都将留在那里，我们不必担心弄乱任何其他环境。如果需要，我们总是可以删除它并重新开始。

我们将使用`-n`命令来显示我们想要给这个环境命名什么。在这种情况下，我们将其命名为`ch2_env`(注意这个名字可以是任何东西；如果使用其他内容，请确保引用此内容)。最后一个命令说我们想要使用 Python 3.8。根据您使用的操作系统，您将看到略有不同的输出:

```py
$ conda create -n ch2_env python=3.8
```

输出将类似于以下内容:

```py
The following NEW packages will be INSTALLED:

  ca-certificates    pkgs/main/win-64::ca-certificates
  certifi    pkgs/main/win-64::certifi
[...]
  wheel              pkgs/main/noarch::wheel-0.36.2
  wincertstore       pkgs/main/win-64::wincertstore-0.2
Proceed ([y]/n)?
```

这将与之前的相同。输入`y`, conda 将在您的系统上安装所需的软件包，直到最后，您将看到以下消息:

```py
# To activate this environment, use
#     $ conda activate ch2_env
```

接受它的建议，输入以下命令:

```py
$ conda activate ch2_env
```

现在，在您的终端中，您应该会看到这样的括号，表示您已经激活了新环境:

```py
$(ch2_env)
```

恭喜你！您现在已经进入了 conda 虚拟环境，应该感到安全，您安装或更改的任何软件包都不会影响您的系统。我们刚刚经历的步骤是您将会使用一百次来创建可重复的环境并获取完成工作所需的包的步骤。

但是什么是包，它与其他类似的术语有什么关系呢？我们现在会谈到这一点。

## 模块、包和库之间的区别

请注意，不同的语言对这些术语的理解略有不同。在本书中，我们将继续关注 Python:

*   一个**模块**是 Python 代码的基本构件。这是一个单独的文件，其中应该有相关的功能。
*   一个**包**，在实践中，只不过是一个模块层次结构的正式名称，它可以被称为一个单一的实体。举个假设的例子，您可能有一个`cooking`包，它包含模块`bake.py`、`saute.py`和`grill.py`。模块是一个特定的组件，它非常类似于一个典型的文件系统，但不是基于那个模型。

根据*进口系统*(【https://docs.python.org/3/reference/import.html】T2)的文件:

重要的是要记住，所有的包都是模块，但不是所有的模块都是包。或者换句话说，包只是一种特殊的模块。具体来说，任何包含 __path__ 属性的模块都被视为一个包。

一个**库**是简单来说就是一个软件的集合，被调用来完成一些事情。这是一个更高级的术语，可以指可能只包含单个模块或可能包含许多包的东西。通常，我们的想法是会有一些点或方法需要调用来使用这个库，并且由于它上面的抽象，您不需要知道很多关于底层代码的知识。

说了这么多，库和包通常可以互换使用，就像有人会说有人送了一个包或者你家门口有一个盒子，这两种说法都是正确的。

您现在已经知道了如何使用 conda 命令行以及什么是包，所以现在让我们看一个实际的例子，将我们所学的内容付诸实践。

# 评估和使用 scikit-learn

假设你想解决一个问题，比如想评估加利福尼亚的房价。您知道您想要评估流行的数据科学框架 scikit——了解一下它是否符合您的需要。Scikit-learn 是一个非常强大的现成解决方案，允许您训练和评估许多不同类型的模型。

一个库或者一个软件可以做的最强大的事情之一就是提供抽象，这样你就可以用很少的资源做很多事情。Scikit-learn 提供了足够多的可读性很强的特定命令，结果是创建了一个模型，而这在几年前可能需要一周时间才能完成。

把它想象成给服务员点餐。你给他们一个高层次的洞察力，让他们知道你想吃什么，然后他们把这个信息传递给已经知道如何准备一顿大餐的厨师。你不需要担心烤箱的确切温度或者如何混合酱汁，你需要担心的是当它出来的时候吃它。

在本节中，我们将查看加州的住房数据，并使用 scikit 创建一个模型——了解如何判断您在市场上看到的当前住房是否划算。

## 评估指标

让我们首先看看 sci kit——学习我们在上一节中发现的路标:

![Figure 2.3 – OSS evaluation metrics
](img/Figure_2.3.jpg)

图 2.3–OSS 评估指标

在所有这些之后，我们得到 4.5/5(开放问题的年龄/PRs 得到半个点)，所以我们可以对使用它感到非常自信。所以，我们走吧！在下一节中，我们将利用 scikit-learn 把我们所学的其余内容放在一起创建一个简单的模型。

## 使用 scikit-learn 起床并跑步

Scikit-learn 是一个 T2 的主要科学图书馆。这是基于 SciPy 的少数科学工具包之一(因此得名)。如果你只是选择了一个工具来建立模型，这是一个不错的选择。我们将通过设置一个这个库为您提供的强大抽象的快速示例，向您展示您可以多快上手并运行它。

### 用五行代码创建回归模型

现在我们已经发现了一个让我们的生活变得更简单的工具，让我们使用 scikit-learn 创建一个模型。我们将利用 scikit-learn 提供的加州示例数据集快速入门。

让我们回到我们之前已经创建的 conda 环境:

1.  在您的终端中，在`ch2_env`环境中输入以下命令:

    ```py
    conda activate ch2_env
    ```

2.  一旦进入，您可以安装 scikit-learn，它将自动安装其他需要的依赖项:

    ```py
    (ch_2) → conda install scikit-learn
    (ch_2) → conda install pandas
    ```

3.  通过这些简单的命令，从您的终端，您现在可以开始制作您的模型了。让我们转到您选择的 IDE 或代码编辑器，首先导入前面的包，然后加载 scikit-learn 附带的 California 示例数据集。

首先，我们导入加州住房数据集方法:

```py
from sklearn.datasets import fetch_california_housing 
```

接下来，我们将数据集保存为`cali_data`变量，将`as_frame`参数设置为`True`,以请求数据和目标为熊猫数据帧。这使得设置从一开始就很容易操作:

```py
 cali_data = fetch_california_housing(as_frame=True)
```

1.  在最基本的层面上，scikit-learn 附带的`fetch_california_housing`对象是一个保存一些值的字典。其中之一是`data`，它包含原始数据集本身。另一个是`DESCR`，你可以显示它以获得关于物体的信息。

让我们打印出来看看信息，包括属性:

```py
print( cali_data.DESCR)
.. _california_housing_dataset:  California Housing dataset --------------------------  **Data Set Characteristics:**      :Number of Instances: 20640  [...]       - Pace, R. Kelley and Ronald Barry, Sparse Spatial Autoregressions,       Statistics and Probability Letters, 33 (1997) 291-297
```

1.  接下来，让我们看看我们正在处理的数据。我们将调用`head`函数，默认情况下，它将显示前 5 行:

    ```py
     print(cali_data.data.head())
    ```

![Figure 2.4 – Head view of the California dataset
](img/Figure_2.4.jpg)

图 2.4–加州数据集的主视图

1.  现在让我们留下一些数据，以便您可以测试预测的效果，这是训练模型的关键组成部分。它使用交叉验证，我们将在第八章[](B16589_08_ePub.xhtml#_idTextAnchor193)**处理常见数据问题*中更深入地讨论。我们将输入数据和目标数据分成两部分，总共得到四组:

    ```py
    from sklearn.model_selection import train_test_split
    training_data =  cali_data.data
    target_value =  cali_data.target
    X_train, X_test, y_train, y_test = train_test_split(training_data, target_value, test_size = 0.2, random_state=5)
    ``` 
**   我们现在准备训练我们的模型！让我们输入本次培训所需的两部分数据。这将有助于告诉我们的模型我们在寻找什么。然后，我们将使用那个模型来预测我们之前保留的测试数据，看看我们做得如何。*

 *首先，我们将使用训练数据`X_train`来训练(或拟合)我们的模型，并基于从分割`y_train`中获得的目标值来教授它:

```py
linear_regressor = LinearRegression()
linear_regressor.fit(X_train,y_train)
Now we can run a prediction from our trained model. We now take our testing data which was held out when we made our train/test split in the earlier in step 8.
y_train_predict = linear_regressor.predict(X_test)
```

1.  最后让我们来绘制结果图！我们将绘制结果，并添加一条简单的红线来显示预测值与实际值相符的完美场景，以了解我们的表现。

`y_test`值就是目标值，这个我们已经知道了。通过尝试预测这些，我们可以看到我们的模型做得如何。这与教师给测验评分是一样的，因为她已经知道正确答案，因此可以确定学生在吸收知识方面做得好还是不好:

```py
import matplotlib.pyplot as plt
plt.title('Actual vs Predicted California Housing price') 
plt.xlabel('Actual price ($1000s)') 
plt.ylabel('Predicted price ($1000s)') 
plt.scatter(y_test,y_train_predict) 
plt.plot([0, 5], [0, 5],"r-") 
plt.show()
```

您应该会看到类似下图的图表:

![Figure 2.5 – Actual versus predicted pricing of California housing prices
](img/Figure_2.5.jpg)

图 2.5–加州房价的实际价格与预测价格

正如你在这里看到的，结果显示它非常符合这条线。你可以获得一些真实世界的住房数据，并利用这些数据来预测价格。你会注意到这并不完美。例如，在右侧有一个异常，许多实际值是 5，但预测值却到处都是。这是我们将在第八章 、*处理常见数据问题*中处理的一个问题。

你可能会问这样一个问题:我们如何真正确定一个模型准确预测某事的程度？我们将在第九章 、*用 scikit-learn 建立回归模型*中更详细地讨论这个问题。

至此，您应该已经看到了 scikit-learn 的威力。只需几行代码，您就可以不费吹灰之力创建一个惊人精确的模型。这是一个数据相对干净的场景，但在很多场景中，您可能会遇到数据不准确、数据不足或需要进行数据转换等问题。我们将在第八章[](B16589_08_ePub.xhtml#_idTextAnchor193)*、*处理常见数据问题*中进行更深入的探讨。*

 *# 总结

在这一章中，我们讨论了很多内容。我们通过深入研究 OSI 如何将其定义为一种共识，即源代码应该是可访问的，开放的，不受行业限制的，等等，来看开源意味着什么。

我们发现了您在旅途中会遇到的主要许可以及它们之间的差异。你看到像 GPL 这样的版权所有的许可证要求你分享你创造的任何东西，但是许可许可证允许你为自己保留这些东西，就像麻省理工学院的许可证一样。

然后我们看了你可以用来评估一个开源工具是否适合你的标准，比如 GitHub 明星的数量，维护者的数量，以及它存在的时间。从整体上来看这些事情，让我们对我们是否能指望我们的 OSS 工具得到维护和可靠有一个更好的了解。

最后，我们看到了在您开始工作时，如何利用 conda 来处理依赖性管理和虚拟环境，从而获得这些 OSS 工具的强大功能。然后，我们通过评估 scikit-learn 将一切付诸实践，并制作了一个非常简单的模型来查看波士顿的房价。

这仅仅触及了作为一名数据科学家如何高效工作的表面。在下一章中，我们将更深入地探讨，从使用新的模型类型到设计您的数据以允许更好的训练。通过引入一些更流行的工具，我们将更深入地了解如何快速、轻松地将工具组合起来解决您的问题。**